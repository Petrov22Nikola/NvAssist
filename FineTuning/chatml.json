{
    "messages": [
        {
            "role": "user",
            "content": "{\"VUID-VkMemoryGetAndroidHardwareBufferInfoANDROID-pNext-01883\", \"If the pNext chain of the VkMemoryAllocateInfo used to allocate memory included a VkMemoryDedicatedAllocateInfo with non-NULL image member, then that image must already be bound to memory\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (!image_state || (0 == (image_state->CountDeviceMemory(mem_info->VkHandle())))) {\n    const LogObjectList objlist(device, pInfo->memory, dedicated_image);\n    skip |= LogError(\"VUID-VkMemoryGetAndroidHardwareBufferInfoANDROID-pNext-01883\", objlist,\n                     error_obj.location.dot(Field::pInfo).dot(Field::memory),\n                     \"(%s) was allocated using a dedicated \"\n                     \"%s, but that image is not bound to the VkDeviceMemory object.\",\n                     FormatHandle(pInfo->memory).c_str(), FormatHandle(dedicated_image).c_str());\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkImportAndroidHardwareBufferInfoANDROID-buffer-01881\", \"If buffer is not NULL, it must be a valid Android hardware buffer object with AHardwareBuffer_Desc::usage compatible with Vulkan as described in Android Hardware Buffers\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (0 == (ahb_desc.usage & ahb_equiv_usage_bits)) {\n    skip |= LogError(\"VUID-VkImportAndroidHardwareBufferInfoANDROID-buffer-01881\", device, ahb_loc,\n                     \"AHardwareBuffer_Desc's usage (0x%\" PRIx64 \") is not compatible with Vulkan. (AHB = %p).\",\n                     ahb_desc.usage, import_ahb_info->buffer);\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkMemoryAllocateInfo-pNext-02384\", \"If the parameters define an import operation and the external handle type is VK_EXTERNAL_MEMORY_HANDLE_TYPE_ANDROID_HARDWARE_BUFFER_BIT_ANDROID, and the pNext chain does not include a VkMemoryDedicatedAllocateInfo structure or VkMemoryDedicatedAllocateInfo::image is VK_NULL_HANDLE, the Android hardware buffer must have a AHardwareBuffer_Desc::format of AHARDWAREBUFFER_FORMAT_BLOB and a AHardwareBuffer_Desc::usage that includes AHARDWAREBUFFER_USAGE_GPU_DATA_BUFFER\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (((uint64_t)AHARDWAREBUFFER_FORMAT_BLOB != ahb_desc.format) ||\n    skip |= LogError(\"VUID-VkMemoryAllocateInfo-pNext-02384\", device, ahb_loc,\n                     \"AHardwareBuffer_Desc's format ( %u ) is not \"\n                     \"AHARDWAREBUFFER_FORMAT_BLOB or usage (0x%\" PRIx64\n                     \") does not include AHARDWAREBUFFER_USAGE_GPU_DATA_BUFFER. (AHB = %p).\",\n                     ahb_desc.format, ahb_desc.usage, import_ahb_info->buffer);\n"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkMemoryAllocateInfo-pNext-02386\", \"If the parameters define an import operation, the external handle is an Android hardware buffer, and the pNext chain includes a VkMemoryDedicatedAllocateInfo with image that is not VK_NULL_HANDLE, the Android hardware buffer's AHardwareBuffer::usage must include at least one of AHARDWAREBUFFER_USAGE_GPU_FRAMEBUFFER, AHARDWAREBUFFER_USAGE_GPU_SAMPLED_IMAGE or AHARDWAREBUFFER_USAGE_GPU_DATA_BUFFER\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (0 == (ahb_desc.usage & (AHARDWAREBUFFER_USAGE_GPU_FRAMEBUFFER | AHARDWAREBUFFER_USAGE_GPU_SAMPLED_IMAGE |\n    skip |= LogError(\"VUID-VkMemoryAllocateInfo-pNext-02386\", device, ahb_loc,\n                     \"AHardwareBuffer's usage is 0x%\" PRIx64 \". (AHB = %p).\", ahb_desc.usage, import_ahb_info->buffer);\n"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkMemoryAllocateInfo-pNext-01874\", \"If the parameters do not define an import operation, and the pNext chain includes a VkExportMemoryAllocateInfo structure with VK_EXTERNAL_MEMORY_HANDLE_TYPE_ANDROID_HARDWARE_BUFFER_BIT_ANDROID included in its handleTypes member, and the pNext chain includes a VkMemoryDedicatedAllocateInfo structure with image not equal to VK_NULL_HANDLE, then allocationSize must be 0\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (mem_ded_alloc_info->image != VK_NULL_HANDLE && allocate_info.allocationSize != 0) {\n    skip |= LogError(\"VUID-VkMemoryAllocateInfo-pNext-01874\", mem_ded_alloc_info->image,\n                     allocate_info_loc.pNext(Struct::VkMemoryDedicatedAllocateInfo, Field::image),\n                     \"is %s but allocationSize is %\" PRIu64 \".\", FormatHandle(mem_ded_alloc_info->image).c_str(),\n                     allocate_info.allocationSize);\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkMemoryAllocateInfo-pNext-07901\", \"If the parameters define an export operation, the handle type is VK_EXTERNAL_MEMORY_HANDLE_TYPE_ANDROID_HARDWARE_BUFFER_BIT_ANDROID, and the pNext chain includes a VkMemoryDedicatedAllocateInfo structure with buffer set to a valid VkBuffer object, allocationSize must be greater than 0\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (mem_ded_alloc_info->buffer != VK_NULL_HANDLE && allocate_info.allocationSize == 0) {\n    skip |= LogError(\"VUID-VkMemoryAllocateInfo-pNext-07901\", mem_ded_alloc_info->buffer,\n                     allocate_info_loc.pNext(Struct::VkMemoryDedicatedAllocateInfo, Field::buffer),\n                     \"is %s but allocationSize is 0.\", FormatHandle(mem_ded_alloc_info->buffer).c_str());\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkMemoryAllocateInfo-pNext-07900\", \"If the parameters define an export operation, the handle type is VK_EXTERNAL_MEMORY_HANDLE_TYPE_ANDROID_HARDWARE_BUFFER_BIT_ANDROID, and the pNext does not include a VkMemoryDedicatedAllocateInfo structure, allocationSize must be greater than 0\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "skip |= LogError(\"VUID-VkMemoryAllocateInfo-pNext-07900\", device, allocate_info_loc,\n                 \"pNext chain does not include VkMemoryDedicatedAllocateInfo, but allocationSize is 0.\");\n"
        },
        {
            "role": "user",
            "content": "{\"VUID-vkGetPhysicalDeviceImageFormatProperties2-pNext-01868\", \"If the pNext chain of pImageFormatProperties includes a VkAndroidHardwareBufferUsageANDROID structure, the pNext chain of pImageFormatInfo must include a VkPhysicalDeviceExternalImageFormatInfo structure with handleType set to VK_EXTERNAL_MEMORY_HANDLE_TYPE_ANDROID_HARDWARE_BUFFER_BIT_ANDROID\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if ((!pdeifi) || (VK_EXTERNAL_MEMORY_HANDLE_TYPE_ANDROID_HARDWARE_BUFFER_BIT_ANDROID != pdeifi->handleType)) {\n    skip |= LogError(\"VUID-vkGetPhysicalDeviceImageFormatProperties2-pNext-01868\", physical_device,\n                     error_obj.location.dot(Field::pImageFormatProperties),\n                     \"includes a chained \"\n                     \"VkAndroidHardwareBufferUsageANDROID struct, but pImageFormatInfo does not include a chained \"\n                     \"VkPhysicalDeviceExternalImageFormatInfo struct with handleType \"\n                     \"VK_EXTERNAL_MEMORY_HANDLE_TYPE_ANDROID_HARDWARE_BUFFER_BIT_ANDROID.\");\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkImageCreateInfo-pNext-02396\", \"If the pNext chain includes a VkExternalFormatANDROID structure whose externalFormat member is not 0, flags must not include VK_IMAGE_CREATE_MUTABLE_FORMAT_BIT\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (0 != (VK_IMAGE_CREATE_MUTABLE_FORMAT_BIT & create_info.flags)) {\n    skip |= LogError(\"VUID-VkImageCreateInfo-pNext-02396\", device,\n                     create_info_loc.pNext(Struct::VkExternalFormatANDROID, Field::externalFormat),\n                     \"(%\" PRIu64 \") is non-zero, but flags is %s.\", ext_fmt_android->externalFormat,\n                     string_VkImageCreateFlags(create_info.flags).c_str());\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkImageCreateInfo-pNext-02397\", \"If the pNext chain includes a VkExternalFormatANDROID structure whose externalFormat member is not 0, usage must not include any usages except VK_IMAGE_USAGE_INPUT_ATTACHMENT_BIT, VK_IMAGE_USAGE_COLOR_ATTACHMENT_BIT, or VK_IMAGE_USAGE_SAMPLED_BIT\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (0 != (~(VK_IMAGE_USAGE_SAMPLED_BIT | VK_IMAGE_USAGE_COLOR_ATTACHMENT_BIT | VK_IMAGE_USAGE_INPUT_ATTACHMENT_BIT) &\n    skip |= LogError(\"VUID-VkImageCreateInfo-pNext-02397\", device,\n                     create_info_loc.pNext(Struct::VkExternalFormatANDROID, Field::externalFormat),\n                     \"(%\" PRIu64 \") is non-zero, but usage is %s.\", ext_fmt_android->externalFormat,\n                     string_VkImageUsageFlags(create_info.usage).c_str());\n"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkImageCreateInfo-pNext-02398\", \"If the pNext chain includes a VkExternalFormatANDROID structure whose externalFormat member is not 0, tiling must be VK_IMAGE_TILING_OPTIMAL\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (VK_IMAGE_TILING_OPTIMAL != create_info.tiling) {\n    skip |= LogError(\"VUID-VkImageCreateInfo-pNext-02398\", device,\n                     create_info_loc.pNext(Struct::VkExternalFormatANDROID, Field::externalFormat),\n                     \"(%\" PRIu64 \") is non-zero, but layout is %s.\", ext_fmt_android->externalFormat,\n                     string_VkImageTiling(create_info.tiling));\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkExternalFormatANDROID-externalFormat-01894\", \"externalFormat must be 0 or a value returned in the externalFormat member of VkAndroidHardwareBufferFormatPropertiesANDROID by an earlier call to vkGetAndroidHardwareBufferPropertiesANDROID\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (ahb_ext_formats_map.find(ext_fmt_android->externalFormat) == ahb_ext_formats_map.end()) {\n    skip |= LogError(\"VUID-VkExternalFormatANDROID-externalFormat-01894\", device,\n                     create_info_loc.pNext(Struct::VkExternalFormatANDROID, Field::externalFormat),\n                     \"(%\" PRIu64 \") has not been previously retrieved by vkGetAndroidHardwareBufferPropertiesANDROID().\",\n                     ext_fmt_android->externalFormat);\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkImageCreateInfo-pNext-01975\", \"If the pNext chain does not include a VkExternalFormatANDROID structure, or does and its externalFormat member is 0, the format must not be VK_FORMAT_UNDEFINED\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "skip |= LogError(\"VUID-VkImageCreateInfo-pNext-01975\", device, create_info_loc.dot(Field::format),\nskip |= LogError(\"VUID-VkImageCreateInfo-pNext-01975\", device, create_info_loc.dot(Field::format),\n                 \"is VK_FORMAT_UNDEFINED, but does not have a chained VkExternalFormatANDROID struct.\");\n"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkImageCreateInfo-pNext-02393\", \"If the pNext chain includes a VkExternalMemoryImageCreateInfo structure whose handleTypes member includes VK_EXTERNAL_MEMORY_HANDLE_TYPE_ANDROID_HARDWARE_BUFFER_BIT_ANDROID, imageType must be VK_IMAGE_TYPE_2D\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (create_info.imageType != VK_IMAGE_TYPE_2D) {\n    skip |= LogError(\"VUID-VkImageCreateInfo-pNext-02393\", device,\n                     create_info_loc.pNext(Struct::VkExternalMemoryImageCreateInfo, Field::handleTypes),\n                     \"includes VK_EXTERNAL_MEMORY_HANDLE_TYPE_ANDROID_HARDWARE_BUFFER_BIT_ANDROID, but imageType is %s.\",\n                     string_VkImageType(create_info.imageType));\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkImageCreateInfo-pNext-02394\", \"If the pNext chain includes a VkExternalMemoryImageCreateInfo structure whose handleTypes member includes VK_EXTERNAL_MEMORY_HANDLE_TYPE_ANDROID_HARDWARE_BUFFER_BIT_ANDROID, mipLevels must either be 1 or equal to the number of levels in the complete mipmap chain based on extent.width, extent.height, and extent.depth\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if ((create_info.mipLevels != 1) && (create_info.mipLevels != FullMipChainLevels(create_info.extent))) {\n    skip |= LogError(\"VUID-VkImageCreateInfo-pNext-02394\", device,\n                     create_info_loc.pNext(Struct::VkExternalMemoryImageCreateInfo, Field::handleTypes),\n                     \"includes VK_EXTERNAL_MEMORY_HANDLE_TYPE_ANDROID_HARDWARE_BUFFER_BIT_ANDROID, \"\n                     \"but mipLevels is %\" PRIu32 \" (full chain mipLevels are %\" PRIu32 \").\",\n                     create_info.mipLevels, FullMipChainLevels(create_info.extent));\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkImageViewCreateInfo-image-02399\", \"If image has an Android external format, format must be VK_FORMAT_UNDEFINED\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (VK_FORMAT_UNDEFINED != create_info.format) {\n    skip |= LogError(\"VUID-VkImageViewCreateInfo-image-02399\", create_info.image, create_info_loc.dot(Field::format),\n                     \"is %s (not VK_FORMAT_UNDEFINED) but the VkImageViewCreateInfo struct has a chained \"\n                     \"VkExternalFormatANDROID struct.\",\n                     string_VkFormat(create_info.format));\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkImageViewCreateInfo-image-02400\", \"If image has an Android external format, the pNext chain must include a VkSamplerYcbcrConversionInfo structure with a conversion object created with the same external format as image\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "const LogObjectList objlist(create_info.image, ycbcr_conv_info->conversion);\nskip |= LogError(\"VUID-VkImageViewCreateInfo-image-02400\", objlist,\n                 create_info_loc.pNext(Struct::VkSamplerYcbcrConversionInfo, Field::conversion),\n                 \"(%s) was created with externalFormat (%\" PRIu64\n                 \") which is different then image chain VkExternalFormatANDROID::externalFormat (%\" PRIu64 \").\",\n                 FormatHandle(ycbcr_conv_info->conversion).c_str(), external_format, image_state->ahb_format);\n"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkBufferViewCreateInfo-range-00928\", \"If range is not equal to VK_WHOLE_SIZE, range must be greater than 0\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (range <= 0) {\n    skip |= LogError(\"VUID-VkBufferViewCreateInfo-range-00928\", buffer_state.Handle(), loc.dot(Field::range),\n                     \"(%\" PRIuLEAST64 \") does not equal VK_WHOLE_SIZE, range must be greater than 0.\", range);\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkBufferViewCreateInfo-range-00930\", \"If range is not equal to VK_WHOLE_SIZE, the number of texel buffer elements given by (\u230arange / (texel block size)\u230b \u00d7 (texels per block)) where texel block size and texels per block are as defined in the Compatible Formats table for format, must be less than or equal to VkPhysicalDeviceLimits::maxTexelBufferElements\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (texels > static_cast<VkDeviceSize>(phys_dev_props.limits.maxTexelBufferElements)) {\n    skip |= LogError(\"VUID-VkBufferViewCreateInfo-range-00930\", buffer_state.Handle(), loc.dot(Field::range),\n                     \"(%\" PRIuLEAST64 \"), %s texel block size (%\" PRIu32 \"), and texels-per-block (%\" PRIuLEAST64\n                     \") is a total of (%\" PRIuLEAST64\n                     \") texels which is more than VkPhysicalDeviceLimits::maxTexelBufferElements (%\" PRIuLEAST32 \").\",\n                     range, string_VkFormat(format), format_info.block_size, texel_per_block, texels,\n                     phys_dev_props.limits.maxTexelBufferElements);\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkBufferViewCreateInfo-offset-00931\", \"If range is not equal to VK_WHOLE_SIZE, the sum of offset and range must be less than or equal to the size of buffer\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (range + create_info.offset > buffer_state.create_info.size) {\n    skip |= LogError(\"VUID-VkBufferViewCreateInfo-offset-00931\", buffer_state.Handle(), loc.dot(Field::range),\n                     \"(%\" PRIuLEAST64 \") does not equal VK_WHOLE_SIZE, the sum of offset (%\" PRIuLEAST64\n                     \") and range must be less than or equal to the size of the buffer (%\" PRIuLEAST64 \").\",\n                     range, create_info.offset, buffer_state.create_info.size);\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkBufferViewCreateInfo-format-08778\", \"If the buffer view usage contains VK_BUFFER_USAGE_UNIFORM_TEXEL_BUFFER_BIT, then format features of format must contain VK_FORMAT_FEATURE_UNIFORM_TEXEL_BUFFER_BIT\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if ((usage & VK_BUFFER_USAGE_UNIFORM_TEXEL_BUFFER_BIT) &&\n    skip |= LogError(\"VUID-VkBufferViewCreateInfo-format-08778\", buffer_state.Handle(), loc.dot(Field::buffer),\n                     \"was created with usage (%s) containing VK_BUFFER_USAGE_UNIFORM_TEXEL_BUFFER_BIT.\\n\"\n                     \"Format (%s) doesn't support VK_BUFFER_USAGE_UNIFORM_TEXEL_BUFFER_BIT.\\n\"\n                     \"(supported bufferFeatures: %s)\",\n                     string_VkBufferUsageFlags2KHR(usage).c_str(), string_VkFormat(format),\n                     string_VkFormatFeatureFlags2(format_properties.bufferFeatures).c_str());\n"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkBufferViewCreateInfo-format-08779\", \"If the buffer view usage contains VK_BUFFER_USAGE_STORAGE_TEXEL_BUFFER_BIT, then format features of format must contain VK_FORMAT_FEATURE_STORAGE_TEXEL_BUFFER_BIT\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if ((usage & VK_BUFFER_USAGE_STORAGE_TEXEL_BUFFER_BIT) &&\n    skip |= LogError(\"VUID-VkBufferViewCreateInfo-format-08779\", buffer_state.Handle(), loc.dot(Field::buffer),\n                     \"was created with usage (%s) containing VK_BUFFER_USAGE_STORAGE_TEXEL_BUFFER_BIT.\\n\"\n                     \"Format (%s) doesn't support VK_BUFFER_USAGE_STORAGE_TEXEL_BUFFER_BIT.\\n\"\n                     \"(supported bufferFeatures: %s)\",\n                     string_VkBufferUsageFlags2KHR(usage).c_str(), string_VkFormat(format),\n                     string_VkFormatFeatureFlags2(format_properties.bufferFeatures).c_str());\n"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkBufferCreateInfo-deviceAddress-02604\", \"If VkBufferDeviceAddressCreateInfoEXT::deviceAddress is not zero, flags must include VK_BUFFER_CREATE_DEVICE_ADDRESS_CAPTURE_REPLAY_BIT\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (!(create_info.flags & VK_BUFFER_CREATE_DEVICE_ADDRESS_CAPTURE_REPLAY_BIT) &&\n    chained_devaddr_struct->deviceAddress != 0) {\n    skip |= LogError(\"VUID-VkBufferCreateInfo-deviceAddress-02604\", device,\n                     create_info_loc.pNext(Struct::VkBufferDeviceAddressCreateInfoEXT, Field::deviceAddress),\n                     \"(%\" PRIu64 \") is non-zero but requires VK_BUFFER_CREATE_DEVICE_ADDRESS_CAPTURE_REPLAY_BIT.\",\n                     chained_devaddr_struct->deviceAddress);\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkBufferCreateInfo-opaqueCaptureAddress-03337\", \"If VkBufferOpaqueCaptureAddressCreateInfo::opaqueCaptureAddress is not zero, flags must include VK_BUFFER_CREATE_DEVICE_ADDRESS_CAPTURE_REPLAY_BIT\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (!(create_info.flags & VK_BUFFER_CREATE_DEVICE_ADDRESS_CAPTURE_REPLAY_BIT) &&\n    chained_opaqueaddr_struct->opaqueCaptureAddress != 0) {\n    skip |= LogError(\"VUID-VkBufferCreateInfo-opaqueCaptureAddress-03337\", device,\n                     create_info_loc.pNext(Struct::VkBufferOpaqueCaptureAddressCreateInfo, Field::opaqueCaptureAddress),\n                     \"(%\" PRIu64 \") is non-zero but requires VK_BUFFER_CREATE_DEVICE_ADDRESS_CAPTURE_REPLAY_BIT.\",\n                     chained_opaqueaddr_struct->opaqueCaptureAddress);\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkBufferCreateInfo-usage-08097\", \"If usage includes VK_BUFFER_USAGE_SAMPLER_DESCRIPTOR_BUFFER_BIT_EXT, creating this VkBuffer must not cause the total required space for all currently valid buffers using this flag on the device to exceed VkPhysicalDeviceDescriptorBufferPropertiesEXT::samplerDescriptorBufferAddressSpaceSize or VkPhysicalDeviceDescriptorBufferPropertiesEXT::descriptorBufferAddressSpaceSize\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "} else if (create_info.size + descriptorBufferAddressSpaceSize >\n    skip |= LogError(\"VUID-VkBufferCreateInfo-usage-08097\", device, create_info_loc.dot(Field::size),\n                     \"(%\" PRIuLEAST64 \") plus current total (%\" PRIuLEAST64\n                     \") is greater than specified in properties field descriptorBufferAddressSpaceSize (%\" PRIuLEAST64 \")\",\n                     create_info.size, descriptorBufferAddressSpaceSize.load(),\n                     phys_dev_ext_props.descriptor_buffer_props.descriptorBufferAddressSpaceSize);\n"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkBufferCreateInfo-usage-08098\", \"If usage includes VK_BUFFER_USAGE_RESOURCE_DESCRIPTOR_BUFFER_BIT_EXT, creating this VkBuffer must not cause the total required space for all currently valid buffers using this flag on the device to exceed VkPhysicalDeviceDescriptorBufferPropertiesEXT::resourceDescriptorBufferAddressSpaceSize or VkPhysicalDeviceDescriptorBufferPropertiesEXT::descriptorBufferAddressSpaceSize\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "} else if (create_info.size + descriptorBufferAddressSpaceSize >\n    skip |= LogError(\"VUID-VkBufferCreateInfo-usage-08098\", device, create_info_loc.dot(Field::size),\n                     \"(%\" PRIuLEAST64 \") plus current total (%\" PRIuLEAST64\n                     \") is greater than specified in properties field descriptorBufferAddressSpaceSize (%\" PRIuLEAST64 \").\",\n                     create_info.size, descriptorBufferAddressSpaceSize.load(),\n                     phys_dev_ext_props.descriptor_buffer_props.descriptorBufferAddressSpaceSize);\n"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkBufferCreateInfo-flags-08099\", \"If flags includes VK_BUFFER_CREATE_DESCRIPTOR_BUFFER_CAPTURE_REPLAY_BIT_EXT, the descriptorBufferCaptureReplay feature must be enabled\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if ((create_info.flags & VK_BUFFER_CREATE_DESCRIPTOR_BUFFER_CAPTURE_REPLAY_BIT_EXT) &&\n    skip |= LogError(\"VUID-VkBufferCreateInfo-flags-08099\", device, create_info_loc.dot(Field::flags),\n                     \"has VK_BUFFER_CREATE_DESCRIPTOR_BUFFER_CAPTURE_REPLAY_BIT_EXT set but the descriptorBufferCaptureReplay \"\n                     \"device feature is not enabled.\");\n"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkBufferCreateInfo-pNext-08100\", \"If the pNext chain includes a VkOpaqueCaptureDescriptorDataCreateInfoEXT structure, flags must contain VK_BUFFER_CREATE_DESCRIPTOR_BUFFER_CAPTURE_REPLAY_BIT_EXT\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (!(create_info.flags & VK_BUFFER_CREATE_DESCRIPTOR_BUFFER_CAPTURE_REPLAY_BIT_EXT)) {\n    skip |= LogError(\"VUID-VkBufferCreateInfo-pNext-08100\", device, create_info_loc.dot(Field::flags),\n                     \"(%s) is missing VK_BUFFER_CREATE_DESCRIPTOR_BUFFER_CAPTURE_REPLAY_BIT_EXT but \"\n                     \"VkOpaqueCaptureDescriptorDataCreateInfoEXT is in pNext chain.\",\n                     string_VkBufferCreateFlags(create_info.flags).c_str());\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkBufferCreateInfo-usage-08102\", \"If usage includes VK_BUFFER_USAGE_PUSH_DESCRIPTORS_DESCRIPTOR_BUFFER_BIT_EXT VkPhysicalDeviceDescriptorBufferPropertiesEXT::bufferlessPushDescriptors must be VK_FALSE\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (phys_dev_ext_props.descriptor_buffer_props.bufferlessPushDescriptors) {\n    skip |= LogError(\"VUID-VkBufferCreateInfo-usage-08102\", device, create_info_loc.dot(Field::usage),\n                     \"has VK_BUFFER_USAGE_PUSH_DESCRIPTORS_DESCRIPTOR_BUFFER_BIT_EXT set but the bufferlessPushDescriptors \"\n                     \"device feature is enabled.\");\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkBufferCreateInfo-usage-08103\", \"If usage includes VK_BUFFER_USAGE_PUSH_DESCRIPTORS_DESCRIPTOR_BUFFER_BIT_EXT, usage must contain at least one of VK_BUFFER_USAGE_RESOURCE_DESCRIPTOR_BUFFER_BIT_EXT or VK_BUFFER_USAGE_SAMPLER_DESCRIPTOR_BUFFER_BIT_EXT\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (!(usage & (VK_BUFFER_USAGE_RESOURCE_DESCRIPTOR_BUFFER_BIT_EXT | VK_BUFFER_USAGE_SAMPLER_DESCRIPTOR_BUFFER_BIT_EXT))) {\n    skip |= LogError(\"VUID-VkBufferCreateInfo-usage-08103\", device, create_info_loc.dot(Field::usage), \"is (%s).\",\n                     string_VkBufferUsageFlags2KHR(usage).c_str());\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkBufferCreateInfo-pNext-01571\", \"If the pNext chain includes a VkDedicatedAllocationBufferCreateInfoNV structure, and the dedicatedAllocation member of the chained structure is VK_TRUE, then flags must not include VK_BUFFER_CREATE_SPARSE_BINDING_BIT, VK_BUFFER_CREATE_SPARSE_RESIDENCY_BIT, or VK_BUFFER_CREATE_SPARSE_ALIASED_BIT\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (pCreateInfo->flags &\n    skip |= LogError(\"VUID-VkBufferCreateInfo-pNext-01571\", device, create_info_loc.dot(Field::flags),\n                     \"%s when VkDedicatedAllocationBufferCreateInfoNV::dedicatedAllocation is VK_TRUE.\",\n                     string_VkBufferCreateFlags(pCreateInfo->flags).c_str());\n"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkBufferCreateInfo-flags-01887\", \"If the protectedMemory feature is not enabled, flags must not contain VK_BUFFER_CREATE_PROTECTED_BIT\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (enabled_features.protectedMemory == VK_FALSE) {\n    skip |= LogError(\"VUID-VkBufferCreateInfo-flags-01887\", device, create_info_loc.dot(Field::flags),\n                     \"has VK_BUFFER_CREATE_PROTECTED_BIT set but the protectedMemory device feature is not enabled.\");\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkBufferCreateInfo-flags-08325\", \"If flags includes VK_BUFFER_CREATE_VIDEO_PROFILE_INDEPENDENT_BIT_KHR, then videoMaintenance1 must be enabled\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (video_profile_independent && !enabled_features.videoMaintenance1) {\n    skip |= LogError(\"VUID-VkBufferCreateInfo-flags-08325\", device, create_info_loc.dot(Field::flags),\n                     \"has VK_BUFFER_CREATE_VIDEO_PROFILE_INDEPENDENT_BIT_KHR set but the videoMaintenance1 \"\n                     \"device feature is not enabled.\");\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkBufferCreateInfo-pNext-00920\", \"If the pNext chain includes a VkExternalMemoryBufferCreateInfo structure, its handleTypes member must only contain bits that are also in VkExternalBufferProperties::externalMemoryProperties.compatibleHandleTypes, as returned by vkGetPhysicalDeviceExternalBufferProperties with pExternalBufferInfo->handleType equal to any one of the handle types specified in VkExternalMemoryBufferCreateInfo::handleTypes\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if ((external_memory_info->handleTypes & compatible_types) != external_memory_info->handleTypes) {\n    skip |= LogError(\"VUID-VkBufferCreateInfo-pNext-00920\", device,\n                     create_info_loc.pNext(Struct::VkExternalMemoryBufferCreateInfo, Field::handleTypes),\n                     \"(%s) is not reported as compatible by vkGetPhysicalDeviceExternalBufferProperties.\",\n                     string_VkExternalMemoryHandleTypeFlags(external_memory_info->handleTypes).c_str());\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkBufferViewCreateInfo-offset-00925\", \"offset must be less than the size of buffer\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (pCreateInfo->offset >= buffer_state.create_info.size) {\n    skip |= LogError(\"VUID-VkBufferViewCreateInfo-offset-00925\", buffer_state.Handle(), create_info_loc.dot(Field::offset),\n                     \"(%\" PRIuLEAST64 \") must be less than the size of the buffer (%\" PRIuLEAST64 \").\", pCreateInfo->offset,\n                     buffer_state.create_info.size);\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkBufferViewCreateInfo-offset-02749\", \"If the texelBufferAlignment feature is not enabled, offset must be a multiple of VkPhysicalDeviceLimits::minTexelBufferOffsetAlignment\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if ((pCreateInfo->offset % phys_dev_props.limits.minTexelBufferOffsetAlignment) != 0 &&\n    skip |= LogError(\"VUID-VkBufferViewCreateInfo-offset-02749\", objlist, create_info_loc.dot(Field::offset),\n                     \"(%\" PRIuLEAST64\n                     \") must be a multiple of VkPhysicalDeviceLimits::minTexelBufferOffsetAlignment (%\" PRIuLEAST64 \").\",\n                     pCreateInfo->offset, phys_dev_props.limits.minTexelBufferOffsetAlignment);\n"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkBufferViewCreateInfo-pNext-08781\", \"If the pNext chain includes a VkBufferUsageFlags2CreateInfoKHR, its usage must be a subset of the VkBufferCreateInfo::usage specified or VkBufferUsageFlags2CreateInfoKHR::usage from VkBufferCreateInfo::pNext when creating buffer\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "create_info_loc.pNext(Struct::VkBufferUsageFlags2CreateInfoKHR, Field::usage), \"is %s.\",\nskip |= LogError(\"VUID-VkBufferViewCreateInfo-pNext-08781\", objlist,\ncreate_info_loc.pNext(Struct::VkBufferUsageFlags2CreateInfoKHR, Field::usage),\n\"(%s) is not a subset of the buffer's usage (%s).\", string_VkBufferUsageFlags2KHR(usage).c_str(),\nstring_VkBufferUsageFlags2KHR(buffer_state.usage).c_str());\n"
        },
        {
            "role": "user",
            "content": "{\"VUID-vkDestroyBuffer-buffer-00922\", \"All submitted commands that refer to buffer, either directly or via a VkBufferView, must have completed execution\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (auto buffer_state = Get<vvl::Buffer>(buffer)) {\n    skip |= ValidateObjectNotInUse(buffer_state.get(), error_obj.location, \"VUID-vkDestroyBuffer-buffer-00922\");\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-vkDestroyBufferView-bufferView-00936\", \"All submitted commands that refer to bufferView must have completed execution\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (auto buffer_view_state = Get<vvl::BufferView>(bufferView)) {\n    skip |= ValidateObjectNotInUse(buffer_view_state.get(), error_obj.location, \"VUID-vkDestroyBufferView-bufferView-00936\");\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-vkCmdFillBuffer-dstBuffer-00031\", \"If dstBuffer is non-sparse then it must be bound completely and contiguously to a single VkDeviceMemory object\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "const LogObjectList objlist(commandBuffer, dstBuffer);\nconst Location buffer_loc = error_obj.location.dot(Field::dstBuffer);\nskip |= ValidateMemoryIsBoundToBuffer(commandBuffer, *buffer_state, buffer_loc, \"VUID-vkCmdFillBuffer-dstBuffer-00031\");\n"
        },
        {
            "role": "user",
            "content": "{\"VUID-vkCmdFillBuffer-commandBuffer-01812\", \"If commandBuffer is a protected command buffer and protectedNoFault is not supported, dstBuffer must not be an unprotected buffer\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "\"VUID-vkCmdFillBuffer-dstBuffer-00029\", buffer_loc);\nskip |= ValidateProtectedBuffer(cb_state, *buffer_state, buffer_loc, \"VUID-vkCmdFillBuffer-commandBuffer-01811\");\nskip |= ValidateUnprotectedBuffer(cb_state, *buffer_state, buffer_loc, \"VUID-vkCmdFillBuffer-commandBuffer-01812\");\n"
        },
        {
            "role": "user",
            "content": "{\"VUID-vkCmdFillBuffer-dstOffset-00024\", \"dstOffset must be less than the size of dstBuffer\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (dstOffset >= buffer_state->create_info.size) {\n    skip |= LogError(\"VUID-vkCmdFillBuffer-dstOffset-00024\", objlist, error_obj.location.dot(Field::dstOffset),\n                     \"(%\" PRIu64 \") is not less than destination buffer (%s) size (%\" PRIu64 \").\", dstOffset,\n                     FormatHandle(dstBuffer).c_str(), buffer_state->create_info.size);\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-vkCmdFillBuffer-size-00027\", \"If size is not equal to VK_WHOLE_SIZE, size must be less than or equal to the size of dstBuffer minus dstOffset\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if ((size != VK_WHOLE_SIZE) && (size > (buffer_state->create_info.size - dstOffset))) {\n    skip |= LogError(\"VUID-vkCmdFillBuffer-size-00027\", objlist, error_obj.location.dot(Field::size),\n                     \"(%\" PRIu64 \") is greater than dstBuffer (%s) size (%\" PRIu64 \") minus dstOffset (%\" PRIu64 \").\", size,\n                     FormatHandle(dstBuffer).c_str(), buffer_state->create_info.size, dstOffset);\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-vkCmdFillBuffer-apiVersion-07894\", \"If the VK_KHR_maintenance1 extension is not enabled and VkPhysicalDeviceProperties::apiVersion is less than Vulkan 1.1, the VkCommandPool that commandBuffer was allocated from must support graphics or compute operations\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (!HasRequiredQueueFlags(cb_state, *physical_device_state, required_flags)) {\n    const LogObjectList objlist_pool(cb_state.Handle(), cb_state.command_pool->Handle());\n    skip |= LogError(\"VUID-vkCmdFillBuffer-apiVersion-07894\", objlist_pool, error_obj.location, \"%s\",\n                     DescribeRequiredQueueFlag(cb_state, *physical_device_state, required_flags).c_str());\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-vkBeginCommandBuffer-commandBuffer-00049\", \"commandBuffer must not be in the recording or pending state\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (cb_state->InUse()) {\n    skip |= LogError(\"VUID-vkBeginCommandBuffer-commandBuffer-00049\", commandBuffer, error_obj.location,\n                     \"on active %s before it has completed. You must check \"\n                     \"command buffer fence before this call.\",\n                     FormatHandle(commandBuffer).c_str());\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-vkBeginCommandBuffer-commandBuffer-00049\", \"commandBuffer must not be in the recording or pending state\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (CbState::Recording == cb_state->state) {\n    skip |= LogError(\"VUID-vkBeginCommandBuffer-commandBuffer-00049\", commandBuffer, error_obj.location,\n                     \"Cannot call Begin on %s in the RECORDING state. Must first call \"\n                     \"vkEndCommandBuffer().\",\n                     FormatHandle(commandBuffer).c_str());\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-vkBeginCommandBuffer-commandBuffer-02840\", \"If commandBuffer is a primary command buffer, then pBeginInfo->flags must not set both the VK_COMMAND_BUFFER_USAGE_ONE_TIME_SUBMIT_BIT and the VK_COMMAND_BUFFER_USAGE_SIMULTANEOUS_USE_BIT flags\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if ((pBeginInfo->flags & invalid_usage) == invalid_usage) {\n    skip |= LogError(\"VUID-vkBeginCommandBuffer-commandBuffer-02840\", commandBuffer, begin_info_loc.dot(Field::flags),\n                     \"is %s for Primary %s (can't have both ONE_TIME_SUBMIT and SIMULTANEOUS_USE).\",\n                     string_VkCommandBufferUsageFlags(pBeginInfo->flags).c_str(), FormatHandle(commandBuffer).c_str());\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-vkBeginCommandBuffer-commandBuffer-00051\", \"If commandBuffer is a secondary command buffer, the pInheritanceInfo member of pBeginInfo must be a valid VkCommandBufferInheritanceInfo structure\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (!info) {\n    skip |= LogError(\"VUID-vkBeginCommandBuffer-commandBuffer-00051\", commandBuffer, inheritance_loc,\n                     \"is null for Secondary %s.\", FormatHandle(commandBuffer).c_str());\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkCommandBufferBeginInfo-flags-06001\", \"If flags contains VK_COMMAND_BUFFER_USAGE_RENDER_PASS_CONTINUE_BIT and the renderPass member of pInheritanceInfo is not VK_NULL_HANDLE, the subpass member of pInheritanceInfo must be a valid subpass index within the renderPass member of pInheritanceInfo\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (info->subpass >= render_pass->create_info.subpassCount) {\n    skip |= LogError(\"VUID-VkCommandBufferBeginInfo-flags-06001\", commandBuffer,\n                     inheritance_loc.dot(Field::subpass),\n                     \"(%\" PRIu32 \") is not valid, renderPass was created with subpassCount %\" PRIu32 \".\",\n                     info->subpass, render_pass->create_info.subpassCount);\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkCommandBufferBeginInfo-flags-06002\", \"If flags contains VK_COMMAND_BUFFER_USAGE_RENDER_PASS_CONTINUE_BIT and the renderPass member of pInheritanceInfo is VK_NULL_HANDLE, the pNext chain of pInheritanceInfo must include a VkCommandBufferInheritanceRenderingInfo structure\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (!p_inherited_rendering_info) {\n    skip |= LogError(\"VUID-VkCommandBufferBeginInfo-flags-06002\", commandBuffer, inheritance_loc,\n                     \"pNext chain of pInheritanceInfo must include a \"\n                     \"VkCommandBufferInheritanceRenderingInfo structure.\");\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkCommandBufferInheritanceRenderingInfo-pColorAttachmentFormats-06492\", \"If any element of pColorAttachmentFormats is not VK_FORMAT_UNDEFINED, it must be a format with potential format features that include VK_FORMAT_FEATURE_COLOR_ATTACHMENT_BIT , or VK_FORMAT_FEATURE_2_LINEAR_COLOR_ATTACHMENT_BIT_NV if the linearColorAttachment feature is enabled\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if ((potential_format_features & (VK_FORMAT_FEATURE_2_COLOR_ATTACHMENT_BIT_KHR |\n    skip |= LogError(\"VUID-VkCommandBufferInheritanceRenderingInfo-pColorAttachmentFormats-06492\",\n                     commandBuffer,\n                     inheritance_loc.pNext(Struct::VkCommandBufferInheritanceRenderingInfo,\n                                           Field::pColorAttachmentFormats, i),\n                     \"is %s with potential format features %s.\", string_VkFormat(attachment_format),\n                     string_VkFormatFeatureFlags2(potential_format_features).c_str());\n"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkCommandBufferInheritanceRenderingInfo-multiview-06008\", \"If the multiview feature is not enabled, viewMask must be 0\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if ((enabled_features.multiview == VK_FALSE) && (p_inherited_rendering_info->viewMask != 0)) {\n    skip |= LogError(\"VUID-VkCommandBufferInheritanceRenderingInfo-multiview-06008\", commandBuffer,\n                     inheritance_loc.pNext(Struct::VkCommandBufferInheritanceRenderingInfo, Field::viewMask),\n                     \"is %\" PRIu32 \", but the multiview feature was not enabled.\",\n                     p_inherited_rendering_info->viewMask);\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-vkBeginCommandBuffer-commandBuffer-00052\", \"If commandBuffer is a secondary command buffer and either the occlusionQueryEnable member of the pInheritanceInfo member of pBeginInfo is VK_FALSE, or the occlusionQueryPrecise feature is not enabled, then pBeginInfo->pInheritanceInfo->queryFlags must not contain VK_QUERY_CONTROL_PRECISE_BIT\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if ((info->occlusionQueryEnable == VK_FALSE || enabled_features.occlusionQueryPrecise == VK_FALSE) &&\n    skip |= LogError(\"VUID-vkBeginCommandBuffer-commandBuffer-00052\", commandBuffer, inheritance_loc,\n                     \"Secondary %s must not have VK_QUERY_CONTROL_PRECISE_BIT if \"\n                     \"occulusionQuery is disabled or the device does not support precise occlusion queries.\",\n                     FormatHandle(commandBuffer).c_str());\n"
        },
        {
            "role": "user",
            "content": "{\"VUID-vkBeginCommandBuffer-commandBuffer-00050\", \"If commandBuffer was allocated from a VkCommandPool which did not have the VK_COMMAND_POOL_CREATE_RESET_COMMAND_BUFFER_BIT flag set, commandBuffer must be in the initial state\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (!(VK_COMMAND_POOL_CREATE_RESET_COMMAND_BUFFER_BIT & pool->createFlags)) {\n    const LogObjectList objlist(commandBuffer, cmd_pool);\n    skip |= LogError(\"VUID-vkBeginCommandBuffer-commandBuffer-00050\", objlist, error_obj.location,\n                     \"%s attempts to implicitly reset cmdBuffer created from \"\n                     \"%s that does NOT have the VK_COMMAND_POOL_CREATE_RESET_COMMAND_BUFFER_BIT bit set.\",\n                     FormatHandle(commandBuffer).c_str(), FormatHandle(cmd_pool).c_str());\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkCommandBufferBeginInfo-flags-09123\", \"If flags contains VK_COMMAND_BUFFER_USAGE_RENDER_PASS_CONTINUE_BIT, the VkCommandPool that commandBuffer was allocated from must support graphics operations\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if ((cb_state->command_pool->queue_flags & VK_QUEUE_GRAPHICS_BIT) == 0) {\n    const LogObjectList objlist(commandBuffer, cb_state->command_pool->Handle());\n    skip |= LogError(\"VUID-VkCommandBufferBeginInfo-flags-09123\", objlist, begin_info_loc.dot(Field::flags),\n                     \"contain VK_COMMAND_BUFFER_USAGE_RENDER_PASS_CONTINUE_BIT, but the command pool (created with \"\n                     \"queueFamilyIndex %\" PRIu32 \") the command buffer %s was allocated from only supports %s.\",\n                     cb_state->command_pool->queueFamilyIndex, FormatHandle(commandBuffer).c_str(),\n                     string_VkQueueFlags(cb_state->command_pool->queue_flags).c_str());\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-vkEndCommandBuffer-commandBuffer-00060\", \"If commandBuffer is a primary command buffer, there must not be an active render pass instance\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (cb_state.IsPrimary() || !(cb_state.beginInfo.flags & VK_COMMAND_BUFFER_USAGE_RENDER_PASS_CONTINUE_BIT)) {\n    skip |= InsideRenderPass(cb_state, error_obj.location, \"VUID-vkEndCommandBuffer-commandBuffer-00060\");\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-vkEndCommandBuffer-commandBuffer-00059\", \"commandBuffer must be in the recording state\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (cb_state.state == CbState::InvalidComplete || cb_state.state == CbState::InvalidIncomplete) {\n    skip |= ReportInvalidCommandBuffer(cb_state, error_obj.location, \"VUID-vkEndCommandBuffer-commandBuffer-00059\");\n    skip |= LogError(\"VUID-vkEndCommandBuffer-commandBuffer-00059\", commandBuffer, error_obj.location,\n                     \"Cannot call End on %s when not in the RECORDING state. Must first call vkBeginCommandBuffer().\",\n                     FormatHandle(commandBuffer).c_str());\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-vkEndCommandBuffer-commandBuffer-00061\", \"All queries made active during the recording of commandBuffer must have been made inactive\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "skip |= LogError(\"VUID-vkEndCommandBuffer-commandBuffer-00061\", commandBuffer, error_obj.location,\n                 \"Ending command buffer with in progress query: %s, query %d.\", FormatHandle(query_obj.pool).c_str(),\n                 query_obj.slot);\n"
        },
        {
            "role": "user",
            "content": "{\"VUID-vkEndCommandBuffer-None-01978\", \"Conditional rendering must not be active\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (cb_state.conditional_rendering_active) {\n    skip |= LogError(\"VUID-vkEndCommandBuffer-None-01978\", commandBuffer, error_obj.location,\n                     \"Ending command buffer with active conditional rendering.\");\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-vkEndCommandBuffer-None-06991\", \"There must be no video session object bound\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "skip |= InsideVideoCodingScope(cb_state, error_obj.location, \"VUID-vkEndCommandBuffer-None-06991\");\n"
        },
        {
            "role": "user",
            "content": "{\"VUID-vkResetCommandBuffer-commandBuffer-00045\", \"commandBuffer must not be in the pending state\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (cb_state->InUse()) {\n    const LogObjectList objlist(commandBuffer, cmd_pool);\n    skip |= LogError(\"VUID-vkResetCommandBuffer-commandBuffer-00045\", objlist, error_obj.location, \"(%s) is in use.\",\n                     FormatHandle(commandBuffer).c_str());\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-vkCmdBindIndexBuffer2KHR-size-08767\", \"If size is not VK_WHOLE_SIZE, size must be a multiple of the size of the type indicated by indexType\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (!IsIntegerMultipleOf(size, offset_align)) {\n    const LogObjectList objlist(commandBuffer, buffer);\n    skip |= LogError(\"VUID-vkCmdBindIndexBuffer2KHR-size-08767\", objlist, error_obj.location.dot(Field::size),\n                     \"(%\" PRIu64 \") does not fall on alignment (%s) boundary.\", size, string_VkIndexType(indexType));\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-vkCmdBindIndexBuffer2KHR-size-08768\", \"If size is not VK_WHOLE_SIZE, the sum of offset and size must be less than or equal to the size of buffer\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if ((offset + size) > buffer_state->create_info.size) {\n    const LogObjectList objlist(commandBuffer, buffer);\n    skip |= LogError(\"VUID-vkCmdBindIndexBuffer2KHR-size-08768\", objlist, error_obj.location.dot(Field::size),\n                     \"(%\" PRIu64 \") + offset (%\" PRIu64 \") is larger than the buffer size (%\" PRIu64 \").\", size, offset,\n                     buffer_state->create_info.size);\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-vkCmdBindVertexBuffers-pOffsets-00626\", \"All elements of pOffsets must be less than the size of the corresponding element in pBuffers\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (pOffsets[i] >= buffer_state->create_info.size) {\n    skip |= LogError(\"VUID-vkCmdBindVertexBuffers-pOffsets-00626\", objlist, error_obj.location.dot(Field::pOffsets, i),\n                     \"(%\" PRIu64 \") is larger than the buffer size (%\" PRIu64 \").\", pOffsets[i],\n                     buffer_state->create_info.size);\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-vkCmdUpdateBuffer-commandBuffer-01813\", \"If commandBuffer is an unprotected command buffer and protectedNoFault is not supported, dstBuffer must not be a protected buffer\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "skip |= ValidateBufferUsageFlags(objlist, *dst_buffer_state, VK_BUFFER_USAGE_TRANSFER_DST_BIT, true,\n                                 \"VUID-vkCmdUpdateBuffer-dstBuffer-00034\", buffer_loc);\nskip |= ValidateCmd(*cb_state, error_obj.location);\nskip |= ValidateProtectedBuffer(*cb_state, *dst_buffer_state, buffer_loc, \"VUID-vkCmdUpdateBuffer-commandBuffer-01813\");\n"
        },
        {
            "role": "user",
            "content": "{\"VUID-vkCmdUpdateBuffer-commandBuffer-01814\", \"If commandBuffer is a protected command buffer and protectedNoFault is not supported, dstBuffer must not be an unprotected buffer\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "\"VUID-vkCmdUpdateBuffer-dstBuffer-00034\", buffer_loc);\nskip |= ValidateCmd(*cb_state, error_obj.location);\nskip |= ValidateProtectedBuffer(*cb_state, *dst_buffer_state, buffer_loc, \"VUID-vkCmdUpdateBuffer-commandBuffer-01813\");\nskip |= ValidateUnprotectedBuffer(*cb_state, *dst_buffer_state, buffer_loc, \"VUID-vkCmdUpdateBuffer-commandBuffer-01814\");\n"
        },
        {
            "role": "user",
            "content": "{\"VUID-vkCmdUpdateBuffer-dstOffset-00032\", \"dstOffset must be less than the size of dstBuffer\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (dstOffset >= dst_buffer_state->create_info.size) {\n    skip |= LogError(\"VUID-vkCmdUpdateBuffer-dstOffset-00032\", objlist, error_obj.location.dot(Field::dstOffset),\n                     \"(%\" PRIu64 \") is not less than the size (%\" PRIu64 \").\", dstOffset, dst_buffer_state->create_info.size);\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-vkCmdUpdateBuffer-dataSize-00033\", \"dataSize must be less than or equal to the size of dstBuffer minus dstOffset\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "skip |= LogError(\"VUID-vkCmdUpdateBuffer-dstOffset-00032\", objlist, error_obj.location.dot(Field::dstOffset),\n} else if (dataSize > dst_buffer_state->create_info.size - dstOffset) {\nskip |= LogError(\"VUID-vkCmdUpdateBuffer-dataSize-00033\", objlist, error_obj.location.dot(Field::dataSize),\n                 \"(%\" PRIu64 \") is not less than the buffer size (%\" PRIu64 \") minus dstOffset (%\" PRIu64 \").\", dataSize,\n                 dst_buffer_state->create_info.size, dstOffset);\n"
        },
        {
            "role": "user",
            "content": "{\"VUID-vkCmdExecuteCommands-pCommandBuffers-00094\", \"Each element of pCommandBuffers must have been allocated from a VkCommandPool that was created for the same queue family as the VkCommandPool from which commandBuffer was allocated\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (primary_pool && secondary_pool && (primary_pool->queueFamilyIndex != secondary_pool->queueFamilyIndex)) {\n    const LogObjectList objlist(sub_cb_state.Handle(), cb_state.Handle());\n    skip |= LogError(\"VUID-vkCmdExecuteCommands-pCommandBuffers-00094\", objlist, cb_loc,\n                     \"Primary command buffer %s created in queue family %\" PRIu32\n                     \" has secondary command buffer %s created in queue family %\" PRIu32 \".\",\n                     FormatHandle(cb_state).c_str(), primary_pool->queueFamilyIndex, FormatHandle(sub_cb_state).c_str(),\n                     secondary_pool->queueFamilyIndex);\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-vkCmdExecuteCommands-commandBuffer-09375\", \"commandBuffer must not be a secondary command buffer unless the nestedCommandBuffer feature is enabled\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (!enabled_features.nestedCommandBuffer) {\n    skip |= LogError(\"VUID-vkCmdExecuteCommands-commandBuffer-09375\", commandBuffer,\n                     error_obj.location.dot(Field::commandBuffer),\n                     \"is a secondary command buffer (and the nestedCommandBuffer feature was not enabled).\");\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-vkCmdExecuteCommands-commandBuffer-07594\", \"commandBuffer must not have any queries other than VK_QUERY_TYPE_OCCLUSION and VK_QUERY_TYPE_PIPELINE_STATISTICS active\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (queryType != VK_QUERY_TYPE_OCCLUSION && queryType != VK_QUERY_TYPE_PIPELINE_STATISTICS) {\n    skip |= LogError(\"VUID-vkCmdExecuteCommands-commandBuffer-07594\", commandBuffer, error_obj.location,\n                     \"query with type %s is active.\", string_VkQueryType(queryType));\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-vkCmdExecuteCommands-contents-09680\", \"If vkCmdExecuteCommands is being called within a render pass instance begun with vkCmdBeginRenderPass, and vkCmdNextSubpass has not been called in the current render pass instance, the contents parameter of vkCmdBeginRenderPass must have been set to VK_SUBPASS_CONTENTS_SECONDARY_COMMAND_BUFFERS , or VK_SUBPASS_CONTENTS_INLINE_AND_SECONDARY_COMMAND_BUFFERS_EXT\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (cb_state.GetActiveSubpass() == 0) {\n    const LogObjectList objlist(commandBuffer, cb_state.activeRenderPass->Handle());\n    skip |= LogError(\"VUID-vkCmdExecuteCommands-contents-09680\", objlist, error_obj.location,\n                     \"contents must be set to VK_SUBPASS_CONTENTS_SECONDARY_COMMAND_BUFFERS or \"\n                     \"VK_SUBPASS_CONTENTS_INLINE_AND_SECONDARY_COMMAND_BUFFERS_KHR\"\n                     \"when calling vkCmdExecuteCommands() within the first subpass.\");\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-vkCmdExecuteCommands-pCommandBuffers-00088\", \"Each element of pCommandBuffers must have been allocated with a level of VK_COMMAND_BUFFER_LEVEL_SECONDARY\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (!sub_cb_state.IsSecondary()) {\n    const LogObjectList objlist(commandBuffer, pCommandBuffers[i]);\n    skip |= LogError(\"VUID-vkCmdExecuteCommands-pCommandBuffers-00088\", objlist, cb_loc,\n                     \"(%s) is not VK_COMMAND_BUFFER_LEVEL_SECONDARY.\", FormatHandle(pCommandBuffers[i]).c_str());\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-vkCmdExecuteCommands-pCommandBuffers-00100\", \"If vkCmdExecuteCommands is not being called within a render pass instance, each element of pCommandBuffers must not have been recorded with the VK_COMMAND_BUFFER_USAGE_RENDER_PASS_CONTINUE_BIT\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (sub_cb_state.beginInfo.flags & VK_COMMAND_BUFFER_USAGE_RENDER_PASS_CONTINUE_BIT) {\n    const LogObjectList objlist(commandBuffer, pCommandBuffers[i]);\n    skip |= LogError(\"VUID-vkCmdExecuteCommands-pCommandBuffers-00100\", objlist, cb_loc,\n                     \"(%s) is executed outside a render pass \"\n                     \"instance scope, but the Secondary Command Buffer does have the \"\n                     \"VK_COMMAND_BUFFER_USAGE_RENDER_PASS_CONTINUE_BIT set in VkCommandBufferBeginInfo::flags when \"\n                     \"the vkBeginCommandBuffer() was called.\",\n                     FormatHandle(pCommandBuffers[i]).c_str());\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-vkCmdExecuteCommands-pCommandBuffers-00096\", \"If vkCmdExecuteCommands is being called within a render pass instance, each element of pCommandBuffers must have been recorded with the VK_COMMAND_BUFFER_USAGE_RENDER_PASS_CONTINUE_BIT\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (!(sub_cb_state.beginInfo.flags & VK_COMMAND_BUFFER_USAGE_RENDER_PASS_CONTINUE_BIT)) {\n    const LogObjectList objlist(pCommandBuffers[i], cb_state.activeRenderPass->Handle());\n    skip |= LogError(\"VUID-vkCmdExecuteCommands-pCommandBuffers-00096\", objlist, cb_loc,\n                     \"(%s) is executed within a %s \"\n                     \"instance scope, but the Secondary Command Buffer does not have the \"\n                     \"VK_COMMAND_BUFFER_USAGE_RENDER_PASS_CONTINUE_BIT set in VkCommandBufferBeginInfo::flags when \"\n                     \"the vkBeginCommandBuffer() was called.\",\n                     FormatHandle(pCommandBuffers[i]).c_str(),\n                     FormatHandle(cb_state.activeRenderPass->Handle()).c_str());\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-vkCmdExecuteCommands-pCommandBuffers-06019\", \"If vkCmdExecuteCommands is being called within a render pass instance begun with vkCmdBeginRenderPass, each element of pCommandBuffers must have been recorded with VkCommandBufferInheritanceInfo::subpass set to the index of the subpass which the given command buffer will be executed in\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (!cb_state.activeRenderPass->UsesDynamicRendering() && (cb_state.GetActiveSubpass() != inheritance_subpass)) {\n    const LogObjectList objlist(commandBuffer, pCommandBuffers[i], cb_state.activeRenderPass->Handle());\n    skip |= LogError(\"VUID-vkCmdExecuteCommands-pCommandBuffers-06019\", objlist, cb_loc,\n                     \"(%s) is executed within a %s \"\n                     \"instance scope begun by vkCmdBeginRenderPass(), but \"\n                     \"VkCommandBufferInheritanceInfo::subpass (%\" PRIu32\n                     \") does not \"\n                     \"match the current subpass (%\" PRIu32 \").\",\n                     FormatHandle(pCommandBuffers[i]).c_str(),\n                     FormatHandle(cb_state.activeRenderPass->Handle()).c_str(), inheritance_subpass,\n                     cb_state.GetActiveSubpass());\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-vkCmdExecuteCommands-colorAttachmentCount-06027\", \"If vkCmdExecuteCommands is being called within a render pass instance begun with vkCmdBeginRendering, the colorAttachmentCount member of the VkCommandBufferInheritanceRenderingInfo structure included in the pNext chain of VkCommandBufferBeginInfo::pInheritanceInfo used to begin recording each element of pCommandBuffers must be equal to the VkRenderingInfo::colorAttachmentCount parameter to vkCmdBeginRendering\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (inheritance_rendering_info.colorAttachmentCount != rendering_info.colorAttachmentCount) {\n    const LogObjectList objlist(commandBuffer, pCommandBuffers[i], cb_state.activeRenderPass->Handle());\n    skip |= LogError(\"VUID-vkCmdExecuteCommands-colorAttachmentCount-06027\", objlist, cb_loc,\n                     \"(%s) is executed within a dynamic renderpass instance scope begun \"\n                     \"by vkCmdBeginRendering(), but \"\n                     \"VkCommandBufferInheritanceRenderingInfo::colorAttachmentCount (%\" PRIu32\n                     \") does \"\n                     \"not match VkRenderingInfo::colorAttachmentCount (%\" PRIu32 \").\",\n                     FormatHandle(pCommandBuffers[i]).c_str(),\n                     inheritance_rendering_info.colorAttachmentCount, rendering_info.colorAttachmentCount);\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-vkCmdExecuteCommands-imageView-07606\", \"If vkCmdExecuteCommands is being called within a render pass instance begun with vkCmdBeginRendering, if the imageView member of an element of the VkRenderingInfo::pColorAttachments parameter to vkCmdBeginRendering is VK_NULL_HANDLE, the corresponding element of the pColorAttachmentFormats member of the VkCommandBufferInheritanceRenderingInfo structure included in the pNext chain of VkCommandBufferBeginInfo::pInheritanceInfo used to begin recording each element of pCommandBuffers must be VK_FORMAT_UNDEFINED\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (inheritance_rendering_info.pColorAttachmentFormats[color_i] != VK_FORMAT_UNDEFINED) {\n    const LogObjectList objlist(commandBuffer, pCommandBuffers[i],\n    skip |= LogError(\"VUID-vkCmdExecuteCommands-imageView-07606\", objlist, cb_loc,\n                     \"(%s) is executed within a dynamic render pass instance \"\n                     \"scope begun \"\n                     \"by vkCmdBeginRendering(), VkRenderingInfo::pColorAttachments[%\" PRIu32\n                     \"].imageView is VK_NULL_HANDLE but \"\n                     \"VkCommandBufferInheritanceRenderingInfo::pColorAttachmentFormats[%\" PRIu32\n                     \"] is %s.\",\n                     FormatHandle(pCommandBuffers[i]).c_str(), color_i, color_i,\n                     string_VkFormat(inheritance_rendering_info.pColorAttachmentFormats[color_i]));\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-vkCmdExecuteCommands-imageView-06028\", \"If vkCmdExecuteCommands is being called within a render pass instance begun with vkCmdBeginRendering, if the imageView member of an element of the VkRenderingInfo::pColorAttachments parameter to vkCmdBeginRendering is not VK_NULL_HANDLE, the corresponding element of the pColorAttachmentFormats member of the VkCommandBufferInheritanceRenderingInfo structure included in the pNext chain of VkCommandBufferBeginInfo::pInheritanceInfo used to begin recording each element of pCommandBuffers must be equal to the format used to create that image view\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "const LogObjectList objlist(commandBuffer, pCommandBuffers[i],\nskip |= LogError(\"VUID-vkCmdExecuteCommands-imageView-06028\", objlist, cb_loc,\n                 \"(%s) is executed within a dynamic render pass instance \"\n                 \"scope begun \"\n                 \"by vkCmdBeginRendering(), VkRenderingInfo::pColorAttachments[%\" PRIu32\n                 \"].imageView format is %s but \"\n                 \"VkCommandBufferInheritanceRenderingInfo::pColorAttachmentFormats[%\" PRIu32\n                 \"] is %s.\",\n                 FormatHandle(pCommandBuffers[i]).c_str(), color_i,\n                 string_VkFormat(image_view_state->create_info.format), color_i,\n                 string_VkFormat(inheritance_rendering_info.pColorAttachmentFormats[color_i]));\n"
        },
        {
            "role": "user",
            "content": "{\"VUID-vkCmdExecuteCommands-pDepthAttachment-06029\", \"If vkCmdExecuteCommands is being called within a render pass instance begun with vkCmdBeginRendering, if the VkRenderingInfo::pDepthAttachment->imageView parameter to vkCmdBeginRendering is not VK_NULL_HANDLE, the value of the depthAttachmentFormat member of the VkCommandBufferInheritanceRenderingInfo structure included in the pNext chain of VkCommandBufferBeginInfo::pInheritanceInfo used to begin recording each element of pCommandBuffers must be equal to the format used to create that image view\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (image_view_state &&\n    const LogObjectList objlist(commandBuffer, pCommandBuffers[i], cb_state.activeRenderPass->Handle());\n    skip |= LogError(\"VUID-vkCmdExecuteCommands-pDepthAttachment-06029\", objlist, cb_loc,\n                     \"(%s) is executed within a dynamic renderpass \"\n                     \"instance scope begun \"\n                     \"by vkCmdBeginRendering(), but \"\n                     \"VkCommandBufferInheritanceRenderingInfo::depthAttachmentFormat does \"\n                     \"not match the format of the imageView in VkRenderingInfo::pDepthAttachment.\",\n                     FormatHandle(pCommandBuffers[i]).c_str());\n"
        },
        {
            "role": "user",
            "content": "{\"VUID-vkCmdExecuteCommands-pDepthAttachment-06774\", \"If vkCmdExecuteCommands is being called within a render pass instance begun with vkCmdBeginRendering and the VkRenderingInfo::pDepthAttachment->imageView parameter to vkCmdBeginRendering was VK_NULL_HANDLE, the value of the depthAttachmentFormat member of the VkCommandBufferInheritanceRenderingInfo structure included in the pNext chain of VkCommandBufferBeginInfo::pInheritanceInfo used to begin recording each element of pCommandBuffers must be VK_FORMAT_UNDEFINED\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (format != VK_FORMAT_UNDEFINED) {\n    const LogObjectList objlist(commandBuffer, pCommandBuffers[i], cb_state.activeRenderPass->Handle());\n    skip |= LogError(\"VUID-vkCmdExecuteCommands-pDepthAttachment-06774\", objlist, cb_loc,\n                     \"(%s) is executed within a dynamic renderpass \"\n                     \"instance scope begun by vkCmdBeginRendering(), and \"\n                     \"VkRenderingInfo::pDepthAttachment does not define an \"\n                     \"image view but VkCommandBufferInheritanceRenderingInfo::depthAttachmentFormat \"\n                     \"is %s instead of VK_FORMAT_UNDEFINED.\",\n                     FormatHandle(pCommandBuffers[i]).c_str(), string_VkFormat(format));\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-vkCmdExecuteCommands-pStencilAttachment-06775\", \"If vkCmdExecuteCommands is being called within a render pass instance begun with vkCmdBeginRendering and the VkRenderingInfo::pStencilAttachment->imageView parameter to vkCmdBeginRendering was VK_NULL_HANDLE, the value of the stencilAttachmentFormat member of the VkCommandBufferInheritanceRenderingInfo structure included in the pNext chain of VkCommandBufferBeginInfo::pInheritanceInfo used to begin recording each element of pCommandBuffers must be VK_FORMAT_UNDEFINED\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (format != VK_FORMAT_UNDEFINED) {\n    const LogObjectList objlist(commandBuffer, pCommandBuffers[i], cb_state.activeRenderPass->Handle());\n    skip |= LogError(\"VUID-vkCmdExecuteCommands-pStencilAttachment-06775\", objlist, cb_loc,\n                     \"(%s) is executed within a dynamic renderpass \"\n                     \"instance scope begun by vkCmdBeginRendering(), and \"\n                     \"VkRenderingInfo::pStencilAttachment does not define an \"\n                     \"image view but VkCommandBufferInheritanceRenderingInfo::stencilAttachmentFormat \"\n                     \"is %s instead of VK_FORMAT_UNDEFINED.\",\n                     FormatHandle(pCommandBuffers[i]).c_str(), string_VkFormat(format));\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-vkCmdExecuteCommands-viewMask-06031\", \"If vkCmdExecuteCommands is being called within a render pass instance begun with vkCmdBeginRendering, the viewMask member of the VkCommandBufferInheritanceRenderingInfo structure included in the pNext chain of VkCommandBufferBeginInfo::pInheritanceInfo used to begin recording each element of pCommandBuffers must be equal to the VkRenderingInfo::viewMask parameter to vkCmdBeginRendering\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (rendering_info.viewMask != inheritance_rendering_info.viewMask) {\n    const LogObjectList objlist(commandBuffer, pCommandBuffers[i], cb_state.activeRenderPass->Handle());\n    skip |= LogError(\"VUID-vkCmdExecuteCommands-viewMask-06031\", objlist, cb_loc,\n                     \"(%s) is executed within a dynamic renderpass instance scope begun \"\n                     \"by vkCmdBeginRendering(), but \"\n                     \"VkCommandBufferInheritanceRenderingInfo::viewMask (%\" PRIu32\n                     \") does \"\n                     \"not match VkRenderingInfo::viewMask (%\" PRIu32 \").\",\n                     FormatHandle(pCommandBuffers[i]).c_str(), inheritance_rendering_info.viewMask,\n                     rendering_info.viewMask);\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-vkCmdExecuteCommands-pNext-06036\", \"If vkCmdExecuteCommands is being called within a render pass instance begun with vkCmdBeginRendering and the pNext chain of VkCommandBufferInheritanceInfo does not include a VkAttachmentSampleCountInfoAMD or VkAttachmentSampleCountInfoNV structure, if the VkRenderingInfo::pDepthAttachment->imageView parameter to vkCmdBeginRendering is not VK_NULL_HANDLE, the value of VkCommandBufferInheritanceRenderingInfo::rasterizationSamples must be equal to the sample count used to create that image view\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "const LogObjectList objlist(commandBuffer, pCommandBuffers[i],\nskip |= LogError(\"VUID-vkCmdExecuteCommands-pNext-06036\", objlist, cb_loc,\n                 \"(%s) is executed within a dynamic renderpass \"\n                 \"instance scope begun \"\n                 \"by vkCmdBeginRenderingKHR(), but the sample count of the image view for \"\n                 \"VkRenderingInfoKHR::pDepthAttachment does not match \"\n                 \"VkCommandBufferInheritanceRenderingInfo::rasterizationSamples.\",\n                 FormatHandle(pCommandBuffers[i]).c_str());\n"
        },
        {
            "role": "user",
            "content": "{\"VUID-vkCmdExecuteCommands-nestedCommandBuffer-09376\", \"If the nestedCommandBuffer feature is enabled, the command buffer nesting level of each element of pCommandBuffers must be less than maxCommandBufferNestingLevel\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (sub_cb_state.nesting_level >= phys_dev_ext_props.nested_command_buffer_props.maxCommandBufferNestingLevel) {\n    skip |= LogError(\"VUID-vkCmdExecuteCommands-nestedCommandBuffer-09376\", pCommandBuffers[i], cb_loc,\n                     \"(%s) has a nesting level of %\" PRIu32\n                     \" which is not less then maxCommandBufferNestingLevel (%\" PRIu32 \").\",\n                     FormatHandle(pCommandBuffers[i]).c_str(), sub_cb_state.nesting_level,\n                     phys_dev_ext_props.nested_command_buffer_props.maxCommandBufferNestingLevel);\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-vkCmdExecuteCommands-pCommandBuffers-00089\", \"Each element of pCommandBuffers must be in the pending or executable state\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "skip |= ValidateSecondaryCommandBufferState(cb_state, sub_cb_state, cb_loc);\nskip |= ValidateCommandBufferState(sub_cb_state, cb_loc, 0, \"VUID-vkCmdExecuteCommands-pCommandBuffers-00089\");\n"
        },
        {
            "role": "user",
            "content": "{\"VUID-vkCmdExecuteCommands-pCommandBuffers-00091\", \"If any element of pCommandBuffers was not recorded with the VK_COMMAND_BUFFER_USAGE_SIMULTANEOUS_USE_BIT flag, it must not be in the pending state\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (sub_cb_state.InUse()) {\n    const LogObjectList objlist(commandBuffer, pCommandBuffers[i]);\n    skip |= LogError(\"VUID-vkCmdExecuteCommands-pCommandBuffers-00091\", objlist, cb_loc,\n                     \"Cannot execute pending %s without VK_COMMAND_BUFFER_USAGE_SIMULTANEOUS_USE_BIT set.\",\n                     FormatHandle(pCommandBuffers[i]).c_str());\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-vkCmdExecuteCommands-pCommandBuffers-00092\", \"If any element of pCommandBuffers was not recorded with the VK_COMMAND_BUFFER_USAGE_SIMULTANEOUS_USE_BIT flag, it must not have already been recorded to commandBuffer\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (cb_state.linkedCommandBuffers.count(const_cast<vvl::CommandBuffer *>(&sub_cb_state))) {\n    const LogObjectList objlist(commandBuffer, pCommandBuffers[i]);\n    skip |= LogError(\"VUID-vkCmdExecuteCommands-pCommandBuffers-00092\", objlist, cb_loc,\n                     \"Cannot execute %s without VK_COMMAND_BUFFER_USAGE_SIMULTANEOUS_USE_BIT \"\n                     \"set if previously executed in %s\",\n                     FormatHandle(pCommandBuffers[i]).c_str(), FormatHandle(commandBuffer).c_str());\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-vkCmdExecuteCommands-commandBuffer-00101\", \"If the inheritedQueries feature is not enabled, commandBuffer must not have any queries active\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (!cb_state.activeQueries.empty() && !enabled_features.inheritedQueries) {\n    const LogObjectList objlist(commandBuffer, pCommandBuffers[i]);\n    skip |= LogError(\"VUID-vkCmdExecuteCommands-commandBuffer-00101\", objlist, cb_loc,\n                     \"cannot be submitted with a query in flight and \"\n                     \"inherited queries not supported on this device.\");\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-vkCmdExecuteCommands-commandBuffer-01820\", \"If commandBuffer is a protected command buffer and protectedNoFault is not supported, each element of pCommandBuffers must be a protected command buffer\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if ((cb_state.unprotected == false) && (sub_cb_state.unprotected == true)) {\n    const LogObjectList objlist(commandBuffer, pCommandBuffers[i]);\n    skip |= LogError(\"VUID-vkCmdExecuteCommands-commandBuffer-01820\", objlist, cb_loc,\n                     \"(%s) is a unprotected while primary command buffer (%s) is protected.\",\n                     FormatHandle(pCommandBuffers[i]).c_str(), FormatHandle(commandBuffer).c_str());\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-vkCmdExecuteCommands-commandBuffer-01821\", \"If commandBuffer is an unprotected command buffer and protectedNoFault is not supported, each element of pCommandBuffers must be an unprotected command buffer\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "FormatHandle(pCommandBuffers[i]).c_str(), FormatHandle(commandBuffer).c_str());\nconst LogObjectList objlist(commandBuffer, pCommandBuffers[i]);\nskip |= LogError(\"VUID-vkCmdExecuteCommands-commandBuffer-01821\", objlist, cb_loc,\n\"(%s) is a protected while primary command buffer (%s) is unprotected.\",\nFormatHandle(pCommandBuffers[i]).c_str(), FormatHandle(commandBuffer).c_str());\n"
        },
        {
            "role": "user",
            "content": "{\"VUID-vkCmdExecuteCommands-commandBuffer-00102\", \"If commandBuffer has a VK_QUERY_TYPE_OCCLUSION query active, then each element of pCommandBuffers must have been recorded with VkCommandBufferInheritanceInfo::occlusionQueryEnable set to VK_TRUE\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (sub_cb_state.inheritanceInfo.occlusionQueryEnable != VK_TRUE) {\n    const LogObjectList objlist(commandBuffer, pCommandBuffers[i]);\n    skip |= LogError(\"VUID-vkCmdExecuteCommands-commandBuffer-00102\", objlist, cb_loc,\n                     \"(%s) was recorded with VkCommandBufferInheritanceInfo::occlusionQueryEnable set to VK_FALSE, but \"\n                     \"primary command buffer %s has an active occlusion query\",\n                     FormatHandle(pCommandBuffers[i]).c_str(), FormatHandle(commandBuffer).c_str());\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-vkCmdBindTransformFeedbackBuffersEXT-None-02365\", \"Transform feedback must not be active when the vkCmdBindTransformFeedbackBuffersEXT command is recorded\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (cb_state->transform_feedback_active) {\n    skip |= LogError(\"VUID-vkCmdBindTransformFeedbackBuffersEXT-None-02365\", commandBuffer, error_obj.location,\n                     \"transform feedback is active.\");\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-vkCmdBindTransformFeedbackBuffersEXT-pOffsets-02358\", \"All elements of pOffsets must be less than the size of the corresponding element in pBuffers\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (pOffsets[i] >= buffer_state->create_info.size) {\n    const LogObjectList objlist(commandBuffer, pBuffers[i]);\n    skip |= LogError(\"VUID-vkCmdBindTransformFeedbackBuffersEXT-pOffsets-02358\", objlist,\n                     error_obj.location.dot(Field::pOffsets, i),\n                     \"(%\" PRIu64 \") is greater than or equal to the size of pBuffers[%\" PRIu32 \"] (%\" PRIu64 \").\",\n                     pOffsets[i], i, buffer_state->create_info.size);\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-vkCmdBindTransformFeedbackBuffersEXT-pBuffers-02360\", \"All elements of pBuffers must have been created with the VK_BUFFER_USAGE_TRANSFORM_FEEDBACK_BUFFER_BIT_EXT flag\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if ((buffer_state->usage & VK_BUFFER_USAGE_TRANSFORM_FEEDBACK_BUFFER_BIT_EXT) == 0) {\n    const LogObjectList objlist(commandBuffer, pBuffers[i]);\n    skip |= LogError(\"VUID-vkCmdBindTransformFeedbackBuffersEXT-pBuffers-02360\", objlist, buffer_loc,\n                     \"was created with %s.\", string_VkBufferUsageFlags2KHR(buffer_state->usage).c_str());\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-vkCmdBindTransformFeedbackBuffersEXT-pSizes-02362\", \"All elements of pSizes must be either VK_WHOLE_SIZE, or less than or equal to the size of the corresponding buffer in pBuffers\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (pSizes[i] > buffer_state->create_info.size) {\n    const LogObjectList objlist(commandBuffer, pBuffers[i]);\n    skip |= LogError(\"VUID-vkCmdBindTransformFeedbackBuffersEXT-pSizes-02362\", objlist,\n                     error_obj.location.dot(Field::pSizes, i),\n                     \"(%\" PRIu64 \") is greater than the size of pBuffers[%\" PRIu32 \"](%\" PRIu64 \").\", pSizes[i], i,\n                     buffer_state->create_info.size);\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-vkCmdBeginTransformFeedbackEXT-None-06233\", \"If the shaderObject feature is not enabled, a valid graphics pipeline must be bound to VK_PIPELINE_BIND_POINT_GRAPHICS\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (!pipe && !enabled_features.shaderObject) {\n    skip |= LogError(\"VUID-vkCmdBeginTransformFeedbackEXT-None-06233\", commandBuffer, error_obj.location,\n                     \"No graphics pipeline has been bound yet.\");\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-vkCmdBeginTransformFeedbackEXT-None-04128\", \"The last pre-rasterization shader stage of the bound graphics pipeline must have been declared with the Xfb execution mode\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (!stage_state.entrypoint->execution_mode.Has(spirv::ExecutionModeSet::xfb_bit)) {\n    const LogObjectList objlist(commandBuffer, pipe->Handle());\n    skip |= LogError(\"VUID-vkCmdBeginTransformFeedbackEXT-None-04128\", objlist, error_obj.location,\n                     \"The last bound pipeline (%s) has no Xfb Execution Mode for stage %s.\",\n                     FormatHandle(pipe->Handle()).c_str(),\n                     string_VkShaderStageFlagBits(pipe->pre_raster_state->last_stage));\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-vkCmdBeginTransformFeedbackEXT-None-02367\", \"Transform feedback must not be active\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (cb_state->transform_feedback_active) {\n    skip |= LogError(\"VUID-vkCmdBeginTransformFeedbackEXT-None-02367\", commandBuffer, error_obj.location,\n                     \"transform feedback is active.\");\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-vkCmdBeginTransformFeedbackEXT-None-02373\", \"Transform feedback must not be made active in a render pass instance with multiview enabled\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (rp_ci.pSubpasses[i].viewMask > 0) {\n    skip |= LogError(\"VUID-vkCmdBeginTransformFeedbackEXT-None-02373\", commandBuffer, error_obj.location,\n                     \"active render pass (%s) has multiview enabled.\",\n                     FormatHandle(cb_state->activeRenderPass->Handle()).c_str());\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-vkCmdBeginTransformFeedbackEXT-pCounterBuffer-02371\", \"If pCounterBuffer is NULL, then pCounterBufferOffsets must also be NULL\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (pCounterBufferOffsets != nullptr) {\n    skip |= LogError(\"VUID-vkCmdBeginTransformFeedbackEXT-pCounterBuffer-02371\", commandBuffer, error_obj.location,\n                     \"pCounterBuffers is NULL and pCounterBufferOffsets is not NULL.\");\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-vkCmdBeginTransformFeedbackEXT-pCounterBufferOffsets-02370\", \"For each buffer handle in the array, if it is not VK_NULL_HANDLE it must reference a buffer large enough to hold 4 bytes at the corresponding offset from the pCounterBufferOffsets array\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (pCounterBufferOffsets != nullptr && pCounterBufferOffsets[i] + 4 > buffer_state->create_info.size) {\n    const LogObjectList objlist(commandBuffer, pCounterBuffers[i]);\n    skip |= LogError(\"VUID-vkCmdBeginTransformFeedbackEXT-pCounterBufferOffsets-02370\", objlist,\n                     error_obj.location.dot(Field::pCounterBuffers, i),\n                     \"is not large enough to hold 4 bytes at pCounterBufferOffsets[%\" PRIu32 \"](0x%\" PRIx64 \").\", i,\n                     pCounterBufferOffsets[i]);\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-vkCmdBeginTransformFeedbackEXT-pCounterBuffers-02372\", \"For each buffer handle in the pCounterBuffers array that is not VK_NULL_HANDLE it must have been created with a usage value containing VK_BUFFER_USAGE_TRANSFORM_FEEDBACK_COUNTER_BUFFER_BIT_EXT\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if ((buffer_state->usage & VK_BUFFER_USAGE_TRANSFORM_FEEDBACK_COUNTER_BUFFER_BIT_EXT) == 0) {\n    const LogObjectList objlist(commandBuffer, pCounterBuffers[i]);\n    skip |= LogError(\"VUID-vkCmdBeginTransformFeedbackEXT-pCounterBuffers-02372\", objlist,\n                     error_obj.location.dot(Field::pCounterBuffers, i), \"was created with %s.\",\n                     string_VkBufferUsageFlags2KHR(buffer_state->usage).c_str());\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-vkCmdEndTransformFeedbackEXT-None-02375\", \"Transform feedback must be active\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (!cb_state->transform_feedback_active) {\n    skip |= LogError(\"VUID-vkCmdEndTransformFeedbackEXT-None-02375\", commandBuffer, error_obj.location,\n                     \"transform feedback is not active.\");\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-vkCmdEndTransformFeedbackEXT-pCounterBuffers-02380\", \"For each buffer handle in the pCounterBuffers array that is not VK_NULL_HANDLE it must have been created with a usage value containing VK_BUFFER_USAGE_TRANSFORM_FEEDBACK_COUNTER_BUFFER_BIT_EXT\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if ((buffer_state->usage & VK_BUFFER_USAGE_TRANSFORM_FEEDBACK_COUNTER_BUFFER_BIT_EXT) == 0) {\n    const LogObjectList objlist(commandBuffer, pCounterBuffers[i]);\n    skip |= LogError(\"VUID-vkCmdEndTransformFeedbackEXT-pCounterBuffers-02380\", objlist,\n                     error_obj.location.dot(Field::pCounterBuffers, i), \"was created with %s.\",\n                     string_VkBufferUsageFlags2KHR(buffer_state->usage).c_str());\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-vkCmdBindVertexBuffers2-pOffsets-03357\", \"If pSizes is not NULL, all elements of pOffsets must be less than the size of the corresponding element in pBuffers\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (offset >= buffer_state->create_info.size) {\n    skip |= LogError(\"VUID-vkCmdBindVertexBuffers2-pOffsets-03357\", objlist, error_obj.location.dot(Field::pOffsets, i),\n                     \"(0x%\" PRIu64 \") is beyond the end of the buffer of size (%\" PRIu64 \").\", offset,\n                     buffer_state->create_info.size);\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-vkCmdBindVertexBuffers2-pSizes-03358\", \"If pSizes is not NULL, all elements of pOffsets plus pSizes , where pSizes is not VK_WHOLE_SIZE, must be less than or equal to the size of the corresponding element in pBuffers\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (!enabled_features.maintenance5) {\n    skip |= LogError(\"VUID-vkCmdBindVertexBuffers2-pSizes-03358\", objlist, error_obj.location.dot(Field::pSizes, i),\n                     \"is VK_WHOLE_SIZE, which is not valid in this context. This can be fixed by enabling the \"\n                     \"VkPhysicalDeviceMaintenance5FeaturesKHR::maintenance5 feature.\");\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-vkCmdBindVertexBuffers2-pSizes-03358\", \"If pSizes is not NULL, all elements of pOffsets plus pSizes , where pSizes is not VK_WHOLE_SIZE, must be less than or equal to the size of the corresponding element in pBuffers\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "skip |= LogError(\"VUID-vkCmdBindVertexBuffers2-pSizes-03358\", objlist, error_obj.location.dot(Field::pOffsets, i),\n                 \"(%\" PRIu64 \") + pSizes[%\" PRIu32 \"] (%\" PRIu64\n                 \") is beyond the end of the buffer of size (%\" PRIu64 \").\",\n                 offset, i, size, buffer_state->create_info.size);\n"
        },
        {
            "role": "user",
            "content": "{\"VUID-vkCmdEndConditionalRenderingEXT-None-01985\", \"Conditional rendering must be active\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (!cb_state->conditional_rendering_active) {\n    skip |= LogError(\"VUID-vkCmdEndConditionalRenderingEXT-None-01985\", commandBuffer, error_obj.location,\n                     \"Conditional rendering is not active.\");\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-vkCmdEndConditionalRenderingEXT-None-01986\", \"If conditional rendering was made active outside of a render pass instance, it must not be ended inside a render pass instance\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (!cb_state->conditional_rendering_inside_render_pass && cb_state->activeRenderPass != nullptr) {\n    skip |= LogError(\"VUID-vkCmdEndConditionalRenderingEXT-None-01986\", commandBuffer, error_obj.location,\n                     \"Conditional rendering was begun outside outside of a render \"\n                     \"pass instance, but a render pass instance is currently active in the command buffer.\");\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-vkCmdEndConditionalRenderingEXT-None-01987\", \"If conditional rendering was made active within a subpass it must be ended in the same subpass\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (cb_state->conditional_rendering_inside_render_pass && cb_state->activeRenderPass != nullptr &&\n    skip |= LogError(\"VUID-vkCmdEndConditionalRenderingEXT-None-01987\", commandBuffer, error_obj.location,\n                     \"Conditional rendering was begun in subpass %\" PRIu32 \", but the current subpass is %\" PRIu32 \".\",\n                     cb_state->conditional_rendering_subpass, cb_state->GetActiveSubpass());\n"
        },
        {
            "role": "user",
            "content": "{\"VUID-vkCmdBindShadingRateImageNV-None-02058\", \"The shadingRateImage feature must be enabled\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (!enabled_features.shadingRateImage) {\n    skip |= LogError(\"VUID-vkCmdBindShadingRateImageNV-None-02058\", commandBuffer, error_obj.location,\n                     \"The shadingRateImage feature is disabled.\");\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-vkCmdBindShadingRateImageNV-imageView-02059\", \"If imageView is not VK_NULL_HANDLE, it must be a valid VkImageView handle of type VK_IMAGE_VIEW_TYPE_2D or VK_IMAGE_VIEW_TYPE_2D_ARRAY\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (ivci.viewType != VK_IMAGE_VIEW_TYPE_2D && ivci.viewType != VK_IMAGE_VIEW_TYPE_2D_ARRAY) {\n    const LogObjectList objlist(commandBuffer, imageView);\n    skip |= LogError(\"VUID-vkCmdBindShadingRateImageNV-imageView-02059\", objlist, error_obj.location,\n                     \"If imageView is not VK_NULL_HANDLE, it must be a valid \"\n                     \"VkImageView handle of type VK_IMAGE_VIEW_TYPE_2D or VK_IMAGE_VIEW_TYPE_2D_ARRAY.\");\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-vkCmdBindShadingRateImageNV-imageView-02060\", \"If imageView is not VK_NULL_HANDLE, it must have a format of VK_FORMAT_R8_UINT\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (ivci.format != VK_FORMAT_R8_UINT) {\n    const LogObjectList objlist(commandBuffer, imageView);\n    skip |= LogError(\"VUID-vkCmdBindShadingRateImageNV-imageView-02060\", objlist, error_obj.location,\n                     \"If imageView is not VK_NULL_HANDLE, it must have a format of \"\n                     \"VK_FORMAT_R8_UINT but is %s.\",\n                     string_VkFormat(ivci.format));\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-vkCmdBindShadingRateImageNV-imageView-02061\", \"If imageView is not VK_NULL_HANDLE, it must have been created with a usage value including VK_IMAGE_USAGE_SHADING_RATE_IMAGE_BIT_NV\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (!(usage & VK_IMAGE_USAGE_SHADING_RATE_IMAGE_BIT_NV)) {\n    const LogObjectList objlist(commandBuffer, imageView);\n    skip |= LogError(\"VUID-vkCmdBindShadingRateImageNV-imageView-02061\", objlist, error_obj.location,\n                     \"If imageView is not VK_NULL_HANDLE, the image must have been \"\n                     \"created with VK_IMAGE_USAGE_SHADING_RATE_IMAGE_BIT_NV set.\");\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-vkCmdEndDebugUtilsLabelEXT-commandBuffer-01913\", \"If commandBuffer is a secondary command buffer, there must be an outstanding vkCmdBeginDebugUtilsLabelEXT command recorded to commandBuffer that has not previously been ended by a call to vkCmdEndDebugUtilsLabelEXT\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (cb_state->LabelStackDepth() < 1) {\n    skip |= LogError(\"VUID-vkCmdEndDebugUtilsLabelEXT-commandBuffer-01913\", commandBuffer, error_obj.location,\n                     \"called without a corresponding vkCmdBeginDebugUtilsLabelEXT first\");\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-vkCmdSetScissor-viewportScissor2D-04789\", \"If this command is recorded in a secondary command buffer with VkCommandBufferInheritanceViewportScissorInfoNV::viewportScissor2D enabled, then this function must not be called\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "auto cb_state = GetRead<vvl::CommandBuffer>(commandBuffer);\nbool skip = false;\nskip |= ValidateExtendedDynamicState(*cb_state, error_obj.location, VK_TRUE, nullptr, nullptr);\nskip |= ForbidInheritedViewportScissor(*cb_state, \"VUID-vkCmdSetScissor-viewportScissor2D-04789\", error_obj.location);\n"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkDepthBiasRepresentationInfoEXT-leastRepresentableValueForceUnormRepresentation-08947\", \"If the leastRepresentableValueForceUnormRepresentation feature is not enabled, depthBiasRepresentation must not be VK_DEPTH_BIAS_REPRESENTATION_LEAST_REPRESENTABLE_VALUE_FORCE_UNORM_EXT\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if ((depth_bias_representation.depthBiasRepresentation ==\n    !enabled_features.leastRepresentableValueForceUnormRepresentation) {\n    skip |= LogError(\"VUID-VkDepthBiasRepresentationInfoEXT-leastRepresentableValueForceUnormRepresentation-08947\", objlist,\n                     loc.pNext(Struct::VkDepthBiasRepresentationInfoEXT, Field::depthBiasRepresentation),\n                     \"is %s, but the leastRepresentableValueForceUnormRepresentation feature was not enabled.\",\n                     string_VkDepthBiasRepresentationEXT(depth_bias_representation.depthBiasRepresentation));\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkDepthBiasRepresentationInfoEXT-floatRepresentation-08948\", \"If the floatRepresentation feature is not enabled, depthBiasRepresentation must not be VK_DEPTH_BIAS_REPRESENTATION_FLOAT_EXT\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if ((depth_bias_representation.depthBiasRepresentation == VK_DEPTH_BIAS_REPRESENTATION_FLOAT_EXT) &&\n    !enabled_features.floatRepresentation) {\n    skip |= LogError(\"VUID-VkDepthBiasRepresentationInfoEXT-floatRepresentation-08948\", objlist,\n                     loc.pNext(Struct::VkDepthBiasRepresentationInfoEXT, Field::depthBiasRepresentation),\n                     \"is %s but the floatRepresentation feature was not enabled.\",\n                     string_VkDepthBiasRepresentationEXT(depth_bias_representation.depthBiasRepresentation));\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkDepthBiasRepresentationInfoEXT-depthBiasExact-08949\", \"If the depthBiasExact feature is not enabled, depthBiasExact must be VK_FALSE\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if ((depth_bias_representation.depthBiasExact == VK_TRUE) && !enabled_features.depthBiasExact) {\n    skip |= LogError(\"VUID-VkDepthBiasRepresentationInfoEXT-depthBiasExact-08949\", objlist,\n                     loc.pNext(Struct::VkDepthBiasRepresentationInfoEXT, Field::depthBiasExact),\n                     \"is VK_TRUE, but the depthBiasExact feature was not enabled.\");\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-vkCmdSetDiscardRectangleEXT-x-00587\", \"The x and y member of offset in each VkRect2D element of pDiscardRectangles must be greater than or equal to 0\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (pDiscardRectangles[i].offset.x < 0) {\n    skip |= LogError(\"VUID-vkCmdSetDiscardRectangleEXT-x-00587\", commandBuffer,\n                     error_obj.location.dot(Field::pDiscardRectangles, i).dot(Field::offset).dot(Field::x),\n                     \"(%\" PRId32 \") is negative.\", pDiscardRectangles[i].offset.x);\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-vkCmdSetDiscardRectangleEXT-x-00587\", \"The x and y member of offset in each VkRect2D element of pDiscardRectangles must be greater than or equal to 0\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (pDiscardRectangles[i].offset.y < 0) {\n    skip |= LogError(\"VUID-vkCmdSetDiscardRectangleEXT-x-00587\", commandBuffer,\n                     error_obj.location.dot(Field::pDiscardRectangles, i).dot(Field::offset).dot(Field::y),\n                     \"(%\" PRId32 \") is negative.\", pDiscardRectangles[i].offset.y);\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-vkCmdSetPatchControlPointsEXT-patchControlPoints-04874\", \"patchControlPoints must be greater than zero and less than or equal to VkPhysicalDeviceLimits::maxTessellationPatchSize\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (patchControlPoints > phys_dev_props.limits.maxTessellationPatchSize) {\n    skip |= LogError(\"VUID-vkCmdSetPatchControlPointsEXT-patchControlPoints-04874\", commandBuffer,\n                     error_obj.location.dot(Field::patchControlPoints),\n                     \"(%\" PRIu32\n                     \") must be less than \"\n                     \"maxTessellationPatchSize (%\" PRIu32 \")\",\n                     patchControlPoints, phys_dev_props.limits.maxTessellationPatchSize);\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-vkCmdSetViewportWithCount-commandBuffer-04819\", \"commandBuffer must not have VkCommandBufferInheritanceViewportScissorInfoNV::viewportScissor2D enabled\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "skip |= ValidateExtendedDynamicState(*cb_state, error_obj.location,\n                                     \"VUID-vkCmdSetViewportWithCount-None-08971\", \"extendedDynamicState or shaderObject\");\nskip |= ForbidInheritedViewportScissor(*cb_state, \"VUID-vkCmdSetViewportWithCount-commandBuffer-04819\", error_obj.location);\n"
        },
        {
            "role": "user",
            "content": "{\"VUID-vkCmdSetScissorWithCount-commandBuffer-04820\", \"commandBuffer must not have VkCommandBufferInheritanceViewportScissorInfoNV::viewportScissor2D enabled\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "skip |= ValidateExtendedDynamicState(*cb_state, error_obj.location,\n                                     \"VUID-vkCmdSetScissorWithCount-None-08971\", \"extendedDynamicState or shaderObject\");\nskip |= ForbidInheritedViewportScissor(*cb_state, \"VUID-vkCmdSetScissorWithCount-commandBuffer-04820\", error_obj.location);\n"
        },
        {
            "role": "user",
            "content": "{\"VUID-vkCmdSetScissorWithCount-commandBuffer-04820\", \"commandBuffer must not have VkCommandBufferInheritanceViewportScissorInfoNV::viewportScissor2D enabled\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "auto cb_state = GetRead<vvl::CommandBuffer>(commandBuffer);\nbool skip = false;\nskip |= ValidateExtendedDynamicState(*cb_state, error_obj.location, VK_TRUE, nullptr, nullptr);\nskip |= ForbidInheritedViewportScissor(*cb_state, \"VUID-vkCmdSetScissorWithCount-commandBuffer-04820\", error_obj.location);\n"
        },
        {
            "role": "user",
            "content": "{\"VUID-vkCmdSetDepthBoundsTestEnable-depthBounds-10010\", \"If the depthBounds feature is not enabled, depthBoundsTestEnable must be VK_FALSE\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (depthBoundsTestEnable == VK_TRUE && !enabled_features.depthBounds) {\n    skip |= LogError(\"VUID-vkCmdSetDepthBoundsTestEnable-depthBounds-10010\", commandBuffer,\n                     error_obj.location.dot(Field::depthBoundsTestEnable),\n                     \"is VK_TRUE but the depthBounds feature was not enabled.\");\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-vkCmdSetDepthBoundsTestEnable-depthBounds-10010\", \"If the depthBounds feature is not enabled, depthBoundsTestEnable must be VK_FALSE\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (depthBoundsTestEnable == VK_TRUE && !enabled_features.depthBounds) {\n    skip |= LogError(\"VUID-vkCmdSetDepthBoundsTestEnable-depthBounds-10010\", commandBuffer,\n                     error_obj.location.dot(Field::depthBoundsTestEnable),\n                     \"is VK_TRUE but the depthBounds feature was not enabled.\");\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-vkCmdSetPolygonModeEXT-fillModeNonSolid-07424\", \"If the fillModeNonSolid feature is not enabled, polygonMode must be VK_POLYGON_MODE_FILL or VK_POLYGON_MODE_FILL_RECTANGLE_NV\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if ((polygonMode == VK_POLYGON_MODE_LINE || polygonMode == VK_POLYGON_MODE_POINT) && !enabled_features.fillModeNonSolid) {\n    skip |= LogError(\"VUID-vkCmdSetPolygonModeEXT-fillModeNonSolid-07424\", commandBuffer,\n                     error_obj.location.dot(Field::polygonMode),\n                     \"is %s but the \"\n                     \"fillModeNonSolid feature was not enabled.\",\n                     string_VkPolygonMode(polygonMode));\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-vkCmdSetPolygonModeEXT-polygonMode-07425\", \"If the VK_NV_fill_rectangle extension is not enabled, polygonMode must not be VK_POLYGON_MODE_FILL_RECTANGLE_NV\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "string_VkPolygonMode(polygonMode));\n} else if (polygonMode == VK_POLYGON_MODE_FILL_RECTANGLE_NV && !IsExtEnabled(device_extensions.vk_nv_fill_rectangle)) {\nskip |= LogError(\"VUID-vkCmdSetPolygonModeEXT-polygonMode-07425\", commandBuffer, error_obj.location.dot(Field::polygonMode),\n\"is VK_POLYGON_MODE_FILL_RECTANGLE_NV but the VK_NV_fill_rectangle \"\n\"extension was not enabled.\");\n"
        },
        {
            "role": "user",
            "content": "{\"VUID-vkCmdSetAlphaToOneEnableEXT-alphaToOne-07607\", \"If the alphaToOne feature is not enabled, alphaToOneEnable must be VK_FALSE\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (alphaToOneEnable != VK_FALSE && !enabled_features.alphaToOne) {\n    skip |= LogError(\"VUID-vkCmdSetAlphaToOneEnableEXT-alphaToOne-07607\", commandBuffer,\n                     error_obj.location.dot(Field::alphaToOneEnable), \"is VK_TRUE but the alphaToOne feature was not enabled.\");\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-vkCmdSetLogicOpEnableEXT-logicOp-07366\", \"If the logicOp feature is not enabled, logicOpEnable must be VK_FALSE\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (logicOpEnable != VK_FALSE && !enabled_features.logicOp) {\n    skip |= LogError(\"VUID-vkCmdSetLogicOpEnableEXT-logicOp-07366\", commandBuffer, error_obj.location.dot(Field::logicOpEnable),\n                     \"is VK_TRUE but the logicOp feature was not enabled.\");\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkColorBlendEquationEXT-constantAlphaColorBlendFactors-07363\", \"If the VK_KHR_portability_subset extension is enabled, and VkPhysicalDevicePortabilitySubsetFeaturesKHR::constantAlphaColorBlendFactors is VK_FALSE, dstColorBlendFactor must not be VK_BLEND_FACTOR_CONSTANT_ALPHA or VK_BLEND_FACTOR_ONE_MINUS_CONSTANT_ALPHA\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (equation.dstColorBlendFactor == VK_BLEND_FACTOR_CONSTANT_ALPHA ||\n    skip |= LogError(\"VUID-VkColorBlendEquationEXT-constantAlphaColorBlendFactors-07363\", commandBuffer,\n                     equation_loc.dot(Field::dstColorBlendFactor),\n                     \"is %s but the constantAlphaColorBlendFactors feature was not supported.\",\n                     string_VkBlendFactor(equation.dstColorBlendFactor));\n"
        },
        {
            "role": "user",
            "content": "{\"VUID-vkCmdSetRasterizationStreamEXT-transformFeedback-07411\", \"The transformFeedback feature must be enabled\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (!enabled_features.transformFeedback) {\n    skip |= LogError(\"VUID-vkCmdSetRasterizationStreamEXT-transformFeedback-07411\", commandBuffer, error_obj.location,\n                     \"the transformFeedback feature was not enabled.\");\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-vkCmdSetRasterizationStreamEXT-rasterizationStream-07412\", \"rasterizationStream must be less than VkPhysicalDeviceTransformFeedbackPropertiesEXT::maxTransformFeedbackStreams\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (rasterizationStream >= phys_dev_ext_props.transform_feedback_props.maxTransformFeedbackStreams) {\n    skip |= LogError(\"VUID-vkCmdSetRasterizationStreamEXT-rasterizationStream-07412\", commandBuffer,\n                     error_obj.location.dot(Field::rasterizationStream),\n                     \"(%\" PRIu32 \") must be less than maxTransformFeedbackStreams (%\" PRIu32 \").\", rasterizationStream,\n                     phys_dev_ext_props.transform_feedback_props.maxTransformFeedbackStreams);\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-vkCmdSetRasterizationStreamEXT-rasterizationStream-07413\", \"rasterizationStream must be zero if VkPhysicalDeviceTransformFeedbackPropertiesEXT::transformFeedbackRasterizationStreamSelect is VK_FALSE\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (rasterizationStream != 0U &&\n    skip |= LogError(\"VUID-vkCmdSetRasterizationStreamEXT-rasterizationStream-07413\", commandBuffer,\n                     error_obj.location.dot(Field::rasterizationStream),\n                     \"(%\" PRIu32\n                     \") is non-zero but \"\n                     \"the transformFeedbackRasterizationStreamSelect feature was not supported.\",\n                     rasterizationStream);\n"
        },
        {
            "role": "user",
            "content": "{\"VUID-vkCmdSetDepthClipEnableEXT-depthClipEnable-07451\", \"The depthClipEnable feature must be enabled\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (!enabled_features.depthClipEnable) {\n    skip |= LogError(\"VUID-vkCmdSetDepthClipEnableEXT-depthClipEnable-07451\", commandBuffer, error_obj.location,\n                     \"the depthClipEnable feature was not enabled.\");\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkColorBlendAdvancedEXT-srcPremultiplied-07505\", \"If the non-premultiplied source color property is not supported, srcPremultiplied must be VK_TRUE\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (advanced.srcPremultiplied == VK_TRUE &&\n    skip |= LogError(\"VUID-VkColorBlendAdvancedEXT-srcPremultiplied-07505\", commandBuffer,\n                     error_obj.location.dot(Field::pColorBlendAdvanced, attachment).dot(Field::srcPremultiplied),\n                     \"is VK_TRUE but the advancedBlendNonPremultipliedSrcColor feature was not enabled.\");\n"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkColorBlendAdvancedEXT-dstPremultiplied-07506\", \"If the non-premultiplied destination color property is not supported, dstPremultiplied must be VK_TRUE\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (advanced.dstPremultiplied == VK_TRUE &&\n    skip |= LogError(\"VUID-VkColorBlendAdvancedEXT-dstPremultiplied-07506\", commandBuffer,\n                     error_obj.location.dot(Field::pColorBlendAdvanced, attachment).dot(Field::dstPremultiplied),\n                     \"is VK_TRUE but the advancedBlendNonPremultipliedDstColor feature was not enabled.\");\n"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkColorBlendAdvancedEXT-blendOverlap-07507\", \"If the correlated overlap property is not supported, blendOverlap must be VK_BLEND_OVERLAP_UNCORRELATED_EXT\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (advanced.blendOverlap != VK_BLEND_OVERLAP_UNCORRELATED_EXT &&\n    skip |= LogError(\"VUID-VkColorBlendAdvancedEXT-blendOverlap-07507\", commandBuffer,\n                     error_obj.location.dot(Field::pColorBlendAdvanced, attachment).dot(Field::blendOverlap),\n                     \"is %s, but the advancedBlendCorrelatedOverlap feature was not supported.\",\n                     string_VkBlendOverlapEXT(advanced.blendOverlap));\n"
        },
        {
            "role": "user",
            "content": "{\"VUID-vkCmdSetLineRasterizationModeEXT-lineRasterizationMode-07418\", \"If lineRasterizationMode is VK_LINE_RASTERIZATION_MODE_RECTANGULAR_KHR, then the rectangularLines feature must be enabled\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (lineRasterizationMode == VK_LINE_RASTERIZATION_MODE_RECTANGULAR_KHR && !enabled_features.rectangularLines) {\n    skip |= LogError(\"VUID-vkCmdSetLineRasterizationModeEXT-lineRasterizationMode-07418\", commandBuffer,\n                     error_obj.location.dot(Field::lineRasterizationMode),\n                     \"is VK_LINE_RASTERIZATION_MODE_RECTANGULAR_KHR \"\n                     \"but the rectangularLines feature was not enabled.\");\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-vkCmdSetLineRasterizationModeEXT-lineRasterizationMode-07419\", \"If lineRasterizationMode is VK_LINE_RASTERIZATION_MODE_BRESENHAM_KHR, then the bresenhamLines feature must be enabled\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "} else if (lineRasterizationMode == VK_LINE_RASTERIZATION_MODE_BRESENHAM_KHR && !enabled_features.bresenhamLines) {\n    skip |= LogError(\"VUID-vkCmdSetLineRasterizationModeEXT-lineRasterizationMode-07419\", commandBuffer,\n                     error_obj.location.dot(Field::lineRasterizationMode),\n                     \"is VK_LINE_RASTERIZATION_MODE_BRESENHAM_KHR \"\n                     \"but the bresenhamLines feature was not enabled.\");\n"
        },
        {
            "role": "user",
            "content": "{\"VUID-vkCmdSetLineRasterizationModeEXT-lineRasterizationMode-07420\", \"If lineRasterizationMode is VK_LINE_RASTERIZATION_MODE_RECTANGULAR_SMOOTH_KHR, then the smoothLines feature must be enabled\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "} else if (lineRasterizationMode == VK_LINE_RASTERIZATION_MODE_RECTANGULAR_SMOOTH_KHR && !enabled_features.smoothLines) {\n    skip |= LogError(\"VUID-vkCmdSetLineRasterizationModeEXT-lineRasterizationMode-07420\", commandBuffer,\n                     error_obj.location.dot(Field::lineRasterizationMode),\n                     \"is \"\n                     \"VK_LINE_RASTERIZATION_MODE_RECTANGULAR_SMOOTH_KHR but the smoothLines feature was not enabled.\");\n"
        },
        {
            "role": "user",
            "content": "{\"VUID-vkCmdSetDepthClipNegativeOneToOneEXT-depthClipControl-07453\", \"The depthClipControl feature must be enabled\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (enabled_features.depthClipControl == VK_FALSE) {\n    skip |= LogError(\"VUID-vkCmdSetDepthClipNegativeOneToOneEXT-depthClipControl-07453\", commandBuffer, error_obj.location,\n                     \"the depthClipControl feature was not enabled.\");\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-vkCmdSetFragmentShadingRateKHR-pipelineFragmentShadingRate-04507\", \"If pipelineFragmentShadingRate is not enabled, pFragmentSize->width must be 1\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (!enabled_features.pipelineFragmentShadingRate && pFragmentSize->width != 1) {\n    skip |= LogError(\"VUID-vkCmdSetFragmentShadingRateKHR-pipelineFragmentShadingRate-04507\", commandBuffer,\n                     error_obj.location.dot(Field::pFragmentSize).dot(Field::width),\n                     \"is %\" PRIu32 \" but the pipelineFragmentShadingRate feature was not enabled.\", pFragmentSize->width);\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-vkCmdSetFragmentShadingRateKHR-pipelineFragmentShadingRate-04508\", \"If pipelineFragmentShadingRate is not enabled, pFragmentSize->height must be 1\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (!enabled_features.pipelineFragmentShadingRate && pFragmentSize->height != 1) {\n    skip |= LogError(\"VUID-vkCmdSetFragmentShadingRateKHR-pipelineFragmentShadingRate-04508\", commandBuffer,\n                     error_obj.location.dot(Field::pFragmentSize).dot(Field::height),\n                     \"is %\" PRIu32 \" but the pipelineFragmentShadingRate feature was not enabled.\", pFragmentSize->height);\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-vkCmdSetFragmentShadingRateKHR-fragmentSizeNonTrivialCombinerOps-04512\", \"If the fragmentSizeNonTrivialCombinerOps limit is not supported, elements of combinerOps must be either VK_FRAGMENT_SHADING_RATE_COMBINER_OP_KEEP_KHR or VK_FRAGMENT_SHADING_RATE_COMBINER_OP_REPLACE_KHR\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (!phys_dev_ext_props.fragment_shading_rate_props.fragmentShadingRateNonTrivialCombinerOps &&\n    skip |= LogError(\"VUID-vkCmdSetFragmentShadingRateKHR-fragmentSizeNonTrivialCombinerOps-04512\", commandBuffer,\n                     error_obj.location.dot(Field::combinerOps, 0),\n                     \"is %s but the fragmentShadingRateNonTrivialCombinerOps feature was not enabled.\",\n                     string_VkFragmentShadingRateCombinerOpKHR(combinerOps[0]));\n"
        },
        {
            "role": "user",
            "content": "{\"VUID-vkCmdSetFragmentShadingRateKHR-fragmentSizeNonTrivialCombinerOps-04512\", \"If the fragmentSizeNonTrivialCombinerOps limit is not supported, elements of combinerOps must be either VK_FRAGMENT_SHADING_RATE_COMBINER_OP_KEEP_KHR or VK_FRAGMENT_SHADING_RATE_COMBINER_OP_REPLACE_KHR\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (!phys_dev_ext_props.fragment_shading_rate_props.fragmentShadingRateNonTrivialCombinerOps &&\n    skip |= LogError(\"VUID-vkCmdSetFragmentShadingRateKHR-fragmentSizeNonTrivialCombinerOps-04512\", commandBuffer,\n                     error_obj.location.dot(Field::combinerOps, 1),\n                     \"is %s but the fragmentShadingRateNonTrivialCombinerOps feature was not enabled.\",\n                     string_VkFragmentShadingRateCombinerOpKHR(combinerOps[1]));\n"
        },
        {
            "role": "user",
            "content": "{\"VUID-vkCmdSetFragmentShadingRateKHR-pFragmentSize-04514\", \"pFragmentSize->height must be greater than or equal to 1\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (pFragmentSize->height == 0) {\n    skip |= LogError(\"VUID-vkCmdSetFragmentShadingRateKHR-pFragmentSize-04514\", commandBuffer,\n                     error_obj.location.dot(Field::pFragmentSize).dot(Field::height), \"is zero\");\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-vkCmdSetFragmentShadingRateKHR-pFragmentSize-04515\", \"pFragmentSize->width must be a power-of-two value\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (pFragmentSize->width != 0 && !IsPowerOfTwo(pFragmentSize->width)) {\n    skip |= LogError(\"VUID-vkCmdSetFragmentShadingRateKHR-pFragmentSize-04515\", commandBuffer,\n                     error_obj.location.dot(Field::pFragmentSize).dot(Field::width), \"(%\" PRIu32 \") is a non-power-of-two.\",\n                     pFragmentSize->width);\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-vkCmdSetFragmentShadingRateKHR-pFragmentSize-04516\", \"pFragmentSize->height must be a power-of-two value\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (pFragmentSize->height != 0 && !IsPowerOfTwo(pFragmentSize->height)) {\n    skip |= LogError(\"VUID-vkCmdSetFragmentShadingRateKHR-pFragmentSize-04516\", commandBuffer,\n                     error_obj.location.dot(Field::pFragmentSize).dot(Field::height), \"(%\" PRIu32 \") is a non-power-of-two.\",\n                     pFragmentSize->height);\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-vkCmdSetFragmentShadingRateKHR-pFragmentSize-04517\", \"pFragmentSize->width must be less than or equal to 4\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (pFragmentSize->width > 4) {\n    skip |= LogError(\"VUID-vkCmdSetFragmentShadingRateKHR-pFragmentSize-04517\", commandBuffer,\n                     error_obj.location.dot(Field::pFragmentSize).dot(Field::width), \"(%\" PRIu32 \") is larger than 4.\",\n                     pFragmentSize->width);\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-vkCmdSetColorWriteEnableEXT-attachmentCount-06656\", \"attachmentCount must be less than or equal to the maxColorAttachments member of VkPhysicalDeviceLimits\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (attachmentCount > phys_dev_props.limits.maxColorAttachments) {\n    skip |= LogError(\"VUID-vkCmdSetColorWriteEnableEXT-attachmentCount-06656\", commandBuffer,\n                     error_obj.location.dot(Field::attachmentCount),\n                     \"(%\" PRIu32 \") is greater than the maxColorAttachments limit (%\" PRIu32 \").\", attachmentCount,\n                     phys_dev_props.limits.maxColorAttachments);\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-vkCmdSetAttachmentFeedbackLoopEnableEXT-attachmentFeedbackLoopLayout-08864\", \"If the attachmentFeedbackLoopLayout feature is not enabled, aspectMask must be VK_IMAGE_ASPECT_NONE\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (aspectMask != VK_IMAGE_ASPECT_NONE && !enabled_features.attachmentFeedbackLoopLayout) {\n    skip |= LogError(\"VUID-vkCmdSetAttachmentFeedbackLoopEnableEXT-attachmentFeedbackLoopLayout-08864\", commandBuffer,\n                     error_obj.location.dot(Field::aspectMask),\n                     \"is %s but the attachmentFeedbackLoopLayout feature \"\n                     \"was not enabled.\",\n                     string_VkImageAspectFlags(aspectMask).c_str());\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-vkCmdSetAttachmentFeedbackLoopEnableEXT-aspectMask-08863\", \"aspectMask must only include VK_IMAGE_ASPECT_NONE, VK_IMAGE_ASPECT_COLOR_BIT, VK_IMAGE_ASPECT_DEPTH_BIT, and VK_IMAGE_ASPECT_STENCIL_BIT\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if ((aspectMask &\n    skip |= LogError(\"VUID-vkCmdSetAttachmentFeedbackLoopEnableEXT-aspectMask-08863\", commandBuffer,\n                     error_obj.location.dot(Field::aspectMask), \"is %s.\", string_VkImageAspectFlags(aspectMask).c_str());\n"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkImageSubresourceLayers-layerCount-09243\", \"If the maintenance5 feature is not enabled, layerCount must not be VK_REMAINING_ARRAY_LAYERS\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (!enabled_features.maintenance5) {\n    skip |= LogError(\"VUID-VkImageSubresourceLayers-layerCount-09243\", handle, subresource_loc.dot(Field::layerCount),\n                     \"is VK_REMAINING_ARRAY_LAYERS.\");\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkImageSubresourceLayers-aspectMask-00167\", \"If aspectMask contains VK_IMAGE_ASPECT_COLOR_BIT, it must not contain either of VK_IMAGE_ASPECT_DEPTH_BIT or VK_IMAGE_ASPECT_STENCIL_BIT\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if ((aspect_mask & VK_IMAGE_ASPECT_COLOR_BIT) && (aspect_mask & (VK_IMAGE_ASPECT_DEPTH_BIT | VK_IMAGE_ASPECT_STENCIL_BIT))) {\n    skip |= LogError(\"VUID-VkImageSubresourceLayers-aspectMask-00167\", handle, subresource_loc.dot(Field::aspectMask), \"is %s.\",\n                     string_VkImageAspectFlags(aspect_mask).c_str());\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkImageSubresourceLayers-aspectMask-02247\", \"aspectMask must not include VK_IMAGE_ASPECT_MEMORY_PLANE_i_BIT_EXT for any index i\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (aspect_mask & (VK_IMAGE_ASPECT_MEMORY_PLANE_0_BIT_EXT | VK_IMAGE_ASPECT_MEMORY_PLANE_1_BIT_EXT |\n    skip |= LogError(\"VUID-VkImageSubresourceLayers-aspectMask-02247\", handle, subresource_loc.dot(Field::aspectMask), \"is %s.\",\n                     string_VkImageAspectFlags(aspect_mask).c_str());\n"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkCopyImageToImageInfoEXT-srcImage-09069\", \"srcImage and dstImage must have been created with identical image creation parameters\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "std::stringstream ss;\nss << \"The creation parameters for srcImage and dstImage differ:\\n\" << mismatch_stream.str();\nLogObjectList objlist(src_image_state.Handle(), dst_image_state.Handle());\nskip |= LogError(\"VUID-VkCopyImageToImageInfoEXT-srcImage-09069\", objlist, loc, \"%s.\", ss.str().c_str());\n"
        },
        {
            "role": "user",
            "content": "{\"VUID-vkCopyImageToImageEXT-hostImageCopy-09068\", \"The hostImageCopy feature must be enabled\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (!(enabled_features.hostImageCopy)) {\n    skip |= LogError(\"VUID-vkCopyImageToImageEXT-hostImageCopy-09068\", device, error_obj.location,\n                     \"the hostImageCopy feature was not enabled\");\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkCopyImageToImageInfoEXT-dstImage-09109\", \"If dstImage is sparse then all memory ranges accessed by the copy command must be bound as described in Binding Resource Memory\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (dst_image_state->sparse && (!dst_image_state->HasFullRangeBound())) {\n    skip |= LogError(\"VUID-VkCopyImageToImageInfoEXT-dstImage-09109\", dst_image_state->Handle(), loc.dot(Field::dstImage),\n                     \"is a sparse image with no memory bound\");\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkCopyImageToImageInfoEXT-srcImage-09111\", \"If the stencil aspect of srcImage is accessed, and srcImage was not created with separate stencil usage, srcImage must have been created with VK_IMAGE_USAGE_HOST_TRANSFER_BIT_EXT set in VkImageCreateInfo::usage\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "\"VUID-VkCopyImageToImageInfoEXT-dstImageLayout-09071\");\nskip |= UsageHostTransferCheck(*src_image_state, has_stencil, has_non_stencil, \"VUID-VkCopyImageToImageInfoEXT-srcImage-09111\",\n\"VUID-VkCopyImageToImageInfoEXT-srcImage-09112\", \"VUID-VkCopyImageToImageInfoEXT-srcImage-09113\",\nerror_obj.location);\n"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkCopyImageToImageInfoEXT-dstImage-09111\", \"If the stencil aspect of dstImage is accessed, and dstImage was not created with separate stencil usage, dstImage must have been created with VK_IMAGE_USAGE_HOST_TRANSFER_BIT_EXT set in VkImageCreateInfo::usage\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "skip |= UsageHostTransferCheck(*src_image_state, has_stencil, has_non_stencil, \"VUID-VkCopyImageToImageInfoEXT-srcImage-09111\",\n                               \"VUID-VkCopyImageToImageInfoEXT-srcImage-09112\", \"VUID-VkCopyImageToImageInfoEXT-srcImage-09113\",\nskip |= UsageHostTransferCheck(*dst_image_state, has_stencil, has_non_stencil, \"VUID-VkCopyImageToImageInfoEXT-dstImage-09111\",\n                               \"VUID-VkCopyImageToImageInfoEXT-dstImage-09112\", \"VUID-VkCopyImageToImageInfoEXT-dstImage-09113\",\n                               error_obj.location);\n"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkDescriptorSetLayoutBindingFlagsCreateInfo-bindingCount-03002\", \"If bindingCount is not zero, bindingCount must equal VkDescriptorSetLayoutCreateInfo::bindingCount\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (flags_info->bindingCount != 0 && flags_info->bindingCount != create_info.bindingCount) {\n    skip |= LogError(\"VUID-VkDescriptorSetLayoutBindingFlagsCreateInfo-bindingCount-03002\", device,\n                     create_info_loc.pNext(Struct::VkDescriptorSetLayoutBindingFlagsCreateInfo, Field::bindingCount),\n                     \"(%\" PRIu32 \") is different from pCreateInfo->bindingCount (%\" PRIu32 \").\", flags_info->bindingCount,\n                     create_info.bindingCount);\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkDescriptorSetLayoutBindingFlagsCreateInfo-None-03011\", \"All bindings with descriptor type VK_DESCRIPTOR_TYPE_INPUT_ATTACHMENT, VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER_DYNAMIC, or VK_DESCRIPTOR_TYPE_STORAGE_BUFFER_DYNAMIC must not use VK_DESCRIPTOR_BINDING_UPDATE_AFTER_BIND_BIT\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if ((binding_info.descriptorType == VK_DESCRIPTOR_TYPE_INPUT_ATTACHMENT ||\n    skip |= LogError(\"VUID-VkDescriptorSetLayoutBindingFlagsCreateInfo-None-03011\", device, binding_flags_loc,\n                     \"includes VK_DESCRIPTOR_BINDING_UPDATE_AFTER_BIND_BIT but pBindings[%\" PRIu32\n                     \"].descriptorType is %s.\",\n                     i, string_VkDescriptorType(binding_info.descriptorType));\n"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkDescriptorSetLayoutBindingFlagsCreateInfo-descriptorBindingUpdateUnusedWhilePending-03012\", \"If VkPhysicalDeviceDescriptorIndexingFeatures::descriptorBindingUpdateUnusedWhilePending is not enabled, all elements of pBindingFlags must not include VK_DESCRIPTOR_BINDING_UPDATE_UNUSED_WHILE_PENDING_BIT\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (!enabled_features.descriptorBindingUpdateUnusedWhilePending) {\n    skip |= LogError(\"VUID-VkDescriptorSetLayoutBindingFlagsCreateInfo-descriptorBindingUpdateUnusedWhilePending-03012\",\n                     device, binding_flags_loc,\n                     \"includes VK_DESCRIPTOR_BINDING_UPDATE_UNUSED_WHILE_PENDING_BIT but pBindings[%\" PRIu32\n                     \"].descriptorType is %s, but the descriptorBindingUpdateUnusedWhilePending was not enabled.\",\n                     i, string_VkDescriptorType(binding_info.descriptorType));\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkDescriptorSetLayoutBindingFlagsCreateInfo-descriptorBindingPartiallyBound-03013\", \"If VkPhysicalDeviceDescriptorIndexingFeatures::descriptorBindingPartiallyBound is not enabled, all elements of pBindingFlags must not include VK_DESCRIPTOR_BINDING_PARTIALLY_BOUND_BIT\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (!enabled_features.descriptorBindingPartiallyBound) {\n    skip |= LogError(\"VUID-VkDescriptorSetLayoutBindingFlagsCreateInfo-descriptorBindingPartiallyBound-03013\", device,\n                     binding_flags_loc,\n                     \"includes VK_DESCRIPTOR_BINDING_PARTIALLY_BOUND_BIT but pBindings[%\" PRIu32\n                     \"].descriptorType is %s, but the descriptorBindingPartiallyBound was not enabled.\",\n                     i, string_VkDescriptorType(binding_info.descriptorType));\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkDescriptorSetLayoutBindingFlagsCreateInfo-pBindingFlags-03004\", \"If an element of pBindingFlags includes VK_DESCRIPTOR_BINDING_VARIABLE_DESCRIPTOR_COUNT_BIT, then it must be the element with the highest binding number\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (binding_info.binding != max_binding) {\n    skip |= LogError(\"VUID-VkDescriptorSetLayoutBindingFlagsCreateInfo-pBindingFlags-03004\", device, binding_flags_loc,\n                     \"includes VK_DESCRIPTOR_BINDING_VARIABLE_DESCRIPTOR_COUNT_BIT \"\n                     \"but %\" PRIu32 \" is the largest value of all the bindings.\",\n                     binding_info.binding);\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkDescriptorSetLayoutBindingFlagsCreateInfo-pBindingFlags-03015\", \"If an element of pBindingFlags includes VK_DESCRIPTOR_BINDING_VARIABLE_DESCRIPTOR_COUNT_BIT, that element's descriptorType must not be VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER_DYNAMIC or VK_DESCRIPTOR_TYPE_STORAGE_BUFFER_DYNAMIC\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if ((binding_info.descriptorType == VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER_DYNAMIC) ||\n    skip |= LogError(\"VUID-VkDescriptorSetLayoutBindingFlagsCreateInfo-pBindingFlags-03015\", device, binding_flags_loc,\n                     \"includes VK_DESCRIPTOR_BINDING_VARIABLE_DESCRIPTOR_COUNT_BIT but pBindings[%\" PRIu32\n                     \"].descriptorType is %s.\",\n                     i, string_VkDescriptorType(binding_info.descriptorType));\n"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkDescriptorSetLayoutBindingFlagsCreateInfo-flags-03003\", \"If VkDescriptorSetLayoutCreateInfo::flags includes VK_DESCRIPTOR_SET_LAYOUT_CREATE_PUSH_DESCRIPTOR_BIT_KHR, then all elements of pBindingFlags must not include VK_DESCRIPTOR_BINDING_UPDATE_AFTER_BIND_BIT, VK_DESCRIPTOR_BINDING_UPDATE_UNUSED_WHILE_PENDING_BIT, or VK_DESCRIPTOR_BINDING_VARIABLE_DESCRIPTOR_COUNT_BIT\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (push_descriptor_set && (flags_info->pBindingFlags[i] & (VK_DESCRIPTOR_BINDING_UPDATE_AFTER_BIND_BIT |\n    skip |= LogError(\"VUID-VkDescriptorSetLayoutBindingFlagsCreateInfo-flags-03003\", device, binding_flags_loc,\n                     \"is %s (which includes CREATE_PUSH_DESCRIPTOR_BIT).\",\n                     string_VkDescriptorBindingFlags(flags_info->pBindingFlags[i]).c_str());\n"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkDescriptorSetLayoutCreateInfo-binding-00279\", \"If the perStageDescriptorSet feature is not enabled, or flags does not contain VK_DESCRIPTOR_SET_LAYOUT_CREATE_PER_STAGE_BIT_NV, then the VkDescriptorSetLayoutBinding::binding members of the elements of the pBindings array must each have different values\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (!bindings.insert(binding_info.binding).second) {\n    skip |= LogError(\"VUID-VkDescriptorSetLayoutCreateInfo-binding-00279\", device, binding_loc.dot(Field::binding),\n                     \"is duplicated at pBindings[%\" PRIu32 \"].binding.\", binding_info.binding);\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkDescriptorSetLayoutCreateInfo-flags-02208\", \"If flags contains VK_DESCRIPTOR_SET_LAYOUT_CREATE_PUSH_DESCRIPTOR_BIT_KHR, then all elements of pBindings must not have a descriptorType of VK_DESCRIPTOR_TYPE_INLINE_UNIFORM_BLOCK\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "\"VUID-VkDescriptorSetLayoutBinding-descriptorType-04604\", device, binding_loc.dot(Field::descriptorType),\nskip |= LogError(\"VUID-VkDescriptorSetLayoutCreateInfo-flags-02208\", device, binding_loc.dot(Field::descriptorType),\n             \"is VK_DESCRIPTOR_TYPE_INLINE_UNIFORM_BLOCK_EXT but \"\n             \"pCreateInfo->flags includes VK_DESCRIPTOR_SET_LAYOUT_CREATE_PUSH_DESCRIPTOR_BIT_KHR.\");\n"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkDescriptorSetLayoutCreateInfo-flags-00280\", \"If flags contains VK_DESCRIPTOR_SET_LAYOUT_CREATE_PUSH_DESCRIPTOR_BIT_KHR, then all elements of pBindings must not have a descriptorType of VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER_DYNAMIC or VK_DESCRIPTOR_TYPE_STORAGE_BUFFER_DYNAMIC\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (push_descriptor_set) {\n    skip |= LogError(\"VUID-VkDescriptorSetLayoutCreateInfo-flags-00280\", device, binding_loc.dot(Field::descriptorType),\n                     \"is VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER_DYNAMIC, but pCreateInfo->flags includes \"\n                     \"VK_DESCRIPTOR_SET_LAYOUT_CREATE_PUSH_DESCRIPTOR_BIT_KHR.\");\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkDescriptorSetLayoutCreateInfo-flags-00280\", \"If flags contains VK_DESCRIPTOR_SET_LAYOUT_CREATE_PUSH_DESCRIPTOR_BIT_KHR, then all elements of pBindings must not have a descriptorType of VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER_DYNAMIC or VK_DESCRIPTOR_TYPE_STORAGE_BUFFER_DYNAMIC\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (push_descriptor_set) {\n    skip |= LogError(\"VUID-VkDescriptorSetLayoutCreateInfo-flags-00280\", device, binding_loc.dot(Field::descriptorType),\n                     \"is VK_DESCRIPTOR_TYPE_STORAGE_BUFFER_DYNAMIC, but pCreateInfo->flags includes \"\n                     \"VK_DESCRIPTOR_SET_LAYOUT_CREATE_PUSH_DESCRIPTOR_BIT_KHR.\");\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkDescriptorSetLayoutBinding-pImmutableSamplers-04009\", \"The sampler objects indicated by pImmutableSamplers must not have a borderColor with one of the values VK_BORDER_COLOR_FLOAT_CUSTOM_EXT or VK_BORDER_COLOR_INT_CUSTOM_EXT\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (sampler_state && (sampler_state->create_info.borderColor == VK_BORDER_COLOR_INT_CUSTOM_EXT ||\n    skip |= LogError(\"VUID-VkDescriptorSetLayoutBinding-pImmutableSamplers-04009\", device,\n                     binding_loc.dot(Field::pImmutableSamplers, j),\n                     \"(%s) presented as immutable has a custom border color.\",\n                     FormatHandle(binding_info.pImmutableSamplers[j]).c_str());\n"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkDescriptorSetLayoutBinding-flags-08007\", \"If VkDescriptorSetLayoutCreateInfo::flags contains VK_DESCRIPTOR_SET_LAYOUT_CREATE_EMBEDDED_IMMUTABLE_SAMPLERS_BIT_EXT, and descriptorCount is equal to 1, pImmutableSamplers must not be NULL\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if ((binding_info.descriptorCount == 1) && (binding_info.pImmutableSamplers == nullptr)) {\n    skip |= LogError(\"VUID-VkDescriptorSetLayoutBinding-flags-08007\", device, binding_loc.dot(Field::descriptorCount),\n                     \"is 1 and pImmutableSamplers is NULL, but pCreateInfo->flags includes \"\n                     \"VK_DESCRIPTOR_SET_LAYOUT_CREATE_EMBEDDED_IMMUTABLE_SAMPLERS_BIT_EXT.\");\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkDescriptorSetLayoutCreateInfo-descriptorType-03001\", \"If any binding has the VK_DESCRIPTOR_BINDING_UPDATE_AFTER_BIND_BIT bit set, then all bindings must not have descriptorType of VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER_DYNAMIC or VK_DESCRIPTOR_TYPE_STORAGE_BUFFER_DYNAMIC\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (storage_buffer_dynamic < create_info.bindingCount) {\n    skip |= LogError(\"VUID-VkDescriptorSetLayoutCreateInfo-descriptorType-03001\", device,\n                     create_info_loc.dot(Field::pBindings, update_after_bind),\n                     \"has VK_DESCRIPTOR_BINDING_UPDATE_AFTER_BIND_BIT \"\n                     \"flag, but pBindings[%\" PRIu32 \"] has descriptor type VK_DESCRIPTOR_TYPE_STORAGE_BUFFER_DYNAMIC.\",\n                     storage_buffer_dynamic);\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkCopyDescriptorSet-srcArrayElement-00346\", \"The sum of srcArrayElement and descriptorCount must be less than or equal to the number of array elements in the descriptor set binding specified by srcBinding, and all applicable consecutive bindings, as described by consecutive binding updates\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if ((src_start_idx + update.descriptorCount) > src_set->GetTotalDescriptorCount()) {\n    const LogObjectList objlist(update.srcSet, src_layout->Handle());\n    skip |= LogError(\"VUID-VkCopyDescriptorSet-srcArrayElement-00346\", objlist, copy_loc.dot(Field::srcArrayElement),\n                     \"(%\" PRIu32 \") plus descriptorCount (%\" PRIu32 \") (plus offset index of %\" PRIu32\n                     \") is larger than the total descriptors count (%\" PRIu32 \") for the binding at srcBinding (%\" PRIu32 \").\",\n                     update.srcArrayElement, update.descriptorCount,\n                     src_set->GetGlobalIndexRangeFromBinding(update.srcBinding).start, src_set->GetTotalDescriptorCount(),\n                     update.srcBinding);\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkCopyDescriptorSet-dstArrayElement-00348\", \"The sum of dstArrayElement and descriptorCount must be less than or equal to the number of array elements in the descriptor set binding specified by dstBinding, and all applicable consecutive bindings, as described by consecutive binding updates\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if ((dst_start_idx + update.descriptorCount) > dst_layout->GetTotalDescriptorCount()) {\n    const LogObjectList objlist(update.dstSet, dst_layout->Handle());\n    skip |= LogError(\"VUID-VkCopyDescriptorSet-dstArrayElement-00348\", objlist, copy_loc.dot(Field::dstArrayElement),\n                     \"(%\" PRIu32 \") plus descriptorCount (%\" PRIu32 \") (plus offset index of %\" PRIu32\n                     \") is larger than the total descriptors count (%\" PRIu32 \") for the binding at srcBinding (%\" PRIu32 \").\",\n                     update.dstArrayElement, update.descriptorCount,\n                     dst_set->GetGlobalIndexRangeFromBinding(update.dstBinding).start, dst_set->GetTotalDescriptorCount(),\n                     update.dstBinding);\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkCopyDescriptorSet-dstBinding-02632\", \"The type of dstBinding within dstSet must be equal to the type of srcBinding within srcSet\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (src_type != VK_DESCRIPTOR_TYPE_MUTABLE_EXT && dst_type != VK_DESCRIPTOR_TYPE_MUTABLE_EXT && src_type != dst_type) {\n    const LogObjectList objlist(update.srcSet, update.dstSet, src_layout->Handle(), dst_layout->Handle());\n    skip |= LogError(\"VUID-VkCopyDescriptorSet-dstBinding-02632\", objlist, copy_loc.dot(Field::dstBinding),\n                     \"(%\" PRIu32 \") (from %s) is %s, but srcBinding (%\" PRIu32 \") (from %s) is %s.\", update.dstBinding,\n                     FormatHandle(dst_set->Handle()).c_str(), string_VkDescriptorType(dst_type), update.srcBinding,\n                     FormatHandle(src_set->Handle()).c_str(), string_VkDescriptorType(src_type));\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkCopyDescriptorSet-srcSet-04885\", \"If srcSet's layout was created without either the VK_DESCRIPTOR_SET_LAYOUT_CREATE_HOST_ONLY_POOL_BIT_EXT flag or the VK_DESCRIPTOR_SET_LAYOUT_CREATE_UPDATE_AFTER_BIND_POOL_BIT flag set, then dstSet's layout must have been created without the VK_DESCRIPTOR_SET_LAYOUT_CREATE_UPDATE_AFTER_BIND_POOL_BIT flag set\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "const LogObjectList objlist(update.srcSet, update.dstSet, src_layout->Handle(), dst_layout->Handle());\nskip |= LogError(\"VUID-VkCopyDescriptorSet-srcSet-04885\", objlist, copy_loc.dot(Field::srcSet),\n                 \"layout was created with %s, but dstSet layout was created with %s.\",\n                 string_VkDescriptorSetLayoutCreateFlags(src_layout->GetCreateFlags()).c_str(),\n                 string_VkDescriptorSetLayoutCreateFlags(dst_layout->GetCreateFlags()).c_str());\n"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkCopyDescriptorSet-srcSet-01920\", \"If the descriptor pool from which srcSet was allocated was created with the VK_DESCRIPTOR_POOL_CREATE_UPDATE_AFTER_BIND_BIT flag set, then the descriptor pool from which dstSet was allocated must also have been created with the VK_DESCRIPTOR_POOL_CREATE_UPDATE_AFTER_BIND_BIT flag set\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if ((src_pool->create_info.flags & VK_DESCRIPTOR_POOL_CREATE_UPDATE_AFTER_BIND_BIT) &&\n    const LogObjectList objlist(update.srcSet, update.dstSet, src_pool->Handle(), dst_pool->Handle());\n    skip |= LogError(\"VUID-VkCopyDescriptorSet-srcSet-01920\", objlist, copy_loc.dot(Field::srcSet),\n                     \"descriptor pool was created with %s, but dstSet descriptor pool was created with %s.\",\n                     string_VkDescriptorPoolCreateFlags(src_pool->create_info.flags).c_str(),\n                     string_VkDescriptorPoolCreateFlags(dst_pool->create_info.flags).c_str());\n"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkCopyDescriptorSet-srcSet-04887\", \"If the descriptor pool from which srcSet was allocated was created without either the VK_DESCRIPTOR_POOL_CREATE_HOST_ONLY_BIT_EXT flag or the VK_DESCRIPTOR_POOL_CREATE_UPDATE_AFTER_BIND_BIT flag set, then the descriptor pool from which dstSet was allocated must have been created without the VK_DESCRIPTOR_POOL_CREATE_UPDATE_AFTER_BIND_BIT flag set\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "const LogObjectList objlist(update.srcSet, update.dstSet, src_pool->Handle(), dst_pool->Handle());\nskip |= LogError(\"VUID-VkCopyDescriptorSet-srcSet-04887\", objlist, copy_loc.dot(Field::srcSet),\n                 \"descriptor pool was created with %s, but dstSet descriptor pool was created with %s.\",\n                 string_VkDescriptorPoolCreateFlags(src_pool->create_info.flags).c_str(),\n                 string_VkDescriptorPoolCreateFlags(dst_pool->create_info.flags).c_str());\n"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkCopyDescriptorSet-srcBinding-02223\", \"If the descriptor type of the descriptor set binding specified by srcBinding is VK_DESCRIPTOR_TYPE_INLINE_UNIFORM_BLOCK, srcArrayElement must be an integer multiple of 4\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (src_type == VK_DESCRIPTOR_TYPE_INLINE_UNIFORM_BLOCK_EXT && ((update.srcArrayElement % 4) != 0)) {\n    const LogObjectList objlist(update.srcSet, src_layout->Handle());\n    skip |= LogError(\"VUID-VkCopyDescriptorSet-srcBinding-02223\", objlist, copy_loc.dot(Field::srcArrayElement),\n                     \"is %\" PRIu32 \", but srcBinding (%\" PRIu32 \") type is VK_DESCRIPTOR_TYPE_INLINE_UNIFORM_BLOCK_EXT.\",\n                     update.srcArrayElement, update.srcBinding);\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkCopyDescriptorSet-srcBinding-02225\", \"If the descriptor type of the descriptor set binding specified by either srcBinding or dstBinding is VK_DESCRIPTOR_TYPE_INLINE_UNIFORM_BLOCK, descriptorCount must be an integer multiple of 4\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if ((update.descriptorCount % 4) != 0) {\n    const LogObjectList objlist(update.srcSet, update.dstSet, src_layout->Handle(), dst_layout->Handle());\n    skip |= LogError(\"VUID-VkCopyDescriptorSet-srcBinding-02225\", objlist, copy_loc.dot(Field::descriptorCount),\n                     \"is %\" PRIu32 \", but srcBinding (%\" PRIu32 \") type is %s and dstBinding (%\" PRIu32 \") type is %s.\",\n                     update.descriptorCount, update.srcBinding, string_VkDescriptorType(src_type), update.dstBinding,\n                     string_VkDescriptorType(dst_type));\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkCopyDescriptorSet-dstSet-04612\", \"If VkDescriptorSetLayoutBinding for dstSet at dstBinding is VK_DESCRIPTOR_TYPE_MUTABLE_EXT, the new active descriptor type must exist in the corresponding pMutableDescriptorTypeLists list for dstBinding if the new active descriptor type is not VK_DESCRIPTOR_TYPE_MUTABLE_EXT\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (!dst_layout->IsTypeMutable(src_type, update.dstBinding)) {\n    const LogObjectList objlist(update.srcSet, update.dstSet, src_layout->Handle(), dst_layout->Handle());\n    skip |= LogError(\"VUID-VkCopyDescriptorSet-dstSet-04612\", objlist, copy_loc.dot(Field::dstBinding),\n                     \"(%\" PRIu32\n                     \") descriptor type  is VK_DESCRIPTOR_TYPE_MUTABLE_EXT, but the new active descriptor type %s is \"\n                     \"not in the corresponding pMutableDescriptorTypeLists list.\",\n                     update.dstBinding, string_VkDescriptorType(src_type));\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkCopyDescriptorSet-srcSet-04613\", \"If VkDescriptorSetLayoutBinding for srcSet at srcBinding is VK_DESCRIPTOR_TYPE_MUTABLE_EXT and the VkDescriptorSetLayoutBinding for dstSet at dstBinding is not VK_DESCRIPTOR_TYPE_MUTABLE_EXT, the active descriptor type for the source descriptor must match the descriptor type of dstBinding\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (mutable_src.ActiveType() != dst_type) {\n    const LogObjectList objlist(update.srcSet, update.dstSet, src_layout->Handle(), dst_layout->Handle());\n    skip |= LogError(\"VUID-VkCopyDescriptorSet-srcSet-04613\", objlist, copy_loc.dot(Field::srcBinding),\n                     \"(%\" PRIu32\n                     \") descriptor type  is VK_DESCRIPTOR_TYPE_MUTABLE_EXT, but the active descriptor type %sdoes not \"\n                     \"match the dstBinding descriptor type %s.\",\n                     update.srcBinding, string_VkDescriptorType(mutable_src.ActiveType()),\n                     string_VkDescriptorType(dst_type));\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkDescriptorImageInfo-imageView-06712\", \"imageView must not be a 2D array image view created from a 3D image\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (view_state.create_info.viewType == VK_IMAGE_VIEW_TYPE_2D_ARRAY) {\n    skip |= LogError(\"VUID-VkDescriptorImageInfo-imageView-06712\", objlist, image_info_loc.dot(Field::imageView),\n                     \"is VK_IMAGE_VIEW_TYPE_2D_ARRAY but the image is VK_IMAGE_TYPE_3D.\");\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkDescriptorImageInfo-descriptorType-06714\", \"If the sampler2DViewOf3D feature is not enabled or descriptorType is not VK_DESCRIPTOR_TYPE_SAMPLED_IMAGE or VK_DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER then imageView must not be a 2D view created from a 3D image\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if ((type == VK_DESCRIPTOR_TYPE_SAMPLED_IMAGE || type == VK_DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER) &&\n    skip |= LogError(\"VUID-VkDescriptorImageInfo-descriptorType-06714\", objlist, image_info_loc.dot(Field::imageView),\n                     \"is VK_IMAGE_VIEW_TYPE_2D, the image is VK_IMAGE_VIEW_TYPE_3D, and the descriptorType is %s, but \"\n                     \"the sampler2DViewOf3D feature was not enabled.\",\n                     string_VkDescriptorType(type));\n"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkDescriptorImageInfo-imageView-07795\", \"If imageView is a 2D view created from a 3D image, then descriptorType must be VK_DESCRIPTOR_TYPE_STORAGE_IMAGE, VK_DESCRIPTOR_TYPE_SAMPLED_IMAGE, or VK_DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if ((type != VK_DESCRIPTOR_TYPE_STORAGE_IMAGE) && (type != VK_DESCRIPTOR_TYPE_SAMPLED_IMAGE) &&\n    skip |= LogError(\"VUID-VkDescriptorImageInfo-imageView-07795\", objlist, image_info_loc.dot(Field::imageView),\n                     \"is VK_IMAGE_VIEW_TYPE_2D, the image is VK_IMAGE_VIEW_TYPE_3D, and the descriptorType is %s.\",\n                     string_VkDescriptorType(type));\n"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkDescriptorImageInfo-imageView-07796\", \"If imageView is a 2D view created from a 3D image, then the image must have been created with VK_IMAGE_CREATE_2D_VIEW_COMPATIBLE_BIT_EXT set\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (!(image_node->create_info.flags & VK_IMAGE_CREATE_2D_VIEW_COMPATIBLE_BIT_EXT)) {\n    skip |= LogError(\"VUID-VkDescriptorImageInfo-imageView-07796\", objlist, image_info_loc.dot(Field::imageView),\n                     \"is VK_IMAGE_VIEW_TYPE_2D, the image is VK_IMAGE_VIEW_TYPE_3D, but the image was created with %s.\",\n                     string_VkImageCreateFlags(image_node->create_info.flags).c_str());\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkDescriptorImageInfo-imageLayout-09425\", \"If imageLayout is VK_IMAGE_LAYOUT_COLOR_ATTACHMENT_OPTIMAL, then the aspectMask used to create imageView must not include either VK_IMAGE_ASPECT_DEPTH_BIT or VK_IMAGE_ASPECT_STENCIL_BIT\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (aspect_mask & (VK_IMAGE_ASPECT_DEPTH_BIT | VK_IMAGE_ASPECT_STENCIL_BIT)) {\n    skip |= LogError(\"VUID-VkDescriptorImageInfo-imageLayout-09425\", objlist, image_info_loc.dot(Field::imageView),\n                     \"uses layout VK_IMAGE_LAYOUT_COLOR_ATTACHMENT_OPTIMAL but aspectMask (%s) include depth/stencil bit.\",\n                     string_VkImageAspectFlags(aspect_mask).c_str());\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkDescriptorImageInfo-imageView-01976\", \"If imageView is created from a depth/stencil image, the aspectMask used to create the imageView must include either VK_IMAGE_ASPECT_DEPTH_BIT or VK_IMAGE_ASPECT_STENCIL_BIT but not both\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (aspect_mask & VK_IMAGE_ASPECT_STENCIL_BIT) {\n    skip |= LogError(\"VUID-VkDescriptorImageInfo-imageView-01976\", objlist, image_info_loc.dot(Field::imageView),\n                     \"use layout %s and the image format (%s), but it has both STENCIL and DEPTH aspects set\",\n                     string_VkImageLayout(image_layout), string_VkFormat(image_node->create_info.format));\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkWriteDescriptorSet-descriptorType-01946\", \"If descriptorType is VK_DESCRIPTOR_TYPE_SAMPLED_IMAGE, then the imageView member of each pImageInfo element must have been created without a VkSamplerYcbcrConversionInfo structure in its pNext chain\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (view_state.samplerConversion != VK_NULL_HANDLE) {\n    skip |= LogError(\"VUID-VkWriteDescriptorSet-descriptorType-01946\", objlist, image_info_loc.dot(Field::imageView),\n                     \"is used as VK_DESCRIPTOR_TYPE_SAMPLED_IMAGE, but was created with %s\",\n                     FormatHandle(view_state.samplerConversion).c_str());\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkWriteDescriptorSet-descriptorType-00337\", \"If descriptorType is VK_DESCRIPTOR_TYPE_SAMPLED_IMAGE or VK_DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER, the imageView member of each element of pImageInfo must have been created with VK_IMAGE_USAGE_SAMPLED_BIT set\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (!(usage & VK_IMAGE_USAGE_SAMPLED_BIT)) {\n    skip |= LogError(\"VUID-VkWriteDescriptorSet-descriptorType-00337\", objlist, image_info_loc.dot(Field::imageView),\n                     \"was created with %s, but descriptorType is %s.\", string_VkImageUsageFlags(usage).c_str(),\n                     string_VkDescriptorType(type));\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkWriteDescriptorSet-descriptorType-00339\", \"If descriptorType is VK_DESCRIPTOR_TYPE_STORAGE_IMAGE, the imageView member of each element of pImageInfo must have been created with VK_IMAGE_USAGE_STORAGE_BIT set\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (!(usage & VK_IMAGE_USAGE_STORAGE_BIT)) {\n    skip |= LogError(\"VUID-VkWriteDescriptorSet-descriptorType-00339\", objlist, image_info_loc.dot(Field::imageView),\n                     \"was created with %s, but descriptorType is VK_DESCRIPTOR_TYPE_STORAGE_IMAGE.\",\n                     string_VkImageUsageFlags(usage).c_str());\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkWriteDescriptorSet-descriptorType-00338\", \"If descriptorType is VK_DESCRIPTOR_TYPE_INPUT_ATTACHMENT, the imageView member of each element of pImageInfo must have been created with VK_IMAGE_USAGE_INPUT_ATTACHMENT_BIT set\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (!(usage & VK_IMAGE_USAGE_INPUT_ATTACHMENT_BIT)) {\n    skip |= LogError(\"VUID-VkWriteDescriptorSet-descriptorType-00338\", objlist, image_info_loc.dot(Field::imageView),\n                     \"was created with %s, but descriptorType is VK_DESCRIPTOR_TYPE_INPUT_ATTACHMENT.\",\n                     string_VkImageUsageFlags(usage).c_str());\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkWriteDescriptorSet-descriptorType-06942\", \"If descriptorType is VK_DESCRIPTOR_TYPE_SAMPLE_WEIGHT_IMAGE_QCOM, the imageView member of each element of pImageInfo must have been created with a view created with an image created with VK_IMAGE_USAGE_SAMPLE_WEIGHT_BIT_QCOM\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (!(usage & VK_IMAGE_USAGE_SAMPLE_WEIGHT_BIT_QCOM)) {\n    skip |= LogError(\"VUID-VkWriteDescriptorSet-descriptorType-06942\", objlist, image_info_loc.dot(Field::imageView),\n                     \"was created with %s, but descriptorType is VK_DESCRIPTOR_TYPE_SAMPLE_WEIGHT_IMAGE_QCOM.\",\n                     string_VkImageUsageFlags(usage).c_str());\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkWriteDescriptorSet-descriptorType-06943\", \"If descriptorType is VK_DESCRIPTOR_TYPE_BLOCK_MATCH_IMAGE_QCOM, the imageView member of each element of pImageInfo must have been created with a view created with an image created with VK_IMAGE_USAGE_SAMPLE_BLOCK_MATCH_BIT_QCOM\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (!(usage & VK_IMAGE_USAGE_SAMPLE_BLOCK_MATCH_BIT_QCOM)) {\n    skip |= LogError(\"VUID-VkWriteDescriptorSet-descriptorType-06943\", objlist, image_info_loc.dot(Field::imageView),\n                     \"was created with %s, but descriptorType is VK_DESCRIPTOR_TYPE_BLOCK_MATCH_IMAGE_QCOM.\",\n                     string_VkImageUsageFlags(usage).c_str());\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkWriteDescriptorSet-descriptorType-00336\", \"If descriptorType is VK_DESCRIPTOR_TYPE_STORAGE_IMAGE or VK_DESCRIPTOR_TYPE_INPUT_ATTACHMENT, the imageView member of each element of pImageInfo must have been created with the identity swizzle\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (IsIdentitySwizzle(components) == false) {\n    skip |= LogError(\"VUID-VkWriteDescriptorSet-descriptorType-00336\", objlist, image_info_loc.dot(Field::imageView),\n                     \"has a non-identiy swizzle component, here are the actual swizzle values:\\n\"\n                     \"r swizzle = %s\\n\"\n                     \"g swizzle = %s\\n\"\n                     \"b swizzle = %s\\n\"\n                     \"a swizzle = %s\\n\",\n                     string_VkComponentSwizzle(components.r), string_VkComponentSwizzle(components.g),\n                     string_VkComponentSwizzle(components.b), string_VkComponentSwizzle(components.a));\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkWriteDescriptorSet-descriptorType-08766\", \"If descriptorType is VK_DESCRIPTOR_TYPE_STORAGE_TEXEL_BUFFER, the pTexelBufferView buffer view usage must include VK_BUFFER_USAGE_STORAGE_TEXEL_BUFFER_BIT\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (!(buffer_state.usage & VK_BUFFER_USAGE_STORAGE_TEXEL_BUFFER_BIT)) {\n    skip |= LogError(\"VUID-VkWriteDescriptorSet-descriptorType-08766\", buffer_state.Handle(), buffer_loc,\n                     \"was created with %s, but descriptorType is VK_DESCRIPTOR_TYPE_STORAGE_TEXEL_BUFFER.\",\n                     string_VkBufferUsageFlags2KHR(buffer_state.usage).c_str());\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkWriteDescriptorSet-descriptorType-00330\", \"If descriptorType is VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER or VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER_DYNAMIC, the buffer member of each element of pBufferInfo must have been created with VK_BUFFER_USAGE_UNIFORM_BUFFER_BIT set\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (!(buffer_state.usage & VK_BUFFER_USAGE_UNIFORM_BUFFER_BIT)) {\n    skip |= LogError(\"VUID-VkWriteDescriptorSet-descriptorType-00330\", buffer_state.Handle(), buffer_loc,\n                     \"was created with %s, but descriptorType is %s.\",\n                     string_VkBufferUsageFlags2KHR(buffer_state.usage).c_str(), string_VkDescriptorType(type));\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkWriteDescriptorSet-descriptorType-00331\", \"If descriptorType is VK_DESCRIPTOR_TYPE_STORAGE_BUFFER or VK_DESCRIPTOR_TYPE_STORAGE_BUFFER_DYNAMIC, the buffer member of each element of pBufferInfo must have been created with VK_BUFFER_USAGE_STORAGE_BUFFER_BIT set\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (!(buffer_state.usage & VK_BUFFER_USAGE_STORAGE_BUFFER_BIT)) {\n    skip |= LogError(\"VUID-VkWriteDescriptorSet-descriptorType-00331\", buffer_state.Handle(), buffer_loc,\n                     \"was created with %s, but descriptorType is %s.\",\n                     string_VkBufferUsageFlags2KHR(buffer_state.usage).c_str(), string_VkDescriptorType(type));\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkDescriptorBufferInfo-offset-00340\", \"offset must be less than the size of buffer\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (buffer_info.offset >= buffer_state->create_info.size) {\n    skip |= LogError(\"VUID-VkDescriptorBufferInfo-offset-00340\", buffer_info.buffer, buffer_info_loc.dot(Field::offset),\n                     \"(%\" PRIu64 \") is greater than or equal to buffer size (%\" PRIu64 \").\", buffer_info.offset,\n                     buffer_state->create_info.size);\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkDescriptorBufferInfo-range-00342\", \"If range is not equal to VK_WHOLE_SIZE, range must be less than or equal to the size of buffer minus offset\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (buffer_info.range > (buffer_state->create_info.size - buffer_info.offset)) {\n    skip |= LogError(\"VUID-VkDescriptorBufferInfo-range-00342\", buffer_info.buffer, buffer_info_loc.dot(Field::range),\n                     \"(%\" PRIu64 \") is larger than buffer size (%\" PRIu64 \") + offset (%\" PRIu64 \").\", buffer_info.range,\n                     buffer_state->create_info.size, buffer_info.offset);\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkCopyDescriptorSet-dstBinding-02753\", \"If the descriptor type of the descriptor set binding specified by dstBinding is VK_DESCRIPTOR_TYPE_SAMPLER, then dstSet must not have been allocated with a layout that included immutable samplers for dstBinding\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (dst_iter.updated() && dst_iter->IsImmutableSampler()) {\n    const LogObjectList objlist(update.srcSet, update.dstSet);\n    skip |= LogError(\"VUID-VkCopyDescriptorSet-dstBinding-02753\", objlist, copy_loc,\n                     \"Attempted copy update to an immutable sampler descriptor.\");\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkWriteDescriptorSet-descriptorType-00325\", \"If descriptorType is VK_DESCRIPTOR_TYPE_SAMPLER or VK_DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER, and dstSet was not allocated with a layout that included immutable samplers for dstBinding with descriptorType, the sampler member of each element of pImageInfo must be a valid VkSampler object\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (!ValidateSampler(update_sampler)) {\n    const LogObjectList objlist(update.srcSet, update_sampler);\n    skip |= LogError(\"VUID-VkWriteDescriptorSet-descriptorType-00325\", objlist, copy_loc,\n                     \"Attempted copy update to sampler descriptor with invalid sampler (%s).\",\n                     FormatHandle(update_sampler).c_str());\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkWriteDescriptorSet-descriptorType-00325\", \"If descriptorType is VK_DESCRIPTOR_TYPE_SAMPLER or VK_DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER, and dstSet was not allocated with a layout that included immutable samplers for dstBinding with descriptorType, the sampler member of each element of pImageInfo must be a valid VkSampler object\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (!ValidateSampler(update_sampler)) {\n    const LogObjectList objlist(update.srcSet);\n    skip |= LogError(\"VUID-VkWriteDescriptorSet-descriptorType-00325\", objlist, copy_loc,\n                     \"Attempted copy update to sampler descriptor with invalid sampler (%s).\",\n                     FormatHandle(update_sampler).c_str());\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkWriteDescriptorSet-descriptorType-02994\", \"If descriptorType is VK_DESCRIPTOR_TYPE_UNIFORM_TEXEL_BUFFER or VK_DESCRIPTOR_TYPE_STORAGE_TEXEL_BUFFER, each element of pTexelBufferView must be either a valid VkBufferView handle or VK_NULL_HANDLE\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (!bv_state) {\n    const LogObjectList objlist(update.srcSet);\n    skip |= LogError(\"VUID-VkWriteDescriptorSet-descriptorType-02994\", objlist, copy_loc,\n                     \"Attempted copy update to texel buffer descriptor with invalid buffer view (%s).\",\n                     FormatHandle(buffer_view).c_str());\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkWriteDescriptorSet-descriptorType-02994\", \"If descriptorType is VK_DESCRIPTOR_TYPE_UNIFORM_TEXEL_BUFFER or VK_DESCRIPTOR_TYPE_STORAGE_TEXEL_BUFFER, each element of pTexelBufferView must be either a valid VkBufferView handle or VK_NULL_HANDLE\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (!bv_state) {\n    skip |= LogError(\"VUID-VkWriteDescriptorSet-descriptorType-02994\", device, write_loc,\n                     \"Attempted write update to texel buffer descriptor with invalid buffer view (%s).\",\n                     FormatHandle(buffer_view).c_str());\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkWriteDescriptorSet-descriptorType-02994\", \"If descriptorType is VK_DESCRIPTOR_TYPE_UNIFORM_TEXEL_BUFFER or VK_DESCRIPTOR_TYPE_STORAGE_TEXEL_BUFFER, each element of pTexelBufferView must be either a valid VkBufferView handle or VK_NULL_HANDLE\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (!buffer_state) {\n    skip |= LogError(\"VUID-VkWriteDescriptorSet-descriptorType-02994\", device, write_loc,\n                     \"Attempted write update to texel buffer descriptor with invalid buffer (%s).\",\n                     FormatHandle(buffer).c_str());\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkWriteDescriptorSet-dstBinding-00316\", \"dstBinding must be a binding with a non-zero descriptorCount\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (!dest) {\n    skip |= LogError(\"VUID-VkWriteDescriptorSet-dstBinding-00316\", objlist, dst_binding_loc,\n                     \"(%\" PRIu32\n                     \") was never set in any VkDescriptorSetLayoutBinding::binding for %s, therefore the descriptorCount value \"\n                     \"is considered zero.\",\n                     update.dstBinding, FormatHandle(dst_layout->Handle()).c_str());\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-vkUpdateDescriptorSets-None-03047\", \"The dstSet member of each element of pDescriptorWrites or pDescriptorCopies for bindings which were created without the VK_DESCRIPTOR_BINDING_UPDATE_AFTER_BIND_BIT or VK_DESCRIPTOR_BINDING_UPDATE_UNUSED_WHILE_PENDING_BIT bits set must not be used by any command that was recorded to a command buffer which is in the pending state\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (used_handle && !vvl::IsBindless(dest->binding_flags)) {\n    skip |= LogError(\"VUID-vkUpdateDescriptorSets-None-03047\", objlist, dst_binding_loc,\n                     \"(%\" PRIu32 \") was created with %s, but %s is in use by %s.\", update.dstBinding,\n                     string_VkDescriptorBindingFlags(dest->binding_flags).c_str(), FormatHandle(update.dstSet).c_str(),\n                     FormatHandle(*used_handle).c_str());\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkWriteDescriptorSet-descriptorType-00319\", \"descriptorType must match the type of dstBinding within dstSet\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if ((dest->type != VK_DESCRIPTOR_TYPE_MUTABLE_EXT) && (dest->type != update.descriptorType)) {\n    skip |= LogError(\"VUID-VkWriteDescriptorSet-descriptorType-00319\", objlist, write_loc.dot(Field::descriptorType),\n                     \"(%s) is different from pBinding[%\" PRIu32 \"].descriptorType (%s) of %s.\",\n                     string_VkDescriptorType(update.descriptorType), update.dstBinding, string_VkDescriptorType(dest->type),\n                     dst_set.StringifySetAndLayout().c_str());\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkWriteDescriptorSet-descriptorType-02219\", \"If descriptorType is VK_DESCRIPTOR_TYPE_INLINE_UNIFORM_BLOCK, dstArrayElement must be an integer multiple of 4\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if ((update.dstArrayElement % 4) != 0) {\n    skip |= LogError(\"VUID-VkWriteDescriptorSet-descriptorType-02219\", objlist, dst_binding_loc,\n                     \"(%\" PRIu32 \") is of type VK_DESCRIPTOR_TYPE_INLINE_UNIFORM_BLOCK_EXT, but dstArrayElement is %\" PRIu32\n                     \".\",\n                     update.dstBinding, update.dstArrayElement);\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkWriteDescriptorSet-descriptorType-02220\", \"If descriptorType is VK_DESCRIPTOR_TYPE_INLINE_UNIFORM_BLOCK, descriptorCount must be an integer multiple of 4\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if ((update.descriptorCount % 4) != 0) {\n    skip |= LogError(\"VUID-VkWriteDescriptorSet-descriptorType-02220\", objlist, dst_binding_loc,\n                     \"(%\" PRIu32 \") is of type VK_DESCRIPTOR_TYPE_INLINE_UNIFORM_BLOCK_EXT, but descriptorCount is %\" PRIu32\n                     \".\",\n                     update.dstBinding, update.descriptorCount);\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkWriteDescriptorSet-descriptorType-02221\", \"If descriptorType is VK_DESCRIPTOR_TYPE_INLINE_UNIFORM_BLOCK, the pNext chain must include a VkWriteDescriptorSetInlineUniformBlock structure whose dataSize member equals descriptorCount\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "skip |= LogError(\"VUID-VkWriteDescriptorSet-descriptorType-02221\", objlist,\n                 write_loc.pNext(Struct::VkWriteDescriptorSetInlineUniformBlock, Field::dataSize),\n                 \"(%\" PRIu32 \") is different then descriptorCount (%\" PRIu32 \"), but dstBinding (%\" PRIu32\n                 \") is of type VK_DESCRIPTOR_TYPE_INLINE_UNIFORM_BLOCK_EXT.\",\n                 write_inline_info->dataSize, update.descriptorCount, update.dstBinding);\n"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkWriteDescriptorSetInlineUniformBlock-dataSize-02222\", \"dataSize must be an integer multiple of 4\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "write_inline_info->dataSize, update.descriptorCount, update.dstBinding);\n} else if ((write_inline_info->dataSize % 4) != 0) {\nskip |= LogError(\"VUID-VkWriteDescriptorSetInlineUniformBlock-dataSize-02222\", objlist,\nwrite_loc.pNext(Struct::VkWriteDescriptorSetInlineUniformBlock, Field::dataSize), \"is %\" PRIu32 \".\",\nwrite_inline_info->dataSize);\n"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkWriteDescriptorSet-descriptorCount-00318\", \"All consecutive bindings updated via a single VkWriteDescriptorSet structure, except those with a descriptorCount of zero, must all either use immutable samplers or must all not use immutable samplers\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (current_binding->has_immutable_samplers != immutable_samplers) {\n    skip |= LogError(\"VUID-VkWriteDescriptorSet-descriptorCount-00318\", objlist, write_loc,\n                     \"binding #%\" PRIu32 \" (started on dstBinding [%\" PRIu32 \"] plus %\" PRIu32\n                     \" descriptors offset) %s Immutable Samplers, which is different from the previous binding.\",\n                     current_binding->binding, update.dstBinding, i,\n                     current_binding->has_immutable_samplers ? \"has\" : \"doesn't have\");\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkWriteDescriptorSet-dstArrayElement-00321\", \"The sum of dstArrayElement and descriptorCount must be less than or equal to the number of array elements in the descriptor set binding specified by dstBinding, and all applicable consecutive bindings, as described by consecutive binding updates\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if ((update.dstArrayElement + update.descriptorCount) > dst_set.GetVariableDescriptorCount()) {\n    skip |= LogError(\"VUID-VkWriteDescriptorSet-dstArrayElement-00321\", objlist, write_loc.dot(Field::dstArrayElement),\n                     \"(%\" PRIu32 \") + descriptorCount (%\" PRIu32 \") is larger than (%\" PRIu32 \") for dstBinding (%\" PRIu32\n                     \") in %s.\",\n                     update.dstArrayElement, update.descriptorCount, dst_set.GetVariableDescriptorCount(),\n                     update.dstBinding, dst_set.StringifySetAndLayout().c_str());\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkWriteDescriptorSet-descriptorType-09506\", \"If descriptorType is VK_DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER, dstSet was allocated with a layout that included immutable samplers for dstBinding, and those samplers enable sampler Y'CBCR conversion, then imageView must not be VK_NULL_HANDLE\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (desc.IsImmutableSampler()) {\n    const LogObjectList objlist(update.dstSet, desc.GetSampler());\n    skip |= LogError(\"VUID-VkWriteDescriptorSet-descriptorType-09506\", objlist,\n                     write_loc.dot(Field::pImageInfo, di).dot(Field::imageView), \"is VK_NULL_HANDLE.\");\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkWriteDescriptorSet-descriptorType-01948\", \"If descriptorType is VK_DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER, and dstSet was allocated with a layout that included immutable samplers for dstBinding, then the imageView member of each element of pImageInfo which corresponds to an immutable sampler that enables sampler Y'CBCR conversion must have been created with a VkSamplerYcbcrConversionInfo structure in its pNext chain with an identically defined VkSamplerYcbcrConversionInfo to the corresponding immutable sampler\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (iv_state->samplerConversion != sampler_state->samplerConversion) {\n    const LogObjectList objlist(update.dstSet, desc.GetSampler(), iv_state->Handle());\n    skip |= LogError(\"VUID-VkWriteDescriptorSet-descriptorType-01948\", objlist, write_loc,\n                     \"Attempted write update to combined image sampler and image view and sampler \"\n                     \"YCbCr conversions are not identical.\");\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkWriteDescriptorSet-descriptorType-02738\", \"If descriptorType is VK_DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER, and if any element of pImageInfo has an imageView member that was created with a VkSamplerYcbcrConversionInfo structure in its pNext chain, then dstSet must have been allocated with a layout that included immutable samplers for dstBinding, and the corresponding immutable sampler must have been created with an identically defined VkSamplerYcbcrConversionInfo object\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "const LogObjectList objlist(update.dstSet, iv_state->Handle());\nskip |= LogError(\"VUID-VkWriteDescriptorSet-descriptorType-02738\", objlist, write_loc.dot(Field::dstSet),\n                 \"is bound to image view that includes a YCbCr conversion, it must have been allocated \"\n                 \"with a layout that includes an immutable sampler.\");\n"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkDescriptorImageInfo-sampler-01564\", \"If sampler is used and the VkFormat of the image is a multi-planar format, the image must have been created with VK_IMAGE_CREATE_MUTABLE_FORMAT_BIT, and the aspectMask of the imageView must be a valid multi-planar aspect mask bit\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (0 == (image_state->create_info.flags & VK_IMAGE_CREATE_MUTABLE_FORMAT_BIT)) {\n    const LogObjectList objlist(update.dstSet, image_state->Handle());\n    skip |= LogError(\"VUID-VkDescriptorImageInfo-sampler-01564\", objlist, write_loc,\n                     \"combined image sampler is a multi-planar format %s and was created with %s.\",\n                     string_VkFormat(image_format),\n                     string_VkImageCreateFlags(image_state->create_info.flags).c_str());\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkDescriptorImageInfo-mutableComparisonSamplers-04450\", \"If the VK_KHR_portability_subset extension is enabled, and VkPhysicalDevicePortabilitySubsetFeaturesKHR::mutableComparisonSamplers is VK_FALSE, then sampler must have been created with VkSamplerCreateInfo::compareEnable set to VK_FALSE\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if ((VK_FALSE == enabled_features.mutableComparisonSamplers) &&\n    skip |= LogError(\"VUID-VkDescriptorImageInfo-mutableComparisonSamplers-04450\", device, write_loc,\n                     \"(portability error): sampler comparison not available.\");\n"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkWriteDescriptorSet-descriptorType-02752\", \"If descriptorType is VK_DESCRIPTOR_TYPE_SAMPLER, then dstSet must not have been allocated with a layout that included immutable samplers for dstBinding\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "FormatHandle(update.pImageInfo[di].sampler).c_str());\n} else if (update.descriptorType == VK_DESCRIPTOR_TYPE_SAMPLER && !push) {\nskip |= LogError(\"VUID-VkWriteDescriptorSet-descriptorType-02752\", update.dstSet, write_loc,\n\"Attempted write update to an immutable sampler descriptor.\");\n"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkDescriptorBufferBindingInfoEXT-bufferlessPushDescriptors-08056\", \"If VkPhysicalDeviceDescriptorBufferPropertiesEXT::bufferlessPushDescriptors is VK_FALSE, and usage contains VK_BUFFER_USAGE_PUSH_DESCRIPTORS_DESCRIPTOR_BUFFER_BIT_EXT, then the pNext chain must include a VkDescriptorBufferBindingPushDescriptorBufferHandleEXT structure\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (!phys_dev_ext_props.descriptor_buffer_props.bufferlessPushDescriptors &&\n    skip |= LogError(\"VUID-VkDescriptorBufferBindingInfoEXT-bufferlessPushDescriptors-08056\", commandBuffer,\n                     binding_loc.dot(Field::pNext),\n                     \"does not contain a VkDescriptorBufferBindingPushDescriptorBufferHandleEXT structure, but \"\n                     \"bufferlessPushDescriptors is VK_FALSE and usage \"\n                     \"contains VK_BUFFER_USAGE_PUSH_DESCRIPTORS_DESCRIPTOR_BUFFER_BIT_EXT\");\n"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkDescriptorBufferBindingInfoEXT-address-08057\", \"address must be aligned to VkPhysicalDeviceDescriptorBufferPropertiesEXT::descriptorBufferOffsetAlignment\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (SafeModulo(pBindingInfos[i].address, phys_dev_ext_props.descriptor_buffer_props.descriptorBufferOffsetAlignment) != 0) {\n    skip |= LogError(\"VUID-VkDescriptorBufferBindingInfoEXT-address-08057\", commandBuffer, binding_loc.dot(Field::address),\n                     \"(%\" PRIuLEAST64\n                     \") is not aligned \"\n                     \"to descriptorBufferOffsetAlignment (%\" PRIuLEAST64 \")\",\n                     pBindingInfos[i].address, phys_dev_ext_props.descriptor_buffer_props.descriptorBufferOffsetAlignment);\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-vkCmdBindDescriptorBuffersEXT-None-08050\", \"There must be no more than 1 descriptor buffer bound that was created with the VK_BUFFER_USAGE_PUSH_DESCRIPTORS_DESCRIPTOR_BUFFER_BIT_EXT bit set\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (num_push_descriptor_buffers > 1) {\n    skip |= LogError(\"VUID-vkCmdBindDescriptorBuffersEXT-None-08050\", commandBuffer, error_obj.location,\n                     \"Number of descriptor buffers is %\" PRIu32\n                     \". \"\n                     \"There must be no more than 1 descriptor buffer bound that was created \"\n                     \"with the VK_BUFFER_USAGE_PUSH_DESCRIPTORS_DESCRIPTOR_BUFFER_BIT_EXT bit set.\",\n                     num_push_descriptor_buffers);\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-vkCmdBindDescriptorBuffersEXT-bufferCount-08051\", \"bufferCount must be less than or equal to VkPhysicalDeviceDescriptorBufferPropertiesEXT::maxDescriptorBufferBindings\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (bufferCount > phys_dev_ext_props.descriptor_buffer_props.maxDescriptorBufferBindings) {\n    skip |= LogError(\"VUID-vkCmdBindDescriptorBuffersEXT-bufferCount-08051\", commandBuffer,\n                     error_obj.location.dot(Field::bufferCount),\n                     \"bufferCount (%\" PRIu32\n                     \") must be less than or equal to \"\n                     \"VkPhysicalDeviceDescriptorBufferPropertiesEXT::maxDescriptorBufferBindings (%\" PRIu32 \").\",\n                     bufferCount, phys_dev_ext_props.descriptor_buffer_props.maxDescriptorBufferBindings);\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-vkGetDescriptorSetLayoutSizeEXT-None-08011\", \"The descriptorBuffer feature must be enabled\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (!enabled_features.descriptorBuffer) {\n    skip |= LogError(\"VUID-vkGetDescriptorSetLayoutSizeEXT-None-08011\", device, error_obj.location,\n                     \"descriptorBuffer feature was not enabled.\");\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-vkGetDescriptorSetLayoutSizeEXT-layout-08012\", \"layout must have been created with the VK_DESCRIPTOR_SET_LAYOUT_CREATE_DESCRIPTOR_BUFFER_BIT_EXT flag set\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (!(create_flags & VK_DESCRIPTOR_SET_LAYOUT_CREATE_DESCRIPTOR_BUFFER_BIT_EXT)) {\n    skip |= LogError(\"VUID-vkGetDescriptorSetLayoutSizeEXT-layout-08012\", layout, error_obj.location.dot(Field::layout),\n                     \"was created with %s.\", string_VkDescriptorSetLayoutCreateFlags(create_flags).c_str());\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-vkGetDescriptorSetLayoutBindingOffsetEXT-layout-08014\", \"layout must have been created with the VK_DESCRIPTOR_SET_LAYOUT_CREATE_DESCRIPTOR_BUFFER_BIT_EXT flag set\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (!(ds_layout_state->GetCreateFlags() & VK_DESCRIPTOR_SET_LAYOUT_CREATE_DESCRIPTOR_BUFFER_BIT_EXT)) {\n    skip |= LogError(\"VUID-vkGetDescriptorSetLayoutBindingOffsetEXT-layout-08014\", layout,\n                     error_obj.location.dot(Field::layout), \"was created with %s.\",\n                     string_VkDescriptorSetLayoutCreateFlags(create_flags).c_str());\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-vkGetBufferOpaqueCaptureDescriptorDataEXT-None-08072\", \"The descriptorBufferCaptureReplay feature must be enabled\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (!enabled_features.descriptorBufferCaptureReplay) {\n    skip |= LogError(\"VUID-vkGetBufferOpaqueCaptureDescriptorDataEXT-None-08072\", pInfo->buffer, error_obj.location,\n                     \"descriptorBufferCaptureReplay feature was not enabled.\");\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-vkGetBufferOpaqueCaptureDescriptorDataEXT-device-08074\", \"If device was created with multiple physical devices, then the bufferDeviceAddressMultiDevice feature must be enabled\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (physical_device_count > 1 && !enabled_features.bufferDeviceAddressMultiDevice &&\n    skip |= LogError(\"VUID-vkGetBufferOpaqueCaptureDescriptorDataEXT-device-08074\", pInfo->buffer, error_obj.location,\n                     \"device was created with multiple physical devices (%\" PRIu32\n                     \"), but the \"\n                     \"bufferDeviceAddressMultiDevice feature was not enabled.\",\n                     physical_device_count);\n"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkBufferCaptureDescriptorDataInfoEXT-buffer-08075\", \"buffer must have been created with VK_BUFFER_CREATE_DESCRIPTOR_BUFFER_CAPTURE_REPLAY_BIT_EXT set in VkBufferCreateInfo::flags\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (!(buffer_state->create_info.flags & VK_BUFFER_CREATE_DESCRIPTOR_BUFFER_CAPTURE_REPLAY_BIT_EXT)) {\n    skip |= LogError(\"VUID-VkBufferCaptureDescriptorDataInfoEXT-buffer-08075\", pInfo->buffer,\n                     error_obj.location.dot(Field::pInfo).dot(Field::buffer), \"was created with %s.\",\n                     string_VkBufferCreateFlags(buffer_state->create_info.flags).c_str());\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-vkGetImageOpaqueCaptureDescriptorDataEXT-device-08078\", \"If device was created with multiple physical devices, then the bufferDeviceAddressMultiDevice feature must be enabled\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (physical_device_count > 1 && !enabled_features.bufferDeviceAddressMultiDevice &&\n    skip |= LogError(\"VUID-vkGetImageOpaqueCaptureDescriptorDataEXT-device-08078\", pInfo->image, error_obj.location,\n                     \"device was created with multiple physical devices (%\" PRIu32\n                     \"), but the \"\n                     \"bufferDeviceAddressMultiDevice feature was not enabled.\",\n                     physical_device_count);\n"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkImageCaptureDescriptorDataInfoEXT-image-08079\", \"image must have been created with VK_IMAGE_CREATE_DESCRIPTOR_BUFFER_CAPTURE_REPLAY_BIT_EXT set in VkImageCreateInfo::flags\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (!(image_state->create_info.flags & VK_IMAGE_CREATE_DESCRIPTOR_BUFFER_CAPTURE_REPLAY_BIT_EXT)) {\n    skip |= LogError(\"VUID-VkImageCaptureDescriptorDataInfoEXT-image-08079\", pInfo->image,\n                     error_obj.location.dot(Field::pInfo).dot(Field::image), \"is %s.\",\n                     string_VkImageCreateFlags(image_state->create_info.flags).c_str());\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-vkGetImageViewOpaqueCaptureDescriptorDataEXT-None-08080\", \"The descriptorBufferCaptureReplay feature must be enabled\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (!enabled_features.descriptorBufferCaptureReplay) {\n    skip |= LogError(\"VUID-vkGetImageViewOpaqueCaptureDescriptorDataEXT-None-08080\", pInfo->imageView, error_obj.location,\n                     \"descriptorBufferCaptureReplay feature was not enabled.\");\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-vkGetImageViewOpaqueCaptureDescriptorDataEXT-device-08082\", \"If device was created with multiple physical devices, then the bufferDeviceAddressMultiDevice feature must be enabled\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (physical_device_count > 1 && !enabled_features.bufferDeviceAddressMultiDevice &&\n    skip |= LogError(\"VUID-vkGetImageViewOpaqueCaptureDescriptorDataEXT-device-08082\", pInfo->imageView, error_obj.location,\n                     \"device was created with multiple physical devices (%\" PRIu32\n                     \"), but the \"\n                     \"bufferDeviceAddressMultiDevice feature was not enabled.\",\n                     physical_device_count);\n"
        },
        {
            "role": "user",
            "content": "{\"VUID-vkGetSamplerOpaqueCaptureDescriptorDataEXT-None-08084\", \"The descriptorBufferCaptureReplay feature must be enabled\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (!enabled_features.descriptorBufferCaptureReplay) {\n    skip |= LogError(\"VUID-vkGetSamplerOpaqueCaptureDescriptorDataEXT-None-08084\", pInfo->sampler, error_obj.location,\n                     \"descriptorBufferCaptureReplay feature was not enabled.\");\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-vkGetSamplerOpaqueCaptureDescriptorDataEXT-device-08086\", \"If device was created with multiple physical devices, then the bufferDeviceAddressMultiDevice feature must be enabled\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (physical_device_count > 1 && !enabled_features.bufferDeviceAddressMultiDevice &&\n    skip |= LogError(\"VUID-vkGetSamplerOpaqueCaptureDescriptorDataEXT-device-08086\", pInfo->sampler, error_obj.location,\n                     \"device was created with multiple physical devices (%\" PRIu32\n                     \"), but the \"\n                     \"bufferDeviceAddressMultiDevice feature was not enabled.\",\n                     physical_device_count);\n"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkSamplerCaptureDescriptorDataInfoEXT-sampler-08087\", \"sampler must have been created with VK_SAMPLER_CREATE_DESCRIPTOR_BUFFER_CAPTURE_REPLAY_BIT_EXT set in VkSamplerCreateInfo::flags\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (!(sampler_state->create_info.flags & VK_SAMPLER_CREATE_DESCRIPTOR_BUFFER_CAPTURE_REPLAY_BIT_EXT)) {\n    skip |= LogError(\"VUID-VkSamplerCaptureDescriptorDataInfoEXT-sampler-08087\", pInfo->sampler,\n                     error_obj.location.dot(Field::pInfo).dot(Field::sampler), \"is %s.\",\n                     string_VkSamplerCreateFlags(sampler_state->create_info.flags).c_str());\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-vkGetAccelerationStructureOpaqueCaptureDescriptorDataEXT-None-08088\", \"The descriptorBufferCaptureReplay feature must be enabled\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (!enabled_features.descriptorBufferCaptureReplay) {\n    skip |= LogError(\"VUID-vkGetAccelerationStructureOpaqueCaptureDescriptorDataEXT-None-08088\", device, error_obj.location,\n                     \"descriptorBufferCaptureReplay feature was not enabled.\");\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkDescriptorAddressInfoEXT-range-08940\", \"range must not be zero\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (address_info->range == 0) {\n    skip |= LogError(\"VUID-VkDescriptorAddressInfoEXT-range-08940\", device, address_loc.dot(Field::range), \"is zero.\");\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkDescriptorAddressInfoEXT-address-08043\", \"If the nullDescriptor feature is not enabled, address must not be zero\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (!enabled_features.nullDescriptor) {\n    skip |= LogError(\"VUID-VkDescriptorAddressInfoEXT-address-08043\", device, address_loc.dot(Field::address),\n                     \"is zero, but the nullDescriptor feature was not enabled.\");\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkDescriptorAddressInfoEXT-nullDescriptor-08938\", \"If address is zero, range must be VK_WHOLE_SIZE\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "skip |= LogError(\"VUID-VkDescriptorAddressInfoEXT-address-08043\", device, address_loc.dot(Field::address),\n                 \"is zero, but the nullDescriptor feature was not enabled.\");\n} else if (address_info->range != VK_WHOLE_SIZE) {\nskip |= LogError(\"VUID-VkDescriptorAddressInfoEXT-nullDescriptor-08938\", device, address_loc.dot(Field::range),\n                 \"(%\" PRIu64 \") is not VK_WHOLE_SIZE, but address is zero.\", address_info->range);\n"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkDescriptorAddressInfoEXT-nullDescriptor-08939\", \"If address is not zero, range must not be VK_WHOLE_SIZE\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (address_info->range == VK_WHOLE_SIZE) {\n    skip |= LogError(\"VUID-VkDescriptorAddressInfoEXT-nullDescriptor-08939\", device, address_loc.dot(Field::range),\n                     \"is VK_WHOLE_SIZE.\");\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-vkGetDescriptorEXT-pDescriptorInfo-09507\", \"If pDescriptorInfo->type is VK_DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER and it has a imageView that is VK_NULL_HANDLE then dataSize must be equal to the size of VkPhysicalDeviceDescriptorBufferPropertiesEXT::combinedImageSamplerDescriptorSize\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (size != data_size) {\n    skip |= LogError(\"VUID-vkGetDescriptorEXT-pDescriptorInfo-09507\", device, descriptor_info_loc.dot(Field::type),\n                     \"(VK_DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER) and combinedImageSamplerDescriptorSize (%zu) not \"\n                     \"equal to dataSize %zu\",\n                     phys_dev_ext_props.descriptor_buffer_props.combinedImageSamplerDescriptorSize, data_size);\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-vkGetDescriptorEXT-descriptorType-09469\", \"If pDescriptorInfo->type is VK_DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER and pDescriptorInfo->data.pCombinedImageSampler has an imageView member that was created with a VkSamplerYcbcrConversionInfo structure in its pNext chain, dataSize must equal the size of VkPhysicalDeviceDescriptorBufferPropertiesEXT::combinedImageSamplerDescriptorSize times VkSamplerYcbcrConversionImageFormatProperties::combinedImageSamplerDescriptorCount\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (size != data_size) {\n    skip |= LogError(\"VUID-vkGetDescriptorEXT-descriptorType-09469\", device, descriptor_info_loc.dot(Field::type),\n                     \"(VK_DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER) has %s and descriptor size is %zu \"\n                     \"[combinedImageSamplerDescriptorCount (%\" PRIu32\n                     \") times combinedImageSamplerDescriptorSize (%zu)], but dataSize is %zu\",\n                     FormatHandle(image_view_state->samplerConversion).c_str(), size,\n                     sampler_ycbcr_image_format_info.combinedImageSamplerDescriptorCount,\n                     phys_dev_ext_props.descriptor_buffer_props.combinedImageSamplerDescriptorSize, data_size);\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-vkGetDescriptorEXT-dataSize-08125\", \"If pDescriptorInfo->type is not VK_DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER or pDescriptorInfo->data.pCombinedImageSampler has an imageView member that was not created with a VkSamplerYcbcrConversionInfo structure in its pNext chain, dataSize must equal the size of a descriptor of type VkDescriptorGetInfoEXT::type determined by the value in VkPhysicalDeviceDescriptorBufferPropertiesEXT , or determined by VkPhysicalDeviceDescriptorBufferDensityMapPropertiesEXT::combinedImageSamplerDensityMapDescriptorSize if pDescriptorInfo specifies a VK_DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER whose VkSampler was created with VK_SAMPLER_CREATE_SUBSAMPLED_BIT_EXT set\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (size != data_size) {\n    skip |= LogError(\"VUID-vkGetDescriptorEXT-dataSize-08125\", device, descriptor_info_loc.dot(Field::type),\n                     \"(%s) has a size of %zu (determined by %s::%s), but dataSize is %zu\",\n                     string_VkDescriptorType(descriptor_info.type), size, String(struct_name), String(field_name), data_size);\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkDescriptorGetInfoEXT-type-08019\", \"If type is VK_DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER, the pCombinedImageSampler->sampler member of data must be a VkSampler created on device\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (Get<vvl::Sampler>(pDescriptorInfo->data.pCombinedImageSampler->sampler).get() == nullptr) {\n    skip |= LogError(\"VUID-VkDescriptorGetInfoEXT-type-08019\", device, descriptor_info_loc.dot(Field::type),\n                     \"is VK_DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER, but \"\n                     \"pCombinedImageSampler->sampler is not a valid sampler.\");\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkDescriptorGetInfoEXT-type-08021\", \"If type is VK_DESCRIPTOR_TYPE_INPUT_ATTACHMENT, the pInputAttachmentImage->imageView member of data must be a VkImageView created on device\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (Get<vvl::ImageView>(pDescriptorInfo->data.pInputAttachmentImage->imageView).get() == nullptr) {\n    skip |= LogError(\"VUID-VkDescriptorGetInfoEXT-type-08021\", device, descriptor_info_loc.dot(Field::type),\n                     \"is VK_DESCRIPTOR_TYPE_INPUT_ATTACHMENT, but \"\n                     \"pInputAttachmentImage->imageView is not valid image view.\");\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkDescriptorGetInfoEXT-type-08022\", \"If type is VK_DESCRIPTOR_TYPE_SAMPLED_IMAGE, and if pSampledImage is not NULL, the pSampledImage->imageView member of data must be a VkImageView created on device, or VK_NULL_HANDLE\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (pDescriptorInfo->data.pSampledImage && (pDescriptorInfo->data.pSampledImage->imageView != VK_NULL_HANDLE) &&\n    skip |= LogError(\"VUID-VkDescriptorGetInfoEXT-type-08022\", device, descriptor_info_loc.dot(Field::type),\n                     \"is VK_DESCRIPTOR_TYPE_SAMPLED_IMAGE, but \"\n                     \"pSampledImage->imageView is not a valid image view.\");\n"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkDescriptorGetInfoEXT-type-08023\", \"If type is VK_DESCRIPTOR_TYPE_STORAGE_IMAGE, and if pStorageImage is not NULL, the pStorageImage->imageView member of data must be a VkImageView created on device, or VK_NULL_HANDLE\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (pDescriptorInfo->data.pStorageImage && (pDescriptorInfo->data.pStorageImage->imageView != VK_NULL_HANDLE) &&\n    skip |= LogError(\"VUID-VkDescriptorGetInfoEXT-type-08023\", device, descriptor_info_loc.dot(Field::type),\n                     \"is VK_DESCRIPTOR_TYPE_SAMPLED_IMAGE, but \"\n                     \"pStorageImage->imageView is not a valid image view.\");\n"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkDescriptorGetInfoEXT-type-08024\", \"If type is VK_DESCRIPTOR_TYPE_UNIFORM_TEXEL_BUFFER, pUniformTexelBuffer is not NULL and pUniformTexelBuffer->address is not zero, pUniformTexelBuffer->address must be an address within a VkBuffer created on device\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (address_info && (address_info->address != 0) && (GetBuffersByAddress(address_info->address).empty())) {\n    skip |= LogError(\"VUID-VkDescriptorGetInfoEXT-type-08024\", device, descriptor_info_loc.dot(Field::type),\n                     \"is VK_DESCRIPTOR_TYPE_UNIFORM_TEXEL_BUFFER, but \"\n                     \"pUniformTexelBuffer->address (%\" PRIu64\n                     \") is not zero or \"\n                     \"an address within a buffer.\",\n                     address_info->address);\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkDescriptorGetInfoEXT-type-08026\", \"If type is VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER, pUniformBuffer is not NULL and pUniformBuffer->address is not zero, pUniformBuffer->address must be an address within a VkBuffer created on device\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (address_info && (address_info->address != 0) && (GetBuffersByAddress(address_info->address).empty())) {\n    skip |= LogError(\"VUID-VkDescriptorGetInfoEXT-type-08026\", device, descriptor_info_loc.dot(Field::type),\n                     \"is VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER, but \"\n                     \"pUniformBuffer->address (%\" PRIu64\n                     \") is not zero or \"\n                     \"an address within a buffer.\",\n                     address_info->address);\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkDescriptorGetInfoEXT-type-08027\", \"If type is VK_DESCRIPTOR_TYPE_STORAGE_BUFFER, pStorageBuffer is not NULL and pStorageBuffer->address is not zero, pStorageBuffer->address must be an address within a VkBuffer created on device\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (address_info && (address_info->address != 0) && (GetBuffersByAddress(address_info->address).empty())) {\n    skip |= LogError(\"VUID-VkDescriptorGetInfoEXT-type-08027\", device, descriptor_info_loc.dot(Field::type),\n                     \"is VK_DESCRIPTOR_TYPE_STORAGE_BUFFER, but \"\n                     \"pStorageBuffer->address (%\" PRIu64\n                     \") is not zero or \"\n                     \"an address within a buffer.\",\n                     address_info->address);\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkDescriptorGetInfoEXT-type-08029\", \"If type is VK_DESCRIPTOR_TYPE_ACCELERATION_STRUCTURE_NV and accelerationStructure is not 0, accelerationStructure must contain the handle of a VkAccelerationStructureNV created on device, returned by vkGetAccelerationStructureHandleNV\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (!as_state) {\n    skip |= LogError(\"VUID-VkDescriptorGetInfoEXT-type-08029\", device, descriptor_info_loc.dot(Field::type),\n                     \"is VK_DESCRIPTOR_TYPE_ACCELERATION_STRUCTURE_NV and accelerationStructure is not 0, \"\n                     \"accelerationStructure must contain the handle of a VkAccelerationStructureNV created on \"\n                     \"device, returned by vkGetAccelerationStructureHandleNV\");\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkDescriptorDataEXT-type-08039\", \"If VkDescriptorGetInfoEXT:type is VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER, and the nullDescriptor feature is not enabled, pUniformBuffer must not be NULL\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (!address_info && !enabled_features.nullDescriptor) {\n    skip |= LogError(\"VUID-VkDescriptorDataEXT-type-08039\", device, descriptor_info_loc.dot(Field::type),\n                     \"is VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER, but \"\n                     \"pUniformBuffer is NULL and the nullDescriptor feature was not enabled.\");\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkDescriptorDataEXT-type-08037\", \"If VkDescriptorGetInfoEXT:type is VK_DESCRIPTOR_TYPE_UNIFORM_TEXEL_BUFFER, and the nullDescriptor feature is not enabled, pUniformTexelBuffer must not be NULL\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (!address_info && !enabled_features.nullDescriptor) {\n    skip |= LogError(\"VUID-VkDescriptorDataEXT-type-08037\", device, descriptor_info_loc.dot(Field::type),\n                     \"is VK_DESCRIPTOR_TYPE_UNIFORM_TEXEL_BUFFER, but \"\n                     \"pUniformTexelBuffer is NULL and the nullDescriptor feature was not enabled.\");\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkDescriptorDataEXT-type-08038\", \"If VkDescriptorGetInfoEXT:type is VK_DESCRIPTOR_TYPE_STORAGE_TEXEL_BUFFER, and the nullDescriptor feature is not enabled, pStorageTexelBuffer must not be NULL\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (!address_info && !enabled_features.nullDescriptor) {\n    skip |= LogError(\"VUID-VkDescriptorDataEXT-type-08038\", device, descriptor_info_loc.dot(Field::type),\n                     \"is VK_DESCRIPTOR_TYPE_STORAGE_TEXEL_BUFFER, but \"\n                     \"pStorageTexelBuffer is NULL and the nullDescriptor feature was not enabled.\");\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkDescriptorDataEXT-type-08041\", \"If VkDescriptorGetInfoEXT:type is VK_DESCRIPTOR_TYPE_ACCELERATION_STRUCTURE_KHR, and the nullDescriptor feature is not enabled, accelerationStructure must not be 0\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if ((pDescriptorInfo->data.accelerationStructure == 0) && !enabled_features.nullDescriptor) {\n    skip |= LogError(\"VUID-VkDescriptorDataEXT-type-08041\", device, descriptor_info_loc.dot(Field::type),\n                     \"is VK_DESCRIPTOR_TYPE_ACCELERATION_STRUCTURE_KHR, but \"\n                     \"accelerationStructure is 0 and the nullDescriptor feature was not enabled.\");\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkDescriptorDataEXT-type-08042\", \"If VkDescriptorGetInfoEXT:type is VK_DESCRIPTOR_TYPE_ACCELERATION_STRUCTURE_NV, and the nullDescriptor feature is not enabled, accelerationStructure must not be 0\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if ((pDescriptorInfo->data.accelerationStructure == 0) && !enabled_features.nullDescriptor) {\n    skip |= LogError(\"VUID-VkDescriptorDataEXT-type-08042\", device, descriptor_info_loc.dot(Field::type),\n                     \"is VK_DESCRIPTOR_TYPE_ACCELERATION_STRUCTURE_NV, but \"\n                     \"accelerationStructure is 0 and the nullDescriptor feature was not enabled.\");\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkDescriptorDataEXT-type-08036\", \"If VkDescriptorGetInfoEXT:type is VK_DESCRIPTOR_TYPE_STORAGE_IMAGE, and the nullDescriptor feature is not enabled, pStorageImage must not be NULL and pStorageImage->imageView must not be VK_NULL_HANDLE\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (!enabled_features.nullDescriptor &&\n    skip |= LogError(\"VUID-VkDescriptorDataEXT-type-08036\", device, descriptor_info_loc.dot(Field::type),\n                     \"is VK_DESCRIPTOR_TYPE_STORAGE_IMAGE, but \"\n                     \"pStorageImage is NULL, or pStorageImage->imageView is VK_NULL_HANDLE, and the nullDescriptor \"\n                     \"feature is not enabled.\");\n"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkDescriptorSetAllocateInfo-pSetLayouts-00308\", \"Each element of pSetLayouts must not have been created with VK_DESCRIPTOR_SET_LAYOUT_CREATE_PUSH_DESCRIPTOR_BIT_KHR set\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (ds_layout_state->IsPushDescriptor()) {\n    skip |= LogError(\"VUID-VkDescriptorSetAllocateInfo-pSetLayouts-00308\", pAllocateInfo->pSetLayouts[i], set_layout_loc,\n                     \"(%s) was created with VK_DESCRIPTOR_SET_LAYOUT_CREATE_PUSH_DESCRIPTOR_BIT_KHR.\",\n                     FormatHandle(pAllocateInfo->pSetLayouts[i]).c_str());\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkDescriptorSetAllocateInfo-pSetLayouts-08009\", \"Each element of pSetLayouts must not have been created with the VK_DESCRIPTOR_SET_LAYOUT_CREATE_DESCRIPTOR_BUFFER_BIT_EXT bit set\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (ds_layout_state->GetCreateFlags() & VK_DESCRIPTOR_SET_LAYOUT_CREATE_DESCRIPTOR_BUFFER_BIT_EXT) {\n    skip |= LogError(\"VUID-VkDescriptorSetAllocateInfo-pSetLayouts-08009\", pAllocateInfo->pSetLayouts[i], set_layout_loc,\n                     \"(%s) was created with VK_DESCRIPTOR_SET_LAYOUT_CREATE_DESCRIPTOR_BUFFER_BIT_EXT.\",\n                     FormatHandle(pAllocateInfo->pSetLayouts[i]).c_str());\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkDescriptorSetAllocateInfo-pSetLayouts-03044\", \"If any element of pSetLayouts was created with the VK_DESCRIPTOR_SET_LAYOUT_CREATE_UPDATE_AFTER_BIND_POOL_BIT bit set, descriptorPool must have been created with the VK_DESCRIPTOR_POOL_CREATE_UPDATE_AFTER_BIND_BIT flag set\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (ds_layout_state->GetCreateFlags() & VK_DESCRIPTOR_SET_LAYOUT_CREATE_UPDATE_AFTER_BIND_POOL_BIT &&\n    const LogObjectList objlist(pAllocateInfo->descriptorPool, pAllocateInfo->pSetLayouts[i]);\n    skip |= LogError(\"VUID-VkDescriptorSetAllocateInfo-pSetLayouts-03044\", objlist, set_layout_loc,\n                     \"was created with %s but the descriptorPool was created with %s\",\n                     string_VkDescriptorSetLayoutCreateFlags(ds_layout_state->GetCreateFlags()).c_str(),\n                     string_VkDescriptorPoolCreateFlags(ds_pool_state->create_info.flags).c_str());\n"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkDescriptorSetAllocateInfo-apiVersion-07895\", \"If the VK_KHR_maintenance1 extension is not enabled and VkPhysicalDeviceProperties::apiVersion is less than Vulkan 1.1, descriptorSetCount must not be greater than the number of sets that are currently available for allocation in descriptorPool\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (ds_pool_state->GetAvailableSets() < pAllocateInfo->descriptorSetCount) {\n    skip |= LogError(\"VUID-VkDescriptorSetAllocateInfo-apiVersion-07895\", ds_pool_state->Handle(), error_obj.location,\n                     \"Unable to allocate %\" PRIu32\n                     \" descriptorSets from %s\"\n                     \". This pool only has %\" PRIu32 \" descriptorSets remaining.\",\n                     pAllocateInfo->descriptorSetCount, FormatHandle(*ds_pool_state).c_str(),\n                     ds_pool_state->GetAvailableSets());\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkDescriptorSetAllocateInfo-apiVersion-07896\", \"If the VK_KHR_maintenance1 extension is not enabled and VkPhysicalDeviceProperties::apiVersion is less than Vulkan 1.1, descriptorPool must have enough free descriptor capacity remaining to allocate the descriptor sets of the specified layouts\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (ds_data.required_descriptors_by_type.at(it->first) > available_count) {\n    skip |= LogError(\"VUID-VkDescriptorSetAllocateInfo-apiVersion-07896\", ds_pool_state->Handle(), error_obj.location,\n                     \"Unable to allocate %\" PRIu32\n                     \" descriptors of type %s from %s\"\n                     \". This pool only has %\" PRIu32 \" descriptors of this type remaining.\",\n                     ds_data.required_descriptors_by_type.at(it->first),\n                     string_VkDescriptorType(VkDescriptorType(it->first)), FormatHandle(*ds_pool_state).c_str(),\n                     available_count);\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkDescriptorSetAllocateInfo-pSetLayouts-09380\", \"If pSetLayouts[i] was created with an element of pBindingFlags that includes VK_DESCRIPTOR_BINDING_VARIABLE_DESCRIPTOR_COUNT_BIT, and VkDescriptorSetVariableDescriptorCountAllocateInfo is included in the pNext chain, and VkDescriptorSetVariableDescriptorCountAllocateInfo::descriptorSetCount is not zero, then VkDescriptorSetVariableDescriptorCountAllocateInfo::pDescriptorCounts[i] must be less than or equal to VkDescriptorSetLayoutBinding::descriptorCount for the corresponding binding used to create pSetLayouts[i]\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (count_allocate_info->pDescriptorCounts[i] >\n    skip |= LogError(\"VUID-VkDescriptorSetAllocateInfo-pSetLayouts-09380\", device,\n                     allocate_info_loc.pNext(Struct::VkDescriptorSetVariableDescriptorCountAllocateInfo,\n                                             Field::pDescriptorCounts, i),\n                     \"is %\" PRIu32 \", but pAllocateInfo->pSetLayouts[%\" PRIu32\n                     \"] binding's descriptorCount = (%\" PRIu32 \")\",\n                     count_allocate_info->pDescriptorCounts[i], i,\n                     ds_layout_state->GetDescriptorCountFromBinding(ds_layout_state->GetMaxBinding()));\n"
        },
        {
            "role": "user",
            "content": "{\"VUID-vkFreeDescriptorSets-pDescriptorSets-00309\", \"All submitted commands that refer to any element of pDescriptorSets must have completed execution\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (auto set_node = Get<vvl::DescriptorSet>(set)) {\n    skip |= ValidateObjectNotInUse(set_node.get(), loc, \"VUID-vkFreeDescriptorSets-pDescriptorSets-00309\");\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkDescriptorUpdateTemplateCreateInfo-templateType-00350\", \"If templateType is VK_DESCRIPTOR_UPDATE_TEMPLATE_TYPE_DESCRIPTOR_SET, descriptorSetLayout must be a valid VkDescriptorSetLayout handle\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (VK_DESCRIPTOR_UPDATE_TEMPLATE_TYPE_DESCRIPTOR_SET == pCreateInfo->templateType && !ds_layout_state) {\n    skip |= LogError(\"VUID-VkDescriptorUpdateTemplateCreateInfo-templateType-00350\", pCreateInfo->descriptorSetLayout,\n                     create_info_loc.dot(Field::descriptorSetLayout), \"(%s) is invalid.\",\n                     FormatHandle(pCreateInfo->descriptorSetLayout).c_str());\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkDescriptorUpdateTemplateCreateInfo-templateType-00351\", \"If templateType is VK_DESCRIPTOR_UPDATE_TEMPLATE_TYPE_PUSH_DESCRIPTORS_KHR, pipelineBindPoint must be a valid VkPipelineBindPoint value\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (!valid_bp) {\n    skip |= LogError(\"VUID-VkDescriptorUpdateTemplateCreateInfo-templateType-00351\", device,\n                     create_info_loc.dot(Field::pipelineBindPoint), \"is %s.\", string_VkPipelineBindPoint(bind_point));\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkDescriptorUpdateTemplateCreateInfo-templateType-00352\", \"If templateType is VK_DESCRIPTOR_UPDATE_TEMPLATE_TYPE_PUSH_DESCRIPTORS_KHR, pipelineLayout must be a valid VkPipelineLayout handle\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (!pipeline_layout) {\n    skip |= LogError(\"VUID-VkDescriptorUpdateTemplateCreateInfo-templateType-00352\", pCreateInfo->pipelineLayout,\n                     create_info_loc.dot(Field::pipelineLayout), \"(%s) is invalid.\",\n                     FormatHandle(pCreateInfo->pipelineLayout).c_str());\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkDescriptorUpdateTemplateEntry-descriptor-02226\", \"If descriptor type is VK_DESCRIPTOR_TYPE_INLINE_UNIFORM_BLOCK, dstArrayElement must be an integer multiple of 4\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (descriptor_update.dstArrayElement & 3) {\n    skip |= LogError(\"VUID-VkDescriptorUpdateTemplateEntry-descriptor-02226\", pCreateInfo->pipelineLayout,\n                     create_info_loc.dot(Field::pDescriptorUpdateEntries, i),\n                     \"has descriptorType VK_DESCRIPTOR_TYPE_INLINE_UNIFORM_BLOCK_EXT, but dstArrayElement (%\" PRIu32\n                     \") is not a \"\n                     \"multiple of 4).\",\n                     descriptor_update.dstArrayElement);\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkPipelineLayoutCreateInfo-pSetLayouts-00293\", \"pSetLayouts must not contain more than one descriptor set layout that was created with VK_DESCRIPTOR_SET_LAYOUT_CREATE_PUSH_DESCRIPTOR_BIT_KHR set\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (push_descriptor_set_found < pCreateInfo->setLayoutCount) {\n    skip |= LogError(\"VUID-VkPipelineLayoutCreateInfo-pSetLayouts-00293\", set_layouts[i]->VkHandle(),\n                     create_info_loc.dot(Field::pSetLayouts, i),\n                     \"and pSetLayouts[%\" PRIu32 \"] both have push descriptor sets.\", push_descriptor_set_found);\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkPipelineLayoutCreateInfo-pSetLayouts-04606\", \"Any element of pSetLayouts must not have been created with the VK_DESCRIPTOR_SET_LAYOUT_CREATE_HOST_ONLY_POOL_BIT_EXT bit set\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (set_layouts[i]->GetCreateFlags() & VK_DESCRIPTOR_SET_LAYOUT_CREATE_HOST_ONLY_POOL_BIT_EXT) {\n    skip |= LogError(\"VUID-VkPipelineLayoutCreateInfo-pSetLayouts-04606\", set_layouts[i]->VkHandle(),\n                     create_info_loc.dot(Field::pSetLayouts, i),\n                     \"was created with VK_DESCRIPTOR_SET_LAYOUT_CREATE_HOST_ONLY_POOL_BIT_EXT bit.\");\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkPipelineLayoutCreateInfo-pSetLayouts-08008\", \"If any element of pSetLayouts was created with the VK_DESCRIPTOR_SET_LAYOUT_CREATE_DESCRIPTOR_BUFFER_BIT_EXT bit set, all elements of pSetLayouts must have been created with the VK_DESCRIPTOR_SET_LAYOUT_CREATE_DESCRIPTOR_BUFFER_BIT_EXT bit set\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if ((descriptor_buffer_set_count != 0) && (valid_set_count != descriptor_buffer_set_count)) {\n    skip |= LogError(\"VUID-VkPipelineLayoutCreateInfo-pSetLayouts-08008\", device, error_obj.location,\n                     \"All sets must be created with \"\n                     \"VK_DESCRIPTOR_SET_LAYOUT_CREATE_DESCRIPTOR_BUFFER_BIT_EXT or none of them.\");\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkPipelineLayoutCreateInfo-descriptorType-03016\", \"The total number of descriptors in descriptor set layouts created without the VK_DESCRIPTOR_SET_LAYOUT_CREATE_UPDATE_AFTER_BIND_POOL_BIT bit set with a descriptorType of VK_DESCRIPTOR_TYPE_SAMPLER and VK_DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER accessible to any given shader stage across all elements of pSetLayouts must be less than or equal to VkPhysicalDeviceLimits::maxPerStageDescriptorSamplers\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (max_descriptors_per_stage[DSL_TYPE_SAMPLERS] > phys_dev_props.limits.maxPerStageDescriptorSamplers) {\n    skip |= LogError(\"VUID-VkPipelineLayoutCreateInfo-descriptorType-03016\", device, error_obj.location,\n                     \"max per-stage sampler bindings count (%\" PRIu32\n                     \") exceeds device \"\n                     \"maxPerStageDescriptorSamplers limit (%\" PRIu32 \").\",\n                     max_descriptors_per_stage[DSL_TYPE_SAMPLERS], phys_dev_props.limits.maxPerStageDescriptorSamplers);\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkPipelineLayoutCreateInfo-descriptorType-03018\", \"The total number of descriptors in descriptor set layouts created without the VK_DESCRIPTOR_SET_LAYOUT_CREATE_UPDATE_AFTER_BIND_POOL_BIT bit set with a descriptorType of VK_DESCRIPTOR_TYPE_STORAGE_BUFFER and VK_DESCRIPTOR_TYPE_STORAGE_BUFFER_DYNAMIC accessible to any given shader stage across all elements of pSetLayouts must be less than or equal to VkPhysicalDeviceLimits::maxPerStageDescriptorStorageBuffers\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (max_descriptors_per_stage[DSL_TYPE_STORAGE_BUFFERS] > phys_dev_props.limits.maxPerStageDescriptorStorageBuffers) {\n    skip |= LogError(\"VUID-VkPipelineLayoutCreateInfo-descriptorType-03018\", device, error_obj.location,\n                     \"max per-stage storage buffer bindings count (%\" PRIu32\n                     \") exceeds device \"\n                     \"maxPerStageDescriptorStorageBuffers limit (%\" PRIu32 \").\",\n                     max_descriptors_per_stage[DSL_TYPE_STORAGE_BUFFERS],\n                     phys_dev_props.limits.maxPerStageDescriptorStorageBuffers);\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkPipelineLayoutCreateInfo-descriptorType-03021\", \"The total number of descriptors in descriptor set layouts created without the VK_DESCRIPTOR_SET_LAYOUT_CREATE_UPDATE_AFTER_BIND_POOL_BIT bit set with a descriptorType of VK_DESCRIPTOR_TYPE_INPUT_ATTACHMENT accessible to any given shader stage across all elements of pSetLayouts must be less than or equal to VkPhysicalDeviceLimits::maxPerStageDescriptorInputAttachments\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (max_descriptors_per_stage[DSL_TYPE_INPUT_ATTACHMENTS] > phys_dev_props.limits.maxPerStageDescriptorInputAttachments) {\n    skip |= LogError(\"VUID-VkPipelineLayoutCreateInfo-descriptorType-03021\", device, error_obj.location,\n                     \"max per-stage input attachment bindings count (%\" PRIu32\n                     \") exceeds device \"\n                     \"maxPerStageDescriptorInputAttachments limit (%\" PRIu32 \").\",\n                     max_descriptors_per_stage[DSL_TYPE_INPUT_ATTACHMENTS],\n                     phys_dev_props.limits.maxPerStageDescriptorInputAttachments);\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkPipelineLayoutCreateInfo-descriptorType-02214\", \"The total number of bindings in descriptor set layouts created without the VK_DESCRIPTOR_SET_LAYOUT_CREATE_UPDATE_AFTER_BIND_POOL_BIT bit set and with a descriptorType of VK_DESCRIPTOR_TYPE_INLINE_UNIFORM_BLOCK accessible to any given shader stage across all elements of pSetLayouts, must be less than or equal to VkPhysicalDeviceInlineUniformBlockProperties::maxPerStageDescriptorInlineUniformBlocks\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (max_descriptors_per_stage[DSL_TYPE_INLINE_UNIFORM_BLOCK] >\n    skip |= LogError(\"VUID-VkPipelineLayoutCreateInfo-descriptorType-02214\", device, error_obj.location,\n                     \"max per-stage inline uniform block bindings count (%\" PRIu32\n                     \") exceeds device \"\n                     \"maxPerStageDescriptorInlineUniformBlocks limit (%\" PRIu32 \").\",\n                     max_descriptors_per_stage[DSL_TYPE_INLINE_UNIFORM_BLOCK],\n                     phys_dev_ext_props.inline_uniform_block_props.maxPerStageDescriptorInlineUniformBlocks);\n"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkPipelineLayoutCreateInfo-descriptorType-03571\", \"The total number of bindings in descriptor set layouts created without the VK_DESCRIPTOR_SET_LAYOUT_CREATE_UPDATE_AFTER_BIND_POOL_BIT bit set with a descriptorType of VK_DESCRIPTOR_TYPE_ACCELERATION_STRUCTURE_KHR accessible to any given shader stage across all elements of pSetLayouts must be less than or equal to VkPhysicalDeviceAccelerationStructurePropertiesKHR::maxPerStageDescriptorAccelerationStructures\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (max_descriptors_per_stage[DSL_TYPE_ACCELERATION_STRUCTURE] >\n    skip |= LogError(\"VUID-VkPipelineLayoutCreateInfo-descriptorType-03571\", device, error_obj.location,\n                     \"max per-stage acceleration structure bindings count (%\" PRIu32\n                     \") exceeds device \"\n                     \"maxPerStageDescriptorAccelerationStructures limit (%\" PRIu32 \").\",\n                     max_descriptors_per_stage[DSL_TYPE_ACCELERATION_STRUCTURE],\n                     phys_dev_ext_props.acc_structure_props.maxPerStageDescriptorAccelerationStructures);\n"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkPipelineLayoutCreateInfo-descriptorType-03029\", \"The total number of descriptors in descriptor set layouts created without the VK_DESCRIPTOR_SET_LAYOUT_CREATE_UPDATE_AFTER_BIND_POOL_BIT bit set with a descriptorType of VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER accessible across all shader stages and across all elements of pSetLayouts must be less than or equal to VkPhysicalDeviceLimits::maxDescriptorSetUniformBuffers\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (sum_all_stages[VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER] > phys_dev_props.limits.maxDescriptorSetUniformBuffers) {\n    skip |= LogError(\"VUID-VkPipelineLayoutCreateInfo-descriptorType-03029\", device, error_obj.location,\n                     \"sum of uniform buffer bindings among all stages (%\" PRIu32\n                     \") exceeds device \"\n                     \"maxDescriptorSetUniformBuffers limit (%\" PRIu32 \").\",\n                     sum_all_stages[VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER], phys_dev_props.limits.maxDescriptorSetUniformBuffers);\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkPipelineLayoutCreateInfo-descriptorType-03031\", \"The total number of descriptors in descriptor set layouts created without the VK_DESCRIPTOR_SET_LAYOUT_CREATE_UPDATE_AFTER_BIND_POOL_BIT bit set with a descriptorType of VK_DESCRIPTOR_TYPE_STORAGE_BUFFER accessible across all shader stages and across all elements of pSetLayouts must be less than or equal to VkPhysicalDeviceLimits::maxDescriptorSetStorageBuffers\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (sum_all_stages[VK_DESCRIPTOR_TYPE_STORAGE_BUFFER] > phys_dev_props.limits.maxDescriptorSetStorageBuffers) {\n    skip |= LogError(\"VUID-VkPipelineLayoutCreateInfo-descriptorType-03031\", device, error_obj.location,\n                     \"sum of storage buffer bindings among all stages (%\" PRIu32\n                     \") exceeds device \"\n                     \"maxDescriptorSetStorageBuffers limit (%\" PRIu32 \").\",\n                     sum_all_stages[VK_DESCRIPTOR_TYPE_STORAGE_BUFFER], phys_dev_props.limits.maxDescriptorSetStorageBuffers);\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkPipelineLayoutCreateInfo-maintenance7-10003\", \"If the maintenance7 feature is enabled, the total number of descriptors in descriptor set layouts created without the VK_DESCRIPTOR_SET_LAYOUT_CREATE_UPDATE_AFTER_BIND_POOL_BIT bit set with a descriptorType of VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER_DYNAMIC accessible across all shader stages and across all elements of pSetLayouts must be less than or equal to VkPhysicalDeviceMaintenance7PropertiesKHR::maxDescriptorSetTotalUniformBuffersDynamic\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (sum_all_uniform_buffer_dynamic > phys_dev_ext_props.maintenance7_props.maxDescriptorSetTotalUniformBuffersDynamic) {\n    skip |= LogError(\"VUID-VkPipelineLayoutCreateInfo-maintenance7-10003\", device, error_obj.location,\n                     \"sum of dynamic uniform buffer bindings among all stages (%\" PRIu32\n                     \") exceeds device \"\n                     \"maxDescriptorSetTotalUniformBuffersDynamic limit (%\" PRIu32 \").\",\n                     sum_all_uniform_buffer_dynamic,\n                     phys_dev_ext_props.maintenance7_props.maxDescriptorSetTotalUniformBuffersDynamic);\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkPipelineLayoutCreateInfo-maintenance7-10004\", \"If the maintenance7 feature is enabled, the total number of descriptors in descriptor set layouts created without the VK_DESCRIPTOR_SET_LAYOUT_CREATE_UPDATE_AFTER_BIND_POOL_BIT bit set with a descriptorType of VK_DESCRIPTOR_TYPE_STORAGE_BUFFER_DYNAMIC accessible across all shader stages and across all elements of pSetLayouts must be less than or equal to VkPhysicalDeviceMaintenance7PropertiesKHR::maxDescriptorSetTotalStorageBuffersDynamic\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (sum_all_storage_buffer_dynamic > phys_dev_ext_props.maintenance7_props.maxDescriptorSetTotalStorageBuffersDynamic) {\n    skip |= LogError(\"VUID-VkPipelineLayoutCreateInfo-maintenance7-10004\", device, error_obj.location,\n                     \"sum of dynamic storage buffer bindings among all stages (%\" PRIu32\n                     \") exceeds device \"\n                     \"maxDescriptorSetTotalStorageBuffersDynamic limit (%\" PRIu32 \").\",\n                     sum_all_storage_buffer_dynamic,\n                     phys_dev_ext_props.maintenance7_props.maxDescriptorSetTotalStorageBuffersDynamic);\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkPipelineLayoutCreateInfo-descriptorType-03030\", \"If the maintenance7 feature is not enabled, the total number of descriptors in descriptor set layouts created without the VK_DESCRIPTOR_SET_LAYOUT_CREATE_UPDATE_AFTER_BIND_POOL_BIT bit set with a descriptorType of VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER_DYNAMIC accessible across all shader stages and across all elements of pSetLayouts must be less than or equal to VkPhysicalDeviceLimits::maxDescriptorSetUniformBuffersDynamic\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (sum_all_uniform_buffer_dynamic > phys_dev_props.limits.maxDescriptorSetUniformBuffersDynamic) {\n    skip |= LogError(\"VUID-VkPipelineLayoutCreateInfo-descriptorType-03030\", device, error_obj.location,\n                     \"sum of dynamic uniform buffer bindings among all stages (%\" PRIu32\n                     \") exceeds device \"\n                     \"maxDescriptorSetUniformBuffersDynamic limit (%\" PRIu32 \").\",\n                     sum_all_uniform_buffer_dynamic, phys_dev_props.limits.maxDescriptorSetUniformBuffersDynamic);\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkPipelineLayoutCreateInfo-descriptorType-03032\", \"If the maintenance7 feature is not enabled, the total number of descriptors in descriptor set layouts created without the VK_DESCRIPTOR_SET_LAYOUT_CREATE_UPDATE_AFTER_BIND_POOL_BIT bit set with a descriptorType of VK_DESCRIPTOR_TYPE_STORAGE_BUFFER_DYNAMIC accessible across all shader stages and across all elements of pSetLayouts must be less than or equal to VkPhysicalDeviceLimits::maxDescriptorSetStorageBuffersDynamic\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (sum_all_storage_buffer_dynamic > phys_dev_props.limits.maxDescriptorSetStorageBuffersDynamic) {\n    skip |= LogError(\"VUID-VkPipelineLayoutCreateInfo-descriptorType-03032\", device, error_obj.location,\n                     \"sum of dynamic storage buffer bindings among all stages (%\" PRIu32\n                     \") exceeds device \"\n                     \"maxDescriptorSetStorageBuffersDynamic limit (%\" PRIu32 \").\",\n                     sum_all_storage_buffer_dynamic, phys_dev_props.limits.maxDescriptorSetStorageBuffersDynamic);\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkPipelineLayoutCreateInfo-descriptorType-03033\", \"The total number of descriptors in descriptor set layouts created without the VK_DESCRIPTOR_SET_LAYOUT_CREATE_UPDATE_AFTER_BIND_POOL_BIT bit set with a descriptorType of VK_DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER, VK_DESCRIPTOR_TYPE_SAMPLED_IMAGE, and VK_DESCRIPTOR_TYPE_UNIFORM_TEXEL_BUFFER accessible across all shader stages and across all elements of pSetLayouts must be less than or equal to VkPhysicalDeviceLimits::maxDescriptorSetSampledImages\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (sum > phys_dev_props.limits.maxDescriptorSetSampledImages) {\n    skip |= LogError(\"VUID-VkPipelineLayoutCreateInfo-descriptorType-03033\", device, error_obj.location,\n                     \"sum of sampled image bindings among all stages (%\" PRIu32\n                     \") exceeds device \"\n                     \"maxDescriptorSetSampledImages limit (%\" PRIu32 \").\",\n                     sum, phys_dev_props.limits.maxDescriptorSetSampledImages);\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkPipelineLayoutCreateInfo-descriptorType-03034\", \"The total number of descriptors in descriptor set layouts created without the VK_DESCRIPTOR_SET_LAYOUT_CREATE_UPDATE_AFTER_BIND_POOL_BIT bit set with a descriptorType of VK_DESCRIPTOR_TYPE_STORAGE_IMAGE, and VK_DESCRIPTOR_TYPE_STORAGE_TEXEL_BUFFER accessible across all shader stages and across all elements of pSetLayouts must be less than or equal to VkPhysicalDeviceLimits::maxDescriptorSetStorageImages\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (sum > phys_dev_props.limits.maxDescriptorSetStorageImages) {\n    skip |= LogError(\"VUID-VkPipelineLayoutCreateInfo-descriptorType-03034\", device, error_obj.location,\n                     \"sum of storage image bindings among all stages (%\" PRIu32\n                     \") exceeds device \"\n                     \"maxDescriptorSetStorageImages limit (%\" PRIu32 \").\",\n                     sum, phys_dev_props.limits.maxDescriptorSetStorageImages);\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkPipelineLayoutCreateInfo-descriptorType-03573\", \"The total number of bindings in descriptor set layouts created without the VK_DESCRIPTOR_SET_LAYOUT_CREATE_UPDATE_AFTER_BIND_POOL_BIT bit set with a descriptorType of VK_DESCRIPTOR_TYPE_ACCELERATION_STRUCTURE_KHR accessible across all shader stages and across all elements of pSetLayouts must be less than or equal to VkPhysicalDeviceAccelerationStructurePropertiesKHR::maxDescriptorSetAccelerationStructures\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (sum_all_stages[VK_DESCRIPTOR_TYPE_ACCELERATION_STRUCTURE_KHR] >\n    skip |= LogError(\"VUID-VkPipelineLayoutCreateInfo-descriptorType-03573\", device, error_obj.location,\n                     \"sum of acceleration structures bindings among all stages (%\" PRIu32\n                     \") exceeds device \"\n                     \"maxDescriptorSetAccelerationStructures limit (%\" PRIu32 \").\",\n                     sum_all_stages[VK_DESCRIPTOR_TYPE_ACCELERATION_STRUCTURE_KHR],\n                     phys_dev_ext_props.acc_structure_props.maxDescriptorSetAccelerationStructures);\n"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkPipelineLayoutCreateInfo-descriptorType-02381\", \"The total number of bindings with a descriptorType of VK_DESCRIPTOR_TYPE_ACCELERATION_STRUCTURE_NV accessible across all shader stages and across all elements of pSetLayouts must be less than or equal to VkPhysicalDeviceRayTracingPropertiesNV::maxDescriptorSetAccelerationStructures\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (sum_all_stages[VK_DESCRIPTOR_TYPE_ACCELERATION_STRUCTURE_NV] >\n    skip |= LogError(\"VUID-VkPipelineLayoutCreateInfo-descriptorType-02381\", device, error_obj.location,\n                     \"sum of acceleration structures NV bindings among all stages (%\" PRIu32\n                     \") exceeds device \"\n                     \"VkPhysicalDeviceRayTracingPropertiesNV::maxDescriptorSetAccelerationStructures limit (%\" PRIu32 \").\",\n                     sum_all_stages[VK_DESCRIPTOR_TYPE_ACCELERATION_STRUCTURE_NV],\n                     phys_dev_ext_props.ray_tracing_props_nv.maxDescriptorSetAccelerationStructures);\n"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkPipelineLayoutCreateInfo-descriptorType-03022\", \"The total number of descriptors with a descriptorType of VK_DESCRIPTOR_TYPE_SAMPLER and VK_DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER accessible to any given shader stage across all elements of pSetLayouts must be less than or equal to VkPhysicalDeviceDescriptorIndexingProperties::maxPerStageDescriptorUpdateAfterBindSamplers\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (max_descriptors_per_stage_update_after_bind[DSL_TYPE_SAMPLERS] >\n    skip |= LogError(\"VUID-VkPipelineLayoutCreateInfo-descriptorType-03022\", device, error_obj.location,\n                     \"max per-stage sampler bindings count (%\" PRIu32\n                     \") exceeds device \"\n                     \"maxPerStageDescriptorUpdateAfterBindSamplers limit (%\" PRIu32 \").\",\n                     max_descriptors_per_stage_update_after_bind[DSL_TYPE_SAMPLERS],\n                     phys_dev_props_core12.maxPerStageDescriptorUpdateAfterBindSamplers);\n"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkPipelineLayoutCreateInfo-descriptorType-03023\", \"The total number of descriptors with a descriptorType of VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER and VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER_DYNAMIC accessible to any given shader stage across all elements of pSetLayouts must be less than or equal to VkPhysicalDeviceDescriptorIndexingProperties::maxPerStageDescriptorUpdateAfterBindUniformBuffers\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (max_descriptors_per_stage_update_after_bind[DSL_TYPE_UNIFORM_BUFFERS] >\n    skip |= LogError(\"VUID-VkPipelineLayoutCreateInfo-descriptorType-03023\", device, error_obj.location,\n                     \"max per-stage uniform buffer bindings count (%\" PRIu32\n                     \") exceeds device \"\n                     \"maxPerStageDescriptorUpdateAfterBindUniformBuffers limit (%\" PRIu32 \").\",\n                     max_descriptors_per_stage_update_after_bind[DSL_TYPE_UNIFORM_BUFFERS],\n                     phys_dev_props_core12.maxPerStageDescriptorUpdateAfterBindUniformBuffers);\n"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkPipelineLayoutCreateInfo-descriptorType-03025\", \"The total number of descriptors with a descriptorType of VK_DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER, VK_DESCRIPTOR_TYPE_SAMPLED_IMAGE, and VK_DESCRIPTOR_TYPE_UNIFORM_TEXEL_BUFFER accessible to any given shader stage across all elements of pSetLayouts must be less than or equal to VkPhysicalDeviceDescriptorIndexingProperties::maxPerStageDescriptorUpdateAfterBindSampledImages\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (max_descriptors_per_stage_update_after_bind[DSL_TYPE_SAMPLED_IMAGES] >\n    skip |= LogError(\"VUID-VkPipelineLayoutCreateInfo-descriptorType-03025\", device, error_obj.location,\n                     \"max per-stage sampled image bindings count (%\" PRIu32\n                     \") exceeds device \"\n                     \"maxPerStageDescriptorUpdateAfterBindSampledImages limit (%\" PRIu32 \").\",\n                     max_descriptors_per_stage_update_after_bind[DSL_TYPE_SAMPLED_IMAGES],\n                     phys_dev_props_core12.maxPerStageDescriptorUpdateAfterBindSampledImages);\n"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkPipelineLayoutCreateInfo-descriptorType-03026\", \"The total number of descriptors with a descriptorType of VK_DESCRIPTOR_TYPE_STORAGE_IMAGE, and VK_DESCRIPTOR_TYPE_STORAGE_TEXEL_BUFFER accessible to any given shader stage across all elements of pSetLayouts must be less than or equal to VkPhysicalDeviceDescriptorIndexingProperties::maxPerStageDescriptorUpdateAfterBindStorageImages\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (max_descriptors_per_stage_update_after_bind[DSL_TYPE_STORAGE_IMAGES] >\n    skip |= LogError(\"VUID-VkPipelineLayoutCreateInfo-descriptorType-03026\", device, error_obj.location,\n                     \"max per-stage storage image bindings count (%\" PRIu32\n                     \") exceeds device \"\n                     \"maxPerStageDescriptorUpdateAfterBindStorageImages limit (%\" PRIu32 \").\",\n                     max_descriptors_per_stage_update_after_bind[DSL_TYPE_STORAGE_IMAGES],\n                     phys_dev_props_core12.maxPerStageDescriptorUpdateAfterBindStorageImages);\n"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkPipelineLayoutCreateInfo-descriptorType-03027\", \"The total number of descriptors with a descriptorType of VK_DESCRIPTOR_TYPE_INPUT_ATTACHMENT accessible to any given shader stage across all elements of pSetLayouts must be less than or equal to VkPhysicalDeviceDescriptorIndexingProperties::maxPerStageDescriptorUpdateAfterBindInputAttachments\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (max_descriptors_per_stage_update_after_bind[DSL_TYPE_INPUT_ATTACHMENTS] >\n    skip |= LogError(\"VUID-VkPipelineLayoutCreateInfo-descriptorType-03027\", device, error_obj.location,\n                     \"max per-stage input attachment bindings count (%\" PRIu32\n                     \") exceeds device \"\n                     \"maxPerStageDescriptorUpdateAfterBindInputAttachments limit (%\" PRIu32 \").\",\n                     max_descriptors_per_stage_update_after_bind[DSL_TYPE_INPUT_ATTACHMENTS],\n                     phys_dev_props_core12.maxPerStageDescriptorUpdateAfterBindInputAttachments);\n"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkPipelineLayoutCreateInfo-descriptorType-02215\", \"The total number of bindings with a descriptorType of VK_DESCRIPTOR_TYPE_INLINE_UNIFORM_BLOCK accessible to any given shader stage across all elements of pSetLayouts must be less than or equal to VkPhysicalDeviceInlineUniformBlockProperties::maxPerStageDescriptorUpdateAfterBindInlineUniformBlocks\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (max_descriptors_per_stage_update_after_bind[DSL_TYPE_INLINE_UNIFORM_BLOCK] >\n    skip |= LogError(\"VUID-VkPipelineLayoutCreateInfo-descriptorType-02215\", device, error_obj.location,\n                     \"max per-stage inline uniform block bindings count (%\" PRIu32\n                     \") exceeds device \"\n                     \"maxPerStageDescriptorUpdateAfterBindInlineUniformBlocks limit (%\" PRIu32 \").\",\n                     max_descriptors_per_stage_update_after_bind[DSL_TYPE_INLINE_UNIFORM_BLOCK],\n                     phys_dev_ext_props.inline_uniform_block_props.maxPerStageDescriptorUpdateAfterBindInlineUniformBlocks);\n"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkPipelineLayoutCreateInfo-pSetLayouts-03036\", \"The total number of descriptors of the type VK_DESCRIPTOR_TYPE_SAMPLER and VK_DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER accessible across all shader stages and across all elements of pSetLayouts must be less than or equal to VkPhysicalDeviceDescriptorIndexingProperties::maxDescriptorSetUpdateAfterBindSamplers\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (sum > phys_dev_props_core12.maxDescriptorSetUpdateAfterBindSamplers) {\n    skip |= LogError(\"VUID-VkPipelineLayoutCreateInfo-pSetLayouts-03036\", device, error_obj.location,\n                     \"sum of sampler bindings among all stages (%\" PRIu32\n                     \") exceeds device \"\n                     \"maxDescriptorSetUpdateAfterBindSamplers limit (%\" PRIu32 \").\",\n                     sum, phys_dev_props_core12.maxDescriptorSetUpdateAfterBindSamplers);\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkPipelineLayoutCreateInfo-pSetLayouts-03037\", \"The total number of descriptors of the type VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER accessible across all shader stages and across all elements of pSetLayouts must be less than or equal to VkPhysicalDeviceDescriptorIndexingProperties::maxDescriptorSetUpdateAfterBindUniformBuffers\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (sum_all_stages_update_after_bind[VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER] >\n    skip |= LogError(\"VUID-VkPipelineLayoutCreateInfo-pSetLayouts-03037\", device, error_obj.location,\n                     \"sum of uniform buffer bindings among all stages (%\" PRIu32\n                     \") exceeds device \"\n                     \"maxDescriptorSetUpdateAfterBindUniformBuffers limit (%\" PRIu32 \").\",\n                     sum_all_stages_update_after_bind[VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER],\n                     phys_dev_props_core12.maxDescriptorSetUpdateAfterBindUniformBuffers);\n"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkPipelineLayoutCreateInfo-pSetLayouts-03039\", \"The total number of descriptors of the type VK_DESCRIPTOR_TYPE_STORAGE_BUFFER accessible across all shader stages and across all elements of pSetLayouts must be less than or equal to VkPhysicalDeviceDescriptorIndexingProperties::maxDescriptorSetUpdateAfterBindStorageBuffers\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (sum_all_stages_update_after_bind[VK_DESCRIPTOR_TYPE_STORAGE_BUFFER] >\n    skip |= LogError(\"VUID-VkPipelineLayoutCreateInfo-pSetLayouts-03039\", device, error_obj.location,\n                     \"sum of storage buffer bindings among all stages (%\" PRIu32\n                     \") exceeds device \"\n                     \"maxDescriptorSetUpdateAfterBindStorageBuffers limit (%\" PRIu32 \").\",\n                     sum_all_stages_update_after_bind[VK_DESCRIPTOR_TYPE_STORAGE_BUFFER],\n                     phys_dev_props_core12.maxDescriptorSetUpdateAfterBindStorageBuffers);\n"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkPipelineLayoutCreateInfo-maintenance7-10007\", \"If the maintenance7 feature is enabled, the total number of descriptors of the type VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER_DYNAMIC accessible across all shader stages and across all elements of pSetLayouts must be less than or equal to VkPhysicalDeviceMaintenance7PropertiesKHR::maxDescriptorSetUpdateAfterBindTotalUniformBuffersDynamic\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (sum_all_after_bind_uniform_buffer_dynamic >\n    skip |= LogError(\"VUID-VkPipelineLayoutCreateInfo-maintenance7-10007\", device, error_obj.location,\n                     \"sum of dynamic uniform buffer bindings among all stages (%\" PRIu32\n                     \") exceeds device \"\n                     \"maxDescriptorSetUpdateAfterBindTotalUniformBuffersDynamic limit (%\" PRIu32 \").\",\n                     sum_all_after_bind_uniform_buffer_dynamic,\n                     phys_dev_ext_props.maintenance7_props.maxDescriptorSetUpdateAfterBindTotalUniformBuffersDynamic);\n"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkPipelineLayoutCreateInfo-pSetLayouts-10006\", \"The total number of descriptors of the type VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER_DYNAMIC or VK_DESCRIPTOR_TYPE_STORAGE_BUFFER_DYNAMIC accessible across all shader stages and across all elements of pSetLayouts must be less than or equal to VkPhysicalDeviceMaintenance7PropertiesKHR::maxDescriptorSetUpdateAfterBindTotalBuffersDynamic\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (total_sum > phys_dev_ext_props.maintenance7_props.maxDescriptorSetUpdateAfterBindTotalBuffersDynamic) {\n    skip |= LogError(\"VUID-VkPipelineLayoutCreateInfo-pSetLayouts-10006\", device, error_obj.location,\n                     \"sum of both dynamic storage buffer bindings (%\" PRIu32\n                     \") and dynamic uniform buffer bindings (%\" PRIu32 \") among all stages (%\" PRIu64\n                     \") exceeds device \"\n                     \"maxDescriptorSetUpdateAfterBindTotalBuffersDynamic limit (%\" PRIu32 \").\",\n                     sum_all_after_bind_uniform_buffer_dynamic, sum_all_after_bind_storage_buffer_dynamic, total_sum,\n                     phys_dev_ext_props.maintenance7_props.maxDescriptorSetUpdateAfterBindTotalBuffersDynamic);\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkPipelineLayoutCreateInfo-pSetLayouts-03038\", \"If the maintenance7 feature is not enabled, the total number of descriptors of the type VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER_DYNAMIC accessible across all shader stages and across all elements of pSetLayouts must be less than or equal to VkPhysicalDeviceLimits::maxDescriptorSetUpdateAfterBindUniformBuffersDynamic\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (sum_all_after_bind_uniform_buffer_dynamic >\n    skip |= LogError(\"VUID-VkPipelineLayoutCreateInfo-pSetLayouts-03038\", device, error_obj.location,\n                     \"sum of dynamic uniform buffer bindings among all stages (%\" PRIu32\n                     \") exceeds device \"\n                     \"maxDescriptorSetUpdateAfterBindUniformBuffersDynamic limit (%\" PRIu32 \").\",\n                     sum_all_after_bind_uniform_buffer_dynamic,\n                     phys_dev_props_core12.maxDescriptorSetUpdateAfterBindUniformBuffersDynamic);\n"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkPipelineLayoutCreateInfo-pSetLayouts-03040\", \"If the maintenance7 feature is not enabled, the total number of descriptors of the type VK_DESCRIPTOR_TYPE_STORAGE_BUFFER_DYNAMIC accessible across all shader stages and across all elements of pSetLayouts must be less than or equal to VkPhysicalDeviceLimits::maxDescriptorSetUpdateAfterBindStorageBuffersDynamic\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (sum_all_after_bind_storage_buffer_dynamic >\n    skip |= LogError(\"VUID-VkPipelineLayoutCreateInfo-pSetLayouts-03040\", device, error_obj.location,\n                     \"sum of dynamic storage buffer bindings among all stages (%\" PRIu32\n                     \") exceeds device \"\n                     \"maxDescriptorSetUpdateAfterBindStorageBuffersDynamic limit (%\" PRIu32 \").\",\n                     sum_all_after_bind_storage_buffer_dynamic,\n                     phys_dev_props_core12.maxDescriptorSetUpdateAfterBindStorageBuffersDynamic);\n"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkPipelineLayoutCreateInfo-pSetLayouts-03041\", \"The total number of descriptors of the type VK_DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER, VK_DESCRIPTOR_TYPE_SAMPLED_IMAGE, and VK_DESCRIPTOR_TYPE_UNIFORM_TEXEL_BUFFER accessible across all shader stages and across all elements of pSetLayouts must be less than or equal to VkPhysicalDeviceDescriptorIndexingProperties::maxDescriptorSetUpdateAfterBindSampledImages\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (sum > phys_dev_props_core12.maxDescriptorSetUpdateAfterBindSampledImages) {\n    skip |= LogError(\"VUID-VkPipelineLayoutCreateInfo-pSetLayouts-03041\", device, error_obj.location,\n                     \"sum of sampled image bindings among all stages (%\" PRIu32\n                     \") exceeds device \"\n                     \"maxDescriptorSetUpdateAfterBindSampledImages limit (%\" PRIu32 \").\",\n                     sum, phys_dev_props_core12.maxDescriptorSetUpdateAfterBindSampledImages);\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkPipelineLayoutCreateInfo-pSetLayouts-03043\", \"The total number of descriptors of the type VK_DESCRIPTOR_TYPE_INPUT_ATTACHMENT accessible across all shader stages and across all elements of pSetLayouts must be less than or equal to VkPhysicalDeviceDescriptorIndexingProperties::maxDescriptorSetUpdateAfterBindInputAttachments\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (sum_all_stages_update_after_bind[VK_DESCRIPTOR_TYPE_INPUT_ATTACHMENT] >\n    skip |= LogError(\"VUID-VkPipelineLayoutCreateInfo-pSetLayouts-03043\", device, error_obj.location,\n                     \"sum of input attachment bindings among all stages (%\" PRIu32\n                     \") exceeds device \"\n                     \"maxDescriptorSetUpdateAfterBindInputAttachments limit (%\" PRIu32 \").\",\n                     sum_all_stages_update_after_bind[VK_DESCRIPTOR_TYPE_INPUT_ATTACHMENT],\n                     phys_dev_props_core12.maxDescriptorSetUpdateAfterBindInputAttachments);\n"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkPipelineLayoutCreateInfo-descriptorType-02217\", \"The total number of bindings with a descriptorType of VK_DESCRIPTOR_TYPE_INLINE_UNIFORM_BLOCK accessible across all shader stages and across all elements of pSetLayouts must be less than or equal to VkPhysicalDeviceInlineUniformBlockProperties::maxDescriptorSetUpdateAfterBindInlineUniformBlocks\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (inline_uniform_block_bindings >\n    skip |= LogError(\"VUID-VkPipelineLayoutCreateInfo-descriptorType-02217\", device, error_obj.location,\n                     \"sum of inline uniform block bindings among all stages (%\" PRIu32\n                     \") exceeds device \"\n                     \"maxDescriptorSetUpdateAfterBindInlineUniformBlocks limit (%\" PRIu32 \").\",\n                     inline_uniform_block_bindings,\n                     phys_dev_ext_props.inline_uniform_block_props.maxDescriptorSetUpdateAfterBindInlineUniformBlocks);\n"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkPipelineLayoutCreateInfo-descriptorType-03574\", \"The total number of bindings with a descriptorType of VK_DESCRIPTOR_TYPE_ACCELERATION_STRUCTURE_KHR accessible across all shader stages and across all elements of pSetLayouts must be less than or equal to VkPhysicalDeviceAccelerationStructurePropertiesKHR::maxDescriptorSetUpdateAfterBindAccelerationStructures\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (sum_all_stages_update_after_bind[VK_DESCRIPTOR_TYPE_ACCELERATION_STRUCTURE_KHR] >\n    skip |= LogError(\"VUID-VkPipelineLayoutCreateInfo-descriptorType-03574\", device, error_obj.location,\n                     \"sum of acceleration structures bindings among all stages (%\" PRIu32\n                     \") exceeds device \"\n                     \"maxDescriptorSetUpdateAfterBindAccelerationStructures limit (%\" PRIu32 \").\",\n                     sum_all_stages_update_after_bind[VK_DESCRIPTOR_TYPE_ACCELERATION_STRUCTURE_KHR],\n                     phys_dev_ext_props.acc_structure_props.maxDescriptorSetUpdateAfterBindAccelerationStructures);\n"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkPipelineLayoutCreateInfo-pImmutableSamplers-03566\", \"The total number of pImmutableSamplers created with flags containing VK_SAMPLER_CREATE_SUBSAMPLED_BIT_EXT or VK_SAMPLER_CREATE_SUBSAMPLED_COARSE_RECONSTRUCTION_BIT_EXT across all shader stages and across all elements of pSetLayouts must be less than or equal to VkPhysicalDeviceFragmentDensityMap2PropertiesEXT::maxDescriptorSetSubsampledSamplers\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (sum_subsampled_samplers > phys_dev_ext_props.fragment_density_map2_props.maxDescriptorSetSubsampledSamplers) {\n    skip |= LogError(\"VUID-VkPipelineLayoutCreateInfo-pImmutableSamplers-03566\", device, error_obj.location,\n                     \"sum of sampler bindings with flags containing \"\n                     \"VK_SAMPLER_CREATE_SUBSAMPLED_BIT_EXT or \"\n                     \"VK_SAMPLER_CREATE_SUBSAMPLED_COARSE_RECONSTRUCTION_BIT_EXT among all stages(% d) \"\n                     \"exceeds device maxDescriptorSetSubsampledSamplers limit (%\" PRIu32 \").\",\n                     sum_subsampled_samplers,\n                     phys_dev_ext_props.fragment_density_map2_props.maxDescriptorSetSubsampledSamplers);\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkPipelineLayoutCreateInfo-graphicsPipelineLibrary-06753\", \"If graphicsPipelineLibrary is not enabled, elements of pSetLayouts must be valid VkDescriptorSetLayout objects\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (!pCreateInfo->pSetLayouts[i]) {\n    skip |= LogError(\"VUID-VkPipelineLayoutCreateInfo-graphicsPipelineLibrary-06753\", device,\n                     create_info_loc.dot(Field::pSetLayouts, i),\n                     \"is VK_NULL_HANDLE, but VK_EXT_graphics_pipeline_library is not enabled.\");\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-vkCreateSampler-maxSamplerAllocationCount-04110\", \"There must be less than VkPhysicalDeviceLimits::maxSamplerAllocationCount VkSampler objects currently created on the device\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (num_samplers >= phys_dev_props.limits.maxSamplerAllocationCount) {\n    skip |= LogError(\"VUID-vkCreateSampler-maxSamplerAllocationCount-04110\", device, error_obj.location,\n                     \"Number of currently valid sampler objects (%zu) is not less than the maximum allowed (%\" PRIu32 \").\",\n                     num_samplers, phys_dev_props.limits.maxSamplerAllocationCount);\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkSamplerCreateInfo-None-04012\", \"The maximum number of samplers with custom border colors which can be simultaneously created on a device is implementation-dependent and specified by the maxCustomBorderColorSamplers member of the VkPhysicalDeviceCustomBorderColorPropertiesEXT structure\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (custom_border_color_sampler_count >= phys_dev_ext_props.custom_border_color_props.maxCustomBorderColorSamplers) {\n    skip |= LogError(\"VUID-VkSamplerCreateInfo-None-04012\", device, error_obj.location,\n                     \"Creating a sampler with a custom border color will exceed the \"\n                     \"maxCustomBorderColorSamplers limit of %\" PRIu32 \".\",\n                     phys_dev_ext_props.custom_border_color_props.maxCustomBorderColorSamplers);\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkSamplerCreateInfo-samplerMipLodBias-04467\", \"If the VK_KHR_portability_subset extension is enabled, and VkPhysicalDevicePortabilitySubsetFeaturesKHR::samplerMipLodBias is VK_FALSE, mipLodBias must be zero\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if ((VK_FALSE == enabled_features.samplerMipLodBias) && pCreateInfo->mipLodBias != 0) {\n    skip |= LogError(\"VUID-VkSamplerCreateInfo-samplerMipLodBias-04467\", device, error_obj.location,\n                     \"(portability error) mipLodBias is %f, but samplerMipLodBias not supported.\", pCreateInfo->mipLodBias);\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkDeviceCreateInfo-queueFamilyIndex-02802\", \"The queueFamilyIndex member of each element of pQueueCreateInfos must be unique within pQueueCreateInfos , except that two members can share the same queueFamilyIndex if one describes protected-capable queues and one describes queues that are not protected-capable\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (queue_family_map.emplace(requested_queue_family, flags).second == false) {\n    skip |= LogError(\"VUID-VkDeviceCreateInfo-queueFamilyIndex-02802\", pd_state.Handle(),\n                     info_loc.dot(Field::queueFamilyIndex),\n                     \"(%\" PRIu32 \") is not unique and was also used in pCreateInfo->pQueueCreateInfos[%\" PRIu32 \"].\",\n                     requested_queue_family, queue_family_map.at(requested_queue_family).unprocted_index);\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkDeviceCreateInfo-queueFamilyIndex-02802\", \"The queueFamilyIndex member of each element of pQueueCreateInfos must be unique within pQueueCreateInfos , except that two members can share the same queueFamilyIndex if one describes protected-capable queues and one describes queues that are not protected-capable\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (it->second.protected_index != not_used) {\n    skip |= LogError(\"VUID-VkDeviceCreateInfo-queueFamilyIndex-02802\", pd_state.Handle(),\n                     info_loc.dot(Field::queueFamilyIndex),\n                     \"(%\" PRIu32 \") is not unique and was also used in pCreateInfo->pQueueCreateInfos[%\" PRIu32\n                     \"] which both have \"\n                     \"VK_DEVICE_QUEUE_CREATE_PROTECTED_BIT.\",\n                     requested_queue_family, queue_family_map.at(requested_queue_family).protected_index);\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkDeviceCreateInfo-queueFamilyIndex-02802\", \"The queueFamilyIndex member of each element of pQueueCreateInfos must be unique within pQueueCreateInfos , except that two members can share the same queueFamilyIndex if one describes protected-capable queues and one describes queues that are not protected-capable\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (it->second.unprocted_index != not_used) {\n    skip |= LogError(\"VUID-VkDeviceCreateInfo-queueFamilyIndex-02802\", pd_state.Handle(),\n                     info_loc.dot(Field::queueFamilyIndex),\n                     \"(%\" PRIu32 \") is not unique and was also used in pCreateInfo->pQueueCreateInfos[%\" PRIu32\n                     \"].\",\n                     requested_queue_family, queue_family_map.at(requested_queue_family).unprocted_index);\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkDeviceCreateInfo-pQueueCreateInfos-06654\", \"If multiple elements of pQueueCreateInfos share the same queueFamilyIndex, then all of such elements must have the same global priority level, which can be specified explicitly by the including a VkDeviceQueueGlobalPriorityCreateInfoKHR structure in the pNext chain, or by the implicit default value\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (prev_global_priority->second != global_priority) {\n    skip |= LogError(\"VUID-VkDeviceCreateInfo-pQueueCreateInfos-06654\", pd_state.Handle(), info_loc,\n                     \"Multiple queues are created with queueFamilyIndex %\" PRIu32\n                     \", but one has global priority %s and another %s.\",\n                     infos[i].queueFamilyIndex, string_VkQueueGlobalPriorityKHR(prev_global_priority->second),\n                     string_VkQueueGlobalPriorityKHR(global_priority));\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkDeviceCreateInfo-pQueueCreateInfos-06755\", \"If multiple elements of pQueueCreateInfos share the same queueFamilyIndex, the sum of their queueCount members must be less than or equal to the queueCount member of the VkQueueFamilyProperties structure, as returned by vkGetPhysicalDeviceQueueFamilyProperties in the pQueueFamilyProperties[queueFamilyIndex]\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (queue_counts[i] > pd_state.queue_family_properties[i].queueCount) {\n    skip |= LogError(\"VUID-VkDeviceCreateInfo-pQueueCreateInfos-06755\", pd_state.Handle(), loc,\n                     \"Total queue count requested from queue family index %\" PRIu32 \" is %\" PRIu32\n                     \", which is greater than queue count available in the queue family (%\" PRIu32 \").\",\n                     i, queue_counts[i], pd_state.queue_family_properties[i].queueCount);\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-vkCreateDevice-physicalDevice-parameter\", \"physicalDevice must be a valid VkPhysicalDevice handle\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (!pd_state) {\n    skip |= LogError(\"VUID-vkCreateDevice-physicalDevice-parameter\", device, error_obj.location,\n                     \"Have not called vkEnumeratePhysicalDevices() yet.\");\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkDeviceCreateInfo-shadingRateImage-04478\", \"If the shadingRateImage feature is enabled, the pipelineFragmentShadingRate feature must not be enabled\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (fragment_shading_rate_features->pipelineFragmentShadingRate) {\n    skip |= LogError(\"VUID-VkDeviceCreateInfo-shadingRateImage-04478\", pd_state->Handle(), error_obj.location,\n                     \"Cannot enable shadingRateImage and pipelineFragmentShadingRate features simultaneously.\");\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkDeviceCreateInfo-shadingRateImage-04479\", \"If the shadingRateImage feature is enabled, the primitiveFragmentShadingRate feature must not be enabled\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (fragment_shading_rate_features->primitiveFragmentShadingRate) {\n    skip |= LogError(\"VUID-VkDeviceCreateInfo-shadingRateImage-04479\", pd_state->Handle(), error_obj.location,\n                     \"Cannot enable shadingRateImage and primitiveFragmentShadingRate features simultaneously.\");\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkDeviceCreateInfo-fragmentDensityMap-04481\", \"If the fragmentDensityMap feature is enabled, the pipelineFragmentShadingRate feature must not be enabled\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (fragment_shading_rate_features->pipelineFragmentShadingRate) {\n    skip |= LogError(\"VUID-VkDeviceCreateInfo-fragmentDensityMap-04481\", pd_state->Handle(), error_obj.location,\n                     \"Cannot enable fragmentDensityMap and pipelineFragmentShadingRate features \"\n                     \"simultaneously.\");\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkDeviceCreateInfo-fragmentDensityMap-04482\", \"If the fragmentDensityMap feature is enabled, the primitiveFragmentShadingRate feature must not be enabled\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (fragment_shading_rate_features->primitiveFragmentShadingRate) {\n    skip |= LogError(\"VUID-VkDeviceCreateInfo-fragmentDensityMap-04482\", pd_state->Handle(), error_obj.location,\n                     \"Cannot enable fragmentDensityMap and primitiveFragmentShadingRate features \"\n                     \"simultaneously.\");\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkDeviceCreateInfo-fragmentDensityMap-04483\", \"If the fragmentDensityMap feature is enabled, the attachmentFragmentShadingRate feature must not be enabled\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (fragment_shading_rate_features->attachmentFragmentShadingRate) {\n    skip |= LogError(\"VUID-VkDeviceCreateInfo-fragmentDensityMap-04483\", pd_state->Handle(), error_obj.location,\n                     \"Cannot enable fragmentDensityMap and attachmentFragmentShadingRate features \"\n                     \"simultaneously.\");\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkDeviceCreateInfo-None-04896\", \"If sparseImageInt64Atomics is enabled, shaderImageInt64Atomics must be enabled\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (shader_image_atomic_int64_features->sparseImageInt64Atomics &&\n    skip |= LogError(\"VUID-VkDeviceCreateInfo-None-04896\", pd_state->Handle(), error_obj.location,\n                     \"if sparseImageInt64Atomics feature is enabled then shaderImageInt64Atomics \"\n                     \"feature must also be enabled.\");\n"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkDeviceCreateInfo-None-04898\", \"If sparseImageFloat32AtomicAdd is enabled, shaderImageFloat32AtomicAdd must be enabled\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (shader_atomic_float_features->sparseImageFloat32AtomicAdd &&\n    skip |= LogError(\"VUID-VkDeviceCreateInfo-None-04898\", pd_state->Handle(), error_obj.location,\n                     \"if sparseImageFloat32AtomicAdd feature is enabled then shaderImageFloat32AtomicAdd \"\n                     \"feature must also be enabled.\");\n"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkDeviceGroupDeviceCreateInfo-pPhysicalDevices-00375\", \"Each element of pPhysicalDevices must be unique\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (device_group_ci->pPhysicalDevices[i] == device_group_ci->pPhysicalDevices[j]) {\n    skip |= LogError(\"VUID-VkDeviceGroupDeviceCreateInfo-pPhysicalDevices-00375\", pd_state->Handle(),\n                     error_obj.location,\n                     \"VkDeviceGroupDeviceCreateInfo has a duplicated physical device \"\n                     \"in pPhysicalDevices [%\" PRIu32 \"] and [%\" PRIu32 \"].\",\n                     i, j);\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-vkGetDeviceQueue-queueIndex-00385\", \"queueIndex must be less than the value of VkDeviceQueueCreateInfo::queueCount for the queue family indicated by queueFamilyIndex when device was created\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (device_queue_info.queue_count <= queueIndex) {\n    skip |= LogError(\"VUID-vkGetDeviceQueue-queueIndex-00385\", device, error_obj.location.dot(Field::queueIndex),\n                     \"(%\" PRIu32 \") is not less than the number of queues requested from queueFamilyIndex (=%\" PRIu32\n                     \") when the device was created vkCreateDevice::pCreateInfo->pQueueCreateInfos[%\" PRIu32\n                     \"] (i.e. is not less than %\" PRIu32 \").\",\n                     queueIndex, queueFamilyIndex, device_queue_info.index, device_queue_info.queue_count);\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkDeviceQueueInfo2-flags-06225\", \"flags must be equal to VkDeviceQueueCreateInfo::flags for a VkDeviceQueueCreateInfo structure for the queue family indicated by queueFamilyIndex when device was created\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (!valid_flags && !skip) {\n    skip |= LogError(\"VUID-VkDeviceQueueInfo2-flags-06225\", device, error_obj.location,\n                     \"The combination of queueFamilyIndex (%\" PRIu32\n                     \") and flags (%s) were never both set together in any element of \"\n                     \"vkCreateDevice::pCreateInfo->pQueueCreateInfos at device creation time.\",\n                     queueFamilyIndex, string_VkDeviceQueueCreateFlags(flags).c_str());\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-vkMergeValidationCachesEXT-dstCache-01536\", \"dstCache must not appear in the list of source caches\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (src == dst) {\n    const Location loc(Func::vkMergePipelineCaches, Field::dstCache);\n    skip |= LogError(\"VUID-vkMergeValidationCachesEXT-dstCache-01536\", device, loc,\n                     \"(0x%\" PRIx64 \") must not appear in pSrcCaches array.\", HandleToUint64(dstCache));\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-vkCmdSetDeviceMask-deviceMask-00108\", \"deviceMask must be a valid device mask value\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "const LogObjectList objlist(commandBuffer);\nskip |= ValidateExtendedDynamicState(cb_state, error_obj.location, VK_TRUE, nullptr, nullptr);\nconst Location loc = error_obj.location.dot(Field::deviceMask);\nskip |= ValidateDeviceMaskToPhysicalDeviceCount(deviceMask, objlist, loc, \"VUID-vkCmdSetDeviceMask-deviceMask-00108\");\n"
        },
        {
            "role": "user",
            "content": "{\"VUID-vkCmdSetDeviceMask-deviceMask-00109\", \"deviceMask must not be zero\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "skip |= ValidateExtendedDynamicState(cb_state, error_obj.location, VK_TRUE, nullptr, nullptr);\nconst Location loc = error_obj.location.dot(Field::deviceMask);\nskip |= ValidateDeviceMaskToPhysicalDeviceCount(deviceMask, objlist, loc, \"VUID-vkCmdSetDeviceMask-deviceMask-00108\");\nskip |= ValidateDeviceMaskToZero(deviceMask, objlist, loc, \"VUID-vkCmdSetDeviceMask-deviceMask-00109\");\n"
        },
        {
            "role": "user",
            "content": "{\"VUID-vkCmdSetDeviceMask-deviceMask-00110\", \"deviceMask must not include any set bits that were not in the VkDeviceGroupCommandBufferBeginInfo::deviceMask value when the command buffer began recording\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "const Location loc = error_obj.location.dot(Field::deviceMask);\nskip |= ValidateDeviceMaskToPhysicalDeviceCount(deviceMask, objlist, loc, \"VUID-vkCmdSetDeviceMask-deviceMask-00108\");\nskip |= ValidateDeviceMaskToZero(deviceMask, objlist, loc, \"VUID-vkCmdSetDeviceMask-deviceMask-00109\");\nskip |= ValidateDeviceMaskToCommandBuffer(cb_state, deviceMask, objlist, loc, \"VUID-vkCmdSetDeviceMask-deviceMask-00110\");\n"
        },
        {
            "role": "user",
            "content": "{\"VUID-vkCreatePrivateDataSlot-privateData-04564\", \"The privateData feature must be enabled\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (!enabled_features.privateData) {\n    skip |= LogError(\"VUID-vkCreatePrivateDataSlot-privateData-04564\", device, error_obj.location,\n                     \"The privateData feature was not enabled.\");\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkCommandPoolCreateInfo-flags-02860\", \"If the protectedMemory feature is not enabled, the VK_COMMAND_POOL_CREATE_PROTECTED_BIT bit of flags must not be set\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if ((enabled_features.protectedMemory == VK_FALSE) && ((pCreateInfo->flags & VK_COMMAND_POOL_CREATE_PROTECTED_BIT) != 0)) {\n    skip |= LogError(\"VUID-VkCommandPoolCreateInfo-flags-02860\", device, create_info_loc.dot(Field::flags),\n                     \"includes VK_COMMAND_POOL_CREATE_PROTECTED_BIT, but the protectedMemory feature was not enabled.\");\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-vkDestroyCommandPool-commandPool-00041\", \"All VkCommandBuffer objects allocated from commandPool must not be in the pending state\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (cb_state->InUse()) {\n    const LogObjectList objlist(cb_state->Handle(), commandPool);\n    skip |= LogError(\"VUID-vkDestroyCommandPool-commandPool-00041\", objlist, error_obj.location, \"(%s) is in use.\",\n                     FormatHandle(cb_state->Handle()).c_str());\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-vkResetCommandPool-commandPool-00040\", \"All VkCommandBuffer objects allocated from commandPool must not be in the pending state\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (cb_state->InUse()) {\n    const LogObjectList objlist(cb_state->Handle(), commandPool);\n    skip |= LogError(\"VUID-vkResetCommandPool-commandPool-00040\", objlist, error_obj.location, \"(%s) is in use.\",\n                     FormatHandle(cb_state->Handle()).c_str());\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkCalibratedTimestampInfoEXT-timeDomain-02354\", \"timeDomain must be one of the VkTimeDomainKHR values returned by vkGetPhysicalDeviceCalibrateableTimeDomainsKHR\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "skip |= LogError(\"VUID-VkCalibratedTimestampInfoEXT-timeDomain-02354\", device,\n                 error_obj.location.dot(Field::pTimestampInfos, i).dot(Field::timeDomain), \"is %s.\",\n                 string_VkTimeDomainKHR(time_domain));\n"
        },
        {
            "role": "user",
            "content": "{\"VUID-vkGetDeviceFaultInfoEXT-device-07336\", \"device must be in the lost state\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (!is_device_lost) {\n    skip |= LogError(\"VUID-vkGetDeviceFaultInfoEXT-device-07336\", device, error_obj.location,\n                     \"device has not been found to be in a lost state.\");\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkMemoryAllocateInfo-allocationSize-07899\", \"If the parameters define an export operation and the handle type is not VK_EXTERNAL_MEMORY_HANDLE_TYPE_ANDROID_HARDWARE_BUFFER_BIT_ANDROID , allocationSize must be greater than 0\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (!IgnoreAllocationSize(*pAllocateInfo) && 0 == pAllocateInfo->allocationSize) {\n    skip |= LogError(\"VUID-VkMemoryAllocateInfo-allocationSize-07899\", device, allocate_info_loc.dot(Field::allocationSize),\n                     \"is 0.\");\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-vkAllocateMemory-pAllocateInfo-01714\", \"pAllocateInfo->memoryTypeIndex must be less than VkPhysicalDeviceMemoryProperties::memoryTypeCount as returned by vkGetPhysicalDeviceMemoryProperties for the VkPhysicalDevice that device was created from\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (pAllocateInfo->memoryTypeIndex >= phys_dev_mem_props.memoryTypeCount) {\n    skip |= LogError(\"VUID-vkAllocateMemory-pAllocateInfo-01714\", device, allocate_info_loc.dot(Field::memoryTypeIndex),\n                     \"%\" PRIu32 \" is not a valid index. Device only advertises %\" PRIu32 \" memory types.\",\n                     pAllocateInfo->memoryTypeIndex, phys_dev_mem_props.memoryTypeCount);\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkMemoryDedicatedAllocateInfo-image-01432\", \"At least one of image and buffer must be VK_NULL_HANDLE\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if ((dedicated_buffer != VK_NULL_HANDLE) && (dedicated_image != VK_NULL_HANDLE)) {\n    skip |= LogError(\"VUID-VkMemoryDedicatedAllocateInfo-image-01432\", device, allocate_info_loc,\n                     \"pNext<VkMemoryDedicatedAllocateInfo> buffer (%s) or image (%s) has to be VK_NULL_HANDLE.\",\n                     FormatHandle(dedicated_buffer).c_str(), FormatHandle(dedicated_image).c_str());\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkMemoryDedicatedAllocateInfo-image-01797\", \"If image is not VK_NULL_HANDLE, image must not have been created with VK_IMAGE_CREATE_DISJOINT_BIT set in VkImageCreateInfo::flags\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (image_state->disjoint == true) {\n    skip |= LogError(\"VUID-VkMemoryDedicatedAllocateInfo-image-01797\", objlist, image_loc,\n                     \"(%s) was created with VK_IMAGE_CREATE_DISJOINT_BIT.\", FormatHandle(dedicated_image).c_str());\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkMemoryDedicatedAllocateInfo-image-02964\", \"If image is not VK_NULL_HANDLE and the memory is not an imported Android Hardware Buffer or an imported QNX Screen buffer , VkMemoryAllocateInfo::allocationSize must equal the VkMemoryRequirements::size of the image\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (!IgnoreAllocationSize(*pAllocateInfo) && (pAllocateInfo->allocationSize != image_state->requirements[0].size) &&\n    skip |= LogError(\"VUID-VkMemoryDedicatedAllocateInfo-image-02964\", objlist,\n                     allocate_info_loc.dot(Field::allocationSize),\n                     \"(%\" PRIu64 \") needs to be equal to %s (%s) VkMemoryRequirements::size (%\" PRIu64 \").\",\n                     pAllocateInfo->allocationSize, image_loc.Fields().c_str(),\n                     FormatHandle(dedicated_image).c_str(), image_state->requirements[0].size);\n"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkMemoryDedicatedAllocateInfo-image-01434\", \"If image is not VK_NULL_HANDLE, image must have been created without VK_IMAGE_CREATE_SPARSE_BINDING_BIT set in VkImageCreateInfo::flags\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if ((image_state->create_info.flags & VK_IMAGE_CREATE_SPARSE_BINDING_BIT) != 0) {\n    skip |= LogError(\"VUID-VkMemoryDedicatedAllocateInfo-image-01434\", objlist, image_loc,\n                     \"(%s): was created with VK_IMAGE_CREATE_SPARSE_BINDING_BIT.\",\n                     FormatHandle(dedicated_image).c_str());\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkMemoryDedicatedAllocateInfo-buffer-01436\", \"If buffer is not VK_NULL_HANDLE, buffer must have been created without VK_BUFFER_CREATE_SPARSE_BINDING_BIT set in VkBufferCreateInfo::flags\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if ((buffer_state->create_info.flags & VK_BUFFER_CREATE_SPARSE_BINDING_BIT) != 0) {\n    skip |= LogError(\"VUID-VkMemoryDedicatedAllocateInfo-buffer-01436\", objlist, buffer_loc,\n                     \"(%s) was created with VK_BUFFER_CREATE_SPARSE_BINDING_BIT.\",\n                     FormatHandle(dedicated_buffer).c_str());\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkMemoryAllocateInfo-allocationSize-01742\", \"If the parameters define an import operation, the external handle specified was created by the Vulkan API, and the external handle type is VK_EXTERNAL_MEMORY_HANDLE_TYPE_OPAQUE_FD_BIT, then the values of allocationSize and memoryTypeIndex must match those specified when the payload being imported was created\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (pAllocateInfo->memoryTypeIndex != payload_info->memory_type_index) {\n    skip |= LogError(\"VUID-VkMemoryAllocateInfo-allocationSize-01742\", device,\n                     allocate_info_loc.dot(Field::memoryTypeIndex),\n                     \"memoryTypeIndex (%\" PRIu32 \") does not match %s (%d) memoryTypeIndex (%\" PRIu32 \").\",\n                     pAllocateInfo->memoryTypeIndex, import_loc.Fields().c_str(), import_memory_fd_info->fd,\n                     payload_info->memory_type_index);\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkMemoryDedicatedAllocateInfo-image-01878\", \"If image is not VK_NULL_HANDLE and VkMemoryAllocateInfo defines a memory import operation with handle type VK_EXTERNAL_MEMORY_HANDLE_TYPE_OPAQUE_FD_BIT, the memory being imported must also be a dedicated image allocation and image must be identical to the image associated with the imported memory\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (payload_info->dedicated_image == VK_NULL_HANDLE) {\n    skip |= LogError(\"VUID-VkMemoryDedicatedAllocateInfo-image-01878\", dedicated_image,\n                     allocate_info_loc.pNext(Struct::VkMemoryDedicatedAllocateInfo, Field::image),\n                     \"is %s but %s (%d) was not created with a dedicated image.\",\n                     FormatHandle(dedicated_image).c_str(), import_loc.Fields().c_str(), import_memory_fd_info->fd);\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkMemoryDedicatedAllocateInfo-image-01878\", \"If image is not VK_NULL_HANDLE and VkMemoryAllocateInfo defines a memory import operation with handle type VK_EXTERNAL_MEMORY_HANDLE_TYPE_OPAQUE_FD_BIT, the memory being imported must also be a dedicated image allocation and image must be identical to the image associated with the imported memory\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "// TODO - Print out info about image creation info\nconst LogObjectList objlist(payload_info->dedicated_image, dedicated_image);\nskip |= LogError(\"VUID-VkMemoryDedicatedAllocateInfo-image-01878\", objlist,\n                 allocate_info_loc.pNext(Struct::VkMemoryDedicatedAllocateInfo, Field::image),\n                 \"is %s but %s (%d) was created with a dedicated image %s.\",\n                 FormatHandle(dedicated_image).c_str(), import_loc.Fields().c_str(),\n                 import_memory_fd_info->fd, FormatHandle(payload_info->dedicated_image).c_str());\n"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkImportMemoryFdInfoKHR-handleType-00667\", \"If handleType is not 0, it must be supported for import, as reported by VkExternalImageFormatProperties or VkExternalBufferProperties\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (dedicated_image_state &&\n    skip |= LogError(\"VUID-VkImportMemoryFdInfoKHR-handleType-00667\", dedicated_image,\n                     allocate_info_loc.pNext(Struct::VkMemoryDedicatedAllocateInfo, Field::image),\n                     \"is %s but vkGetPhysicalDeviceImageFormatProperties2 shows no support for \"\n                     \"VK_EXTERNAL_MEMORY_FEATURE_IMPORTABLE_BIT.\",\n                     FormatHandle(dedicated_image).c_str());\n"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkImportMemoryFdInfoKHR-handleType-00667\", \"If handleType is not 0, it must be supported for import, as reported by VkExternalImageFormatProperties or VkExternalBufferProperties\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (dedicated_buffer_state &&\n    skip |= LogError(\"VUID-VkImportMemoryFdInfoKHR-handleType-00667\", dedicated_buffer,\n                     allocate_info_loc.pNext(Struct::VkMemoryDedicatedAllocateInfo, Field::buffer),\n                     \"is %s but vkGetPhysicalDeviceExternalBufferProperties shows no support for \"\n                     \"VK_EXTERNAL_MEMORY_FEATURE_IMPORTABLE_BIT.\",\n                     FormatHandle(dedicated_buffer).c_str());\n"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkMemoryAllocateInfo-allocationSize-01743\", \"If the parameters define an import operation, the external handle was created by the Vulkan API, and the external handle type is VK_EXTERNAL_MEMORY_HANDLE_TYPE_OPAQUE_WIN32_BIT or VK_EXTERNAL_MEMORY_HANDLE_TYPE_OPAQUE_WIN32_KMT_BIT, then the values of allocationSize and memoryTypeIndex must match those specified when the payload being imported was created\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (pAllocateInfo->memoryTypeIndex != payload_info->memory_type_index) {\n    skip |= LogError(\"VUID-VkMemoryAllocateInfo-allocationSize-01743\", device,\n                     allocate_info_loc.dot(Field::memoryTypeIndex),\n                     \"memoryTypeIndex (%\" PRIu32 \") does not match %s (0x%\" PRIxPTR\n                     \") of type %s memoryTypeIndex (%\" PRIu32 \").\",\n                     pAllocateInfo->memoryTypeIndex, import_loc.Fields().c_str(),\n                     reinterpret_cast<std::uintptr_t>(import_memory_win32_info->handle),\n                     string_VkExternalMemoryHandleTypeFlagBits(import_memory_win32_info->handleType),\n                     payload_info->memory_type_index);\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkMemoryDedicatedAllocateInfo-image-01876\", \"If image is not VK_NULL_HANDLE and VkMemoryAllocateInfo defines a memory import operation with handle type VK_EXTERNAL_MEMORY_HANDLE_TYPE_OPAQUE_WIN32_BIT, VK_EXTERNAL_MEMORY_HANDLE_TYPE_OPAQUE_WIN32_KMT_BIT, VK_EXTERNAL_MEMORY_HANDLE_TYPE_D3D11_TEXTURE_BIT, VK_EXTERNAL_MEMORY_HANDLE_TYPE_D3D11_TEXTURE_KMT_BIT, VK_EXTERNAL_MEMORY_HANDLE_TYPE_D3D12_HEAP_BIT, or VK_EXTERNAL_MEMORY_HANDLE_TYPE_D3D12_RESOURCE_BIT, and the external handle was created by the Vulkan API, then the memory being imported must also be a dedicated image allocation and image must be identical to the image associated with the imported memory\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (payload_info->dedicated_image == VK_NULL_HANDLE) {\n    skip |= LogError(\"VUID-VkMemoryDedicatedAllocateInfo-image-01876\", dedicated_image,\n                     allocate_info_loc.pNext(Struct::VkMemoryDedicatedAllocateInfo, Field::image),\n                     \"is %s but %s (0x%\" PRIxPTR \") was not created with a dedicated image.\",\n                     FormatHandle(dedicated_image).c_str(), import_loc.Fields().c_str(),\n                     reinterpret_cast<std::uintptr_t>(import_memory_win32_info->handle));\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-vkFreeMemory-memory-00677\", \"All submitted commands that refer to memory (via images or buffers) must have completed execution\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (auto mem_info = Get<vvl::DeviceMemory>(memory)) {\n    skip |= ValidateObjectNotInUse(mem_info.get(), error_obj.location, \"VUID-vkFreeMemory-memory-00677\");\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkBindBufferMemoryDeviceGroupInfo-deviceIndexCount-01606\", \"deviceIndexCount must either be zero or equal to the number of physical devices in the logical device\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "bind_buffer_memory_device_group_info->deviceIndexCount != device_group_create_info.physicalDeviceCount &&\nconst LogObjectList objlist(buffer, memory);\nskip |= LogError(\"VUID-VkBindBufferMemoryDeviceGroupInfo-deviceIndexCount-01606\", objlist,\n                 loc.pNext(Struct::VkBindBufferMemoryDeviceGroupInfo, Field::deviceIndexCount),\n                 \"(%\" PRIu32 \") is not the same as the number of physical devices in the logical device (%\" PRIu32 \").\",\n                 bind_buffer_memory_device_group_info->deviceIndexCount, device_group_create_info.physicalDeviceCount);\n"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkExportMemoryAllocateInfo-handleTypes-00656\", \"The bits in handleTypes must be supported and compatible, as reported by VkExternalImageFormatProperties or VkExternalBufferProperties\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if ((external_features & VK_EXTERNAL_MEMORY_FEATURE_EXPORTABLE_BIT) == 0) {\n    const LogObjectList objlist(buffer, memory);\n    skip |= LogError(\"VUID-VkExportMemoryAllocateInfo-handleTypes-00656\", objlist, loc,\n                     \"The VkDeviceMemory (%s) has VkExportMemoryAllocateInfo::handleTypes with the %s flag \"\n                     \"set, which does not support VK_EXTERNAL_MEMORY_FEATURE_EXPORTABLE_BIT with the buffer \"\n                     \"create flags (%s) and usage flags (%s).\",\n                     FormatHandle(memory).c_str(), string_VkExternalMemoryHandleTypeFlagBits(flag),\n                     string_VkBufferCreateFlags(external_info.flags).c_str(),\n                     string_VkBufferUsageFlags(external_info.usage).c_str());\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkExportMemoryAllocateInfo-handleTypes-00656\", \"The bits in handleTypes must be supported and compatible, as reported by VkExternalImageFormatProperties or VkExternalBufferProperties\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (export_supported && (mem_info->export_handle_types & compatible_types) != mem_info->export_handle_types) {\n    const LogObjectList objlist(buffer, memory);\n    skip |= LogError(\"VUID-VkExportMemoryAllocateInfo-handleTypes-00656\", objlist, loc.dot(Field::memory),\n                     \"(%s) has VkExportMemoryAllocateInfo::handleTypes (%s) that are not \"\n                     \"reported as compatible by vkGetPhysicalDeviceExternalBufferProperties with the buffer create \"\n                     \"flags (%s) and usage flags (%s).\",\n                     FormatHandle(memory).c_str(),\n                     string_VkExternalMemoryHandleTypeFlags(mem_info->export_handle_types).c_str(),\n                     string_VkBufferCreateFlags(external_info.flags).c_str(),\n                     string_VkBufferUsageFlags(external_info.usage).c_str());\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkMemoryAllocateInfo-pNext-00639\", \"If the pNext chain includes a VkExportMemoryAllocateInfo structure, and any of the handle types specified in VkExportMemoryAllocateInfo::handleTypes require a dedicated allocation, as reported by vkGetPhysicalDeviceImageFormatProperties2 in VkExternalImageFormatProperties::externalMemoryProperties.externalMemoryFeatures, or by vkGetPhysicalDeviceExternalBufferProperties in VkExternalBufferProperties::externalMemoryProperties.externalMemoryFeatures, the pNext chain must include a VkMemoryDedicatedAllocateInfo or VkDedicatedAllocationMemoryAllocateInfoNV structure with either its image or buffer member set to a value other than VK_NULL_HANDLE\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (!mem_info->IsDedicatedBuffer()) {\n    const LogObjectList objlist(buffer, memory);\n    skip |= LogError(\"VUID-VkMemoryAllocateInfo-pNext-00639\", objlist, loc.dot(Field::memory),\n                     \"(%s) has VkExportMemoryAllocateInfo::handleTypes with the %s flag \"\n                     \"set, which requires dedicated allocation for the buffer created with flags (%s) and \"\n                     \"usage flags (%s), but the memory is allocated without dedicated allocation support.\",\n                     FormatHandle(memory).c_str(), string_VkExternalMemoryHandleTypeFlagBits(flag),\n                     string_VkBufferCreateFlags(external_info.flags).c_str(),\n                     string_VkBufferUsageFlags(external_info.usage).c_str());\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-vkGetImageMemoryRequirements-image-01588\", \"image must not have been created with the VK_IMAGE_CREATE_DISJOINT_BIT flag set\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (image_state->disjoint == true) {\n    skip |= LogError(\"VUID-vkGetImageMemoryRequirements-image-01588\", image, image_loc,\n                     \"(%s) must not have been created with the VK_IMAGE_CREATE_DISJOINT_BIT \"\n                     \"(need to use vkGetImageMemoryRequirements2).\",\n                     FormatHandle(image).c_str());\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkImageMemoryRequirementsInfo2-image-01589\", \"If image was created with a multi-planar format and the VK_IMAGE_CREATE_DISJOINT_BIT flag, there must be a VkImagePlaneMemoryRequirementsInfo included in the pNext chain of the VkImageMemoryRequirementsInfo2 structure\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (vkuFormatIsMultiplane(image_format)) {\n    skip |= LogError(\"VUID-VkImageMemoryRequirementsInfo2-image-01589\", pInfo->image, image_loc,\n                     \"(%s) was created with a multi-planar format (%s) and \"\n                     \"VK_IMAGE_CREATE_DISJOINT_BIT, but the current pNext doesn't include a \"\n                     \"VkImagePlaneMemoryRequirementsInfo struct\",\n                     FormatHandle(pInfo->image).c_str(), string_VkFormat(image_format));\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkImageMemoryRequirementsInfo2-image-02279\", \"If image was created with VK_IMAGE_CREATE_DISJOINT_BIT and with VK_IMAGE_TILING_DRM_FORMAT_MODIFIER_EXT, then there must be a VkImagePlaneMemoryRequirementsInfo included in the pNext chain of the VkImageMemoryRequirementsInfo2 structure\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (image_state->create_info.tiling == VK_IMAGE_TILING_DRM_FORMAT_MODIFIER_EXT) {\n    skip |= LogError(\"VUID-VkImageMemoryRequirementsInfo2-image-02279\", pInfo->image, image_loc,\n                     \"(%s) was created with VK_IMAGE_CREATE_DISJOINT_BIT and has tiling of \"\n                     \"VK_IMAGE_TILING_DRM_FORMAT_MODIFIER_EXT, \"\n                     \"but the current pNext does not include a VkImagePlaneMemoryRequirementsInfo struct\",\n                     FormatHandle(pInfo->image).c_str());\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkImageMemoryRequirementsInfo2-image-02280\", \"If image was created with a single-plane format and with any tiling other than VK_IMAGE_TILING_DRM_FORMAT_MODIFIER_EXT, then there must not be a VkImagePlaneMemoryRequirementsInfo included in the pNext chain of the VkImageMemoryRequirementsInfo2 structure\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if ((vkuFormatIsMultiplane(image_format) == false) && (image_tiling != VK_IMAGE_TILING_DRM_FORMAT_MODIFIER_EXT)) {\n    skip |= LogError(\"VUID-VkImageMemoryRequirementsInfo2-image-02280\", pInfo->image, image_loc,\n                     \"(%s) is a single-plane format (%s) and does not have tiling of \"\n                     \"VK_IMAGE_TILING_DRM_FORMAT_MODIFIER_EXT,\"\n                     \"but the current pNext includes a VkImagePlaneMemoryRequirementsInfo struct\",\n                     FormatHandle(pInfo->image).c_str(), string_VkFormat(image_format));\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkMemoryMapInfoKHR-memory-07962\", \"memory must have been created with a memory type that reports VK_MEMORY_PROPERTY_HOST_VISIBLE_BIT\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if ((propertyFlags & VK_MEMORY_PROPERTY_HOST_VISIBLE_BIT) == 0) {\n    skip |= LogError(map2 ? \"VUID-VkMemoryMapInfoKHR-memory-07962\" : \"VUID-vkMapMemory-memory-00682\", memory, loc,\n                     \"Mapping memory without VK_MEMORY_PROPERTY_HOST_VISIBLE_BIT set. \"\n                     \"Memory has type %\" PRIu32 \" which has properties %s.\",\n                     memoryTypeIndex, string_VkMemoryPropertyFlags(propertyFlags).c_str());\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-vkMapMemory-memory-00682\", \"memory must have been created with a memory type that reports VK_MEMORY_PROPERTY_HOST_VISIBLE_BIT\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if ((propertyFlags & VK_MEMORY_PROPERTY_HOST_VISIBLE_BIT) == 0) {\n    skip |= LogError(map2 ? \"VUID-VkMemoryMapInfoKHR-memory-07962\" : \"VUID-vkMapMemory-memory-00682\", memory, loc,\n                     \"Mapping memory without VK_MEMORY_PROPERTY_HOST_VISIBLE_BIT set. \"\n                     \"Memory has type %\" PRIu32 \" which has properties %s.\",\n                     memoryTypeIndex, string_VkMemoryPropertyFlags(propertyFlags).c_str());\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkMemoryMapInfoKHR-memory-07963\", \"memory must not have been allocated with multiple instances\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (mem_info.multi_instance) {\n    skip |= LogError(map2 ? \"VUID-VkMemoryMapInfoKHR-memory-07963\" : \"VUID-vkMapMemory-memory-00683\", instance, loc,\n                     \"Memory allocated with multiple instances.\");\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkMemoryMapInfoKHR-size-07960\", \"If size is not equal to VK_WHOLE_SIZE, size must be greater than 0\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (size == 0) {\n    skip |= LogError(map2 ? \"VUID-VkMemoryMapInfoKHR-size-07960\" : \"VUID-vkMapMemory-size-00680\", memory, size_loc, \"is zero.\");\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-vkMapMemory-size-00680\", \"If size is not equal to VK_WHOLE_SIZE, size must be greater than 0\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (size == 0) {\n    skip |= LogError(map2 ? \"VUID-VkMemoryMapInfoKHR-size-07960\" : \"VUID-vkMapMemory-size-00680\", memory, size_loc, \"is zero.\");\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkMemoryMapInfoKHR-memory-07958\", \"memory must not be currently host mapped\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (mem_info.mapped_range.size != 0) {\n    skip |= LogError(map2 ? \"VUID-VkMemoryMapInfoKHR-memory-07958\" : \"VUID-vkMapMemory-memory-00678\", memory, loc,\n                     \"memory has already be mapped.\");\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-vkMapMemory-memory-00678\", \"memory must not be currently host mapped\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (mem_info.mapped_range.size != 0) {\n    skip |= LogError(map2 ? \"VUID-VkMemoryMapInfoKHR-memory-07958\" : \"VUID-vkMapMemory-memory-00678\", memory, loc,\n                     \"memory has already be mapped.\");\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-vkMapMemory-offset-00679\", \"offset must be less than the size of memory\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (offset >= allocationSize) {\n    skip |= LogError(map2 ? \"VUID-VkMemoryMapInfoKHR-offset-07959\" : \"VUID-vkMapMemory-offset-00679\", memory, offset_loc,\n                     \"0x%\" PRIx64 \" is larger than the total array size 0x%\" PRIx64, offset, allocationSize);\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-vkMapMemory-flags-09568\", \"VK_MEMORY_MAP_PLACED_BIT_EXT must not be set in flags\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (flags & VK_MEMORY_MAP_PLACED_BIT_EXT) {\n    skip |= LogError(\"VUID-vkMapMemory-flags-09568\", memory, error_obj.location.dot(Field::flags),\n                     \"VK_MEMORY_MAP_PLACED_BIT_EXT is not allowed in vkMapMemory()\");\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkMemoryMapInfoKHR-flags-09569\", \"If VK_MEMORY_MAP_PLACED_BIT_EXT is set in flags, the memoryMapPlaced feature must be enabled\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (!enabled_features.memoryMapPlaced) {\n    skip |= LogError(\"VUID-VkMemoryMapInfoKHR-flags-09569\", pMemoryMapInfo->memory, error_obj.location,\n                     \"(%s) has VK_MEMORY_MAP_PLACED_BIT_EXT set but memoryMapPlaced is not enabled\",\n                     string_VkMemoryMapFlags(pMemoryMapInfo->flags).c_str());\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkMemoryMapInfoKHR-flags-09573\", \"If VK_MEMORY_MAP_PLACED_BIT_EXT is set in flags and the memoryMapRangePlaced feature is enabled, offset must be aligned to an integer multiple of VkPhysicalDeviceMapMemoryPlacedPropertiesEXT::minPlacedMemoryMapAlignment\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (pMemoryMapInfo->offset % phys_dev_ext_props.map_memory_placed_props.minPlacedMemoryMapAlignment != 0) {\n    skip |= LogError(\"VUID-VkMemoryMapInfoKHR-flags-09573\", pMemoryMapInfo->memory, info_loc.dot(Field::offset),\n                     \"(0x%\" PRIx64\n                     \") is not an integer multiple of \"\n                     \"minPlacedMemoryMapAlignment (0x%\" PRIx64 \") while VK_MEMORY_MAP_PLACED_BIT_EXT is set\",\n                     pMemoryMapInfo->offset, phys_dev_ext_props.map_memory_placed_props.minPlacedMemoryMapAlignment);\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkMemoryMapInfoKHR-flags-09572\", \"If VK_MEMORY_MAP_PLACED_BIT_EXT is set in flags and the memoryMapRangePlaced feature is not enabled, size must be VK_WHOLE_SIZE or VkMemoryAllocateInfo::allocationSize\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (pMemoryMapInfo->size != VK_WHOLE_SIZE && pMemoryMapInfo->size != mem_info->allocate_info.allocationSize) {\n    skip |= LogError(\"VUID-VkMemoryMapInfoKHR-flags-09572\", pMemoryMapInfo->memory, info_loc.dot(Field::size),\n                     \"(0x%\" PRIx64 \") is not VK_WHOLE_SIZE or the size of memory (%\" PRIu64\n                     \") while VK_MEMORY_MAP_PLACED_BIT_EXT is set and memoryMapRangePlaced is not enabled.\",\n                     pMemoryMapInfo->size, mem_info->allocate_info.allocationSize);\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkMemoryMapInfoKHR-flags-09651\", \"If VK_MEMORY_MAP_PLACED_BIT_EXT is set in flags and size is VK_WHOLE_SIZE, VkMemoryAllocateInfo::allocationSize must be aligned to an integer multiple of VkPhysicalDeviceMapMemoryPlacedPropertiesEXT::minPlacedMemoryMapAlignment\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (mem_info->allocate_info.allocationSize % phys_dev_ext_props.map_memory_placed_props.minPlacedMemoryMapAlignment !=\n    skip |= LogError(\"VUID-VkMemoryMapInfoKHR-flags-09651\", pMemoryMapInfo->memory, info_loc.dot(Field::size),\n                     \"is VK_WHOLE_SIZE but the size of the memory (0x%\" PRIx64\n                     \") is not an integer multiple of minPlacedMemoryMapAlignment (0x%\" PRIx64 \")\",\n                     mem_info->allocate_info.allocationSize,\n                     phys_dev_ext_props.map_memory_placed_props.minPlacedMemoryMapAlignment);\n"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkMemoryMapInfoKHR-flags-09574\", \"If VK_MEMORY_MAP_PLACED_BIT_EXT is set in flags and size is not VK_WHOLE_SIZE, size must be aligned to an integer multiple of VkPhysicalDeviceMapMemoryPlacedPropertiesEXT::minPlacedMemoryMapAlignment\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (pMemoryMapInfo->size % phys_dev_ext_props.map_memory_placed_props.minPlacedMemoryMapAlignment != 0) {\n    skip |= LogError(\"VUID-VkMemoryMapInfoKHR-flags-09574\", pMemoryMapInfo->memory, info_loc.dot(Field::size),\n                     \"(0x%\" PRIx64\n                     \") is not VK_WHOLE_SIZE and is not an integer multiple of \"\n                     \"minPlacedMemoryMapAlignment (0x%\" PRIx64 \") while VK_MEMORY_MAP_PLACED_BIT_EXT is set\",\n                     pMemoryMapInfo->size, phys_dev_ext_props.map_memory_placed_props.minPlacedMemoryMapAlignment);\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkMemoryMapInfoKHR-flags-09575\", \"If VK_MEMORY_MAP_PLACED_BIT_EXT is set in flags, the memory object must not have been imported from a handle type of VK_EXTERNAL_MEMORY_HANDLE_TYPE_HOST_ALLOCATION_BIT_EXT or VK_EXTERNAL_MEMORY_HANDLE_TYPE_HOST_MAPPED_FOREIGN_MEMORY_BIT_EXT\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (mem_info->IsImport() &&\n    skip |= LogError(\"VUID-VkMemoryMapInfoKHR-flags-09575\", pMemoryMapInfo->memory, info_loc.dot(Field::flags),\n                     \"(%s) has VK_MEMORY_MAP_PLACED_BIT_EXT set but memory was imported with a handle type of %s\",\n                     string_VkMemoryMapFlags(pMemoryMapInfo->flags).c_str(),\n                     string_VkExternalMemoryHandleTypeFlagBits(mem_info->import_handle_type.value()));\n"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkMemoryMapInfoKHR-flags-09570\", \"If VK_MEMORY_MAP_PLACED_BIT_EXT is set in flags, the pNext chain must include a VkMemoryMapPlacedInfoEXT structure and VkMemoryMapPlacedInfoEXT::pPlacedAddress must not be NULL\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "\"does not contain VkMemoryMapPlacedInfoEXT, but VK_MEMORY_MAP_PLACED_BIT_EXT was set in flags (%s)\",\nstring_VkMemoryMapFlags(pMemoryMapInfo->flags).c_str());\nskip |= LogError(\"VUID-VkMemoryMapInfoKHR-flags-09570\", pMemoryMapInfo->memory, addr_loc,\n\"is NULL, but VK_MEMORY_MAP_PLACED_BIT_EXT was set in flags (%s)\",\nstring_VkMemoryMapFlags(pMemoryMapInfo->flags).c_str());\n"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkMemoryMapPlacedInfoEXT-pPlacedAddress-09577\", \"pPlacedAddress must be aligned to an integer multiple of VkPhysicalDeviceMapMemoryPlacedPropertiesEXT::minPlacedMemoryMapAlignment\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "} else if (reinterpret_cast<std::uintptr_t>(placed_info->pPlacedAddress) %\n    skip |= LogError(\"VUID-VkMemoryMapPlacedInfoEXT-pPlacedAddress-09577\", pMemoryMapInfo->memory, addr_loc,\n                     \"(%p) is not an integer multiple of \"\n                     \"minPlacedMemoryMapAlignment (0x%\" PRIx64 \")\",\n                     placed_info->pPlacedAddress, phys_dev_ext_props.map_memory_placed_props.minPlacedMemoryMapAlignment);\n"
        },
        {
            "role": "user",
            "content": "{\"VUID-vkUnmapMemory-memory-00689\", \"memory must be currently host mapped\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (!mem_info->mapped_range.size) {\n    skip |= LogError(\"VUID-vkUnmapMemory-memory-00689\", memory, error_obj.location,\n                     \"Unmapping Memory without memory being mapped.\");\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkMemoryUnmapInfoKHR-memory-07964\", \"memory must be currently host mapped\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (!mem_info->mapped_range.size) {\n    const Location info_loc = error_obj.location.dot(Field::pMemoryUnmapInfo);\n    skip |= LogError(\"VUID-VkMemoryUnmapInfoKHR-memory-07964\", pMemoryUnmapInfo->memory, error_obj.location,\n                     \"Unmapping Memory without memory being mapped.\");\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkMemoryUnmapInfoKHR-flags-09580\", \"If VK_MEMORY_UNMAP_RESERVE_BIT_EXT is set in flags, the memory object must not have been imported from a handle type of VK_EXTERNAL_MEMORY_HANDLE_TYPE_HOST_ALLOCATION_BIT_EXT or VK_EXTERNAL_MEMORY_HANDLE_TYPE_HOST_MAPPED_FOREIGN_MEMORY_BIT_EXT\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (mem_info->IsImport() &&\n    skip |= LogError(\"VUID-VkMemoryUnmapInfoKHR-flags-09580\", pMemoryUnmapInfo->memory, info_loc.dot(Field::flags),\n                     \"VK_MEMORY_MAP_PLACED_BIT_EXT is set but memory was imported with a handle type of %s\",\n                     string_VkExternalMemoryHandleTypeFlagBits(mem_info->import_handle_type.value()));\n"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkMappedMemoryRange-memory-00684\", \"memory must be currently host mapped\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (mem_info->mapped_range.size == 0) {\n    skip |= LogError(\"VUID-VkMappedMemoryRange-memory-00684\", mem_ranges[i].memory, memory_range_loc,\n                     \"Attempting to use memory (%s) that is not currently host mapped.\",\n                     FormatHandle(mem_ranges[i].memory).c_str());\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkMappedMemoryRange-size-00686\", \"If size is equal to VK_WHOLE_SIZE, offset must be within the currently mapped range of memory\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (mem_info->mapped_range.offset > mem_ranges[i].offset) {\n    skip |= LogError(\"VUID-VkMappedMemoryRange-size-00686\", mem_ranges[i].memory, memory_range_loc.dot(Field::offset),\n                     \"(%\" PRIu64 \") is less than the mapped memory offset (%\" PRIu64 \") (and size is VK_WHOLE_SIZE).\",\n                     mem_ranges[i].offset, mem_info->mapped_range.offset);\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkMappedMemoryRange-size-00685\", \"If size is not equal to VK_WHOLE_SIZE, offset and size must specify a range contained within the currently mapped range of memory\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if ((data_end < (mem_ranges[i].offset + mem_ranges[i].size))) {\n    skip |= LogError(\"VUID-VkMappedMemoryRange-size-00685\", mem_ranges[i].memory, memory_range_loc,\n                     \"size (%\" PRIu64 \") plus offset (%\" PRIu64\n                     \") \"\n                     \"exceed the Memory Object's upper-bound (%\" PRIu64 \").\",\n                     mem_ranges[i].size, mem_ranges[i].offset, data_end);\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkMappedMemoryRange-size-01389\", \"If size is equal to VK_WHOLE_SIZE, the end of the current mapping of memory must either be a multiple of VkPhysicalDeviceLimits::nonCoherentAtomSize bytes from the beginning of the memory object, or be equal to the end of the memory object\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (SafeModulo(mapping_end, atom_size) != 0 && mapping_end != allocation_size) {\n    skip |= LogError(\"VUID-VkMappedMemoryRange-size-01389\", mem_ranges->memory, memory_range_loc.dot(Field::size),\n                     \"is VK_WHOLE_SIZE and the mapping end (%\" PRIu64 \" = %\" PRIu64 \" + %\" PRIu64\n                     \") not a multiple of VkPhysicalDeviceLimits::nonCoherentAtomSize (%\" PRIu64\n                     \") and not equal to the end of the memory object (%\" PRIu64 \").\",\n                     mapping_end, mapping_offset, mapping_size, atom_size, allocation_size);\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkMappedMemoryRange-size-01390\", \"If size is not equal to VK_WHOLE_SIZE, size must either be a multiple of VkPhysicalDeviceLimits::nonCoherentAtomSize, or offset plus size must equal the size of memory\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (range_end != allocation_size && SafeModulo(size, atom_size) != 0) {\n    skip |= LogError(\"VUID-VkMappedMemoryRange-size-01390\", mem_ranges->memory, memory_range_loc.dot(Field::size),\n                     \"(%\" PRIu64 \") is not a multiple of VkPhysicalDeviceLimits::nonCoherentAtomSize (%\" PRIu64\n                     \") and offset + size (%\" PRIu64 \" + %\" PRIu64 \" = %\" PRIu64\n                     \") not equal to the memory size (%\" PRIu64 \").\",\n                     size, atom_size, offset, size, range_end, allocation_size);\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-vkGetDeviceMemoryCommitment-memory-00690\", \"memory must have been created with a memory type that reports VK_MEMORY_PROPERTY_LAZILY_ALLOCATED_BIT\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if ((phys_dev_mem_props.memoryTypes[mem_info->allocate_info.memoryTypeIndex].propertyFlags &\n    skip |= LogError(\"VUID-vkGetDeviceMemoryCommitment-memory-00690\", memory, error_obj.location,\n                     \"Querying commitment for memory without \"\n                     \"VK_MEMORY_PROPERTY_LAZILY_ALLOCATED_BIT set: %s.\",\n                     FormatHandle(memory).c_str());\n"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkBindImageMemoryInfo-image-07736\", \"If image was created with the VK_IMAGE_CREATE_DISJOINT_BIT bit set, then the pNext chain must include a VkBindImagePlaneMemoryInfo structure\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (image_state->disjoint && plane_info == nullptr) {\n    const LogObjectList objlist(bind_info.image, bind_info.memory);\n    skip |= LogError(\"VUID-VkBindImageMemoryInfo-image-07736\", objlist, loc.dot(Field::image),\n                     \"is disjoint, add a VkBindImagePlaneMemoryInfo structure to the pNext chain of \"\n                     \"VkBindImageMemoryInfo in order to bind planes of a disjoint image.\");\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-vkBindImageMemory2-pBindInfos-04006\", \"pBindInfos must not refer to the same image subresource more than once\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "const LogObjectList objlist(bind_info.image, bind_info.memory);\nskip |= LogError(\"VUID-vkBindImageMemory2-pBindInfos-04006\", objlist, loc.dot(Field::image),\n                 \"is a disjoint image for plane %d but is being bound twice at \"\n                 \"pBindInfos[%d]\",\n                 plane, it->second[plane]);\n"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkImportMemoryWin32HandleInfoKHR-handleType-00658\", \"If handleType is not 0, it must be supported for import, as reported by VkExternalImageFormatProperties or VkExternalBufferProperties\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (!HasExternalMemoryImportSupport(*image_state, mem_info->import_handle_type.value())) {\n    const LogObjectList objlist(bind_info.image, bind_info.memory);\n    skip |= LogError(\"VUID-VkImportMemoryWin32HandleInfoKHR-handleType-00658\", objlist, loc.dot(Field::memory),\n                     \"(%s) was imported from handleType %s but VkExternalImageFormatProperties does not report \"\n                     \"it as importable.\",\n                     FormatHandle(bind_info.memory).c_str(),\n                     string_VkExternalMemoryHandleTypeFlagBits(mem_info->import_handle_type.value()));\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkBindImageMemoryInfo-pNext-01631\", \"If the pNext chain includes a VkBindImageMemorySwapchainInfoKHR structure, memory must be VK_NULL_HANDLE\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (bind_info.memory != VK_NULL_HANDLE) {\n    const LogObjectList objlist(bind_info.image, bind_info.memory);\n    skip |= LogError(\"VUID-VkBindImageMemoryInfo-pNext-01631\", objlist, loc.dot(Field::memory),\n                     \"(%s) is not VK_NULL_HANDLE.\", FormatHandle(bind_info.memory).c_str());\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkBindImageMemorySwapchainInfoKHR-imageIndex-01644\", \"imageIndex must be less than the number of images in swapchain\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (swapchain_state->images.size() <= swapchain_info->imageIndex) {\n    const LogObjectList objlist(bind_info.image, bind_info.memory);\n    skip |= LogError(\"VUID-VkBindImageMemorySwapchainInfoKHR-imageIndex-01644\", objlist,\n                     loc.pNext(Struct::VkBindImageMemorySwapchainInfoKHR, Field::swapchain),\n                     \"imageIndex (%\" PRIu32 \") is out of bounds of %s images (size: %zu)\",\n                     swapchain_info->imageIndex, FormatHandle(swapchain_info->swapchain).c_str(),\n                     swapchain_state->images.size());\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkBindImageMemoryInfo-image-01630\", \"If image was created with a valid swapchain handle in VkImageSwapchainCreateInfoKHR::swapchain, then the pNext chain must include a VkBindImageMemorySwapchainInfoKHR structure containing the same swapchain handle\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (image_state->create_from_swapchain) {\n    const LogObjectList objlist(bind_info.image, bind_info.memory);\n    skip |= LogError(\"VUID-VkBindImageMemoryInfo-image-01630\", objlist, loc,\n                     \"pNext doesn't include VkBindImageMemorySwapchainInfoKHR.\");\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkBindImageMemoryInfo-pNext-01632\", \"If the pNext chain does not include a VkBindImageMemorySwapchainInfoKHR structure, memory must be a valid VkDeviceMemory handle\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (!mem_info) {\n    const LogObjectList objlist(bind_info.image, bind_info.memory);\n    skip |= LogError(\"VUID-VkBindImageMemoryInfo-pNext-01632\", objlist, loc.dot(Field::memory), \"(%s) is invalid.\",\n                     FormatHandle(bind_info.memory).c_str());\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkBindImageMemoryInfo-pNext-01627\", \"If the pNext chain includes a VkBindImageMemoryDeviceGroupInfo structure, and VkBindImageMemoryDeviceGroupInfo::splitInstanceBindRegionCount is not zero, then image must have been created with the VK_IMAGE_CREATE_SPLIT_INSTANCE_BIND_REGIONS_BIT bit set\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (!(image_state->create_info.flags & VK_IMAGE_CREATE_SPLIT_INSTANCE_BIND_REGIONS_BIT)) {\n    const LogObjectList objlist(bind_info.image, bind_info.memory);\n    skip |= LogError(\"VUID-VkBindImageMemoryInfo-pNext-01627\", objlist,\n                     loc.pNext(Struct::VkBindImageMemoryDeviceGroupInfo, Field::splitInstanceBindRegionCount),\n                     \"(%\" PRId32\n                     \") is not 0 and %s is not created with \"\n                     \"VK_IMAGE_CREATE_SPLIT_INSTANCE_BIND_REGIONS_BIT.\",\n                     bind_image_memory_device_group_info->splitInstanceBindRegionCount,\n                     FormatHandle(bind_info.image).c_str());\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkBindImagePlaneMemoryInfo-planeAspect-02283\", \"If the image's tiling is VK_IMAGE_TILING_LINEAR or VK_IMAGE_TILING_OPTIMAL, then planeAspect must be a single valid multi-planar aspect mask bit\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (vkuFormatIsMultiplane(image_format) && !IsOnlyOneValidPlaneAspect(image_format, aspect)) {\n    const LogObjectList objlist(bind_info.image, bind_info.memory);\n    skip |= LogError(\"VUID-VkBindImagePlaneMemoryInfo-planeAspect-02283\", objlist,\n                     loc.pNext(Struct::VkBindImagePlaneMemoryInfo, Field::planeAspect),\n                     \"is %s but is invalid for %s.\", string_VkImageAspectFlags(aspect).c_str(),\n                     string_VkFormat(image_format));\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkBindImageMemoryDeviceGroupInfo-deviceIndexCount-01633\", \"At least one of deviceIndexCount and splitInstanceBindRegionCount must be zero\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (bind_image_memory_device_group->deviceIndexCount > 0 &&\n    const LogObjectList objlist(bind_info.image, bind_info.memory);\n    skip |= LogError(\"VUID-VkBindImageMemoryDeviceGroupInfo-deviceIndexCount-01633\", objlist, loc,\n                     \"VkBindImageMemoryDeviceGroupInfo has both deviceIndexCount (%\" PRIu32\n                     \") and splitInstanceBindRegionCount (%\" PRIu32 \") greater than 0.\",\n                     bind_image_memory_device_group->deviceIndexCount,\n                     bind_image_memory_device_group->splitInstanceBindRegionCount);\n"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkBindImageMemoryDeviceGroupInfo-deviceIndexCount-01634\", \"deviceIndexCount must either be zero or equal to the number of physical devices in the logical device\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "bind_image_memory_device_group->deviceIndexCount != device_group_create_info.physicalDeviceCount &&\nconst LogObjectList objlist(bind_info.image, bind_info.memory);\nskip |= LogError(\"VUID-VkBindImageMemoryDeviceGroupInfo-deviceIndexCount-01634\", objlist,\n                 loc.pNext(Struct::VkBindImageMemoryDeviceGroupInfo, Field::deviceIndexCount),\n                 \"is %\" PRIu32 \", but the number of physical devices in the logical device is %\" PRIu32 \".\",\n                 bind_image_memory_device_group->deviceIndexCount, device_group_create_info.physicalDeviceCount);\n"
        },
        {
            "role": "user",
            "content": "{\"VUID-vkBindImageMemory2-pBindInfos-02858\", \"If any VkBindImageMemoryInfo::image was created with VK_IMAGE_CREATE_DISJOINT_BIT then all planes of VkBindImageMemoryInfo::image must be bound individually in separate pBindInfos\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (resource.second[i] == vvl::kU32Max) {\n    skip |= LogError(\"VUID-vkBindImageMemory2-pBindInfos-02858\", resource.first, error_obj.location,\n                     \"Plane %u of the disjoint image was not bound. All %d planes need to bound individually \"\n                     \"in separate pBindInfos in a single call.\",\n                     i, total_planes);\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-vkBindImageMemory-image-01608\", \"image must not have been created with the VK_IMAGE_CREATE_DISJOINT_BIT set\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (image_state->disjoint == true) {\n    const LogObjectList objlist(image, memory);\n    skip |= LogError(\"VUID-vkBindImageMemory-image-01608\", objlist, error_obj.location.dot(Field::image),\n                     \"was created with the VK_IMAGE_CREATE_DISJOINT_BIT (need to use vkBindImageMemory2).\");\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkSparseMemoryBind-memory-01096\", \"If memory is not VK_NULL_HANDLE, memory and memoryOffset must match the memory requirements of the resource, as described in section Resource Memory Association\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (!((uint32_t(1) << mem_state->allocate_info.memoryTypeIndex) & requirements.memoryTypeBits)) {\n    const LogObjectList objlist(bind.memory, resource_handle);\n    skip |= LogError(\"VUID-VkSparseMemoryBind-memory-01096\", objlist, loc.dot(Field::memory),\n                     \"has a type index (%\" PRIu32 \") that is not among the allowed types mask (0x%\" PRIX32\n                     \") for this resource.\",\n                     mem_state->allocate_info.memoryTypeIndex, requirements.memoryTypeBits);\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkSparseMemoryBind-memory-01096\", \"If memory is not VK_NULL_HANDLE, memory and memoryOffset must match the memory requirements of the resource, as described in section Resource Memory Association\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (SafeModulo(bind.memoryOffset, requirements.alignment) != 0) {\n    const LogObjectList objlist(bind.memory, resource_handle);\n    skip |= LogError(\"VUID-VkSparseMemoryBind-memory-01096\", objlist, loc.dot(Field::memoryOffset),\n                     \"(%\" PRIu64 \") is not a multiple of required memory alignment (%\" PRIu64 \")\", bind.memoryOffset,\n                     requirements.alignment);\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkSparseMemoryBind-memory-01097\", \"If memory is not VK_NULL_HANDLE, memory must not have been created with a memory type that reports VK_MEMORY_PROPERTY_LAZILY_ALLOCATED_BIT bit set\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (phys_dev_mem_props.memoryTypes[mem_state->allocate_info.memoryTypeIndex].propertyFlags &\n    const LogObjectList objlist(bind.memory, resource_handle);\n    skip |= LogError(\"VUID-VkSparseMemoryBind-memory-01097\", objlist, loc.dot(Field::memory),\n                     \"type has VK_MEMORY_PROPERTY_LAZILY_ALLOCATED_BIT bit set.\");\n"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkSparseMemoryBind-memoryOffset-01101\", \"memoryOffset must be less than the size of memory\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (bind.memoryOffset >= mem_state->allocate_info.allocationSize) {\n    const LogObjectList objlist(bind.memory, resource_handle);\n    skip |= LogError(\"VUID-VkSparseMemoryBind-memoryOffset-01101\", objlist, loc.dot(Field::memoryOffset),\n                     \"(%\" PRIu64 \") must be less than the size of memory (%\" PRIu64 \")\", bind.memoryOffset,\n                     mem_state->allocate_info.allocationSize);\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkSparseMemoryBind-size-01102\", \"size must be less than or equal to the size of memory minus memoryOffset\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if ((mem_state->allocate_info.allocationSize - bind.memoryOffset) < bind.size) {\n    const LogObjectList objlist(bind.memory, resource_handle);\n    skip |= LogError(\"VUID-VkSparseMemoryBind-size-01102\", objlist, loc.dot(Field::size),\n                     \"(%\" PRIu64 \") must be less than or equal to the size of memory (%\" PRIu64\n                     \") minus memoryOffset (%\" PRIu64 \").\",\n                     bind.size, mem_state->allocate_info.allocationSize, bind.memoryOffset);\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkSparseMemoryBind-memory-02730\", \"If memory was created with VkExportMemoryAllocateInfo::handleTypes not equal to 0, at least one handle type it contained must also have been set in VkExternalMemoryBufferCreateInfo::handleTypes or VkExternalMemoryImageCreateInfo::handleTypes when the resource was created\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (!(mem_state->export_handle_types & external_handle_types)) {\n    const LogObjectList objlist(bind.memory, resource_handle);\n    skip |= LogError(\"VUID-VkSparseMemoryBind-memory-02730\", objlist,\n                     loc.dot(Field::memory).pNext(Struct::VkExportMemoryAllocateInfo).dot(Field::handleTypes),\n                     \"is %s, but the external handle types specified in resource are %s.\",\n                     string_VkExternalMemoryHandleTypeFlags(mem_state->export_handle_types).c_str(),\n                     string_VkExternalMemoryHandleTypeFlags(external_handle_types).c_str());\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkSparseMemoryBind-memory-02731\", \"If memory was created by a memory import operation, the external handle type of the imported memory must also have been set in VkExternalMemoryBufferCreateInfo::handleTypes or VkExternalMemoryImageCreateInfo::handleTypes when the resource was created\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (!(*mem_state->import_handle_type & external_handle_types)) {\n    const LogObjectList objlist(bind.memory, resource_handle);\n    skip |= LogError(\"VUID-VkSparseMemoryBind-memory-02731\", objlist, loc.dot(Field::memory),\n                     \"was created with memory import operation, with handle type %s, but the external handle types \"\n                     \"specified in resource are %s.\",\n                     string_VkExternalMemoryHandleTypeFlagBits(*mem_state->import_handle_type),\n                     string_VkExternalMemoryHandleTypeFlags(external_handle_types).c_str());\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkSparseMemoryBind-size-01098\", \"size must be greater than 0\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (bind.size <= 0) {\n    const LogObjectList objlist(bind.memory, resource_handle);\n    skip |= LogError(\"VUID-VkSparseMemoryBind-size-01098\", objlist, loc.dot(Field::size),\n                     \"(%\" PRIu64 \") must be greater than 0.\", bind.size);\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkSparseImageMemoryBindInfo-subresource-01723\", \"The subresource.arrayLayer member of each element of pBinds must be less than the arrayLayers specified in VkImageCreateInfo when image was created\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (subresource.arrayLayer >= image_state.create_info.arrayLayers) {\n    skip |= LogError(\"VUID-VkSparseImageMemoryBindInfo-subresource-01723\", image_state.Handle(),\n                     subresource_loc.dot(Field::arrayLayer),\n                     \"(%\" PRIu32 \") is not less than arrayLayers (%\" PRIu32 \") of %s.image.\", subresource.arrayLayer,\n                     image_state.create_info.arrayLayers, bind_loc.Fields().c_str());\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkSparseImageMemoryBind-memory-02732\", \"If memory was created with VkExportMemoryAllocateInfo::handleTypes not equal to 0, at least one handle type it contained must also have been set in VkExternalMemoryImageCreateInfo::handleTypes when the image was created\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (!(mem_state->export_handle_types & image_state->external_memory_handle_types)) {\n    const LogObjectList objlist(bind.memory, image_state->Handle());\n    skip |= LogError(\"VUID-VkSparseImageMemoryBind-memory-02732\", objlist,\n                     memory_loc.dot(Field::memory).pNext(Struct::VkExportMemoryAllocateInfo).dot(Field::handleTypes),\n                     \"is %s, but the external handle types specified in resource are %s.\",\n                     string_VkExternalMemoryHandleTypeFlags(mem_state->export_handle_types).c_str(),\n                     string_VkExternalMemoryHandleTypeFlags(image_state->external_memory_handle_types).c_str());\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkSparseImageMemoryBind-memory-02733\", \"If memory was created by a memory import operation, the external handle type of the imported memory must also have been set in VkExternalMemoryImageCreateInfo::handleTypes when image was created\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (!(*mem_state->import_handle_type & image_state->external_memory_handle_types)) {\n    const LogObjectList objlist(bind.memory, image_state->Handle());\n    skip |= LogError(\"VUID-VkSparseImageMemoryBind-memory-02733\", objlist, memory_loc.dot(Field::memory),\n                     \"was created with memory import operation, with handle type %s, but the external handle types \"\n                     \"specified in resource are %s.\",\n                     string_VkExternalMemoryHandleTypeFlagBits(*mem_state->import_handle_type),\n                     string_VkExternalMemoryHandleTypeFlags(image_state->external_memory_handle_types).c_str());\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkSparseImageMemoryBind-offset-01107\", \"offset.x must be a multiple of the sparse image block width (VkSparseImageFormatProperties::imageGranularity.width) of the image\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (SafeModulo(bind.offset.x, granularity.width) != 0) {\n    skip |= LogError(\"VUID-VkSparseImageMemoryBind-offset-01107\", image_state->Handle(),\n                     bind_loc.dot(Field::offset).dot(Field::x),\n                     \"(%\" PRId32\n                     \") must be a multiple of the sparse image block width \"\n                     \"(VkSparseImageFormatProperties::imageGranularity.width (%\" PRIu32 \")) of the image.\",\n                     bind.offset.x, granularity.width);\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkSparseImageMemoryBind-offset-01111\", \"offset.z must be a multiple of the sparse image block depth (VkSparseImageFormatProperties::imageGranularity.depth) of the image\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (SafeModulo(bind.offset.z, granularity.depth) != 0) {\n    skip |= LogError(\"VUID-VkSparseImageMemoryBind-offset-01111\", image_state->Handle(),\n                     bind_loc.dot(Field::offset).dot(Field::z),\n                     \"(%\" PRId32\n                     \") must be a multiple of the sparse image block depth \"\n                     \"(VkSparseImageFormatProperties::imageGranularity.depth (%\" PRIu32 \")) of the image.\",\n                     bind.offset.z, granularity.depth);\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkSparseImageMemoryBind-extent-01108\", \"extent.width must either be a multiple of the sparse image block width of the image, or else (extent.width + offset.x) must equal the width of the image subresource\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if ((SafeModulo(bind.extent.width, granularity.width) != 0) &&\n    ((bind.extent.width + bind.offset.x) != subresource_extent.width)) {\n    skip |= LogError(\"VUID-VkSparseImageMemoryBind-extent-01108\", image_state->Handle(),\n                     bind_loc.dot(Field::extent).dot(Field::width),\n                     \"(%\" PRIu32\n                     \") must either be a multiple of the sparse image block width \"\n                     \"(VkSparseImageFormatProperties::imageGranularity.width (%\" PRIu32\n                     \")) of the image, or else (extent.width + offset.x) (%\" PRIu32\n                     \") must equal the width of the image subresource (%\" PRIu32 \").\",\n                     bind.extent.width, granularity.width, bind.extent.width + bind.offset.x, subresource_extent.width);\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkSparseImageMemoryBind-extent-01110\", \"extent.height must either be a multiple of the sparse image block height of the image, or else (extent.height + offset.y) must equal the height of the image subresource\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if ((SafeModulo(bind.extent.height, granularity.height) != 0) &&\n    ((bind.extent.height + bind.offset.y) != subresource_extent.height)) {\n    skip |= LogError(\"VUID-VkSparseImageMemoryBind-extent-01110\", image_state->Handle(),\n                     bind_loc.dot(Field::extent).dot(Field::height),\n                     \"(%\" PRIu32\n                     \") must either be a multiple of the sparse image block height \"\n                     \"(VkSparseImageFormatProperties::imageGranularity.height (%\" PRIu32\n                     \")) of the image, or else (extent.height + offset.y) (%\" PRIu32\n                     \") must equal the height of the image subresource (%\" PRIu32 \").\",\n                     bind.extent.height, granularity.height, bind.extent.height + bind.offset.y, subresource_extent.height);\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkSparseImageMemoryBind-extent-01112\", \"extent.depth must either be a multiple of the sparse image block depth of the image, or else (extent.depth + offset.z) must equal the depth of the image subresource\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if ((SafeModulo(bind.extent.depth, granularity.depth) != 0) &&\n    ((bind.extent.depth + bind.offset.z) != subresource_extent.depth)) {\n    skip |= LogError(\"VUID-VkSparseImageMemoryBind-extent-01112\", image_state->Handle(),\n                     bind_loc.dot(Field::extent).dot(Field::depth),\n                     \"(%\" PRIu32\n                     \") must either be a multiple of the sparse image block depth \"\n                     \"(VkSparseImageFormatProperties::imageGranularity.depth (%\" PRIu32\n                     \")) of the image, or else (extent.depth + offset.z) (%\" PRIu32\n                     \") must equal the depth of the image subresource (%\" PRIu32 \").\",\n                     bind.extent.depth, granularity.depth, bind.extent.depth + bind.offset.z, subresource_extent.depth);\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-vkCmdCopyMemoryIndirectNV-copyBufferAddress-07654\", \"copyBufferAddress must be 4 byte aligned\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (copyBufferAddress & 0x3) {\n    skip |= LogError(\"VUID-vkCmdCopyMemoryIndirectNV-copyBufferAddress-07654\", commandBuffer, \n                     error_obj.location.dot(Field::copyBufferAddress),\n                     \"(0x%\" PRIx64 \") is not 4-byte aligned\", copyBufferAddress);\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-vkCmdCopyMemoryIndirectNV-stride-07655\", \"stride must be a multiple of 4 and must be greater than or equal to sizeof(VkCopyMemoryIndirectCommandNV)\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (stride % 4 != 0 || stride < sizeof(VkCopyMemoryIndirectCommandKHR)) {\n    skip |= LogError(\"VUID-vkCmdCopyMemoryIndirectNV-stride-07655\", commandBuffer, \n                     error_obj.location.dot(Field::stride),\n                     \"(%u) must be a multiple of 4 and must be greater than or equal to size of VkCopyMemoryIndirectCommandKHR (%u)\",\n                     stride, sizeof(VkCopyMemoryIndirectCommandKHR));\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-vkCmdCopyMemoryIndirectNV-commandBuffer-07656\", \"The VkCommandPool that commandBuffer was allocated from must support at least one of the VkPhysicalDeviceCopyMemoryIndirectPropertiesKHR::supportedQueues\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (!(phys_dev_ext_props.copy_memory_indirect_props.supportedQueues & cb_state->command_pool->queue_flags)) {\n    skip |= LogError(\"VUID-vkCmdCopyMemoryIndirectNV-commandBuffer-07656\", commandBuffer,\n                     error_obj.location.dot(Field::commandBuffer),\n                     \"was allocated from a VkCommandPool that doesn't match the queues supported in \"\n                     \"VkPhysicalDeviceCopyMemoryIndirectPropertiesKHR::supportedQueues. \"\n                     \"Supported queues: %s, \"\n                     \"Command pool queues: %s\",\n                     string_VkQueueFlags(phys_dev_ext_props.copy_memory_indirect_props.supportedQueues).c_str(),\n                     string_VkQueueFlags(cb_state->command_pool->queue_flags).c_str());\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-vkCmdCopyMemoryToImageIndirectNV-None-07660\", \"The indirectMemoryToImageCopy feature must be enabled\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (!enabled_features.indirectMemoryToImageCopy) {\n    skip |= LogError(\"VUID-vkCmdCopyMemoryToImageIndirectNV-None-07660\", commandBuffer, error_obj.location,\n                     \"The indirectMemoryToImageCopy feature must be enabled.\");\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-vkCmdCopyMemoryToImageIndirectNV-aspectMask-07662\", \"The aspectMask member for every subresource in pImageSubresources must only have a single bit set\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (!IsPowerOfTwo(aspect_mask)) {\n    skip |= LogError(\"VUID-vkCmdCopyMemoryToImageIndirectNV-aspectMask-07662\", commandBuffer,\n                     subresource_loc.dot(Field::aspectMask),\n                     \"(0x%\" PRIx32 \") in region (%d) must have only a single bit set.\", aspect_mask, i);\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-vkCmdCopyMemoryToImageIndirectNV-mipLevel-07670\", \"The specified mipLevel of each region must be less than the mipLevels specified in VkImageCreateInfo when dstImage was created\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (mip_level >= dst_image_state->create_info.mipLevels) {\n    const LogObjectList objlist(commandBuffer, dstImage);\n    skip |= LogError(\"VUID-vkCmdCopyMemoryToImageIndirectNV-mipLevel-07670\", objlist,\n                     subresource_loc.dot(Field::mipLevel),\n                     \"(%u) of region (%d) must be less than the mipLevels (%u) specified in \"\n                     \"VkImageCreateInfo when dstImage was created.\",\n                     mip_level, i, dst_image_state->create_info.mipLevels);\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-vkCmdCopyMemoryToImageIndirectNV-commandBuffer-07674\", \"If the queue family used to create the VkCommandPool which commandBuffer was allocated from does not support VK_QUEUE_GRAPHICS_BIT, for each region, the aspectMask member of pImageSubresources must not be VK_IMAGE_ASPECT_DEPTH_BIT or VK_IMAGE_ASPECT_STENCIL_BIT\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (!(cb_state.command_pool->queue_flags & VK_QUEUE_GRAPHICS_BIT) &&\n    skip |= LogError(\"VUID-vkCmdCopyMemoryToImageIndirectNV-commandBuffer-07674\", commandBuffer,\n                     subresource_loc.dot(Field::aspectMask),\n                     \"If the queue family used to create the VkCommandPool which commandBuffer was allocated from does \"\n                     \"not support VK_QUEUE_GRAPHICS_BIT, \"\n                     \"the aspectMask member of region (%d) in pImageSubresources must not be VK_IMAGE_ASPECT_DEPTH_BIT \"\n                     \"or VK_IMAGE_ASPECT_STENCIL_BIT. \"\n                     \"Current aspectMask: 0x%\" PRIx32 \".\",\n                     i, string_VkQueueFlags(cb_state.command_pool->queue_flags).c_str());\n"
        },
        {
            "role": "user",
            "content": "{\"VUID-vkCmdCopyMemoryToImageIndirectNV-dstImage-07664\", \"dstImage must have been created with VK_IMAGE_USAGE_TRANSFER_DST_BIT usage flag\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (!(dst_image_state->create_info.usage & VK_IMAGE_USAGE_TRANSFER_DST_BIT)) {\n    const LogObjectList objlist(commandBuffer, dstImage);\n    skip |= LogError(\"VUID-vkCmdCopyMemoryToImageIndirectNV-dstImage-07664\", objlist, error_obj.location.dot(Field::dstImage),\n                     \"was created with usage (%s) which is missing VK_IMAGE_USAGE_TRANSFER_DST_BIT.\", string_VkImageUsageFlags(dst_image_state->create_info.usage).c_str());\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-vkCmdCopyMemoryToImageIndirectKHR-dstImage-07973\", \"dstImage must have a sample count equal to VK_SAMPLE_COUNT_1_BIT\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (dst_image_state->create_info.samples != VK_SAMPLE_COUNT_1_BIT) {\n    const LogObjectList objlist(commandBuffer, dstImage);\n    skip |= LogError(\"VUID-vkCmdCopyMemoryToImageIndirectKHR-dstImage-07973\", objlist, error_obj.location.dot(Field::dstImage),\n                     \"is created with %s but needs to be VK_SAMPLE_COUNT_1_BIT.\",\n                     string_VkSampleCountFlagBits(dst_image_state->create_info.samples));\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-vkCmdCopyMemoryToImageIndirectNV-dstImageLayout-07669\", \"dstImageLayout must be VK_IMAGE_LAYOUT_TRANSFER_DST_OPTIMAL, VK_IMAGE_LAYOUT_SHARED_PRESENT_KHR, or VK_IMAGE_LAYOUT_GENERAL\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (!IsValueIn(dstImageLayout,\n    const LogObjectList objlist(commandBuffer, dstImage);\n    skip |= LogError(\"VUID-vkCmdCopyMemoryToImageIndirectNV-dstImageLayout-07669\", objlist,\n                     error_obj.location.dot(Field::dstImageLayout), \"is %s.\", string_VkImageLayout(dstImageLayout));\n"
        },
        {
            "role": "user",
            "content": "{\"VUID-vkCmdCopyMemoryToImageIndirectNV-dstImage-07673\", \"dstImage must not have been created with flags containing VK_IMAGE_CREATE_SUBSAMPLED_BIT_EXT\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (dst_image_state->create_info.flags & VK_IMAGE_CREATE_SUBSAMPLED_BIT_EXT) {\n    const LogObjectList objlist(commandBuffer, dstImage);\n    skip |= LogError(\"VUID-vkCmdCopyMemoryToImageIndirectNV-dstImage-07673\", objlist, error_obj.location.dot(Field::dstImage),\n                     \"is created with %s (which contains VK_IMAGE_CREATE_SUBSAMPLED_BIT_EXT).\",\n                     string_VkImageCreateFlagBits((VkImageCreateFlagBits)dst_image_state->create_info.flags));\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-vkCmdCopyMemoryToImageIndirectNV-stride-07677\", \"stride must be a multiple of 4 and must be greater than or equal to sizeof(VkCopyMemoryToImageIndirectCommandKHR)\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (stride % 4 != 0 || stride < sizeof(VkCopyMemoryToImageIndirectCommandKHR)) {\n    skip |= LogError(\"VUID-vkCmdCopyMemoryToImageIndirectNV-stride-07677\", commandBuffer, error_obj.location.dot(Field::stride),\n                     \"(%u) must be a multiple of 4 and must be greater than or equal to \"\n                     \"size of VkCopyMemoryToImageIndirectCommandKHR (%u).\",\n                     stride, sizeof(VkCopyMemoryToImageIndirectCommandKHR));\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-vkGetBufferDeviceAddress-device-03325\", \"If device was created with multiple physical devices, then the bufferDeviceAddressMultiDevice or VkPhysicalDeviceBufferDeviceAddressFeaturesEXT::bufferDeviceAddressMultiDevice feature must be enabled\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (physical_device_count > 1 && !enabled_features.bufferDeviceAddressMultiDevice &&\n    skip |= LogError(\"VUID-vkGetBufferDeviceAddress-device-03325\", pInfo->buffer, error_obj.location,\n                     \"If device was created with multiple physical devices, then the \"\n                     \"bufferDeviceAddressMultiDevice feature must be enabled.\");\n"
        },
        {
            "role": "user",
            "content": "{\"VUID-vkGetBufferOpaqueCaptureAddress-None-03326\", \"The bufferDeviceAddress feature must be enabled\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (!enabled_features.bufferDeviceAddress) {\n    skip |= LogError(\"VUID-vkGetBufferOpaqueCaptureAddress-None-03326\", objlist, error_obj.location,\n                     \"The bufferDeviceAddress feature must be enabled.\");\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-vkGetBufferOpaqueCaptureAddress-device-03327\", \"If device was created with multiple physical devices, then the bufferDeviceAddressMultiDevice feature must be enabled\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (physical_device_count > 1 && !enabled_features.bufferDeviceAddressMultiDevice) {\n    skip |= LogError(\"VUID-vkGetBufferOpaqueCaptureAddress-device-03327\", objlist, error_obj.location,\n                     \"If device was created with multiple physical devices, then the \"\n                     \"bufferDeviceAddressMultiDevice feature must be enabled.\");\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-vkGetDeviceMemoryOpaqueCaptureAddress-None-03334\", \"The bufferDeviceAddress feature must be enabled\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (!enabled_features.bufferDeviceAddress) {\n    skip |= LogError(\"VUID-vkGetDeviceMemoryOpaqueCaptureAddress-None-03334\", objlst, error_obj.location,\n                     \"The bufferDeviceAddress feature was not enabled.\");\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkDeviceMemoryOpaqueCaptureAddressInfo-memory-03336\", \"memory must have been allocated with VK_MEMORY_ALLOCATE_DEVICE_ADDRESS_BIT\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (!chained_flags_struct || !(chained_flags_struct->flags & VK_MEMORY_ALLOCATE_DEVICE_ADDRESS_BIT)) {\n    skip |= LogError(\"VUID-VkDeviceMemoryOpaqueCaptureAddressInfo-memory-03336\", objlst, error_obj.location,\n                     \"memory must have been allocated with VK_MEMORY_ALLOCATE_DEVICE_ADDRESS_BIT.\");\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-vkCmdDrawMultiEXT-None-04933\", \"The multiDraw feature must be enabled\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (!enabled_features.multiDraw) {\n    skip |= LogError(\"VUID-vkCmdDrawMultiEXT-None-04933\", cb_state.GetObjectList(VK_PIPELINE_BIND_POINT_GRAPHICS),\n                     error_obj.location, \"The multiDraw feature was not enabled.\");\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-vkCmdDrawMultiEXT-drawCount-09628\", \"If drawCount is greater than 1, stride must be a multiple of 4 and must be greater than or equal to sizeof(VkMultiDrawInfoEXT)\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (drawCount > 1) {\n    skip |= ValidateCmdDrawStrideWithStruct(cb_state, \"VUID-vkCmdDrawMultiEXT-drawCount-09628\", stride,\n                                            Struct::VkMultiDrawInfoEXT, sizeof(VkMultiDrawInfoEXT), error_obj.location);\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-vkCmdDrawMultiEXT-drawCount-04935\", \"If drawCount is greater than zero, pVertexInfo must be a valid pointer to memory containing one or more valid instances of VkMultiDrawInfoEXT structures\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (drawCount != 0 && !pVertexInfo) {\n    skip |= LogError(\"VUID-vkCmdDrawMultiEXT-drawCount-04935\", cb_state.GetObjectList(VK_PIPELINE_BIND_POINT_GRAPHICS),\n                     error_obj.location.dot(Field::drawCount), \"is %\" PRIu32 \" but pVertexInfo is NULL.\", drawCount);\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-vkCmdDrawMultiIndexedEXT-drawCount-04939\", \"drawCount must be less than VkPhysicalDeviceMultiDrawPropertiesEXT::maxMultiDrawCount\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (drawCount > phys_dev_ext_props.multi_draw_props.maxMultiDrawCount) {\n    skip |= LogError(\"VUID-vkCmdDrawMultiIndexedEXT-drawCount-04939\", cb_state.GetObjectList(VK_PIPELINE_BIND_POINT_GRAPHICS),\n                     error_obj.location.dot(Field::drawCount),\n                     \"(%\" PRIu32 \") must be less than VkPhysicalDeviceMultiDrawPropertiesEXT::maxMultiDrawCount (%\" PRIu32 \").\",\n                     drawCount, phys_dev_ext_props.multi_draw_props.maxMultiDrawCount);\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-vkCmdDrawMultiIndexedEXT-drawCount-09629\", \"If drawCount is greater than 1, stride must be a multiple of 4 and must be greater than or equal to sizeof(VkMultiDrawIndexedInfoEXT)\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (drawCount > 1) {\n    skip |= ValidateCmdDrawStrideWithStruct(cb_state, \"VUID-vkCmdDrawMultiIndexedEXT-drawCount-09629\", stride,\n                                            Struct::VkMultiDrawIndexedInfoEXT, sizeof(VkMultiDrawIndexedInfoEXT),\n                                            error_obj.location);\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-vkCmdDrawMultiIndexedEXT-drawCount-04940\", \"If drawCount is greater than zero, pIndexInfo must be a valid pointer to memory containing one or more valid instances of VkMultiDrawIndexedInfoEXT structures\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (drawCount != 0 && !pIndexInfo) {\n    skip |= LogError(\"VUID-vkCmdDrawMultiIndexedEXT-drawCount-04940\", cb_state.GetObjectList(VK_PIPELINE_BIND_POINT_GRAPHICS),\n                     error_obj.location.dot(Field::drawCount), \"is %\" PRIu32 \" but pIndexInfo is NULL.\", drawCount);\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-vkCmdDrawIndirect-drawCount-02718\", \"If the multiDrawIndirect feature is not enabled, drawCount must be 0 or 1\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (!enabled_features.multiDrawIndirect && ((drawCount > 1))) {\n    skip |= LogError(\"VUID-vkCmdDrawIndirect-drawCount-02718\", cb_state.GetObjectList(VK_PIPELINE_BIND_POINT_GRAPHICS),\n                     error_obj.location.dot(Field::drawCount),\n                     \"(%\" PRIu32 \") must be 0 or 1 if multiDrawIndirect feature is not enabled.\", drawCount);\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-vkCmdDrawIndirect-offset-02710\", \"offset must be a multiple of 4\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (offset & 3) {\n    skip |= LogError(\"VUID-vkCmdDrawIndirect-offset-02710\", cb_state.GetObjectList(VK_PIPELINE_BIND_POINT_GRAPHICS),\n                     error_obj.location.dot(Field::offset), \"(%\" PRIu64 \") must be a multiple of 4.\", offset);\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-vkCmdDrawIndirect-drawCount-00476\", \"If drawCount is greater than 1, stride must be a multiple of 4 and must be greater than or equal to sizeof(VkDrawIndirectCommand)\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (drawCount > 1) {\n    skip |= ValidateCmdDrawStrideWithStruct(cb_state, \"VUID-vkCmdDrawIndirect-drawCount-00476\", stride,\n                                            Struct::VkDrawIndirectCommand, sizeof(VkDrawIndirectCommand), error_obj.location);\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-vkCmdDrawIndirect-drawCount-00488\", \"If drawCount is greater than 1, (stride \u00d7 (drawCount - 1) + offset + sizeof(VkDrawIndirectCommand)) must be less than or equal to the size of buffer\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (drawCount > 1) {\n    skip |= ValidateCmdDrawStrideWithStruct(cb_state, \"VUID-vkCmdDrawIndirect-drawCount-00476\", stride,\n    skip |= ValidateCmdDrawStrideWithBuffer(cb_state, \"VUID-vkCmdDrawIndirect-drawCount-00488\", stride,\n                                            Struct::VkDrawIndirectCommand, sizeof(VkDrawIndirectCommand), drawCount, offset,\n                                            *buffer_state, error_obj.location);\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-vkCmdDrawIndirect-drawCount-00487\", \"If drawCount is equal to 1, (offset + sizeof(VkDrawIndirectCommand)) must be less than or equal to the size of buffer\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "} else if ((drawCount == 1) && (offset + sizeof(VkDrawIndirectCommand)) > buffer_state->create_info.size) {\n    LogObjectList objlist = cb_state.GetObjectList(VK_PIPELINE_BIND_POINT_GRAPHICS);\n    objlist.add(buffer);\n    skip |= LogError(\"VUID-vkCmdDrawIndirect-drawCount-00487\", objlist, error_obj.location.dot(Field::drawCount),\n                     \"is 1 and (offset + sizeof(VkDrawIndirectCommand)) (%\" PRIu64\n                     \") is not less than \"\n                     \"or equal to the size of buffer (%\" PRIu64 \").\",\n                     (offset + sizeof(VkDrawIndirectCommand)), buffer_state->create_info.size);\n"
        },
        {
            "role": "user",
            "content": "{\"VUID-vkCmdDrawIndexedIndirect-drawCount-02719\", \"drawCount must be less than or equal to VkPhysicalDeviceLimits::maxDrawIndirectCount\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (drawCount > phys_dev_props.limits.maxDrawIndirectCount) {\n    skip |= LogError(\"VUID-vkCmdDrawIndexedIndirect-drawCount-02719\", cb_state.GetObjectList(VK_PIPELINE_BIND_POINT_GRAPHICS),\n                     error_obj.location.dot(Field::drawCount),\n                     \"(%\" PRIu32 \") is not less than or equal to the maximum allowed (%\" PRIu32 \").\", drawCount,\n                     phys_dev_props.limits.maxDrawIndirectCount);\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-vkCmdDrawIndexedIndirect-drawCount-00528\", \"If drawCount is greater than 1, stride must be a multiple of 4 and must be greater than or equal to sizeof(VkDrawIndexedIndirectCommand)\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (drawCount > 1) {\n    skip |= ValidateCmdDrawStrideWithStruct(cb_state, \"VUID-vkCmdDrawIndexedIndirect-drawCount-00528\", stride,\n                                            Struct::VkDrawIndexedIndirectCommand, sizeof(VkDrawIndexedIndirectCommand),\n                                            error_obj.location);\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-vkCmdDrawIndexedIndirect-drawCount-00540\", \"If drawCount is greater than 1, (stride \u00d7 (drawCount - 1) + offset + sizeof(VkDrawIndexedIndirectCommand)) must be less than or equal to the size of buffer\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "skip |= ValidateCmdDrawStrideWithStruct(cb_state, \"VUID-vkCmdDrawIndexedIndirect-drawCount-00528\", stride,\nskip |= ValidateCmdDrawStrideWithBuffer(cb_state, \"VUID-vkCmdDrawIndexedIndirect-drawCount-00540\", stride,\n                                        Struct::VkDrawIndexedIndirectCommand, sizeof(VkDrawIndexedIndirectCommand),\n                                        drawCount, offset, *buffer_state, error_obj.location);\n"
        },
        {
            "role": "user",
            "content": "{\"VUID-vkCmdDrawIndexedIndirect-offset-02710\", \"offset must be a multiple of 4\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "drawCount, offset, *buffer_state, error_obj.location);\n} else if (offset & 3) {\nskip |= LogError(\"VUID-vkCmdDrawIndexedIndirect-offset-02710\", cb_state.GetObjectList(VK_PIPELINE_BIND_POINT_GRAPHICS),\nerror_obj.location.dot(Field::offset), \"(%\" PRIu64 \") must be a multiple of 4.\", offset);\n"
        },
        {
            "role": "user",
            "content": "{\"VUID-vkCmdDispatch-groupCountX-00386\", \"groupCountX must be less than or equal to VkPhysicalDeviceLimits::maxComputeWorkGroupCount[0]\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (groupCountX > phys_dev_props.limits.maxComputeWorkGroupCount[0]) {\n    skip |= LogError(\"VUID-vkCmdDispatch-groupCountX-00386\", cb_state.GetObjectList(VK_SHADER_STAGE_COMPUTE_BIT),\n                     error_obj.location.dot(Field::groupCountX),\n                     \"(%\" PRIu32 \") exceeds device limit maxComputeWorkGroupCount[0] (%\" PRIu32 \").\", groupCountX,\n                     phys_dev_props.limits.maxComputeWorkGroupCount[0]);\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-vkCmdDispatch-groupCountY-00387\", \"groupCountY must be less than or equal to VkPhysicalDeviceLimits::maxComputeWorkGroupCount[1]\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (groupCountY > phys_dev_props.limits.maxComputeWorkGroupCount[1]) {\n    skip |= LogError(\"VUID-vkCmdDispatch-groupCountY-00387\", cb_state.GetObjectList(VK_SHADER_STAGE_COMPUTE_BIT),\n                     error_obj.location.dot(Field::groupCountY),\n                     \"(%\" PRIu32 \") exceeds device limit maxComputeWorkGroupCount[1] (%\" PRIu32 \").\", groupCountY,\n                     phys_dev_props.limits.maxComputeWorkGroupCount[1]);\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-vkCmdDispatch-groupCountZ-00388\", \"groupCountZ must be less than or equal to VkPhysicalDeviceLimits::maxComputeWorkGroupCount[2]\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (groupCountZ > phys_dev_props.limits.maxComputeWorkGroupCount[2]) {\n    skip |= LogError(\"VUID-vkCmdDispatch-groupCountZ-00388\", cb_state.GetObjectList(VK_SHADER_STAGE_COMPUTE_BIT),\n                     error_obj.location.dot(Field::groupCountZ),\n                     \"(%\" PRIu32 \") exceeds device limit maxComputeWorkGroupCount[2] (%\" PRIu32 \").\", groupCountZ,\n                     phys_dev_props.limits.maxComputeWorkGroupCount[2]);\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-vkCmdDispatchBase-baseGroupX-00427\", \"If any of baseGroupX, baseGroupY, or baseGroupZ are not zero, then the bound compute pipeline must have been created with the VK_PIPELINE_CREATE_DISPATCH_BASE flag or the bound compute shader object must have been created with the VK_SHADER_CREATE_DISPATCH_BASE_BIT_EXT flag\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (!(pipeline_state->create_flags & VK_PIPELINE_CREATE_DISPATCH_BASE)) {\n    skip |= LogError(\"VUID-vkCmdDispatchBase-baseGroupX-00427\", cb_state.GetObjectList(VK_SHADER_STAGE_COMPUTE_BIT),\n                     error_obj.location,\n                     \"If any of baseGroupX (%\" PRIu32 \"), baseGroupY (%\" PRIu32 \"), or baseGroupZ (%\" PRIu32\n                     \") are not zero, then the bound compute pipeline \"\n                     \"must have been created with the VK_PIPELINE_CREATE_DISPATCH_BASE flag\",\n                     baseGroupX, baseGroupY, baseGroupZ);\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-vkCmdDispatchIndirect-offset-02710\", \"offset must be a multiple of 4\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (offset & 3) {\n    skip |= LogError(\"VUID-vkCmdDispatchIndirect-offset-02710\", cb_state.GetObjectList(VK_SHADER_STAGE_COMPUTE_BIT),\n                     error_obj.location.dot(Field::offset), \"(%\" PRIu64 \") must be a multiple of 4.\", offset);\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-vkCmdDispatchIndirect-offset-00407\", \"The sum of offset and the size of VkDispatchIndirectCommand must be less than or equal to the size of buffer\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if ((offset + sizeof(VkDispatchIndirectCommand)) > buffer_state->create_info.size) {\n    skip |= LogError(\"VUID-vkCmdDispatchIndirect-offset-00407\", cb_state.GetObjectList(VK_SHADER_STAGE_COMPUTE_BIT),\n                     error_obj.location,\n                     \"The (offset + sizeof(VkDrawIndexedIndirectCommand)) (%\" PRIu64\n                     \")  is greater than the \"\n                     \"size of the buffer (%\" PRIu64 \").\",\n                     offset + sizeof(VkDispatchIndirectCommand), buffer_state->create_info.size);\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-vkCmdDrawIndirectCount-offset-02710\", \"offset must be a multiple of 4\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (offset & 3) {\n    skip |= LogError(\"VUID-vkCmdDrawIndirectCount-offset-02710\", cb_state.GetObjectList(VK_PIPELINE_BIND_POINT_GRAPHICS),\n                     error_obj.location.dot(Field::offset), \"(%\" PRIu64 \"), is not a multiple of 4.\", offset);\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-vkCmdDrawIndirectCount-None-04445\", \"If drawIndirectCount is not enabled this function must not be used\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if ((device_extensions.vk_khr_draw_indirect_count != kEnabledByCreateinfo) &&\n    skip |= LogError(\"VUID-vkCmdDrawIndirectCount-None-04445\", cb_state.GetObjectList(VK_PIPELINE_BIND_POINT_GRAPHICS),\n                     error_obj.location,\n                     \"Starting in Vulkan 1.2 the VkPhysicalDeviceVulkan12Features::drawIndirectCount must be enabled to \"\n                     \"call this command.\");\n"
        },
        {
            "role": "user",
            "content": "{\"VUID-vkCmdDrawIndirectCount-maxDrawCount-03111\", \"If maxDrawCount is greater than or equal to 1, (stride \u00d7 (maxDrawCount - 1) + offset + sizeof(VkDrawIndirectCommand)) must be less than or equal to the size of buffer\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (maxDrawCount > 1) {\n    skip |= ValidateCmdDrawStrideWithBuffer(cb_state, \"VUID-vkCmdDrawIndirectCount-maxDrawCount-03111\", stride,\n                                            Struct::VkDrawIndirectCommand, sizeof(VkDrawIndirectCommand), maxDrawCount, offset,\n                                            *buffer_state, error_obj.location);\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-vkCmdDrawIndexedIndirectCount-offset-02710\", \"offset must be a multiple of 4\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (offset & 3) {\n    skip |= LogError(\"VUID-vkCmdDrawIndexedIndirectCount-offset-02710\", cb_state.GetObjectList(VK_PIPELINE_BIND_POINT_GRAPHICS),\n                     error_obj.location.dot(Field::offset), \"(%\" PRIu64 \"), is not a multiple of 4.\", offset);\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-vkCmdDrawIndexedIndirectCount-countBufferOffset-02716\", \"countBufferOffset must be a multiple of 4\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (countBufferOffset & 3) {\n    skip |= LogError(\"VUID-vkCmdDrawIndexedIndirectCount-countBufferOffset-02716\",\n                     cb_state.GetObjectList(VK_PIPELINE_BIND_POINT_GRAPHICS), error_obj.location.dot(Field::countBufferOffset),\n                     \"(%\" PRIu64 \"), is not a multiple of 4.\", countBufferOffset);\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-vkCmdDrawIndexedIndirectCount-None-04445\", \"If drawIndirectCount is not enabled this function must not be used\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if ((device_extensions.vk_khr_draw_indirect_count != kEnabledByCreateinfo) &&\n    skip |= LogError(\"VUID-vkCmdDrawIndexedIndirectCount-None-04445\", cb_state.GetObjectList(VK_PIPELINE_BIND_POINT_GRAPHICS),\n                     error_obj.location,\n                     \"Starting in Vulkan 1.2 the VkPhysicalDeviceVulkan12Features::drawIndirectCount must be enabled to \"\n                     \"call this command.\");\n"
        },
        {
            "role": "user",
            "content": "{\"VUID-vkCmdDrawIndexedIndirectCount-maxDrawCount-03143\", \"If maxDrawCount is greater than or equal to 1, (stride \u00d7 (maxDrawCount - 1) + offset + sizeof(VkDrawIndexedIndirectCommand)) must be less than or equal to the size of buffer\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (maxDrawCount > 1) {\n    skip |= ValidateCmdDrawStrideWithBuffer(cb_state, \"VUID-vkCmdDrawIndexedIndirectCount-maxDrawCount-03143\", stride,\n                                            Struct::VkDrawIndexedIndirectCommand, sizeof(VkDrawIndexedIndirectCommand),\n                                            maxDrawCount, offset, *buffer_state, error_obj.location);\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-vkCmdDrawIndirectByteCountEXT-transformFeedback-02287\", \"VkPhysicalDeviceTransformFeedbackFeaturesEXT::transformFeedback must be enabled\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (!enabled_features.transformFeedback) {\n    skip |= LogError(\"VUID-vkCmdDrawIndirectByteCountEXT-transformFeedback-02287\",\n                     cb_state.GetObjectList(VK_PIPELINE_BIND_POINT_GRAPHICS), error_obj.location,\n                     \"transformFeedback feature is not enabled.\");\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-vkCmdDrawIndirectByteCountEXT-transformFeedbackDraw-02288\", \"The implementation must support VkPhysicalDeviceTransformFeedbackPropertiesEXT::transformFeedbackDraw\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (IsExtEnabled(device_extensions.vk_ext_transform_feedback) &&\n    !phys_dev_ext_props.transform_feedback_props.transformFeedbackDraw) {\n    skip |= LogError(\"VUID-vkCmdDrawIndirectByteCountEXT-transformFeedbackDraw-02288\",\n                     cb_state.GetObjectList(VK_PIPELINE_BIND_POINT_GRAPHICS), error_obj.location,\n                     \"VkPhysicalDeviceTransformFeedbackPropertiesEXT::transformFeedbackDraw is not supported\");\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-vkCmdDrawIndirectByteCountEXT-vertexStride-02289\", \"vertexStride must be greater than 0 and less than or equal to VkPhysicalDeviceTransformFeedbackPropertiesEXT::maxTransformFeedbackBufferDataStride\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if ((vertexStride <= 0) || (vertexStride > phys_dev_ext_props.transform_feedback_props.maxTransformFeedbackBufferDataStride)) {\n    skip |= LogError(\"VUID-vkCmdDrawIndirectByteCountEXT-vertexStride-02289\",\n                     cb_state.GetObjectList(VK_PIPELINE_BIND_POINT_GRAPHICS), error_obj.location.dot(Field::vertexStride),\n                     \"(%\" PRIu32 \") must be between 0 and maxTransformFeedbackBufferDataStride (%\" PRIu32 \").\", vertexStride,\n                     phys_dev_ext_props.transform_feedback_props.maxTransformFeedbackBufferDataStride);\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-vkCmdDrawIndirectByteCountEXT-vertexStride-09475\", \"vertexStride must be a multiple of 4\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (SafeModulo(vertexStride, 4) != 0) {\n    skip |= LogError(\"VUID-vkCmdDrawIndirectByteCountEXT-vertexStride-09475\",\n                     cb_state.GetObjectList(VK_PIPELINE_BIND_POINT_GRAPHICS), error_obj.location.dot(Field::vertexStride),\n                     \"(%\" PRIu32 \") must be a multiple of 4.\", vertexStride);\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-vkCmdTraceRaysNV-callableShaderBindingOffset-02462\", \"callableShaderBindingOffset must be a multiple of VkPhysicalDeviceRayTracingPropertiesNV::shaderGroupBaseAlignment\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (SafeModulo(callableShaderBindingOffset, phys_dev_ext_props.ray_tracing_props_nv.shaderGroupBaseAlignment) != 0) {\n    skip |= LogError(\"VUID-vkCmdTraceRaysNV-callableShaderBindingOffset-02462\",\n                     cb_state.GetObjectList(VK_PIPELINE_BIND_POINT_RAY_TRACING_KHR),\n                     error_obj.location.dot(Field::callableShaderBindingOffset),\n                     \"must be a multiple of \"\n                     \"VkPhysicalDeviceRayTracingPropertiesNV::shaderGroupBaseAlignment.\");\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-vkCmdTraceRaysNV-callableShaderBindingStride-02465\", \"callableShaderBindingStride must be a multiple of VkPhysicalDeviceRayTracingPropertiesNV::shaderGroupHandleSize\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (SafeModulo(callableShaderBindingStride, phys_dev_ext_props.ray_tracing_props_nv.shaderGroupHandleSize) != 0) {\n    skip |= LogError(\"VUID-vkCmdTraceRaysNV-callableShaderBindingStride-02465\",\n                     cb_state.GetObjectList(VK_PIPELINE_BIND_POINT_RAY_TRACING_KHR),\n                     error_obj.location.dot(Field::callableShaderBindingStride),\n                     \"must be a multiple of \"\n                     \"VkPhysicalDeviceRayTracingPropertiesNV::shaderGroupHandleSize.\");\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-vkCmdTraceRaysNV-callableShaderBindingStride-02468\", \"callableShaderBindingStride must be less than or equal to VkPhysicalDeviceRayTracingPropertiesNV::maxShaderGroupStride\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (callableShaderBindingStride > phys_dev_ext_props.ray_tracing_props_nv.maxShaderGroupStride) {\n    skip |= LogError(\"VUID-vkCmdTraceRaysNV-callableShaderBindingStride-02468\",\n                     cb_state.GetObjectList(VK_PIPELINE_BIND_POINT_RAY_TRACING_KHR),\n                     error_obj.location.dot(Field::callableShaderBindingStride),\n                     \"must be less than or equal to \"\n                     \"VkPhysicalDeviceRayTracingPropertiesNV::maxShaderGroupStride. \");\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-vkCmdTraceRaysNV-hitShaderBindingStride-02464\", \"hitShaderBindingStride must be a multiple of VkPhysicalDeviceRayTracingPropertiesNV::shaderGroupHandleSize\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (SafeModulo(hitShaderBindingStride, phys_dev_ext_props.ray_tracing_props_nv.shaderGroupHandleSize) != 0) {\n    skip |= LogError(\"VUID-vkCmdTraceRaysNV-hitShaderBindingStride-02464\",\n                     cb_state.GetObjectList(VK_PIPELINE_BIND_POINT_RAY_TRACING_KHR),\n                     error_obj.location.dot(Field::hitShaderBindingStride),\n                     \"must be a multiple of \"\n                     \"VkPhysicalDeviceRayTracingPropertiesNV::shaderGroupHandleSize.\");\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-vkCmdTraceRaysNV-hitShaderBindingStride-02467\", \"hitShaderBindingStride must be less than or equal to VkPhysicalDeviceRayTracingPropertiesNV::maxShaderGroupStride\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (hitShaderBindingStride > phys_dev_ext_props.ray_tracing_props_nv.maxShaderGroupStride) {\n    skip |= LogError(\"VUID-vkCmdTraceRaysNV-hitShaderBindingStride-02467\",\n                     cb_state.GetObjectList(VK_PIPELINE_BIND_POINT_RAY_TRACING_KHR),\n                     error_obj.location.dot(Field::hitShaderBindingStride),\n                     \"must be less than or equal to \"\n                     \"VkPhysicalDeviceRayTracingPropertiesNV::maxShaderGroupStride.\");\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-vkCmdTraceRaysNV-missShaderBindingOffset-02458\", \"missShaderBindingOffset must be a multiple of VkPhysicalDeviceRayTracingPropertiesNV::shaderGroupBaseAlignment\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (SafeModulo(missShaderBindingOffset, phys_dev_ext_props.ray_tracing_props_nv.shaderGroupBaseAlignment) != 0) {\n    skip |= LogError(\"VUID-vkCmdTraceRaysNV-missShaderBindingOffset-02458\",\n                     cb_state.GetObjectList(VK_PIPELINE_BIND_POINT_RAY_TRACING_KHR),\n                     error_obj.location.dot(Field::missShaderBindingOffset),\n                     \"must be a multiple of \"\n                     \"VkPhysicalDeviceRayTracingPropertiesNV::shaderGroupBaseAlignment.\");\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-vkCmdTraceRaysNV-missShaderBindingStride-02463\", \"missShaderBindingStride must be a multiple of VkPhysicalDeviceRayTracingPropertiesNV::shaderGroupHandleSize\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (SafeModulo(missShaderBindingStride, phys_dev_ext_props.ray_tracing_props_nv.shaderGroupHandleSize) != 0) {\n    skip |= LogError(\"VUID-vkCmdTraceRaysNV-missShaderBindingStride-02463\",\n                     cb_state.GetObjectList(VK_PIPELINE_BIND_POINT_RAY_TRACING_KHR),\n                     error_obj.location.dot(Field::missShaderBindingStride),\n                     \"must be a multiple of \"\n                     \"VkPhysicalDeviceRayTracingPropertiesNV::shaderGroupHandleSize.\");\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-vkCmdTraceRaysNV-raygenShaderBindingOffset-02456\", \"raygenShaderBindingOffset must be a multiple of VkPhysicalDeviceRayTracingPropertiesNV::shaderGroupBaseAlignment\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (SafeModulo(raygenShaderBindingOffset, phys_dev_ext_props.ray_tracing_props_nv.shaderGroupBaseAlignment) != 0) {\n    skip |= LogError(\"VUID-vkCmdTraceRaysNV-raygenShaderBindingOffset-02456\",\n                     cb_state.GetObjectList(VK_PIPELINE_BIND_POINT_RAY_TRACING_KHR),\n                     error_obj.location.dot(Field::raygenShaderBindingOffset),\n                     \"must be a multiple of \"\n                     \"VkPhysicalDeviceRayTracingPropertiesNV::shaderGroupBaseAlignment.\");\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-vkCmdTraceRaysNV-width-02469\", \"width must be less than or equal to VkPhysicalDeviceLimits::maxComputeWorkGroupCount[0]\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (width > phys_dev_props.limits.maxComputeWorkGroupCount[0]) {\n    skip |= LogError(\"VUID-vkCmdTraceRaysNV-width-02469\", cb_state.GetObjectList(VK_PIPELINE_BIND_POINT_RAY_TRACING_KHR),\n                     error_obj.location.dot(Field::width),\n                     \"must be less than or equal to VkPhysicalDeviceLimits::maxComputeWorkGroupCount[0].\");\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-vkCmdTraceRaysNV-height-02470\", \"height must be less than or equal to VkPhysicalDeviceLimits::maxComputeWorkGroupCount[1]\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (height > phys_dev_props.limits.maxComputeWorkGroupCount[1]) {\n    skip |= LogError(\"VUID-vkCmdTraceRaysNV-height-02470\", cb_state.GetObjectList(VK_PIPELINE_BIND_POINT_RAY_TRACING_KHR),\n                     error_obj.location.dot(Field::height),\n                     \"must be less than or equal to VkPhysicalDeviceLimits::maxComputeWorkGroupCount[1].\");\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-vkCmdTraceRaysNV-depth-02471\", \"depth must be less than or equal to VkPhysicalDeviceLimits::maxComputeWorkGroupCount[2]\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (depth > phys_dev_props.limits.maxComputeWorkGroupCount[2]) {\n    skip |= LogError(\"VUID-vkCmdTraceRaysNV-depth-02471\", cb_state.GetObjectList(VK_PIPELINE_BIND_POINT_RAY_TRACING_KHR),\n                     error_obj.location.dot(Field::depth),\n                     \"must be less than or equal to VkPhysicalDeviceLimits::maxComputeWorkGroupCount[2].\");\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-vkCmdTraceRaysNV-hitShaderBindingOffset-02459\", \"hitShaderBindingOffset must be less than the size of hitShaderBindingTableBuffer\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (hit_shader_buffer_state && hitShaderBindingOffset >= hit_shader_buffer_state->create_info.size) {\n    LogObjectList objlist = cb_state.GetObjectList(VK_PIPELINE_BIND_POINT_RAY_TRACING_KHR);\n    objlist.add(hitShaderBindingTableBuffer);\n    skip |= LogError(\"VUID-vkCmdTraceRaysNV-hitShaderBindingOffset-02459\", objlist,\n                     error_obj.location.dot(Field::hitShaderBindingOffset),\n                     \"%\" PRIu64 \" must be less than the size of hitShaderBindingTableBuffer %\" PRIu64 \" .\",\n                     hitShaderBindingOffset, hit_shader_buffer_state->create_info.size);\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-vkCmdTraceRaysNV-missShaderBindingOffset-02457\", \"missShaderBindingOffset must be less than the size of missShaderBindingTableBuffer\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (miss_shader_buffer_state && missShaderBindingOffset >= miss_shader_buffer_state->create_info.size) {\n    LogObjectList objlist = cb_state.GetObjectList(VK_PIPELINE_BIND_POINT_RAY_TRACING_KHR);\n    objlist.add(missShaderBindingTableBuffer);\n    skip |= LogError(\"VUID-vkCmdTraceRaysNV-missShaderBindingOffset-02457\", objlist,\n                     error_obj.location.dot(Field::missShaderBindingOffset),\n                     \"%\" PRIu64 \" must be less than the size of missShaderBindingTableBuffer %\" PRIu64 \" .\",\n                     missShaderBindingOffset, miss_shader_buffer_state->create_info.size);\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-vkCmdTraceRaysNV-raygenShaderBindingOffset-02455\", \"raygenShaderBindingOffset must be less than the size of raygenShaderBindingTableBuffer\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (raygenShaderBindingOffset >= raygen_shader_buffer_state->create_info.size) {\n    LogObjectList objlist = cb_state.GetObjectList(VK_PIPELINE_BIND_POINT_RAY_TRACING_KHR);\n    objlist.add(raygenShaderBindingTableBuffer);\n    skip |= LogError(\"VUID-vkCmdTraceRaysNV-raygenShaderBindingOffset-02455\", objlist,\n                     error_obj.location.dot(Field::raygenShaderBindingOffset),\n                     \"%\" PRIu64 \" must be less than the size of raygenShaderBindingTableBuffer %\" PRIu64 \" .\",\n                     raygenShaderBindingOffset, raygen_shader_buffer_state->create_info.size);\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-vkCmdDrawMeshTasksIndirectNV-drawCount-02157\", \"If drawCount is greater than 1, (stride \u00d7 (drawCount - 1) + offset + sizeof(VkDrawMeshTasksIndirectCommandNV)) must be less than or equal to the size of buffer\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (drawCount > 1) {\n    skip |= ValidateCmdDrawStrideWithBuffer(cb_state, \"VUID-vkCmdDrawMeshTasksIndirectNV-drawCount-02157\", stride,\n                                            Struct::VkDrawMeshTasksIndirectCommandNV, sizeof(VkDrawMeshTasksIndirectCommandNV),\n                                            drawCount, offset, *buffer_state, error_obj.location);\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-vkCmdDrawMeshTasksIndirectNV-offset-02710\", \"offset must be a multiple of 4\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (offset & 3) {\n    skip |= LogError(\"VUID-vkCmdDrawMeshTasksIndirectNV-offset-02710\", cb_state.GetObjectList(VK_PIPELINE_BIND_POINT_GRAPHICS),\n                     error_obj.location.dot(Field::offset), \"(%\" PRIu64 \"), is not a multiple of 4.\", offset);\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-vkCmdDrawMeshTasksIndirectNV-drawCount-02719\", \"drawCount must be less than or equal to VkPhysicalDeviceLimits::maxDrawIndirectCount\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (drawCount > phys_dev_props.limits.maxDrawIndirectCount) {\n    skip |= LogError(\"VUID-vkCmdDrawMeshTasksIndirectNV-drawCount-02719\",\n                     cb_state.GetObjectList(VK_PIPELINE_BIND_POINT_GRAPHICS), error_obj.location.dot(Field::drawCount),\n                     \"(%\" PRIu32 \") is not less than or equal to maxDrawIndirectCount (%\" PRIu32 \").\", drawCount,\n                     phys_dev_props.limits.maxDrawIndirectCount);\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-vkCmdDrawMeshTasksIndirectCountNV-countBufferOffset-02716\", \"countBufferOffset must be a multiple of 4\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (countBufferOffset & 3) {\n    skip |= LogError(\"VUID-vkCmdDrawMeshTasksIndirectCountNV-countBufferOffset-02716\",\n                     cb_state.GetObjectList(VK_PIPELINE_BIND_POINT_GRAPHICS), error_obj.location.dot(Field::countBufferOffset),\n                     \"(%\" PRIu64 \"), is not a multiple of 4.\", countBufferOffset);\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-vkCmdDrawMeshTasksIndirectCountNV-stride-02182\", \"stride must be a multiple of 4 and must be greater than or equal to sizeof(VkDrawMeshTasksIndirectCommandNV)\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "skip |= ValidateIndirectCmd(cb_state, *buffer_state, error_obj.location);\nskip |= ValidateIndirectCountCmd(cb_state, *count_buffer_state, countBufferOffset, error_obj.location);\nskip |= ValidateCmdDrawStrideWithStruct(cb_state, \"VUID-vkCmdDrawMeshTasksIndirectCountNV-stride-02182\", stride,\n                                        Struct::VkDrawMeshTasksIndirectCommandNV, sizeof(VkDrawMeshTasksIndirectCommandNV),\n                                        error_obj.location);\n"
        },
        {
            "role": "user",
            "content": "{\"VUID-vkCmdDrawMeshTasksIndirectEXT-drawCount-07088\", \"If drawCount is greater than 1, stride must be a multiple of 4 and must be greater than or equal to sizeof(VkDrawMeshTasksIndirectCommandEXT)\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (drawCount > 1) {\n    skip |= ValidateCmdDrawStrideWithStruct(cb_state, \"VUID-vkCmdDrawMeshTasksIndirectEXT-drawCount-07088\", stride,\n                                            Struct::VkDrawMeshTasksIndirectCommandEXT,\n                                            sizeof(VkDrawMeshTasksIndirectCommandEXT), error_obj.location);\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-vkCmdDrawMeshTasksIndirectEXT-drawCount-07089\", \"If drawCount is equal to 1, (offset + sizeof(VkDrawMeshTasksIndirectCommandEXT)) must be less than or equal to the size of buffer\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if ((drawCount == 1) && (offset + sizeof(VkDrawMeshTasksIndirectCommandEXT)) > buffer_state->create_info.size) {\n    LogObjectList objlist = cb_state.GetObjectList(VK_PIPELINE_BIND_POINT_GRAPHICS);\n    objlist.add(buffer);\n    skip |= LogError(\"VUID-vkCmdDrawMeshTasksIndirectEXT-drawCount-07089\", objlist, error_obj.location.dot(Field::drawCount),\n                     \"is 1 and (offset + sizeof(vkCmdDrawMeshTasksIndirectEXT)) (%\" PRIu64\n                     \") is not less than \"\n                     \"or equal to the size of buffer (%\" PRIu64 \").\",\n                     (offset + sizeof(VkDrawMeshTasksIndirectCommandEXT)), buffer_state->create_info.size);\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-vkCmdDrawMeshTasksIndirectEXT-drawCount-02718\", \"If the multiDrawIndirect feature is not enabled, drawCount must be 0 or 1\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (!enabled_features.multiDrawIndirect && ((drawCount > 1))) {\n    skip |= LogError(\"VUID-vkCmdDrawMeshTasksIndirectEXT-drawCount-02718\",\n                     cb_state.GetObjectList(VK_PIPELINE_BIND_POINT_GRAPHICS), error_obj.location.dot(Field::drawCount),\n                     \"(%\" PRIu32 \") must be 0 or 1 if multiDrawIndirect feature is not enabled.\", drawCount);\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-vkCmdDrawMeshTasksIndirectEXT-drawCount-02719\", \"drawCount must be less than or equal to VkPhysicalDeviceLimits::maxDrawIndirectCount\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (drawCount > phys_dev_props.limits.maxDrawIndirectCount) {\n    skip |= LogError(\"VUID-vkCmdDrawMeshTasksIndirectEXT-drawCount-02719\",\n                     cb_state.GetObjectList(VK_PIPELINE_BIND_POINT_GRAPHICS), error_obj.location.dot(Field::drawCount),\n                     \"%\" PRIu32 \") is not less than or equal to maxDrawIndirectCount (%\" PRIu32 \").\", drawCount,\n                     phys_dev_props.limits.maxDrawIndirectCount);\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkMemoryGetFdInfoKHR-handleType-00671\", \"handleType must have been included in VkExportMemoryAllocateInfo::handleTypes when memory was created\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (!export_info) {\n    skip |= LogError(\"VUID-VkMemoryGetFdInfoKHR-handleType-00671\", pGetFdInfo->memory,\n                     error_obj.location.dot(Field::pGetFdInfo).dot(Field::memory),\n                     \"pNext chain does not include a VkExportMemoryAllocateInfo structure.\");\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkMemoryGetFdInfoKHR-handleType-00671\", \"handleType must have been included in VkExportMemoryAllocateInfo::handleTypes when memory was created\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "error_obj.location.dot(Field::pGetFdInfo).dot(Field::memory),\n} else if ((export_info->handleTypes & pGetFdInfo->handleType) == 0) {\nskip |= LogError(\"VUID-VkMemoryGetFdInfoKHR-handleType-00671\", pGetFdInfo->memory,\nerror_obj.location.dot(Field::pGetFdInfo).dot(Field::memory),\n\"the requested handle type (%s) is not included in the memory's \"\n\"VkExportMemoryAllocateInfo::handleTypes (%s).\",\nstring_VkExternalMemoryHandleTypeFlagBits(pGetFdInfo->handleType),\nstring_VkExternalMemoryHandleTypeFlags(export_info->handleTypes).c_str());\n"
        },
        {
            "role": "user",
            "content": "{\"VUID-vkImportSemaphoreFdKHR-semaphore-01142\", \"semaphore must not be associated with any queue command that has not yet completed execution on that queue\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "ASSERT_AND_RETURN_SKIP(sem_state);\nconst Location info_loc = error_obj.location.dot(Field::pImportSemaphoreFdInfo);\nskip |= ValidateObjectNotInUse(sem_state.get(), info_loc.dot(Field::semaphore), \"VUID-vkImportSemaphoreFdKHR-semaphore-01142\");\n"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkImportSemaphoreFdInfoKHR-flags-03323\", \"If flags contains VK_SEMAPHORE_IMPORT_TEMPORARY_BIT, the VkSemaphoreTypeCreateInfo::semaphoreType field of the semaphore from which fd was exported must not be VK_SEMAPHORE_TYPE_TIMELINE\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (sem_state->type == VK_SEMAPHORE_TYPE_TIMELINE) {\n    skip |= LogError(\"VUID-VkImportSemaphoreFdInfoKHR-flags-03323\", sem_state->Handle(), info_loc.dot(Field::flags),\n                     \"includes VK_SEMAPHORE_IMPORT_TEMPORARY_BIT and semaphore is VK_SEMAPHORE_TYPE_TIMELINE.\");\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkImportSemaphoreFdInfoKHR-handleType-07307\", \"If handleType refers to a handle type with copy payload transference semantics, flags must contain VK_SEMAPHORE_IMPORT_TEMPORARY_BIT\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (pImportSemaphoreFdInfo->handleType == VK_EXTERNAL_SEMAPHORE_HANDLE_TYPE_SYNC_FD_BIT &&\n    (pImportSemaphoreFdInfo->flags & VK_SEMAPHORE_IMPORT_TEMPORARY_BIT) == 0) {\n    skip |= LogError(\"VUID-VkImportSemaphoreFdInfoKHR-handleType-07307\", pImportSemaphoreFdInfo->semaphore,\n                     info_loc.dot(Field::handleType),\n                     \"is VK_EXTERNAL_SEMAPHORE_HANDLE_TYPE_SYNC_FD_BIT so\"\n                     \" VK_SEMAPHORE_IMPORT_TEMPORARY_BIT must be set, but flags is 0x%x\",\n                     pImportSemaphoreFdInfo->flags);\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkImportSemaphoreFdInfoKHR-handleType-03263\", \"If handleType is VK_EXTERNAL_SEMAPHORE_HANDLE_TYPE_OPAQUE_FD_BIT, the VkSemaphoreCreateInfo::flags field must match that of the semaphore from which fd was exported\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (sem_state->flags != payload_info->semaphore_flags) {\n    skip |= LogError(\"VUID-VkImportSemaphoreFdInfoKHR-handleType-03263\", device, info_loc.dot(Field::semaphore),\n                     \"was created with flags 0x%\" PRIx32 \" but fd (%d) was exported with 0x%\" PRIx32 \".\",\n                     sem_state->flags, pImportSemaphoreFdInfo->fd, payload_info->semaphore_flags);\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkImportSemaphoreFdInfoKHR-handleType-03264\", \"If handleType is VK_EXTERNAL_SEMAPHORE_HANDLE_TYPE_OPAQUE_FD_BIT, the VkSemaphoreTypeCreateInfo::semaphoreType field must match that of the semaphore from which fd was exported\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (sem_state->type != payload_info->semaphore_type) {\n    skip |= LogError(\"VUID-VkImportSemaphoreFdInfoKHR-handleType-03264\", device, info_loc.dot(Field::semaphore),\n                     \"was created with %s but fd (%d) was exported as %s.\", string_VkSemaphoreType(sem_state->type),\n                     pImportSemaphoreFdInfo->fd, string_VkSemaphoreType(payload_info->semaphore_type));\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkSemaphoreGetFdInfoKHR-handleType-01132\", \"handleType must have been included in VkExportSemaphoreCreateInfo::handleTypes when semaphore's current payload was created\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if ((pGetFdInfo->handleType & sem_state->exportHandleTypes) == 0) {\n    skip |= LogError(\"VUID-VkSemaphoreGetFdInfoKHR-handleType-01132\", sem_state->Handle(), info_loc.dot(Field::handleType),\n                     \"(%s) is different from VkExportSemaphoreCreateInfo::handleTypes (%s).\",\n                     string_VkExternalSemaphoreHandleTypeFlagBits(pGetFdInfo->handleType),\n                     string_VkExternalSemaphoreHandleTypeFlags(sem_state->exportHandleTypes).c_str());\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkSemaphoreGetFdInfoKHR-handleType-03253\", \"If handleType refers to a handle type with copy payload transference semantics, semaphore must have been created with a VkSemaphoreType of VK_SEMAPHORE_TYPE_BINARY\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (sem_state->type != VK_SEMAPHORE_TYPE_BINARY) {\n    skip |= LogError(\"VUID-VkSemaphoreGetFdInfoKHR-handleType-03253\", sem_state->Handle(), info_loc.dot(Field::handleType),\n                     \"is VK_EXTERNAL_SEMAPHORE_HANDLE_TYPE_SYNC_FD_BIT, but semaphore type is %s.\",\n                     string_VkSemaphoreType(sem_state->type));\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkSemaphoreGetFdInfoKHR-handleType-03254\", \"If handleType refers to a handle type with copy payload transference semantics, semaphore must have an associated semaphore signal operation that has been submitted for execution and any semaphore signal operations on which it depends must have also been submitted for execution\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "\"is VK_EXTERNAL_SEMAPHORE_HANDLE_TYPE_SYNC_FD_BIT, but semaphore type is %s.\",\nstring_VkSemaphoreType(sem_state->type));\n} else if (!sem_state->CanBinaryBeWaited()) {\nskip |= LogError(\"VUID-VkSemaphoreGetFdInfoKHR-handleType-03254\", sem_state->Handle(), info_loc.dot(Field::semaphore),\n\"must be signaled or have a pending signal operation.\");\n"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkFenceGetFdInfoKHR-handleType-01453\", \"handleType must have been included in VkExportFenceCreateInfo::handleTypes when fence's current payload was created\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if ((pGetFdInfo->handleType & fence_state->exportHandleTypes) == 0) {\n    skip |= LogError(\"VUID-VkFenceGetFdInfoKHR-handleType-01453\", fence_state->Handle(), info_loc.dot(Field::handleType),\n                     \"(%s) is different from VkExportFenceCreateInfo::handleTypes (%s). \",\n                     string_VkExternalFenceHandleTypeFlagBits(pGetFdInfo->handleType),\n                     string_VkExternalFenceHandleTypeFlags(fence_state->exportHandleTypes).c_str());\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkFenceGetFdInfoKHR-fence-01455\", \"fence must not currently have its payload replaced by an imported payload as described below in Importing Fence Payloads unless that imported payload's handle type was included in VkExternalFenceProperties::exportFromImportedHandleTypes for handleType\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (fence_state->Scope() != vvl::Fence::kInternal && fence_state->HasImportedHandleType() &&\n    !CanFenceExportFromImported(physical_device, pGetFdInfo->handleType, fence_state->ImportedHandleType())) {\n    skip |= LogError(\"VUID-VkFenceGetFdInfoKHR-fence-01455\", fence_state->Handle(), info_loc.dot(Field::handleType),\n                     \"(%s) cannot be exported from fence with imported payload with handle type %s\",\n                     string_VkExternalFenceHandleTypeFlagBits(pGetFdInfo->handleType),\n                     string_VkExternalFenceHandleTypeFlagBits(fence_state->ImportedHandleType()));\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkMemoryGetWin32HandleInfoKHR-handleType-00662\", \"handleType must have been included in VkExportMemoryAllocateInfo::handleTypes when memory was created\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (!export_info) {\n    skip |= LogError(\"VUID-VkMemoryGetWin32HandleInfoKHR-handleType-00662\", pGetWin32HandleInfo->memory,\n                     error_obj.location.dot(Field::pGetWin32HandleInfo).dot(Field::memory),\n                     \"pNext chain does not include a VkExportMemoryAllocateInfo structure.\");\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkMemoryGetWin32HandleInfoKHR-handleType-00662\", \"handleType must have been included in VkExportMemoryAllocateInfo::handleTypes when memory was created\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "error_obj.location.dot(Field::pGetWin32HandleInfo).dot(Field::memory),\n} else if ((export_info->handleTypes & pGetWin32HandleInfo->handleType) == 0) {\nskip |= LogError(\"VUID-VkMemoryGetWin32HandleInfoKHR-handleType-00662\", pGetWin32HandleInfo->memory,\nerror_obj.location.dot(Field::pGetWin32HandleInfo).dot(Field::memory),\n\"the requested handle type (%s) is not included in the memory's \"\n\"VkExportMemoryAllocateInfo::handleTypes (%s).\",\nstring_VkExternalMemoryHandleTypeFlagBits(pGetWin32HandleInfo->handleType),\nstring_VkExternalMemoryHandleTypeFlags(export_info->handleTypes).c_str());\n"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkImportSemaphoreWin32HandleInfoKHR-flags-03322\", \"If flags contains VK_SEMAPHORE_IMPORT_TEMPORARY_BIT, the VkSemaphoreTypeCreateInfo::semaphoreType field of the semaphore from which handle or name was exported must not be VK_SEMAPHORE_TYPE_TIMELINE\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if ((pImportSemaphoreWin32HandleInfo->flags & VK_SEMAPHORE_IMPORT_TEMPORARY_BIT) != 0 &&\n    sem_state->type == VK_SEMAPHORE_TYPE_TIMELINE) {\n    skip |= LogError(\"VUID-VkImportSemaphoreWin32HandleInfoKHR-flags-03322\", sem_state->Handle(),\n                     error_obj.location.dot(Field::pImportSemaphoreWin32HandleInfo).dot(Field::semaphore),\n                     \"includes VK_SEMAPHORE_IMPORT_TEMPORARY_BIT and semaphore is VK_SEMAPHORE_TYPE_TIMELINE.\");\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkSemaphoreGetWin32HandleInfoKHR-handleType-01126\", \"handleType must have been included in VkExportSemaphoreCreateInfo::handleTypes when the semaphore's current payload was created\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if ((pGetWin32HandleInfo->handleType & sem_state->exportHandleTypes) == 0) {\n    skip |= LogError(\"VUID-VkSemaphoreGetWin32HandleInfoKHR-handleType-01126\", sem_state->Handle(),\n                     error_obj.location.dot(Field::pGetWin32HandleInfo).dot(Field::handleType),\n                     \"(%s) is different from VkExportSemaphoreCreateInfo::handleTypes (%s)\",\n                     string_VkExternalSemaphoreHandleTypeFlagBits(pGetWin32HandleInfo->handleType),\n                     string_VkExternalSemaphoreHandleTypeFlags(sem_state->exportHandleTypes).c_str());\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkFenceGetWin32HandleInfoKHR-handleType-01448\", \"handleType must have been included in VkExportFenceCreateInfo::handleTypes when the fence's current payload was created\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if ((pGetWin32HandleInfo->handleType & fence_state->exportHandleTypes) == 0) {\n    skip |= LogError(\"VUID-VkFenceGetWin32HandleInfoKHR-handleType-01448\", fence_state->Handle(),\n                     error_obj.location.dot(Field::pGetWin32HandleInfo).dot(Field::handleType),\n                     \"(%s) is different from VkExportFenceCreateInfo::handleTypes (%s)\",\n                     string_VkExternalFenceHandleTypeFlagBits(pGetWin32HandleInfo->handleType),\n                     string_VkExternalFenceHandleTypeFlags(fence_state->exportHandleTypes).c_str());\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkFenceGetWin32HandleInfoKHR-fence-01450\", \"fence must not currently have its payload replaced by an imported payload as described below in Importing Fence Payloads unless that imported payload's handle type was included in VkExternalFenceProperties::exportFromImportedHandleTypes for handleType\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (fence_state->Scope() != vvl::Fence::kInternal && fence_state->HasImportedHandleType() &&\n    !CanFenceExportFromImported(physical_device, pGetWin32HandleInfo->handleType, fence_state->ImportedHandleType())) {\n    skip |= LogError(\"VUID-VkFenceGetWin32HandleInfoKHR-fence-01450\", fence_state->Handle(),\n                     error_obj.location.dot(Field::pGetWin32HandleInfo).dot(Field::handleType),\n                     \"(%s) cannot be exported from fence with imported payload with handle type %s\",\n                     string_VkExternalFenceHandleTypeFlagBits(pGetWin32HandleInfo->handleType),\n                     string_VkExternalFenceHandleTypeFlagBits(fence_state->ImportedHandleType()));\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkImportSemaphoreZirconHandleInfoFUCHSIA-semaphoreType-04768\", \"The VkSemaphoreTypeCreateInfo::semaphoreType field must not be VK_SEMAPHORE_TYPE_TIMELINE\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (sem_state->type == VK_SEMAPHORE_TYPE_TIMELINE) {\n    skip |= LogError(\"VUID-VkImportSemaphoreZirconHandleInfoFUCHSIA-semaphoreType-04768\", sem_state->Handle(),\n                     error_obj.location.dot(Field::pImportSemaphoreZirconHandleInfo).dot(Field::semaphore),\n                     \"was created with VK_SEMAPHORE_TYPE_TIMELINE.\");\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkExportMetalObjectsInfoEXT-pNext-06792\", \"If the pNext chain includes a VkExportMetalCommandQueueInfoEXT structure, the VkInstance must have been created with VK_EXPORT_METAL_OBJECT_TYPE_METAL_COMMAND_QUEUE_BIT_EXT in the exportObjectType member of a VkExportMetalObjectCreateInfoEXT structure in the pNext chain of the VkInstanceCreateInfo structure in the vkCreateInstance command\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (std::find(instance_state->export_metal_flags.begin(), instance_state->export_metal_flags.end(),\n    skip |= LogError(\"VUID-VkExportMetalObjectsInfoEXT-pNext-06792\", device, error_obj.location,\n                     \"pNext chain contains a VkExportMetalCommandQueueInfoEXT structure \"\n                     \"but instance %s did not have a \"\n                     \"VkExportMetalObjectCreateInfoEXT struct with exportObjectType of \"\n                     \"VK_EXPORT_METAL_OBJECT_TYPE_METAL_COMMAND_QUEUE_BIT_EXT in the pNext chain of its \"\n                     \"VkInstanceCreateInfo structure\",\n                     FormatHandle(instance_state->instance).c_str());\n"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkExportMetalObjectsInfoEXT-pNext-06804\", \"If the pNext chain includes a VkExportMetalSharedEventInfoEXT structure, exactly one of its semaphore or event members must not be VK_NULL_HANDLE\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if ((metal_shared_event_ptr->event == VK_NULL_HANDLE && metal_shared_event_ptr->semaphore == VK_NULL_HANDLE) ||\n    skip |= LogError(\"VUID-VkExportMetalObjectsInfoEXT-pNext-06804\", device, error_obj.location,\n                     \"pNext chain contains a VkExportMetalSharedEventInfoEXT structure with semaphore = \"\n                     \"%s, and event = %s, but exactly one of them must not be VK_NULL_HANDLE\",\n                     FormatHandle(metal_shared_event_ptr->semaphore).c_str(),\n                     FormatHandle(metal_shared_event_ptr->event).c_str());\n"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkImageCreateInfo-imageCreateFormatFeatures-02260\", \"If format is a multi-planar format, and if imageCreateFormatFeatures (as defined in Image Creation Limits) does not contain VK_FORMAT_FEATURE_DISJOINT_BIT, then flags must not contain VK_IMAGE_CREATE_DISJOINT_BIT\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (vkuFormatIsMultiplane(image_format) && ((create_info.flags & VK_IMAGE_CREATE_DISJOINT_BIT) != 0) &&\n    skip |= LogError(\"VUID-VkImageCreateInfo-imageCreateFormatFeatures-02260\", device, loc.dot(Field::usage),\n                     \"includes VK_IMAGE_CREATE_DISJOINT_BIT, but %s doesn't support \"\n                     \"VK_FORMAT_FEATURE_DISJOINT_BIT.\\n\"\n                     \"(supported features: %s)\",\n                     string_VkFormat(create_info.format), string_VkFormatFeatureFlags2(tiling_features).c_str());\n"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkImageCreateInfo-imageCreateFormatFeatures-09048\", \"If imageCreateFormatFeatures (as defined in Image Creation Limits) does not contain VK_FORMAT_FEATURE_2_HOST_IMAGE_TRANSFER_BIT_EXT, then usage must not contain VK_IMAGE_USAGE_HOST_TRANSFER_BIT_EXT\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (((tiling_features & VK_FORMAT_FEATURE_2_HOST_IMAGE_TRANSFER_BIT_EXT) == 0) &&\n    (create_info.usage & VK_IMAGE_USAGE_HOST_TRANSFER_BIT_EXT)) {\n    skip |= LogError(\"VUID-VkImageCreateInfo-imageCreateFormatFeatures-09048\", device, loc.dot(Field::usage),\n                     \"includes VK_IMAGE_USAGE_HOST_TRANSFER_BIT_EXT, but %s doesn't support \"\n                     \"VK_FORMAT_FEATURE_2_HOST_IMAGE_TRANSFER_BIT_EXT.\\n\"\n                     \"(supported features: %s)\",\n                     string_VkFormat(create_info.format), string_VkFormatFeatureFlags2(tiling_features).c_str());\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkImageCreateInfo-pNext-09654\", \"If the pNext chain contains a VkImageAlignmentControlCreateInfoMESA structure, it must not contain a VkExternalMemoryImageCreateInfo structure\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (vku::FindStructInPNextChain<VkExternalMemoryImageCreateInfo>(create_info.pNext)) {\n    skip |= LogError(\"VUID-VkImageCreateInfo-pNext-09654\", device, create_info_loc.dot(Field::pNext),\n                     \"contains both a VkImageAlignmentControlCreateInfoMESA and VkExternalMemoryImageCreateInfo struct.\");\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkImageAlignmentControlCreateInfoMESA-maximumRequestedAlignment-09655\", \"If maximumRequestedAlignment is not 0, maximumRequestedAlignment must be a power of two\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (!IsPowerOfTwo(alignment_control_create_info->maximumRequestedAlignment)) {\n    skip |= LogError(\"VUID-VkImageAlignmentControlCreateInfoMESA-maximumRequestedAlignment-09655\", device,\n                     create_info_loc.pNext(Struct::VkImageAlignmentControlCreateInfoMESA, Field::maximumRequestedAlignment),\n                     \"(%\" PRIu32 \") must be a power of two.\", alignment_control_create_info->maximumRequestedAlignment);\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkImageAlignmentControlCreateInfoMESA-maximumRequestedAlignment-09656\", \"If maximumRequestedAlignment is not 0, the bitwise-and of maximumRequestedAlignment and supportedImageAlignmentMask must be non-zero\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "\"(%\" PRIu32 \") must be a power of two.\", alignment_control_create_info->maximumRequestedAlignment);\n} else if ((alignment_control_create_info->maximumRequestedAlignment &\nskip |= LogError(\"VUID-VkImageAlignmentControlCreateInfoMESA-maximumRequestedAlignment-09656\", device,\ncreate_info_loc.pNext(Struct::VkImageAlignmentControlCreateInfoMESA, Field::maximumRequestedAlignment),\n\"(0x%\" PRIx32 \") and supportedImageAlignmentMask (0x%\" PRIx32 \") don't share any bits.\",\nalignment_control_create_info->maximumRequestedAlignment,\nphys_dev_ext_props.image_alignment_control_props.supportedImageAlignmentMask);\n"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkImageCreateInfo-usage-00964\", \"If usage includes VK_IMAGE_USAGE_COLOR_ATTACHMENT_BIT, VK_IMAGE_USAGE_DEPTH_STENCIL_ATTACHMENT_BIT, VK_IMAGE_USAGE_TRANSIENT_ATTACHMENT_BIT, or VK_IMAGE_USAGE_INPUT_ATTACHMENT_BIT, extent.width must be less than or equal to VkPhysicalDeviceLimits::maxFramebufferWidth\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (pCreateInfo->extent.width > device_limits->maxFramebufferWidth) {\n    skip |= LogError(\"VUID-VkImageCreateInfo-usage-00964\", device, create_info_loc.dot(Field::usage),\n                     \"(%s) include a frame buffer attachment bit and image width (%\" PRIu32\n                     \") exceeds \"\n                     \"device maxFramebufferWidth (%\" PRIu32 \").\",\n                     string_VkImageUsageFlags(pCreateInfo->usage).c_str(), pCreateInfo->extent.width,\n                     device_limits->maxFramebufferWidth);\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkImageCreateInfo-usage-00965\", \"If usage includes VK_IMAGE_USAGE_COLOR_ATTACHMENT_BIT, VK_IMAGE_USAGE_DEPTH_STENCIL_ATTACHMENT_BIT, VK_IMAGE_USAGE_TRANSIENT_ATTACHMENT_BIT, or VK_IMAGE_USAGE_INPUT_ATTACHMENT_BIT, extent.height must be less than or equal to VkPhysicalDeviceLimits::maxFramebufferHeight\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (pCreateInfo->extent.height > device_limits->maxFramebufferHeight) {\n    skip |= LogError(\"VUID-VkImageCreateInfo-usage-00965\", device, create_info_loc.dot(Field::usage),\n                     \"(%s) include a frame buffer attachment bit and image height (%\" PRIu32\n                     \") exceeds \"\n                     \"device maxFramebufferHeight (%\" PRIu32 \").\",\n                     string_VkImageUsageFlags(pCreateInfo->usage).c_str(), pCreateInfo->extent.height,\n                     device_limits->maxFramebufferHeight);\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkImageCreateInfo-fragmentDensityMapOffset-06514\", \"If the fragmentDensityMapOffset feature is not enabled and usage includes VK_IMAGE_USAGE_FRAGMENT_DENSITY_MAP_BIT_EXT, extent.width must be less than or equal to the ceiling of maxFramebufferWidth/minFragmentDensityTexelSize.width\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (pCreateInfo->extent.width > ceiling_width) {\n    skip |= LogError(\"VUID-VkImageCreateInfo-fragmentDensityMapOffset-06514\", device, create_info_loc.dot(Field::usage),\n                     \"includes VK_IMAGE_USAGE_FRAGMENT_DENSITY_MAP_BIT_EXT and image width (%\" PRIu32\n                     \") exceeds the \"\n                     \"ceiling of device \"\n                     \"maxFramebufferWidth (%\" PRIu32 \") / minFragmentDensityTexelSize.width (%\" PRIu32\n                     \"). The ceiling value: %\" PRIu32 \".\",\n                     pCreateInfo->extent.width, device_limits->maxFramebufferWidth,\n                     phys_dev_ext_props.fragment_density_map_props.minFragmentDensityTexelSize.width, ceiling_width);\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkImageCreateInfo-fragmentDensityMapOffset-06515\", \"If the fragmentDensityMapOffset feature is not enabled and usage includes VK_IMAGE_USAGE_FRAGMENT_DENSITY_MAP_BIT_EXT, extent.height must be less than or equal to the ceiling of maxFramebufferHeight/minFragmentDensityTexelSize.height\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (pCreateInfo->extent.height > ceiling_height) {\n    skip |= LogError(\"VUID-VkImageCreateInfo-fragmentDensityMapOffset-06515\", device, create_info_loc.dot(Field::usage),\n                     \"includes VK_IMAGE_USAGE_FRAGMENT_DENSITY_MAP_BIT_EXT and image height (%\" PRIu32\n                     \") exceeds the \"\n                     \"ceiling of device \"\n                     \"maxFramebufferHeight (%\" PRIu32 \") / minFragmentDensityTexelSize.height (%\" PRIu32\n                     \"). The ceiling value: %\" PRIu32 \".\",\n                     pCreateInfo->extent.height, device_limits->maxFramebufferHeight,\n                     phys_dev_ext_props.fragment_density_map_props.minFragmentDensityTexelSize.height, ceiling_height);\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkImageCreateInfo-imageCreateMaxMipLevels-02251\", \"Each of the following values (as described in Image Creation Limits) must not be undefined : imageCreateMaxMipLevels, imageCreateMaxArrayLayers, imageCreateMaxExtent, and imageCreateSampleCounts\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "skip |= LogError(\"VUID-VkImageCreateInfo-imageCreateMaxMipLevels-02251\", device, create_info_loc,\n                 \"The following parameters -\\n\"\n                 \"format (%s)\\n\"\n                 \"type (%s)\\n\"\n                 \"tiling (%s)\\n\"\n                 \"usage (%s)\\n\"\n                 \"flags (%s)\\n\"\n                 \"returned (%s) when calling %s.\",\n                 string_VkFormat(pCreateInfo->format), string_VkImageType(pCreateInfo->imageType),\n                 string_VkImageTiling(pCreateInfo->tiling), string_VkImageUsageFlags(pCreateInfo->usage).c_str(),\n                 string_VkImageCreateFlags(pCreateInfo->flags).c_str(), string_VkResult(result), String(command));\n"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkImageCreateInfo-imageCreateMaxMipLevels-02251\", \"Each of the following values (as described in Image Creation Limits) must not be undefined : imageCreateMaxMipLevels, imageCreateMaxArrayLayers, imageCreateMaxExtent, and imageCreateSampleCounts\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (result != VK_SUCCESS) {\n    skip |= LogError(\"VUID-VkImageCreateInfo-imageCreateMaxMipLevels-02251\", device, create_info_loc,\n                     \"The following parameters -\\n\"\n                     \"format (%s)\\n\"\n                     \"type (%s)\\n\"\n                     \"tiling (%s)\\n\"\n                     \"usage (%s)\\n\"\n                     \"flags (%s)\\n\"\n                     \"drmFormatModifier (%\" PRIu64\n                     \") from %s\\n\"\n                     \"returned (%s) when calling VkGetPhysicalDeviceImageFormatProperties2.\",\n                     string_VkFormat(pCreateInfo->format), string_VkImageType(pCreateInfo->imageType),\n                     string_VkImageTiling(pCreateInfo->tiling), string_VkImageUsageFlags(pCreateInfo->usage).c_str(),\n                     string_VkImageCreateFlags(pCreateInfo->flags).c_str(), drm_format_modifier.drmFormatModifier,\n                     drm_source.c_str(), string_VkResult(result));\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkImageCreateInfo-arrayLayers-02256\", \"arrayLayers must be less than or equal to imageCreateMaxArrayLayers (as defined in Image Creation Limits)\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (pCreateInfo->arrayLayers > format_limits.maxArrayLayers) {\n    skip |= LogError(\"VUID-VkImageCreateInfo-arrayLayers-02256\", device, create_info_loc.dot(Field::arrayLayers),\n                     \"(%d) exceeds allowable maximum supported by format %s (format maxArrayLayers: %\" PRIu32 \").\",\n                     pCreateInfo->arrayLayers, string_VkFormat(pCreateInfo->format), format_limits.maxArrayLayers);\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkImageCreateInfo-samples-02258\", \"samples must be a valid VkSampleCountFlagBits value that is set in imageCreateSampleCounts (as defined in Image Creation Limits)\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if ((pCreateInfo->samples & format_limits.sampleCounts) == 0) {\n    skip |= LogError(\"VUID-VkImageCreateInfo-samples-02258\", device, create_info_loc.dot(Field::samples),\n                     \"(%s) is not supported by format %s (format sampleCounts: %s).\",\n                     string_VkSampleCountFlagBits(pCreateInfo->samples), string_VkFormat(pCreateInfo->format),\n                     string_VkSampleCountFlags(format_limits.sampleCounts).c_str());\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkImageCreateInfo-extent-02252\", \"extent.width must be less than or equal to imageCreateMaxExtent.width (as defined in Image Creation Limits)\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (pCreateInfo->extent.width > format_limits.maxExtent.width) {\n    skip |= LogError(\"VUID-VkImageCreateInfo-extent-02252\", device, create_info_loc.dot(Field::extent).dot(Field::width),\n                     \"(%\" PRIu32 \") exceeds allowable maximum image extent width %\" PRIu32 \" for format %s.\",\n                     pCreateInfo->extent.width, format_limits.maxExtent.width, string_VkFormat(pCreateInfo->format));\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkImageCreateInfo-extent-02253\", \"extent.height must be less than or equal to imageCreateMaxExtent.height (as defined in Image Creation Limits)\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (pCreateInfo->extent.height > format_limits.maxExtent.height) {\n    skip |= LogError(\"VUID-VkImageCreateInfo-extent-02253\", device, create_info_loc.dot(Field::extent).dot(Field::height),\n                     \"(%\" PRIu32 \") exceeds allowable maximum image extent height %\" PRIu32 \" for format %s.\",\n                     pCreateInfo->extent.height, format_limits.maxExtent.height, string_VkFormat(pCreateInfo->format));\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkImageCreateInfo-format-06410\", \"If the image format is one of the formats that require a sampler Y'CBCR conversion, mipLevels must be 1\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (pCreateInfo->mipLevels != 1) {\n    skip |= LogError(\"VUID-VkImageCreateInfo-format-06410\", device, create_info_loc.dot(Field::mipLevels),\n                     \"(%d), but when using a YCbCr Conversion format (%s), mipLevels must be 1.\", pCreateInfo->mipLevels,\n                     string_VkFormat(pCreateInfo->format));\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkImageCreateInfo-format-06411\", \"If the image format is one of the formats that require a sampler Y'CBCR conversion, samples must be VK_SAMPLE_COUNT_1_BIT\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (pCreateInfo->samples != VK_SAMPLE_COUNT_1_BIT) {\n    skip |= LogError(\"VUID-VkImageCreateInfo-format-06411\", device, create_info_loc.dot(Field::samples),\n                     \"(%s), but when using a YCbCr Conversion format (%s), samples must be \"\n                     \"VK_SAMPLE_COUNT_1_BIT.\",\n                     string_VkSampleCountFlagBits(pCreateInfo->samples), string_VkFormat(pCreateInfo->format));\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkImageCreateInfo-format-06412\", \"If the image format is one of the formats that require a sampler Y'CBCR conversion, imageType must be VK_IMAGE_TYPE_2D\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (pCreateInfo->imageType != VK_IMAGE_TYPE_2D) {\n    skip |= LogError(\"VUID-VkImageCreateInfo-format-06412\", device, create_info_loc.dot(Field::imageType),\n                     \"(%s), but when using a YCbCr Conversion format (%s), imageType must be \"\n                     \"VK_IMAGE_TYPE_2D.\",\n                     string_VkImageType(pCreateInfo->imageType), string_VkFormat(pCreateInfo->format));\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkImageCreateInfo-flags-01573\", \"If flags contains VK_IMAGE_CREATE_BLOCK_TEXEL_VIEW_COMPATIBLE_BIT, then flags must also contain VK_IMAGE_CREATE_MUTABLE_FORMAT_BIT\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (!(pCreateInfo->flags & VK_IMAGE_CREATE_MUTABLE_FORMAT_BIT)) {\n    skip |= LogError(\"VUID-VkImageCreateInfo-flags-01573\", device, create_info_loc.dot(Field::flags),\n                     \"contains VK_IMAGE_CREATE_BLOCK_TEXEL_VIEW_COMPATIBLE_BIT, \"\n                     \"flags must also contain VK_IMAGE_CREATE_MUTABLE_FORMAT_BIT.\");\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkImageCreateInfo-flags-01890\", \"If the protectedMemory feature is not enabled, flags must not contain VK_IMAGE_CREATE_PROTECTED_BIT\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (enabled_features.protectedMemory == VK_FALSE) {\n    skip |= LogError(\"VUID-VkImageCreateInfo-flags-01890\", device, create_info_loc.dot(Field::flags),\n                     \"has VK_IMAGE_CREATE_PROTECTED_BIT set, but the protectedMemory device feature is not enabled.\");\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkImageCreateInfo-None-01891\", \"If any of the bits VK_IMAGE_CREATE_SPARSE_BINDING_BIT, VK_IMAGE_CREATE_SPARSE_RESIDENCY_BIT, or VK_IMAGE_CREATE_SPARSE_ALIASED_BIT are set, VK_IMAGE_CREATE_PROTECTED_BIT must not also be set\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if ((pCreateInfo->flags & invalid_flags) != 0) {\n    skip |= LogError(\"VUID-VkImageCreateInfo-None-01891\", device, create_info_loc.dot(Field::flags),\n                     \"can't have both protected and sparse flags set.\");\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkImageCreateInfo-multisampledRenderToSingleSampled-06882\", \"If the multisampledRenderToSingleSampled feature is not enabled, flags must not contain VK_IMAGE_CREATE_MULTISAMPLED_RENDER_TO_SINGLE_SAMPLED_BIT_EXT\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (!(enabled_features.multisampledRenderToSingleSampled)) {\n    skip |= LogError(\"VUID-VkImageCreateInfo-multisampledRenderToSingleSampled-06882\", device,\n                     create_info_loc.dot(Field::flags),\n                     \"contains VK_IMAGE_CREATE_MULTISAMPLED_RENDER_TO_SINGLE_SAMPLED_BIT_EXT but the \"\n                     \"multisampledRenderToSingleSampled feature is not enabled.\");\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkImageCreateInfo-flags-06883\", \"If flags contains VK_IMAGE_CREATE_MULTISAMPLED_RENDER_TO_SINGLE_SAMPLED_BIT_EXT, samples must be VK_SAMPLE_COUNT_1_BIT\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (pCreateInfo->samples != VK_SAMPLE_COUNT_1_BIT) {\n    skip |= LogError(\"VUID-VkImageCreateInfo-flags-06883\", device, create_info_loc.dot(Field::flags),\n                     \"contains VK_IMAGE_CREATE_MULTISAMPLED_RENDER_TO_SINGLE_SAMPLED_BIT_EXT but samples (%s) is not equal \"\n                     \"to VK_SAMPLE_COUNT_1_BIT.\",\n                     string_VkSampleCountFlagBits(pCreateInfo->samples));\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkImageCreateInfo-multisampleArrayImage-04460\", \"If the VK_KHR_portability_subset extension is enabled, and VkPhysicalDevicePortabilitySubsetFeaturesKHR::multisampleArrayImage is VK_FALSE, and samples is not VK_SAMPLE_COUNT_1_BIT, then arrayLayers must be 1\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if ((VK_SAMPLE_COUNT_1_BIT != pCreateInfo->samples) && (1 != pCreateInfo->arrayLayers) &&\n    (VK_FALSE == enabled_features.multisampleArrayImage)) {\n    skip |= LogError(\"VUID-VkImageCreateInfo-multisampleArrayImage-04460\", device, create_info_loc,\n                     \"(portability error) Cannot create an image with samples/texel > 1 && arrayLayers != 1\");\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkImageCreateInfo-pNext-00988\", \"If the pNext chain includes a VkExternalMemoryImageCreateInfoNV structure, it must not contain a VkExternalMemoryImageCreateInfo structure\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (external_memory_create_info_nv != nullptr && external_memory_create_info != nullptr) {\n    skip |= LogError(\"VUID-VkImageCreateInfo-pNext-00988\", device, create_info_loc,\n                     \"has both VkExternalMemoryImageCreateInfoNV and \"\n                     \"VkExternalMemoryImageCreateInfo chained structs.\");\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkImageCreateInfo-pNext-01443\", \"If the pNext chain includes a VkExternalMemoryImageCreateInfo or VkExternalMemoryImageCreateInfoNV structure whose handleTypes member is not 0, initialLayout must be VK_IMAGE_LAYOUT_UNDEFINED\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (pCreateInfo->initialLayout != VK_IMAGE_LAYOUT_UNDEFINED) {\n    skip |= LogError(\"VUID-VkImageCreateInfo-pNext-01443\", device,\n                     create_info_loc.pNext(Struct::VkExternalMemoryImageCreateInfo, Field::handleTypes),\n                     \"is %\" PRIu32 \" but pCreateInfo->initialLayout is %s.\", external_memory_create_info->handleTypes,\n                     string_VkImageLayout(pCreateInfo->initialLayout));\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkImageCreateInfo-pNext-01443\", \"If the pNext chain includes a VkExternalMemoryImageCreateInfo or VkExternalMemoryImageCreateInfoNV structure whose handleTypes member is not 0, initialLayout must be VK_IMAGE_LAYOUT_UNDEFINED\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (pCreateInfo->initialLayout != VK_IMAGE_LAYOUT_UNDEFINED) {\n    skip |= LogError(\"VUID-VkImageCreateInfo-pNext-01443\", device,\n                     create_info_loc.pNext(Struct::VkExternalMemoryImageCreateInfoNV, Field::handleTypes),\n                     \"is %\" PRIu32 \" but pCreateInfo->initialLayout is %s.\", external_memory_create_info_nv->handleTypes,\n                     string_VkImageLayout(pCreateInfo->initialLayout));\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkImageCreateInfo-pNext-00991\", \"If the pNext chain includes a VkExternalMemoryImageCreateInfoNV structure, its handleTypes member must only contain bits that are also in VkExternalImageFormatPropertiesNV::externalMemoryProperties.compatibleHandleTypes, as returned by vkGetPhysicalDeviceExternalImageFormatPropertiesNV with format, imageType, tiling, usage, and flags equal to those in this structure, and with externalHandleType equal to any one of the handle types specified in VkExternalMemoryImageCreateInfoNV::handleTypes\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "skip |= LogError(\"VUID-VkImageCreateInfo-pNext-00991\", device,\n                 create_info_loc.pNext(Struct::VkExternalMemoryImageCreateInfoNV, Field::handleTypes),\n                 \"(%s) is not reported as compatible by vkGetPhysicalDeviceExternalImageFormatPropertiesNV.\",\n                 string_VkExternalMemoryHandleTypeFlagsNV(external_memory_create_info_nv->handleTypes).c_str());\n"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkImageCreateInfo-physicalDeviceCount-01421\", \"If the logical device was created with VkDeviceGroupDeviceCreateInfo::physicalDeviceCount equal to 1, flags must not contain VK_IMAGE_CREATE_SPLIT_INSTANCE_BIND_REGIONS_BIT\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (pCreateInfo->flags & VK_IMAGE_CREATE_SPLIT_INSTANCE_BIND_REGIONS_BIT) {\n    skip |= LogError(\"VUID-VkImageCreateInfo-physicalDeviceCount-01421\", device, create_info_loc.dot(Field::flags),\n                     \"contains VK_IMAGE_CREATE_SPLIT_INSTANCE_BIND_REGIONS_BIT, but the device was created with \"\n                     \"VkDeviceGroupDeviceCreateInfo::physicalDeviceCount equal to 1. Device creation with \"\n                     \"VkDeviceGroupDeviceCreateInfo::physicalDeviceCount equal to 1 may have been implicit.\");\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkImageCreateInfo-flags-08104\", \"If flags includes VK_IMAGE_CREATE_DESCRIPTOR_BUFFER_CAPTURE_REPLAY_BIT_EXT, the descriptorBufferCaptureReplay feature must be enabled\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if ((pCreateInfo->flags & VK_IMAGE_CREATE_DESCRIPTOR_BUFFER_CAPTURE_REPLAY_BIT_EXT) &&\n    skip |= LogError(\"VUID-VkImageCreateInfo-flags-08104\", device, create_info_loc.dot(Field::flags),\n                     \"contains VK_IMAGE_CREATE_DESCRIPTOR_BUFFER_CAPTURE_REPLAY_BIT_EXT but the descriptorBufferCaptureReplay \"\n                     \"feature is not enabled.\");\n"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkImageCreateInfo-pNext-08105\", \"If the pNext chain includes a VkOpaqueCaptureDescriptorDataCreateInfoEXT structure, flags must contain VK_IMAGE_CREATE_DESCRIPTOR_BUFFER_CAPTURE_REPLAY_BIT_EXT\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (opaque_capture_descriptor_buffer && !(pCreateInfo->flags & VK_IMAGE_CREATE_DESCRIPTOR_BUFFER_CAPTURE_REPLAY_BIT_EXT)) {\n    skip |= LogError(\"VUID-VkImageCreateInfo-pNext-08105\", device, create_info_loc.dot(Field::flags),\n                     \"(%s) does not have VK_IMAGE_CREATE_DESCRIPTOR_BUFFER_CAPTURE_REPLAY_BIT_EXT, but \"\n                     \"VkOpaqueCaptureDescriptorDataCreateInfoEXT is in pNext chain.\",\n                     string_VkImageCreateFlags(pCreateInfo->flags).c_str());\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkImageCreateInfo-flags-08329\", \"If flags includes VK_IMAGE_CREATE_VIDEO_PROFILE_INDEPENDENT_BIT_KHR and usage does not include VK_IMAGE_USAGE_VIDEO_DECODE_DST_BIT_KHR, then usage must not include VK_IMAGE_USAGE_VIDEO_DECODE_DPB_BIT_KHR\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (video_profile_independent && (pCreateInfo->usage & VK_IMAGE_USAGE_VIDEO_DECODE_DPB_BIT_KHR) &&\n    skip |= LogError(\"VUID-VkImageCreateInfo-flags-08329\", device, create_info_loc.dot(Field::flags),\n                     \"has VK_IMAGE_CREATE_VIDEO_PROFILE_INDEPENDENT_BIT_KHR set but usage (%s) contains \"\n                     \"VK_IMAGE_USAGE_VIDEO_DECODE_DPB_BIT_KHR without also containing \"\n                     \"VK_IMAGE_USAGE_VIDEO_DECODE_DST_BIT_KHR.\",\n                     string_VkImageUsageFlags(pCreateInfo->usage).c_str());\n"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkImageCreateInfo-flags-08331\", \"If flags includes VK_IMAGE_CREATE_VIDEO_PROFILE_INDEPENDENT_BIT_KHR, then usage must not include VK_IMAGE_USAGE_VIDEO_ENCODE_DPB_BIT_KHR\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (video_profile_independent && (pCreateInfo->usage & VK_IMAGE_USAGE_VIDEO_ENCODE_DPB_BIT_KHR)) {\n    skip |= LogError(\"VUID-VkImageCreateInfo-flags-08331\", device, create_info_loc.dot(Field::flags),\n                     \"has VK_IMAGE_CREATE_VIDEO_PROFILE_INDEPENDENT_BIT_KHR set but usage (%s) contains \"\n                     \"VK_IMAGE_USAGE_VIDEO_ENCODE_DPB_BIT_KHR.\",\n                     string_VkImageUsageFlags(pCreateInfo->usage).c_str());\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkImageCreateInfo-pNext-06811\", \"If the pNext chain includes a VkVideoProfileListInfoKHR structure with profileCount greater than 0, then supportedVideoFormat must be VK_TRUE\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (!supported_video_format) {\n    skip |= LogError(\"VUID-VkImageCreateInfo-pNext-06811\", device, create_info_loc,\n                     \"specifies flags (%s), format (%s), imageType (%s), and tiling (%s) which are not \"\n                     \"supported by any of the supported video format properties for the video profiles \"\n                     \"specified in the VkVideoProfileListInfoKHR structure included in the \"\n                     \"pCreateInfo->pNext chain, as reported by \"\n                     \"vkGetPhysicalDeviceVideoFormatPropertiesKHR for the same video profiles \"\n                     \"and the image usage flags specified in pCreateInfo->usage (%s).\",\n                     string_VkImageCreateFlags(pCreateInfo->flags).c_str(), string_VkFormat(pCreateInfo->format),\n                     string_VkImageType(pCreateInfo->imageType), string_VkImageTiling(pCreateInfo->tiling),\n                     string_VkImageUsageFlags(pCreateInfo->usage).c_str());\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkImageCreateInfo-pNext-06743\", \"If the pNext chain includes a VkImageCompressionControlEXT structure, format is a multi-planar format, and VkImageCompressionControlEXT::flags includes VK_IMAGE_COMPRESSION_FIXED_RATE_EXPLICIT_EXT, then VkImageCompressionControlEXT::compressionControlPlaneCount must be equal to the number of planes in format\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (image_compression_control->compressionControlPlaneCount != vkuFormatPlaneCount(pCreateInfo->format)) {\n    skip |= LogError(\"VUID-VkImageCreateInfo-pNext-06743\", device, create_info_loc,\n                     \"VkImageCompressionControlEXT::flags contain VK_IMAGE_COMPRESSION_FIXED_RATE_EXPLICIT_EXT, but \"\n                     \"VkImageCompressionControlEXT::compressionControlPlaneCount (%\" PRIu32\n                     \") is not equal to the number of planes in the multi-planar format %s (%\" PRIu32 \")\",\n                     image_compression_control->compressionControlPlaneCount, string_VkFormat(pCreateInfo->format),\n                     vkuFormatPlaneCount(pCreateInfo->format));\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-vkDestroyImage-image-04882\", \"image must not have been acquired from vkGetSwapchainImagesKHR\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (image_state->IsSwapchainImage() && image_state->owned_by_swapchain) {\n    skip |= LogError(\"VUID-vkDestroyImage-image-04882\", image, error_obj.location.dot(Field::image),\n                     \"%s is a presentable image controlled by the implementation and must be destroyed \"\n                     \"with vkDestroySwapchainKHR.\",\n                     FormatHandle(image_state->Handle()).c_str());\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-vkDestroyImage-image-01000\", \"All submitted commands that refer to image, either directly or via a VkImageView, must have completed execution\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "FormatHandle(image_state->Handle()).c_str());\nskip |= ValidateObjectNotInUse(image_state.get(), error_obj.location, \"VUID-vkDestroyImage-image-01000\");\n"
        },
        {
            "role": "user",
            "content": "{\"VUID-vkCmdClearColorImage-aspectMask-02498\", \"The VkImageSubresourceRange::aspectMask members of the elements of the pRanges array must each only include VK_IMAGE_ASPECT_COLOR_BIT\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (range.aspectMask != VK_IMAGE_ASPECT_COLOR_BIT) {\n    skip |= LogError(\"VUID-vkCmdClearColorImage-aspectMask-02498\", objlist, loc.dot(Field::aspectMask),\n                     \"is %s (must only include COLOR_BIT).\", string_VkImageAspectFlags(range.aspectMask).c_str());\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-vkCmdClearColorImage-image-00003\", \"If image is non-sparse then it must be bound completely and contiguously to a single VkDeviceMemory object\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "const auto &image_state = *image_state_ptr;\nconst Location image_loc = error_obj.location.dot(Field::image);\nLogObjectList objlist(commandBuffer, image);\nskip |= ValidateMemoryIsBoundToImage(objlist, image_state, image_loc, \"VUID-vkCmdClearColorImage-image-00003\");\n"
        },
        {
            "role": "user",
            "content": "{\"VUID-vkCmdClearColorImage-commandBuffer-01806\", \"If commandBuffer is a protected command buffer and protectedNoFault is not supported, must not be an unprotected image\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "\"VUID-vkCmdClearColorImage-image-01993\");\nskip |= ValidateProtectedImage(cb_state, image_state, image_loc, \"VUID-vkCmdClearColorImage-commandBuffer-01805\");\nskip |= ValidateUnprotectedImage(cb_state, image_state, image_loc, \"VUID-vkCmdClearColorImage-commandBuffer-01806\");\n"
        },
        {
            "role": "user",
            "content": "{\"VUID-vkCmdClearColorImage-image-00007\", \"image must not have a compressed or depth/stencil format\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "LogError(\"VUID-vkCmdClearColorImage-image-00007\", objlist, image_loc,\n         \"(%s) was created with a depth/stencil format (%s).\", FormatHandle(image).c_str(), string_VkFormat(format));\nskip |= LogError(\"VUID-vkCmdClearColorImage-image-00007\", objlist, image_loc,\n             \"(%s) was created with a compressed format (%s).\", FormatHandle(image).c_str(), string_VkFormat(format));\n"
        },
        {
            "role": "user",
            "content": "{\"VUID-vkCmdClearColorImage-image-09678\", \"If image's format has components other than R and G, it must not have a 64-bit component width\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (vkuFormatIs64bit(format) && vkuFormatComponentCount(format) > 2) {\n    skip |= LogError(\"VUID-vkCmdClearColorImage-image-09678\", objlist, image_loc,\n                     \"(%s) was created with a 64-bit format (%s) but it has more than 2 components. The clear command can only \"\n                     \"clear 16 bytes so this format is too large\",\n                     FormatHandle(image).c_str(), string_VkFormat(format));\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-vkCmdClearColorImage-image-00002\", \"image must have been created with VK_IMAGE_USAGE_TRANSFER_DST_BIT usage flag\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (!(image_state.create_info.usage & VK_IMAGE_USAGE_TRANSFER_DST_BIT)) {\n    skip |= LogError(\"VUID-vkCmdClearColorImage-image-00002\", objlist, image_loc,\n                     \"(%s) was created with usage %s (missing VK_IMAGE_USAGE_TRANSFER_DST_BIT).\", FormatHandle(image).c_str(),\n                     string_VkImageUsageFlags(image_state.create_info.usage).c_str());\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-vkCmdClearDepthStencilImage-image-00010\", \"If image is non-sparse then it must be bound completely and contiguously to a single VkDeviceMemory object\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "const VkFormat image_format = image_state.create_info.format;\nconst LogObjectList objlist(commandBuffer, image);\nskip |= ValidateMemoryIsBoundToImage(objlist, image_state, image_loc, \"VUID-vkCmdClearDepthStencilImage-image-00010\");\n"
        },
        {
            "role": "user",
            "content": "{\"VUID-vkCmdClearDepthStencilImage-commandBuffer-01807\", \"If commandBuffer is an unprotected command buffer and protectedNoFault is not supported, image must not be a protected image\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "\"VUID-vkCmdClearDepthStencilImage-image-01994\");\nskip |= ValidateClearDepthStencilValue(commandBuffer, *pDepthStencil, error_obj.location.dot(Field::pDepthStencil));\nskip |= ValidateProtectedImage(cb_state, image_state, image_loc, \"VUID-vkCmdClearDepthStencilImage-commandBuffer-01807\");\n"
        },
        {
            "role": "user",
            "content": "{\"VUID-vkCmdClearDepthStencilImage-commandBuffer-01808\", \"If commandBuffer is a protected command buffer and protectedNoFault is not supported, image must not be an unprotected image\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "skip |= ValidateClearDepthStencilValue(commandBuffer, *pDepthStencil, error_obj.location.dot(Field::pDepthStencil));\nskip |= ValidateProtectedImage(cb_state, image_state, image_loc, \"VUID-vkCmdClearDepthStencilImage-commandBuffer-01807\");\nskip |= ValidateUnprotectedImage(cb_state, image_state, image_loc, \"VUID-vkCmdClearDepthStencilImage-commandBuffer-01808\");\n"
        },
        {
            "role": "user",
            "content": "{\"VUID-vkCmdClearDepthStencilImage-image-02826\", \"If the image's format does not have a depth component, then the VkImageSubresourceRange::aspectMask member of each element of the pRanges array must not include the VK_IMAGE_ASPECT_DEPTH_BIT bit\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (vkuFormatHasDepth(image_format) == false) {\n    skip |= LogError(\"VUID-vkCmdClearDepthStencilImage-image-02826\", objlist, range_loc.dot(Field::aspectMask),\n                     \"has a VK_IMAGE_ASPECT_DEPTH_BIT but %s \"\n                     \"doesn't have a depth component.\",\n                     string_VkFormat(image_format));\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-vkCmdClearDepthStencilImage-pRanges-02658\", \"If the aspect member of any element of pRanges includes VK_IMAGE_ASPECT_STENCIL_BIT, and image was created with separate stencil usage, VK_IMAGE_USAGE_TRANSFER_DST_BIT must have been included in the VkImageStencilUsageCreateInfo::stencilUsage used to create image\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if ((image_stencil_struct->stencilUsage & VK_IMAGE_USAGE_TRANSFER_DST_BIT) == 0) {\n    skip |= LogError(\"VUID-vkCmdClearDepthStencilImage-pRanges-02658\", objlist, range_loc.dot(Field::aspectMask),\n                     \"includes VK_IMAGE_ASPECT_STENCIL_BIT and \"\n                     \"image was created with VkImageStencilUsageCreateInfo::stencilUsage = %s.\",\n                     string_VkImageUsageFlags(image_stencil_struct->stencilUsage).c_str());\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-vkCmdClearDepthStencilImage-pRanges-02659\", \"If the aspect member of any element of pRanges includes VK_IMAGE_ASPECT_STENCIL_BIT, and image was not created with separate stencil usage, VK_IMAGE_USAGE_TRANSFER_DST_BIT must have been included in the VkImageCreateInfo::usage used to create image\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "skip |= LogError(\"VUID-vkCmdClearDepthStencilImage-pRanges-02659\", objlist, range_loc.dot(Field::aspectMask),\n                 \"includes VK_IMAGE_ASPECT_STENCIL_BIT and \"\n                 \"image was not created with VkImageStencilUsageCreateInfo, but was created with \"\n                 \"VK_IMAGE_USAGE_TRANSFER_DST_BIT.\");\n"
        },
        {
            "role": "user",
            "content": "{\"VUID-vkCmdClearDepthStencilImage-pRanges-02659\", \"If the aspect member of any element of pRanges includes VK_IMAGE_ASPECT_STENCIL_BIT, and image was not created with separate stencil usage, VK_IMAGE_USAGE_TRANSFER_DST_BIT must have been included in the VkImageCreateInfo::usage used to create image\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (VK_IMAGE_USAGE_TRANSFER_DST_BIT != (VK_IMAGE_USAGE_TRANSFER_DST_BIT & image_state.create_info.usage)) {\n    skip |= LogError(\"VUID-vkCmdClearDepthStencilImage-pRanges-02659\", objlist, image_loc,\n                     \"(%s) was not created with the \"\n                     \"VK_IMAGE_USAGE_TRANSFER_DST_BIT set.\",\n                     FormatHandle(image).c_str());\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-vkCmdClearAttachments-aspectMask-07884\", \"If the current render pass instance does not use dynamic rendering, and the aspectMask member of any element of pAttachments contains VK_IMAGE_ASPECT_DEPTH_BIT, the current subpass instance's depth-stencil attachment must be either VK_ATTACHMENT_UNUSED or the attachment format must contain a depth component\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if ((aspect_mask & VK_IMAGE_ASPECT_DEPTH_BIT) && !vkuFormatHasDepth(image_view_format)) {\n    const LogObjectList objlist(commandBuffer, cb_state.activeRenderPass->Handle(),\n    skip |= LogError(\"VUID-vkCmdClearAttachments-aspectMask-07884\", objlist, attachment_loc,\n                     \"in pSubpasses[%\" PRIu32\n                     \"] has VK_IMAGE_ASPECT_DEPTH_BIT and is backed by an image view with format (%s).\",\n                     cb_state.GetActiveSubpass(), string_VkFormat(image_view_format));\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkClearAttachment-aspectMask-00020\", \"aspectMask must not include VK_IMAGE_ASPECT_METADATA_BIT\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (aspect_mask & VK_IMAGE_ASPECT_METADATA_BIT) {\n    const LogObjectList objlist(commandBuffer, cb_state.activeRenderPass->Handle());\n    skip |= LogError(\"VUID-VkClearAttachment-aspectMask-00020\", objlist, attachment_loc.dot(Field::aspectMask), \"is %s.\",\n                     string_VkImageAspectFlags(aspect_mask).c_str());\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkClearAttachment-aspectMask-02246\", \"aspectMask must not include VK_IMAGE_ASPECT_MEMORY_PLANE_i_BIT_EXT for any index i\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "const LogObjectList objlist(commandBuffer, cb_state.activeRenderPass->Handle());\nskip |= LogError(\"VUID-VkClearAttachment-aspectMask-02246\", objlist, attachment_loc.dot(Field::aspectMask), \"is %s.\",\n                 string_VkImageAspectFlags(aspect_mask).c_str());\n"
        },
        {
            "role": "user",
            "content": "{\"VUID-vkCmdClearAttachments-aspectMask-07271\", \"If the aspectMask member of any element of pAttachments contains VK_IMAGE_ASPECT_COLOR_BIT, the colorAttachment must be a valid color attachment index in the current render pass instance\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (clear_desc->colorAttachment == VK_ATTACHMENT_UNUSED) {\n    const LogObjectList objlist(commandBuffer, cb_state.activeRenderPass->Handle());\n    skip |= LogError(\"VUID-vkCmdClearAttachments-aspectMask-07271\", objlist, attachment_loc.dot(Field::colorAttachment),\n                     \"is VK_ATTACHMENT_UNUSED, but aspectMask is VK_IMAGE_ASPECT_COLOR_BIT.\");\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkClearAttachment-aspectMask-00019\", \"If aspectMask includes VK_IMAGE_ASPECT_COLOR_BIT, it must not include VK_IMAGE_ASPECT_DEPTH_BIT or VK_IMAGE_ASPECT_STENCIL_BIT\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if ((aspect_mask & VK_IMAGE_ASPECT_DEPTH_BIT) || (aspect_mask & VK_IMAGE_ASPECT_STENCIL_BIT)) {\n    const LogObjectList objlist(commandBuffer, cb_state.activeRenderPass->Handle());\n    skip |= LogError(\"VUID-VkClearAttachment-aspectMask-00019\", objlist, attachment_loc.dot(Field::aspectMask),\n                     \"is %s.\", string_VkImageAspectFlags(aspect_mask).c_str());\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-vkCmdClearAttachments-None-09679\", \"If the attachment format has components other than R and G, it must not have a 64-bit component width\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (vkuFormatIs64bit(image_view_format) && vkuFormatComponentCount(image_view_format) > 2) {\n    const LogObjectList objlist(commandBuffer, image_view->Handle());\n    skip |= LogError(\"VUID-vkCmdClearAttachments-None-09679\", objlist, attachment_loc,\n                     \"(%s) was created with a 64-bit format (%s) but it has more than 2 components. The clear command \"\n                     \"can only clear 16 bytes so this format is too large\",\n                     FormatHandle(image_view->Handle()).c_str(), string_VkFormat(image_view_format));\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-vkCmdClearAttachments-baseArrayLayer-00018\", \"If the render pass instance this is recorded in uses multiview, then baseArrayLayer must be zero and layerCount must be one\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (pRects[i].baseArrayLayer != 0 || pRects[i].layerCount != 1) {\n    const LogObjectList objlist(commandBuffer, cb_state.activeRenderPass->Handle());\n    skip |= LogError(\"VUID-vkCmdClearAttachments-baseArrayLayer-00018\", objlist,\n                     error_obj.location.dot(Field::pRects, i).dot(Field::baseArrayLayer),\n                     \"is %\" PRIu32 \" and layerCount is %\" PRIu32 \", but the render pass instance uses multiview.\",\n                     pRects[i].baseArrayLayer, pRects[i].layerCount);\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkImageSubresourceRange-levelCount-01720\", \"If levelCount is not VK_REMAINING_MIP_LEVELS, it must be greater than 0\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (subresourceRange.levelCount == 0) {\n    skip |= LogError(\"VUID-VkImageSubresourceRange-levelCount-01720\", objlist, subresource_loc.dot(Field::levelCount),\n                     \"is zero.\");\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkImageSubresourceRange-layerCount-01721\", \"If layerCount is not VK_REMAINING_ARRAY_LAYERS, it must be greater than 0\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (subresourceRange.layerCount == 0) {\n    skip |= LogError(\"VUID-VkImageSubresourceRange-layerCount-01721\", objlist, subresource_loc.dot(Field::layerCount),\n                     \"is zero.\");\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkImageSubresourceRange-aspectMask-02278\", \"aspectMask must not include VK_IMAGE_ASPECT_MEMORY_PLANE_i_BIT_EXT for any index i\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (subresourceRange.aspectMask & (VK_IMAGE_ASPECT_MEMORY_PLANE_0_BIT_EXT | VK_IMAGE_ASPECT_MEMORY_PLANE_1_BIT_EXT |\n    skip |= LogError(\"VUID-VkImageSubresourceRange-aspectMask-02278\", objlist, subresource_loc.dot(Field::aspectMask), \"is %s.\",\n                     string_VkImageAspectFlags(subresourceRange.aspectMask).c_str());\n"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkImageViewCreateInfo-None-02273\", \"The format features of the resultant image view must contain at least one bit\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (tiling_features == 0) {\n    skip |= LogError(\"VUID-VkImageViewCreateInfo-None-02273\", image_state.Handle(), create_info_loc.dot(Field::format),\n                     \"%s with tiling %s has no supported format features on this \"\n                     \"physical device.\",\n                     string_VkFormat(view_format), string_VkImageTiling(image_tiling));\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkImageViewCreateInfo-usage-02274\", \"If usage contains VK_IMAGE_USAGE_SAMPLED_BIT, then the format features of the resultant image view must contain VK_FORMAT_FEATURE_SAMPLED_IMAGE_BIT\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "skip |= LogError(\"VUID-VkImageViewCreateInfo-usage-02274\", image_state.Handle(), create_info_loc.dot(Field::format),\n                 \"%s with tiling %s doesn't support VK_FORMAT_FEATURE_SAMPLED_IMAGE_BIT.\\n\"\n                 \"(supported features: %s)\",\n                 string_VkFormat(view_format), string_VkImageTiling(image_tiling),\n                 string_VkFormatFeatureFlags2(tiling_features).c_str());\n"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkImageViewCreateInfo-usage-02275\", \"If usage contains VK_IMAGE_USAGE_STORAGE_BIT, then the image view's format features must contain VK_FORMAT_FEATURE_STORAGE_IMAGE_BIT\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "skip |= LogError(\"VUID-VkImageViewCreateInfo-usage-02275\", image_state.Handle(), create_info_loc.dot(Field::format),\n                 \"%s with tiling %s doesn't support VK_FORMAT_FEATURE_STORAGE_IMAGE_BIT.\\n\"\n                 \"(supported features: %s)\",\n                 string_VkFormat(view_format), string_VkImageTiling(image_tiling),\n                 string_VkFormatFeatureFlags2(tiling_features).c_str());\n"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkImageViewCreateInfo-usage-02277\", \"If usage contains VK_IMAGE_USAGE_DEPTH_STENCIL_ATTACHMENT_BIT, then the image view's format features must contain VK_FORMAT_FEATURE_DEPTH_STENCIL_ATTACHMENT_BIT\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "skip |= LogError(\"VUID-VkImageViewCreateInfo-usage-02277\", image_state.Handle(), create_info_loc.dot(Field::format),\n                 \"%s with tiling %s doesn't support VK_FORMAT_FEATURE_DEPTH_STENCIL_ATTACHMENT_BIT.\\n.\"\n                 \"(supported features: %s)\",\n                 string_VkFormat(view_format), string_VkImageTiling(image_tiling),\n                 string_VkFormatFeatureFlags2(tiling_features).c_str());\n"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkImageViewCreateInfo-usage-08932\", \"If usage contains VK_IMAGE_USAGE_INPUT_ATTACHMENT_BIT, and any of the following is true: the externalFormatResolve feature is not enabled the nullColorAttachmentWithExternalFormatResolve property is VK_FALSE image was created with an VkExternalFormatANDROID::externalFormat value of 0 then the image view's format features must contain at least one of VK_FORMAT_FEATURE_COLOR_ATTACHMENT_BIT or VK_FORMAT_FEATURE_DEPTH_STENCIL_ATTACHMENT_BIT or VK_FORMAT_FEATURE_2_LINEAR_COLOR_ATTACHMENT_BIT_NV\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (!enabled_features.externalFormatResolve && !android_external_format_resolve_null_color_attachment_prop &&\n    !image_state.HasAHBFormat()) {\n    skip |= LogError(\"VUID-VkImageViewCreateInfo-usage-08932\", image_state.Handle(), create_info_loc.dot(Field::format),\n                     \"%s with tiling %s doesn't support one of the required formats.\\n.\"\n                     \"(supported features: %s)\",\n                     string_VkFormat(view_format), string_VkImageTiling(image_tiling),\n                     string_VkFormatFeatureFlags2(tiling_features).c_str());\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkImageViewCreateInfo-usage-04550\", \"If the attachmentFragmentShadingRate feature is enabled, and the usage for the image view includes VK_IMAGE_USAGE_FRAGMENT_SHADING_RATE_ATTACHMENT_BIT_KHR, then the image view's format features must contain VK_FORMAT_FEATURE_FRAGMENT_SHADING_RATE_ATTACHMENT_BIT_KHR\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (enabled_features.attachmentFragmentShadingRate) {\n    skip |= LogError(\"VUID-VkImageViewCreateInfo-usage-04550\", image_state.Handle(), create_info_loc.dot(Field::format),\n                     \"%s with tiling %s doesn't support VK_FORMAT_FEATURE_FRAGMENT_SHADING_RATE_ATTACHMENT_BIT_KHR.\\n.\"\n                     \"(supported features: %s)\",\n                     string_VkFormat(view_format), string_VkImageTiling(image_tiling),\n                     string_VkFormatFeatureFlags2(tiling_features).c_str());\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkImageViewCreateInfo-image-08333\", \"If image was created with VK_IMAGE_CREATE_VIDEO_PROFILE_INDEPENDENT_BIT_KHR and usage contains VK_IMAGE_USAGE_VIDEO_DECODE_DST_BIT_KHR, then the image view's format features must contain VK_FORMAT_FEATURE_VIDEO_DECODE_OUTPUT_BIT_KHR\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if ((image_usage & VK_IMAGE_USAGE_VIDEO_DECODE_DST_BIT_KHR) &&\n    skip |= LogError(\"VUID-VkImageViewCreateInfo-image-08333\", image_state.Handle(), create_info_loc.dot(Field::format),\n                     \"%s and tiling %s doesn't support VK_FORMAT_FEATURE_VIDEO_DECODE_OUTPUT_BIT_KHR.\\n\"\n                     \"(supported features: %s)\",\n                     string_VkFormat(view_format), string_VkImageTiling(image_tiling),\n                     string_VkFormatFeatureFlags2(tiling_features).c_str());\n"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkImageViewCreateInfo-image-08335\", \"If image was created with VK_IMAGE_CREATE_VIDEO_PROFILE_INDEPENDENT_BIT_KHR, then usage must not include VK_IMAGE_USAGE_VIDEO_DECODE_SRC_BIT_KHR\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "skip |= LogError(\"VUID-VkImageViewCreateInfo-image-08335\", image_state.Handle(), create_info_loc.dot(Field::usage),\n                 \"is VK_IMAGE_USAGE_VIDEO_DECODE_SRC_BIT_KHR which is not allowed for image views from video profile \"\n                 \"independent images.\");\n"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkImageViewCreateInfo-image-08336\", \"If image was created with VK_IMAGE_CREATE_VIDEO_PROFILE_INDEPENDENT_BIT_KHR and usage contains VK_IMAGE_USAGE_VIDEO_ENCODE_SRC_BIT_KHR, then the image view's format features must contain VK_FORMAT_FEATURE_VIDEO_ENCODE_INPUT_BIT_KHR\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "skip |= LogError(\"VUID-VkImageViewCreateInfo-image-08336\", image_state.Handle(), create_info_loc.dot(Field::format),\n                 \"%s and tiling %s doesn't support VK_FORMAT_FEATURE_VIDEO_ENCODE_INPUT_BIT_KHR.\\n\"\n                 \"(supported features: %s)\",\n                 string_VkFormat(view_format), string_VkImageTiling(image_tiling),\n                 string_VkFormatFeatureFlags2(tiling_features).c_str());\n"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkImageViewCreateInfo-image-08337\", \"If image was created with VK_IMAGE_CREATE_VIDEO_PROFILE_INDEPENDENT_BIT_KHR and usage contains VK_IMAGE_USAGE_VIDEO_ENCODE_DPB_BIT_KHR, then the image view's format features must contain VK_FORMAT_FEATURE_VIDEO_ENCODE_DPB_BIT_KHR\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "skip |= LogError(\"VUID-VkImageViewCreateInfo-image-08337\", image_state.Handle(), create_info_loc.dot(Field::format),\n                 \"%s and tiling %s doesn't support VK_FORMAT_FEATURE_VIDEO_ENCODE_DPB_BIT_KHR.\\n\"\n                 \"(supported features: %s)\",\n                 string_VkFormat(view_format), string_VkImageTiling(image_tiling),\n                 string_VkFormatFeatureFlags2(tiling_features).c_str());\n"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkImageViewCreateInfo-image-08338\", \"If image was created with VK_IMAGE_CREATE_VIDEO_PROFILE_INDEPENDENT_BIT_KHR, then usage must not include VK_IMAGE_USAGE_VIDEO_ENCODE_DST_BIT_KHR\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "skip |= LogError(\"VUID-VkImageViewCreateInfo-image-08338\", image_state.Handle(), create_info_loc.dot(Field::usage),\n                 \"is VK_IMAGE_USAGE_VIDEO_ENCODE_DST_BIT_KHR which is not allowed for image views from video profile \"\n                 \"independent images.\");\n"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkImageViewSlicedCreateInfoEXT-None-07871\", \"The imageSlicedViewOf3D feature must be enabled on the device\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (feature_disabled) {\n    skip |= LogError(\"VUID-VkImageViewSlicedCreateInfoEXT-None-07871\", pCreateInfo->image, create_info_loc,\n                     \"imageSlicedViewOf3D is not enabled.\");\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkImageViewSlicedCreateInfoEXT-None-07870\", \"The image view must reference exactly 1 mip level\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (normalized_subresource_range.levelCount != 1) {\n    skip |= LogError(\"VUID-VkImageViewSlicedCreateInfoEXT-None-07870\", pCreateInfo->image,\n                     create_info_loc.dot(Field::subresourceRange).dot(Field::levelCount),\n                     \"must be 1 (since pNext includes a VkImageViewSlicedCreateInfoEXT structure) but it is %s\",\n                     string_LevelCount(image_state.create_info, pCreateInfo->subresourceRange).c_str());\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkImageViewSlicedCreateInfoEXT-sliceOffset-07867\", \"sliceOffset must be less than the effective view depth as specified in Image Mip Level Sizing\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (slice_offset >= effective_view_depth) {\n    skip |= LogError(\"VUID-VkImageViewSlicedCreateInfoEXT-sliceOffset-07867\", pCreateInfo->image,\n                     create_info_loc.pNext(Struct::VkImageViewSlicedCreateInfoEXT, Field::sliceOffset),\n                     \"(%\" PRIu32 \") must be less than the effective view depth (%\" PRIu32 \").\", slice_offset,\n                     effective_view_depth);\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkImageViewSlicedCreateInfoEXT-sliceCount-07868\", \"If sliceCount is not VK_REMAINING_3D_SLICES_EXT, it must be non-zero and sliceOffset + sliceCount must be less than or equal to the effective view depth as specified in Image Mip Level Sizing\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (slice_count == 0) {\n    skip |= LogError(\"VUID-VkImageViewSlicedCreateInfoEXT-sliceCount-07868\", pCreateInfo->image,\n                     create_info_loc.pNext(Struct::VkImageViewSlicedCreateInfoEXT, Field::sliceCount), \"is 0.\");\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkImageViewCreateInfo-pNext-01585\", \"If a VkImageFormatListCreateInfo structure was included in the pNext chain of the VkImageCreateInfo structure used when creating image and VkImageFormatListCreateInfo::viewFormatCount is not zero then format must be one of the formats in VkImageFormatListCreateInfo::pViewFormats\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (found_format == false) {\n    skip |= LogError(\"VUID-VkImageViewCreateInfo-pNext-01585\", pCreateInfo->image,\n                     create_info_loc.pNext(Struct::VkImageFormatListCreateInfo, Field::pViewFormats),\n                     \"has no formats that match the VkImageViewCreateInfo::format (%s).\", string_VkFormat(view_format));\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkImageViewCreateInfo-subresourceRange-07818\", \"subresourceRange.aspectMask must only have at most 1 valid multi-planar aspect mask bit\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (multiplane_image && IsMultiplePlaneAspect(aspect_mask)) {\n    skip |= LogError(\"VUID-VkImageViewCreateInfo-subresourceRange-07818\", pCreateInfo->image,\n                     create_info_loc.dot(Field::subresourceRange).dot(Field::aspectMask), \"(%s) is invalid for %s.\",\n                     string_VkImageAspectFlags(aspect_mask).c_str(), string_VkFormat(image_format));\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkImageViewCreateInfo-image-01586\", \"If image was created with the VK_IMAGE_CREATE_MUTABLE_FORMAT_BIT flag, if the format of the image is a multi-planar format, and if subresourceRange.aspectMask is one of the multi-planar aspect mask bits, then format must be compatible with the VkFormat for the plane of the image format indicated by subresourceRange.aspectMask, as defined in Compatible Formats of Planes of Multi-Planar Formats\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (has_valid_aspect && ((image_class != view_class) || (image_class == VKU_FORMAT_COMPATIBILITY_CLASS_NONE))) {\n    // View format must match the multiplane compatible format\n    skip |= LogError(\"VUID-VkImageViewCreateInfo-image-01586\", pCreateInfo->image, create_info_loc.dot(Field::format),\n                     \"(%s) is not compatible with plane %\" PRIu32 \" of the %s format %s, must be compatible with %s.\",\n                     string_VkFormat(view_format), vkuGetPlaneIndex(static_cast<VkImageAspectFlagBits>(aspect_mask)), FormatHandle(pCreateInfo->image).c_str(),\n                     string_VkFormat(image_format), string_VkFormat(compat_format));\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkImageViewCreateInfo-image-01762\", \"If image was not created with the VK_IMAGE_CREATE_MUTABLE_FORMAT_BIT flag, or if the format of the image is a multi-planar format and if subresourceRange.aspectMask is VK_IMAGE_ASPECT_COLOR_BIT, format must be identical to the format used to create image\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if ((image_format != view_format) && (!multiplane_image || (aspect_mask != VK_IMAGE_ASPECT_COLOR_BIT))) {\n    skip |= LogError(\"VUID-VkImageViewCreateInfo-image-01762\", pCreateInfo->image, create_info_loc.dot(Field::format),\n                     \"%s is different from %s format (%s). Formats MUST be IDENTICAL unless VK_IMAGE_CREATE_MUTABLE_FORMAT \"\n                     \"BIT was set on image creation.\",\n                     string_VkFormat(view_format), FormatHandle(pCreateInfo->image).c_str(), string_VkFormat(image_format));\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkImageViewCreateInfo-subResourceRange-01021\", \"viewType must be compatible with the type of image as shown in the view type compatibility table\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (view_type != VK_IMAGE_VIEW_TYPE_1D && view_type != VK_IMAGE_VIEW_TYPE_1D_ARRAY) {\n    skip |= LogError(\"VUID-VkImageViewCreateInfo-subResourceRange-01021\", pCreateInfo->image,\n                     create_info_loc.dot(Field::viewType), \"(%s) is not compatible with image type %s.\",\n                     string_VkImageViewType(view_type), string_VkImageType(image_type));\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkImageViewCreateInfo-subResourceRange-01021\", \"viewType must be compatible with the type of image as shown in the view type compatibility table\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "create_info_loc.dot(Field::viewType), \"(%s) is not compatible with image type %s.\",\nskip |= LogError(\"VUID-VkImageViewCreateInfo-subResourceRange-01021\", pCreateInfo->image,\ncreate_info_loc.dot(Field::viewType), \"(%s) is not compatible with image type %s.\",\nstring_VkImageViewType(view_type), string_VkImageType(image_type));\n"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkImageViewCreateInfo-subResourceRange-01021\", \"viewType must be compatible with the type of image as shown in the view type compatibility table\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "string_LevelCount(image_state.create_info, pCreateInfo->subresourceRange).c_str());\nskip |= LogError(\"VUID-VkImageViewCreateInfo-subResourceRange-01021\", pCreateInfo->image,\ncreate_info_loc.dot(Field::viewType), \"(%s) is not compatible with image type %s.\",\nstring_VkImageViewType(view_type), string_VkImageType(image_type));\n"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkImageViewCreateInfo-subResourceRange-01021\", \"viewType must be compatible with the type of image as shown in the view type compatibility table\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if ((view_type == VK_IMAGE_VIEW_TYPE_2D || view_type == VK_IMAGE_VIEW_TYPE_2D_ARRAY)) {\n    skip |= LogError(\"VUID-VkImageViewCreateInfo-subResourceRange-01021\", pCreateInfo->image,\n                     create_info_loc.dot(Field::viewType),\n                     \"(%s) is not compatible with image type %s \"\n                     \"without VK_KHR_maintenance1 enabled which was promoted in Vulkan 1.0.\",\n                     string_VkImageViewType(view_type), string_VkImageType(image_type));\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkImageViewCreateInfo-image-01003\", \"If image was not created with VK_IMAGE_CREATE_CUBE_COMPATIBLE_BIT then viewType must not be VK_IMAGE_VIEW_TYPE_CUBE or VK_IMAGE_VIEW_TYPE_CUBE_ARRAY\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if ((view_type == VK_IMAGE_VIEW_TYPE_CUBE || view_type == VK_IMAGE_VIEW_TYPE_CUBE_ARRAY) &&\n    skip |= LogError(\"VUID-VkImageViewCreateInfo-image-01003\", pCreateInfo->image,\n                     create_info_loc.dot(Field::viewType), \"(%s) is not compatible with image type %s.\",\n                     string_VkImageViewType(view_type), string_VkImageType(image_type));\n"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkImageViewCreateInfo-image-06728\", \"If image was created with VK_IMAGE_TYPE_3D but without VK_IMAGE_CREATE_2D_ARRAY_COMPATIBLE_BIT or VK_IMAGE_CREATE_2D_VIEW_COMPATIBLE_BIT_EXT set, then viewType must not be VK_IMAGE_VIEW_TYPE_2D\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "skip |= LogError(\"VUID-VkImageViewCreateInfo-image-06728\", pCreateInfo->image,\n                 create_info_loc.dot(Field::viewType),\n                 \"(%s) is not compatible with image type \"\n                 \"%s since the image doesn't have VK_IMAGE_CREATE_2D_ARRAY_COMPATIBLE_BIT or \"\n                 \"VK_IMAGE_CREATE_2D_VIEW_COMPATIBLE_BIT_EXT flag set.\",\n                 string_VkImageViewType(view_type), string_VkImageType(image_type));\n"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkImageViewCreateInfo-image-06728\", \"If image was created with VK_IMAGE_TYPE_3D but without VK_IMAGE_CREATE_2D_ARRAY_COMPATIBLE_BIT or VK_IMAGE_CREATE_2D_VIEW_COMPATIBLE_BIT_EXT set, then viewType must not be VK_IMAGE_VIEW_TYPE_2D\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "skip |= LogError(\"VUID-VkImageViewCreateInfo-image-06728\", pCreateInfo->image,\n                 create_info_loc.dot(Field::viewType),\n                 \"VK_IMAGE_VIEW_TYPE_2D is not compatible \"\n                 \"with image type \"\n                 \"%s since the image doesn't have VK_IMAGE_CREATE_2D_ARRAY_COMPATIBLE_BIT flag set.\",\n                 string_VkImageType(image_type));\n"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkImageViewCreateInfo-image-04970\", \"If image was created with VK_IMAGE_TYPE_3D and viewType is VK_IMAGE_VIEW_TYPE_2D or VK_IMAGE_VIEW_TYPE_2D_ARRAY then subresourceRange.levelCount must be 1\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "skip |= LogError(\"VUID-VkImageViewCreateInfo-image-04970\", pCreateInfo->image,\n                 create_info_loc.dot(Field::viewType),\n                 \"(%s) is with image type %s must have a \"\n                 \"subresourcesRange.levelCount of 1 but it is %s.\",\n                 string_VkImageViewType(view_type), string_VkImageType(image_type),\n                 string_LevelCount(image_state.create_info, pCreateInfo->subresourceRange).c_str());\n"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkImageViewCreateInfo-image-02086\", \"If image was created with usage containing VK_IMAGE_USAGE_FRAGMENT_SHADING_RATE_ATTACHMENT_BIT_KHR, viewType must be VK_IMAGE_VIEW_TYPE_2D or VK_IMAGE_VIEW_TYPE_2D_ARRAY\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (view_type != VK_IMAGE_VIEW_TYPE_2D && view_type != VK_IMAGE_VIEW_TYPE_2D_ARRAY) {\n    skip |= LogError(\"VUID-VkImageViewCreateInfo-image-02086\", pCreateInfo->image, create_info_loc.dot(Field::image),\n                     \"was created with usage containing \"\n                     \"VK_IMAGE_USAGE_FRAGMENT_SHADING_RATE_ATTACHMENT_BIT_KHR, viewType must be \"\n                     \"VK_IMAGE_VIEW_TYPE_2D or VK_IMAGE_VIEW_TYPE_2D_ARRAY.\");\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkImageViewCreateInfo-usage-04551\", \"If the attachmentFragmentShadingRate feature is enabled, the usage for the image view includes VK_IMAGE_USAGE_FRAGMENT_SHADING_RATE_ATTACHMENT_BIT_KHR, and layeredShadingRateAttachments is VK_FALSE, subresourceRange.layerCount must be 1\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (enabled_features.attachmentFragmentShadingRate &&\n    skip |= LogError(\"VUID-VkImageViewCreateInfo-usage-04551\", pCreateInfo->image,\n                     create_info_loc.dot(Field::subresourceRange).dot(Field::layerCount),\n                     \"is %s for a shading rate attachment image view.\",\n                     string_LayerCount(image_state.create_info, pCreateInfo->subresourceRange).c_str());\n"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkImageViewCreateInfo-viewType-02962\", \"If viewType is VK_IMAGE_VIEW_TYPE_CUBE and subresourceRange.layerCount is VK_REMAINING_ARRAY_LAYERS, the remaining number of layers must be 6\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (view_type == VK_IMAGE_VIEW_TYPE_CUBE && remaining_layers != 6) {\n    skip |= LogError(\"VUID-VkImageViewCreateInfo-viewType-02962\", pCreateInfo->image,\n                     create_info_loc.dot(Field::subresourceRange).dot(Field::layerCount),\n                     \"VK_REMAINING_ARRAY_LAYERS=(%d) must be 6.\", remaining_layers);\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkImageViewCreateInfo-viewType-02963\", \"If viewType is VK_IMAGE_VIEW_TYPE_CUBE_ARRAY and subresourceRange.layerCount is VK_REMAINING_ARRAY_LAYERS, the remaining number of layers must be a multiple of 6\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (view_type == VK_IMAGE_VIEW_TYPE_CUBE_ARRAY && ((remaining_layers) % 6) != 0) {\n    skip |= LogError(\"VUID-VkImageViewCreateInfo-viewType-02963\", pCreateInfo->image,\n                     create_info_loc.dot(Field::subresourceRange).dot(Field::layerCount),\n                     \"VK_REMAINING_ARRAY_LAYERS=(%d) must be a multiple of 6.\", remaining_layers);\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkImageViewCreateInfo-image-02571\", \"If image was created with usage containing VK_IMAGE_USAGE_FRAGMENT_DENSITY_MAP_BIT_EXT, subresourceRange.levelCount must be 1\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (normalized_subresource_range.levelCount != 1) {\n    skip |= LogError(\"VUID-VkImageViewCreateInfo-image-02571\", pCreateInfo->image, create_info_loc.dot(Field::image),\n                     \"was created with usage containing \"\n                     \"VK_IMAGE_USAGE_FRAGMENT_DENSITY_MAP_BIT_EXT and subresourcesRange.levelCount must be 1 but it is %s\",\n                     string_LevelCount(image_state.create_info, pCreateInfo->subresourceRange).c_str());\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkImageViewCreateInfo-flags-02572\", \"If the fragmentDensityMapDynamic feature is not enabled, flags must not contain VK_IMAGE_VIEW_CREATE_FRAGMENT_DENSITY_MAP_DYNAMIC_BIT_EXT\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (!enabled_features.fragmentDensityMapDynamic) {\n    skip |= LogError(\"VUID-VkImageViewCreateInfo-flags-02572\", pCreateInfo->image, create_info_loc.dot(Field::flags),\n                     \"contains VK_IMAGE_VIEW_CREATE_FRAGMENT_DENSITY_MAP_DYNAMIC_BIT_EXT but the fragmentDensityMapDynamic \"\n                     \"feature is not enabled.\");\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkImageViewCreateInfo-flags-04116\", \"If flags does not contain VK_IMAGE_VIEW_CREATE_FRAGMENT_DENSITY_MAP_DYNAMIC_BIT_EXT and image was created with usage containing VK_IMAGE_USAGE_FRAGMENT_DENSITY_MAP_BIT_EXT, its flags must not contain any of VK_IMAGE_CREATE_PROTECTED_BIT, VK_IMAGE_CREATE_SPARSE_BINDING_BIT, VK_IMAGE_CREATE_SPARSE_RESIDENCY_BIT, or VK_IMAGE_CREATE_SPARSE_ALIASED_BIT\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (image_flags & (VK_IMAGE_CREATE_PROTECTED_BIT | VK_IMAGE_CREATE_SPARSE_BINDING_BIT |\n    skip |= LogError(\"VUID-VkImageViewCreateInfo-flags-04116\", pCreateInfo->image, create_info_loc.dot(Field::image),\n                     \"was created with usage containing \"\n                     \"VK_IMAGE_USAGE_FRAGMENT_DENSITY_MAP_BIT_EXT flags must not contain any of \"\n                     \"VK_IMAGE_CREATE_PROTECTED_BIT, VK_IMAGE_CREATE_SPARSE_BINDING_BIT, \"\n                     \"VK_IMAGE_CREATE_SPARSE_RESIDENCY_BIT, or VK_IMAGE_CREATE_SPARSE_ALIASED_BIT\");\n"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkImageViewCreateInfo-image-07072\", \"If image was created with the VK_IMAGE_CREATE_BLOCK_TEXEL_VIEW_COMPATIBLE_BIT flag and format is a non-compressed format, the levelCount member of subresourceRange must be 1\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (normalized_subresource_range.levelCount != 1) {\n    skip |= LogError(\"VUID-VkImageViewCreateInfo-image-07072\", pCreateInfo->image, create_info_loc.dot(Field::image),\n                     \"was created with VK_IMAGE_CREATE_BLOCK_TEXEL_VIEW_COMPATIBLE_BIT bit, \"\n                     \"and format (%s) is not compressed, but subresourcesRange.levelCount is %s (instead of 1).\",\n                     string_VkFormat(view_format),\n                     string_LevelCount(image_state.create_info, pCreateInfo->subresourceRange).c_str());\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkImageViewCreateInfo-image-01583\", \"If image was created with the VK_IMAGE_CREATE_BLOCK_TEXEL_VIEW_COMPATIBLE_BIT flag, format must be compatible with, or must be an uncompressed format that is size-compatible with, the format used to create image\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (!class_compatible && !size_compatible) {\n    skip |= LogError(\"VUID-VkImageViewCreateInfo-image-01583\", pCreateInfo->image, create_info_loc.dot(Field::image),\n                     \"was created with VK_IMAGE_CREATE_BLOCK_TEXEL_VIEW_COMPATIBLE_BIT bit and \"\n                     \"format (%s), but pCreateInfo->format (%s) are not compatible.\",\n                     string_VkFormat(image_format), string_VkFormat(view_format));\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkImageViewCreateInfo-flags-03567\", \"If the fragmentDensityMapDeferred feature is not enabled, flags must not contain VK_IMAGE_VIEW_CREATE_FRAGMENT_DENSITY_MAP_DEFERRED_BIT_EXT\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (!enabled_features.fragmentDensityMapDeferred) {\n    skip |= LogError(\"VUID-VkImageViewCreateInfo-flags-03567\", pCreateInfo->image, create_info_loc.dot(Field::flags),\n                     \"includes VK_IMAGE_VIEW_CREATE_FRAGMENT_DENSITY_MAP_DEFERRED_BIT_EXT but the \"\n                     \"fragmentDensityMapDeferred feature is not enabled.\");\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkImageViewCreateInfo-flags-03568\", \"If flags contains VK_IMAGE_VIEW_CREATE_FRAGMENT_DENSITY_MAP_DEFERRED_BIT_EXT, flags must not contain VK_IMAGE_VIEW_CREATE_FRAGMENT_DENSITY_MAP_DYNAMIC_BIT_EXT\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (pCreateInfo->flags & VK_IMAGE_VIEW_CREATE_FRAGMENT_DENSITY_MAP_DYNAMIC_BIT_EXT) {\n    skip |= LogError(\"VUID-VkImageViewCreateInfo-flags-03568\", pCreateInfo->image, create_info_loc.dot(Field::flags),\n                     \"(%s) includes both DEFERRED_BIT and DYNAMIC_BIT.\",\n                     string_VkImageViewCreateFlags(pCreateInfo->flags).c_str());\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkImageViewCreateInfo-image-03569\", \"If image was created with flags containing VK_IMAGE_CREATE_SUBSAMPLED_BIT_EXT and usage containing VK_IMAGE_USAGE_SAMPLED_BIT, subresourceRange.layerCount must be less than or equal to VkPhysicalDeviceFragmentDensityMap2PropertiesEXT::maxSubsampledArrayLayers\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if ((image_flags & VK_IMAGE_CREATE_SUBSAMPLED_BIT_EXT) && (image_usage & VK_IMAGE_USAGE_SAMPLED_BIT) &&\n    skip |= LogError(\"VUID-VkImageViewCreateInfo-image-03569\", pCreateInfo->image, create_info_loc.dot(Field::image),\n                     \"was created with flags containing \"\n                     \"VK_IMAGE_CREATE_SUBSAMPLED_BIT_EXT and usage containing VK_IMAGE_USAGE_SAMPLED_BIT \"\n                     \"but subresourceRange.layerCount (%s) must be less than or equal to maxSubsampledArrayLayers (%d)\",\n                     string_LayerCount(image_state.create_info, pCreateInfo->subresourceRange).c_str(),\n                     phys_dev_ext_props.fragment_density_map2_props.maxSubsampledArrayLayers);\n"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkImageViewCreateInfo-imageViewFormatSwizzle-04465\", \"If the VK_KHR_portability_subset extension is enabled, and VkPhysicalDevicePortabilitySubsetFeaturesKHR::imageViewFormatSwizzle is VK_FALSE, all elements of components must have the identity swizzle\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if ((VK_FALSE == enabled_features.imageViewFormatSwizzle) && !IsIdentitySwizzle(pCreateInfo->components)) {\n    skip |= LogError(\"VUID-VkImageViewCreateInfo-imageViewFormatSwizzle-04465\", pCreateInfo->image, create_info_loc,\n                     \"(portability error): swizzle is disabled for this device.\");\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkImageViewMinLodCreateInfoEXT-minLod-06455\", \"If the minLod feature is not enabled, minLod must be 0.0\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if ((!enabled_features.minLod) && (image_view_min_lod->minLod != 0)) {\n    skip |= LogError(\"VUID-VkImageViewMinLodCreateInfoEXT-minLod-06455\", pCreateInfo->image,\n                     create_info_loc.pNext(Struct::VkImageViewMinLodCreateInfoEXT, Field::minLod),\n                     \"%f, but the minLod feature is not enabled.\", image_view_min_lod->minLod);\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkImageViewMinLodCreateInfoEXT-minLod-06456\", \"minLod must be less or equal to the index of the last mipmap level accessible to the view\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (image_view_min_lod->minLod > max_level) {\n    skip |= LogError(\"VUID-VkImageViewMinLodCreateInfoEXT-minLod-06456\", pCreateInfo->image,\n                     create_info_loc.pNext(Struct::VkImageViewMinLodCreateInfoEXT, Field::minLod),\n                     \"(%f) must be less or equal to the index of the last mipmap level \"\n                     \"accessible to the view (%f).\",\n                     image_view_min_lod->minLod, max_level);\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkImageViewCreateInfo-pNext-06658\", \"If the pNext chain includes a VkSamplerYcbcrConversionInfo structure with a conversion value other than VK_NULL_HANDLE, format must be the same used in VkSamplerYcbcrConversionCreateInfo::format\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (ycbcr_state && (pCreateInfo->format != ycbcr_state->format)) {\n    skip |= LogError(\"VUID-VkImageViewCreateInfo-pNext-06658\", pCreateInfo->image,\n                     create_info_loc.pNext(Struct::VkSamplerYcbcrConversionInfo, Field::conversion),\n                     \"was created with format %s which is different than pCreateInfo->format %s.\",\n                     string_VkFormat(ycbcr_state->format), string_VkFormat(view_format));\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkImageViewCreateInfo-image-04817\", \"If image was created with usage containing VK_IMAGE_USAGE_VIDEO_DECODE_DST_BIT_KHR, VK_IMAGE_USAGE_VIDEO_DECODE_SRC_BIT_KHR, or VK_IMAGE_USAGE_VIDEO_DECODE_DPB_BIT_KHR, then the viewType must be VK_IMAGE_VIEW_TYPE_2D or VK_IMAGE_VIEW_TYPE_2D_ARRAY\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (image_usage & decode_usage) {\n    skip |= LogError(\"VUID-VkImageViewCreateInfo-image-04817\", pCreateInfo->image, create_info_loc.dot(Field::viewType),\n                     \"%s is incompatible with video decode usage.\", string_VkImageViewType(pCreateInfo->viewType));\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkImageViewCreateInfo-image-04818\", \"If image was created with usage containing VK_IMAGE_USAGE_VIDEO_ENCODE_DST_BIT_KHR, VK_IMAGE_USAGE_VIDEO_ENCODE_SRC_BIT_KHR, or VK_IMAGE_USAGE_VIDEO_ENCODE_DPB_BIT_KHR, then the viewType must be VK_IMAGE_VIEW_TYPE_2D or VK_IMAGE_VIEW_TYPE_2D_ARRAY\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (image_usage & encode_usage) {\n    skip |= LogError(\"VUID-VkImageViewCreateInfo-image-04818\", pCreateInfo->image, create_info_loc.dot(Field::viewType),\n                     \"%s is incompatible with video encode usage.\", string_VkImageViewType(pCreateInfo->viewType));\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkImageViewCreateInfo-flags-08106\", \"If flags includes VK_IMAGE_VIEW_CREATE_DESCRIPTOR_BUFFER_CAPTURE_REPLAY_BIT_EXT, the descriptorBufferCaptureReplay feature must be enabled\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if ((pCreateInfo->flags & VK_IMAGE_VIEW_CREATE_DESCRIPTOR_BUFFER_CAPTURE_REPLAY_BIT_EXT) &&\n    skip |= LogError(\"VUID-VkImageViewCreateInfo-flags-08106\", pCreateInfo->image, create_info_loc.dot(Field::flags),\n                     \"includes VK_IMAGE_VIEW_CREATE_DESCRIPTOR_BUFFER_CAPTURE_REPLAY_BIT_EXT but the \"\n                     \"descriptorBufferCaptureReplay feature is not enabled.\");\n"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkImageViewCreateInfo-pNext-08107\", \"If the pNext chain includes a VkOpaqueCaptureDescriptorDataCreateInfoEXT structure, flags must contain VK_IMAGE_VIEW_CREATE_DESCRIPTOR_BUFFER_CAPTURE_REPLAY_BIT_EXT\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (const auto opaque_capture_descriptor_buffer =\n        vku::FindStructInPNextChain<VkOpaqueCaptureDescriptorDataCreateInfoEXT>(pCreateInfo->pNext);\n    opaque_capture_descriptor_buffer && !(pCreateInfo->flags & VK_IMAGE_VIEW_CREATE_DESCRIPTOR_BUFFER_CAPTURE_REPLAY_BIT_EXT)) {\n    skip |= LogError(\"VUID-VkImageViewCreateInfo-pNext-08107\", pCreateInfo->image, create_info_loc.dot(Field::flags),\n                     \"(%s) is missing VK_IMAGE_VIEW_CREATE_DESCRIPTOR_BUFFER_CAPTURE_REPLAY_BIT_EXT but \"\n                     \"VkOpaqueCaptureDescriptorDataCreateInfoEXT is in pNext chain.\",\n                     string_VkImageViewCreateFlags(pCreateInfo->flags).c_str());\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkImageViewCreateInfo-format-04715\", \"If format has a _420 suffix then image must have been created with a height that is a multiple of 2\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (vkuFormatIsYChromaSubsampled(view_format) && (SafeModulo(image_state.create_info.extent.height, 2) != 0)) {\n    skip |= LogError(\"VUID-VkImageViewCreateInfo-format-04715\", device, create_info_loc.dot(Field::format),\n                     \"(%s) is Y Chroma Subsampled (has _420 suffix) so the image height (%\" PRIu32 \") must be a multiple of 2.\",\n                     string_VkFormat(view_format), image_state.create_info.extent.height);\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-vkDestroyImageView-imageView-01026\", \"All submitted commands that refer to imageView must have completed execution\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (auto image_view_state = Get<vvl::ImageView>(imageView)) {\n    skip |= ValidateObjectNotInUse(image_view_state.get(), error_obj.location, \"VUID-vkDestroyImageView-imageView-01026\");\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-vkGetImageSubresourceLayout-image-07790\", \"image must have been created with tiling equal to VK_IMAGE_TILING_LINEAR or VK_IMAGE_TILING_DRM_FORMAT_MODIFIER_EXT\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if ((image_state->create_info.tiling != VK_IMAGE_TILING_LINEAR) &&\n    skip |= LogError(\"VUID-vkGetImageSubresourceLayout-image-07790\", image, error_obj.location,\n                     \"image was created with tiling %s.\", string_VkImageTiling(image_state->create_info.tiling));\n"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkHostImageLayoutTransitionInfoEXT-image-09055\", \"image must have been created with VK_IMAGE_USAGE_HOST_TRANSFER_BIT_EXT\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if ((image_state->create_info.usage & VK_IMAGE_USAGE_HOST_TRANSFER_BIT_EXT) == 0) {\n    const LogObjectList objlist(device, image_state->Handle());\n    skip |= LogError(\"VUID-VkHostImageLayoutTransitionInfoEXT-image-09055\", objlist, transition_loc.dot(Field::image),\n                     \"was created with usage (%s) which does not contain \"\n                     \"VK_IMAGE_USAGE_HOST_TRANSFER_BIT_EXT.\",\n                     string_VkImageUsageFlags(image_state->create_info.usage).c_str());\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkHostImageLayoutTransitionInfoEXT-image-09242\", \"If image has a color format and is not disjoint, then the aspectMask member of subresourceRange must be VK_IMAGE_ASPECT_COLOR_BIT\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "const LogObjectList objlist(device, image_state->Handle());\nskip |= LogError(\"VUID-VkHostImageLayoutTransitionInfoEXT-image-09242\", objlist,\n                 transition_loc.dot(Field::subresourceRange).dot(Field::aspectMask),\n                 \"is %s (not VK_IMAGE_ASPECT_COLOR_BIT) and image was created with format %s.\",\n                 string_VkImageAspectFlags(aspect_mask).c_str(), string_VkFormat(image_format));\n"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkHostImageLayoutTransitionInfoEXT-image-01672\", \"If image has a multi-planar format and the image is disjoint, then the aspectMask member of subresourceRange must include at least one multi-planar aspect mask bit or VK_IMAGE_ASPECT_COLOR_BIT\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (!IsValidPlaneAspect(image_format, aspect_mask) && ((aspect_mask & VK_IMAGE_ASPECT_COLOR_BIT) == 0)) {\n    const LogObjectList objlist(device, image_state->Handle());\n    skip |= LogError(\"VUID-VkHostImageLayoutTransitionInfoEXT-image-01672\", objlist,\n                     transition_loc.dot(Field::subresourceRange).dot(Field::aspectMask),\n                     \"is %s and image was created with format %s.\", string_VkImageAspectFlags(aspect_mask).c_str(),\n                     string_VkFormat(image_format));\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkHostImageLayoutTransitionInfoEXT-image-03319\", \"If image has a depth/stencil format with both depth and stencil and the separateDepthStencilLayouts feature is enabled, then the aspectMask member of subresourceRange must include either or both VK_IMAGE_ASPECT_DEPTH_BIT and VK_IMAGE_ASPECT_STENCIL_BIT\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (!has_depth_mask && !has_stencil_mask) {\n    const LogObjectList objlist(device, image_state->Handle());\n    skip |= LogError(\"VUID-VkHostImageLayoutTransitionInfoEXT-image-03319\", objlist,\n                     transition_loc.dot(Field::subresourceRange).dot(Field::aspectMask),\n                     \"is %s and image was created with format %s.\", string_VkImageAspectFlags(aspect_mask).c_str(),\n                     string_VkFormat(image_format));\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkHostImageLayoutTransitionInfoEXT-image-03320\", \"If image has a depth/stencil format with both depth and stencil and the separateDepthStencilLayouts feature is not enabled, then the aspectMask member of subresourceRange must include both VK_IMAGE_ASPECT_DEPTH_BIT and VK_IMAGE_ASPECT_STENCIL_BIT\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (!has_depth_mask || !has_stencil_mask) {\n    const LogObjectList objlist(device, image_state->Handle());\n    skip |= LogError(\"VUID-VkHostImageLayoutTransitionInfoEXT-image-03320\", objlist,\n                     transition_loc.dot(Field::subresourceRange).dot(Field::aspectMask),\n                     \"is %s and image was created with format %s.\", string_VkImageAspectFlags(aspect_mask).c_str(),\n                     string_VkFormat(image_format));\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkHostImageLayoutTransitionInfoEXT-aspectMask-08703\", \"If the aspectMask member of subresourceRange includes VK_IMAGE_ASPECT_STENCIL_BIT, oldLayout and newLayout must not be one of VK_IMAGE_LAYOUT_DEPTH_ATTACHMENT_OPTIMAL or VK_IMAGE_LAYOUT_DEPTH_READ_ONLY_OPTIMAL\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "const LogObjectList objlist(device, image_state->Handle());\nskip |= LogError(\"VUID-VkHostImageLayoutTransitionInfoEXT-aspectMask-08703\", objlist,\n                 transition_loc.dot(Field::subresourceRange).dot(Field::aspectMask),\n                 \"is %s meaning that neither oldLayout nor newLayout can be \"\n                 \"VK_IMAGE_LAYOUT_DEPTH_ATTACHMENT_OPTIMAL or VK_IMAGE_LAYOUT_DEPTH_READ_ONLY_OPTIMAL\"\n                 \" (oldLayout = %s and newLayout = %s).\",\n                 string_VkImageAspectFlags(aspect_mask).c_str(), string_VkImageLayout(transition.oldLayout),\n                 string_VkImageLayout(transition.oldLayout));\n"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkImageViewCreateInfo-pNext-06944\", \"If the pNext chain includes VkImageViewSampleWeightCreateInfoQCOM structure, then textureSampleWeighted feature must be enabled\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if ((enabled_features.textureSampleWeighted == VK_FALSE)) {\n    skip |= LogError(\"VUID-VkImageViewCreateInfo-pNext-06944\", create_info.image, loc,\n                     \"pNext chain includes VkImageViewSampleWeightCreateInfoQCOM \"\n                     \"but textureSampleWeighted feature is not enabled.\");\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkImageViewCreateInfo-pNext-06945\", \"If the pNext chain includes VkImageViewSampleWeightCreateInfoQCOM structure, then image must have been created with usage containing VK_IMAGE_USAGE_SAMPLE_WEIGHT_BIT_QCOM\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if ((image_usage & VK_IMAGE_USAGE_SAMPLE_WEIGHT_BIT_QCOM) == 0) {\n    skip |= LogError(\"VUID-VkImageViewCreateInfo-pNext-06945\", create_info.image, loc,\n                     \"pNext chain includes VkImageViewSampleWeightCreateInfoQCOM \"\n                     \"but image not created with VK_IMAGE_USAGE_SAMPLE_WEIGHT_BIT_QCOM.\");\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkImageViewCreateInfo-pNext-06947\", \"If the pNext chain includes VkImageViewSampleWeightCreateInfoQCOM structure, then subresourceRange.aspectMask must be VK_IMAGE_ASPECT_COLOR_BIT\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (aspect_mask != VK_IMAGE_ASPECT_COLOR_BIT) {\n    skip |= LogError(\"VUID-VkImageViewCreateInfo-pNext-06947\", create_info.image, loc,\n                     \"pNext chain includes VkImageViewSampleWeightCreateInfoQCOM \"\n                     \"but the subresource range aspect mask (%s) is not VK_IMAGE_ASPECT_COLOR_BIT.\",\n                     string_VkImageAspectFlags(aspect_mask).c_str());\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkImageViewCreateInfo-pNext-06949\", \"If the pNext chain includes VkImageViewSampleWeightCreateInfoQCOM structure, then viewType must be VK_IMAGE_VIEW_TYPE_1D_ARRAY or VK_IMAGE_VIEW_TYPE_2D_ARRAY\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if ((create_info.viewType != VK_IMAGE_VIEW_TYPE_1D_ARRAY) && (create_info.viewType != VK_IMAGE_VIEW_TYPE_2D_ARRAY)) {\n    skip |= LogError(\"VUID-VkImageViewCreateInfo-pNext-06949\", create_info.image, loc,\n                     \"pNext chain includes VkImageViewSampleWeightCreateInfoQCOM \"\n                     \"but the view type (%s) is not VK_IMAGE_VIEW_TYPE_1D_ARRAY or VK_IMAGE_VIEW_TYPE_2D_ARRAY.\",\n                     string_VkImageViewType(create_info.viewType));\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkImageViewCreateInfo-pNext-06950\", \"If the pNext chain includes VkImageViewSampleWeightCreateInfoQCOM structure and if viewType is VK_IMAGE_VIEW_TYPE_1D_ARRAY, then image must have been created with imageType VK_IMAGE_TYPE_1D\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if ((create_info.viewType == VK_IMAGE_VIEW_TYPE_1D_ARRAY) && (image_type != VK_IMAGE_TYPE_1D)) {\n    skip |= LogError(\"VUID-VkImageViewCreateInfo-pNext-06950\", create_info.image, loc,\n                     \"pNext chain includes VkImageViewSampleWeightCreateInfoQCOM \"\n                     \"and the viewType is VK_IMAGE_VIEW_TYPE_1D_ARRAY but the image type (%s) is not VK_IMAGE_TYPE_1D.\",\n                     string_VkImageType(image_type));\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkImageViewCreateInfo-pNext-06952\", \"If the pNext chain includes VkImageViewSampleWeightCreateInfoQCOM structure and viewType is VK_IMAGE_VIEW_TYPE_1D_ARRAY, then image must have been created with width equal to or greater than \\\\((numPhases \\\\times \\\\mathbin{max}\\\\left( \\\\mathbin{align}\\\\left(filterSize.width,4\\\\right), filterSize.height\\\\right))\\\\)\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if ((create_info.viewType == VK_IMAGE_VIEW_TYPE_1D_ARRAY) && (image_extent.width < min_image_width)) {\n    skip |= LogError(\"VUID-VkImageViewCreateInfo-pNext-06952\", create_info.image, loc,\n                     \"pNext chain includes VkImageViewSampleWeightCreateInfoQCOM \"\n                     \"for a VK_IMAGE_VIEW_TYPE_1D_ARRAY with an image created with extent.width (%\" PRIu32\n                     \"), but numPhases (%\" PRIu32 \"), filterSize.width (%\" PRIu32 \"), and filterSize.height (%\" PRIu32\n                     \") requires an image extent.width greater than or equal to (%\" PRIu32 \").\",\n                     image_extent.width, sample_weight_info->numPhases, sample_weight_info->filterSize.width,\n                     sample_weight_info->filterSize.height, min_image_width);\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkImageViewCreateInfo-pNext-06953\", \"If the pNext chain includes VkImageViewSampleWeightCreateInfoQCOM structure and if viewType is VK_IMAGE_VIEW_TYPE_2D_ARRAY, then image must have been created with imageType VK_IMAGE_TYPE_2D\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if ((create_info.viewType == VK_IMAGE_VIEW_TYPE_2D_ARRAY) && (image_type != VK_IMAGE_TYPE_2D)) {\n    skip |= LogError(\"VUID-VkImageViewCreateInfo-pNext-06953\", create_info.image, loc,\n                     \"pNext chain includes VkImageViewSampleWeightCreateInfoQCOM \"\n                     \"and the view type is VK_IMAGE_VIEW_TYPE_2D_ARRAY but the image created type (%s) is \"\n                     \"not VK_IMAGE_TYPE_2D.\",\n                     string_VkImageType(image_type));\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkImageViewCreateInfo-pNext-06955\", \"If the pNext chain includes VkImageViewSampleWeightCreateInfoQCOM structure and viewType is VK_IMAGE_VIEW_TYPE_2D_ARRAY, then image must have been created with width equal to or greater than filterSize.width\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if ((create_info.viewType == VK_IMAGE_VIEW_TYPE_2D_ARRAY) && (image_extent.width < sample_weight_info->filterSize.width)) {\n    skip |= LogError(\"VUID-VkImageViewCreateInfo-pNext-06955\", create_info.image, loc,\n                     \"pNext chain includes VkImageViewSampleWeightCreateInfoQCOM \"\n                     \"for a VK_IMAGE_VIEW_TYPE_2D_ARRAY but the created image extent.width (%\" PRIu32\n                     \") is not greater than or equal to filerSize.width (%\" PRIu32 \").\",\n                     image_extent.width, sample_weight_info->filterSize.width);\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkImageViewCreateInfo-pNext-06956\", \"If the pNext chain includes VkImageViewSampleWeightCreateInfoQCOM structure and viewType is VK_IMAGE_VIEW_TYPE_2D_ARRAY, then image must have been created with height equal to or greater than filterSize.height\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if ((create_info.viewType == VK_IMAGE_VIEW_TYPE_2D_ARRAY) && (image_extent.width < sample_weight_info->filterSize.height)) {\n    skip |= LogError(\"VUID-VkImageViewCreateInfo-pNext-06956\", create_info.image, loc,\n                     \"pNext chain includes VkImageViewSampleWeightCreateInfoQCOM \"\n                     \"for a VK_IMAGE_VIEW_TYPE_2D_ARRAY but the created image extent.height (%\" PRIu32\n                     \") is not greater than or equal to filerSize.height (%\" PRIu32 \").\",\n                     image_extent.height, sample_weight_info->filterSize.height);\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkImageViewCreateInfo-pNext-06957\", \"If the pNext chain includes VkImageViewSampleWeightCreateInfoQCOM structure then VkImageViewSampleWeightCreateInfoQCOM::filterSize.height must be less than or equal to VkPhysicalDeviceImageProcessingPropertiesQCOM::maxWeightFilterDimension.height\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if ((sample_weight_info->filterSize.height > phys_dev_ext_props.image_processing_props.maxWeightFilterDimension.height)) {\n    skip |= LogError(\"VUID-VkImageViewCreateInfo-pNext-06957\", create_info.image, loc,\n                     \"VkImageViewSampleWeightCreateInfoQCOM::filterSize.height (%\" PRIu32\n                     \") is not less than or equal to \"\n                     \"VkPhysicalDeviceImageProcessingPropertiesQCOM::maxWeightFilterDimension.height (%\" PRIu32 \").\",\n                     sample_weight_info->filterSize.height,\n                     phys_dev_ext_props.image_processing_props.maxWeightFilterDimension.height);\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkImageViewSampleWeightCreateInfoQCOM-filterSize-06958\", \"filterSize.width must be less than or equal to VkPhysicalDeviceImageProcessingPropertiesQCOM::maxWeightFilterDimension.width\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if ((sample_weight_info->filterSize.width > phys_dev_ext_props.image_processing_props.maxWeightFilterDimension.width)) {\n    skip |= LogError(\"VUID-VkImageViewSampleWeightCreateInfoQCOM-filterSize-06958\", create_info.image, loc,\n                     \"VkImageViewSampleWeightCreateInfoQCOM::filterSize.width (%\" PRIu32\n                     \") is not less than or equal to \"\n                     \"VkPhysicalDeviceImageProcessingPropertiesQCOM::maxWeightFilterDimension.width (%\" PRIu32 \").\",\n                     sample_weight_info->filterSize.width,\n                     phys_dev_ext_props.image_processing_props.maxWeightFilterDimension.width);\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkImageViewSampleWeightCreateInfoQCOM-filterCenter-06960\", \"filterCenter.x must be less than or equal to (filterSize.width - 1)\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if ((static_cast<uint32_t>(sample_weight_info->filterCenter.x) >= sample_weight_info->filterSize.width)) {\n    skip |= LogError(\"VUID-VkImageViewSampleWeightCreateInfoQCOM-filterCenter-06960\", create_info.image, loc,\n                     \"VkImageViewSampleWeightCreateInfoQCOM::filterCenter.x (%\" PRId32\n                     \") is not less than \"\n                     \"VkImageViewSampleWeightCreateInfoQCOM::filterSize.width (%\" PRIu32 \").\",\n                     sample_weight_info->filterCenter.x, sample_weight_info->filterSize.width);\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkImageViewSampleWeightCreateInfoQCOM-filterCenter-06961\", \"filterCenter.y must be less than or equal to (filterSize.height - 1)\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if ((static_cast<uint32_t>(sample_weight_info->filterCenter.y) >= sample_weight_info->filterSize.height)) {\n    skip |= LogError(\"VUID-VkImageViewSampleWeightCreateInfoQCOM-filterCenter-06961\", create_info.image, loc,\n                     \"VkImageViewSampleWeightCreateInfoQCOM::filterCenter.y (%\" PRId32\n                     \") is not less than \"\n                     \"VkImageViewSampleWeightCreateInfoQCOM::filterSize.height (%\" PRIu32 \").\",\n                     sample_weight_info->filterCenter.y, sample_weight_info->filterSize.height);\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkImageViewSampleWeightCreateInfoQCOM-numPhases-06962\", \"numPhases must be a power of two squared value (i.e., 1, 4, 16, 64, 256, etc.)\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (!IsPowerOfTwo(sample_weight_info->numPhases) || (MostSignificantBit(sample_weight_info->numPhases) % 2 != 0)) {\n    skip |= LogError(\"VUID-VkImageViewSampleWeightCreateInfoQCOM-numPhases-06962\", create_info.image, loc,\n                     \"VkImageViewSampleWeightCreateInfoQCOM::numPhasaes (%\" PRIu32\n                     \") is not a power of two squared \"\n                     \"value (i.e., 1, 4, 16, 64, 256, etc.)\",\n                     sample_weight_info->numPhases);\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkImageViewSampleWeightCreateInfoQCOM-numPhases-06963\", \"numPhases must be less than or equal to VkPhysicalDeviceImageProcessingPropertiesQCOM::maxWeightFilterPhases\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if ((sample_weight_info->numPhases > phys_dev_ext_props.image_processing_props.maxWeightFilterPhases)) {\n    skip |= LogError(\"VUID-VkImageViewSampleWeightCreateInfoQCOM-numPhases-06963\", create_info.image, loc,\n                     \"VkImageViewSampleWeightCreateInfoQCOM::numPhases (%\" PRIu32\n                     \") is not less than or equal to \"\n                     \"VkPhysicalDeviceImageProcessingPropertiesQCOM::maxWeightFilterPhases (%\" PRIu32 \")\",\n                     sample_weight_info->numPhases, phys_dev_ext_props.image_processing_props.maxWeightFilterPhases);\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkRenderPassCreateInfo-pAttachments-01566\", \"For any member of pAttachments with a loadOp equal to VK_ATTACHMENT_LOAD_OP_CLEAR, the first use of that attachment must not specify a layout equal to VK_IMAGE_LAYOUT_DEPTH_READ_ONLY_STENCIL_ATTACHMENT_OPTIMAL\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "skip |= LogError(\"VUID-VkRenderPassCreateInfo-pAttachments-01566\", device, layout_loc,\n                 \"(%s) is an invalid for pAttachments[%d] (first attachment to have LOAD_OP_CLEAR).\",\n                 string_VkImageLayout(first_layout), attachment);\n"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkRenderPassCreateInfo-pAttachments-00836\", \"For any member of pAttachments with a loadOp equal to VK_ATTACHMENT_LOAD_OP_CLEAR, the first use of that attachment must not specify a layout equal to VK_IMAGE_LAYOUT_SHADER_READ_ONLY_OPTIMAL or VK_IMAGE_LAYOUT_DEPTH_STENCIL_READ_ONLY_OPTIMAL\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "skip |= LogError(\"VUID-VkRenderPassCreateInfo-pAttachments-00836\", device, layout_loc,\n                 \"(%s) is an invalid for pAttachments[%d] (first attachment to have LOAD_OP_CLEAR).\",\n                 string_VkImageLayout(first_layout), attachment);\n"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkRenderPassCreateInfo2-pAttachments-02523\", \"For any member of pAttachments with a stencilLoadOp equal to VK_ATTACHMENT_LOAD_OP_CLEAR, the first use of that attachment must not specify a layout equal to VK_IMAGE_LAYOUT_SHADER_READ_ONLY_OPTIMAL, VK_IMAGE_LAYOUT_DEPTH_STENCIL_READ_ONLY_OPTIMAL, or VK_IMAGE_LAYOUT_DEPTH_ATTACHMENT_STENCIL_READ_ONLY_OPTIMAL\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (use_rp2 && ((first_layout == VK_IMAGE_LAYOUT_DEPTH_STENCIL_READ_ONLY_OPTIMAL) ||\n    skip |= LogError(\"VUID-VkRenderPassCreateInfo2-pAttachments-02523\", device, layout_loc,\n                     \"(%s) is an invalid for pAttachments[%d] (first attachment to have LOAD_OP_CLEAR).\",\n                     string_VkImageLayout(first_layout), attachment);\n"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkRenderPassCreateInfo-pAttachments-01567\", \"For any member of pAttachments with a stencilLoadOp equal to VK_ATTACHMENT_LOAD_OP_CLEAR, the first use of that attachment must not specify a layout equal to VK_IMAGE_LAYOUT_DEPTH_ATTACHMENT_STENCIL_READ_ONLY_OPTIMAL\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "skip |= LogError(\"VUID-VkRenderPassCreateInfo-pAttachments-01567\", device, layout_loc,\n                 \"(%s) is an invalid for pAttachments[%d] (first attachment to have LOAD_OP_CLEAR).\",\n                 string_VkImageLayout(first_layout), attachment);\n"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkRenderPassAttachmentBeginInfo-pAttachments-07010\", \"If multisampled-render-to-single-sampled is enabled for any subpass, all element of pAttachments which have a sample count equal to VK_SAMPLE_COUNT_1_BIT must have a format that supports the sample count specified in VkMultisampledRenderToSingleSampledInfoEXT::rasterizationSamples\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (!image_state.image_format_properties.sampleCounts) {\n    skip |= GetPhysicalDeviceImageFormatProperties(image_state, \"VUID-VkRenderPassAttachmentBeginInfo-pAttachments-07010\",\n                                                   rasterization_samples_loc);\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkRenderPassAttachmentBeginInfo-pAttachments-07010\", \"If multisampled-render-to-single-sampled is enabled for any subpass, all element of pAttachments which have a sample count equal to VK_SAMPLE_COUNT_1_BIT must have a format that supports the sample count specified in VkMultisampledRenderToSingleSampledInfoEXT::rasterizationSamples\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (!(image_state.image_format_properties.sampleCounts & msrtss_samples)) {\n    const LogObjectList objlist(renderpass, framebuffer, image_state.Handle());\n    skip |= LogError(\"VUID-VkRenderPassAttachmentBeginInfo-pAttachments-07010\", objlist, rasterization_samples_loc,\n                     \"is %s but is not supported with image (%s) created with\\n\"\n                     \"format: %s\\n\"\n                     \"imageType: %s\\n\"\n                     \"tiling: %s\\n\"\n                     \"usage: %s\\n\"\n                     \"flags: %s\\n\",\n                     string_VkSampleCountFlagBits(msrtss_samples), FormatHandle(image_state).c_str(),\n                     string_VkFormat(image_create_info.format), string_VkImageType(image_create_info.imageType),\n                     string_VkImageTiling(image_create_info.tiling), string_VkImageUsageFlags(image_create_info.usage).c_str(),\n                     string_VkImageCreateFlags(image_create_info.flags).c_str());\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkRenderPassBeginInfo-framebuffer-parameter\", \"framebuffer must be a valid VkFramebuffer handle\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (!view_state) {\n    const LogObjectList objlist(render_pass, framebuffer_state.Handle(), image_view);\n    skip |= LogError(\"VUID-VkRenderPassBeginInfo-framebuffer-parameter\", objlist, attachment_loc, \"%s is invalid.\",\n                     FormatHandle(image_view).c_str());\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkRenderPassBeginInfo-framebuffer-parameter\", \"framebuffer must be a valid VkFramebuffer handle\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (!image_state) {\n    const LogObjectList objlist(render_pass, framebuffer_state.Handle(), image_view, image);\n    skip |= LogError(\"VUID-VkRenderPassBeginInfo-framebuffer-parameter\", objlist, attachment_loc,\n                     \"%s references invalid image (%s).\", FormatHandle(image_view).c_str(), FormatHandle(image).c_str());\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-vkCmdClearDepthStencilImage-imageLayout-00012\", \"imageLayout must be either of VK_IMAGE_LAYOUT_TRANSFER_DST_OPTIMAL or VK_IMAGE_LAYOUT_GENERAL\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if ((dest_image_layout != VK_IMAGE_LAYOUT_TRANSFER_DST_OPTIMAL) && (dest_image_layout != VK_IMAGE_LAYOUT_GENERAL)) {\n    LogObjectList objlist(cb_state.Handle(), image_state.Handle());\n    skip |= LogError(\"VUID-vkCmdClearDepthStencilImage-imageLayout-00012\", objlist, loc,\n                     \"Layout for cleared image is %s but can only be TRANSFER_DST_OPTIMAL or GENERAL.\",\n                     string_VkImageLayout(dest_image_layout));\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-vkCmdClearColorImage-imageLayout-01394\", \"imageLayout must be VK_IMAGE_LAYOUT_SHARED_PRESENT_KHR, VK_IMAGE_LAYOUT_TRANSFER_DST_OPTIMAL or VK_IMAGE_LAYOUT_GENERAL\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if ((dest_image_layout != VK_IMAGE_LAYOUT_TRANSFER_DST_OPTIMAL) && (dest_image_layout != VK_IMAGE_LAYOUT_GENERAL) &&\n    LogObjectList objlist(cb_state.Handle(), image_state.Handle());\n    skip |= LogError(\"VUID-vkCmdClearColorImage-imageLayout-01394\", objlist, loc,\n                     \"Layout for cleared image is %s but can only be TRANSFER_DST_OPTIMAL, SHARED_PRESENT_KHR, or GENERAL.\",\n                     string_VkImageLayout(dest_image_layout));\n"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkGraphicsPipelineCreateInfo-pipelineProtectedAccess-07368\", \"If the pipelineProtectedAccess feature is not enabled, flags must not include VK_PIPELINE_CREATE_NO_PROTECTED_ACCESS_BIT_EXT or VK_PIPELINE_CREATE_PROTECTED_ACCESS_ONLY_BIT_EXT\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if ((flags & invalid_flags) != 0) {\n    skip |= LogError(\"VUID-VkGraphicsPipelineCreateInfo-pipelineProtectedAccess-07368\", device, loc,\n                     \"is %s, but pipelineProtectedAccess feature was not enabled.\",\n                     string_VkPipelineCreateFlags2KHR(flags).c_str());\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkGraphicsPipelineCreateInfo-flags-07369\", \"flags must not include both VK_PIPELINE_CREATE_NO_PROTECTED_ACCESS_BIT_EXT and VK_PIPELINE_CREATE_PROTECTED_ACCESS_ONLY_BIT_EXT\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if ((flags & VK_PIPELINE_CREATE_2_NO_PROTECTED_ACCESS_BIT_EXT) && (flags & VK_PIPELINE_CREATE_2_PROTECTED_ACCESS_ONLY_BIT_EXT)) {\n    skip |= LogError(\"VUID-VkGraphicsPipelineCreateInfo-flags-07369\", device, loc,\n                     \"is %s (contains both NO_PROTECTED_ACCESS_BIT and PROTECTED_ACCESS_ONLY_BIT).\",\n                     string_VkPipelineCreateFlags2KHR(flags).c_str());\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkPipelineRobustnessCreateInfoEXT-pipelineRobustness-06926\", \"If the pipelineRobustness feature is not enabled, storageBuffers must be VK_PIPELINE_ROBUSTNESS_BUFFER_BEHAVIOR_DEVICE_DEFAULT_EXT\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (pipeline_robustness_info.storageBuffers != VK_PIPELINE_ROBUSTNESS_BUFFER_BEHAVIOR_DEVICE_DEFAULT_EXT) {\n    skip |= LogError(\"VUID-VkPipelineRobustnessCreateInfoEXT-pipelineRobustness-06926\", device,\n                     loc.pNext(Struct::VkPipelineRobustnessCreateInfoEXT, Field::storageBuffers),\n                     \"is %s but the pipelineRobustness feature was not enabled.\",\n                     string_VkPipelineRobustnessBufferBehaviorEXT(pipeline_robustness_info.storageBuffers));\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkPipelineRobustnessCreateInfoEXT-pipelineRobustness-06927\", \"If the pipelineRobustness feature is not enabled, uniformBuffers must be VK_PIPELINE_ROBUSTNESS_BUFFER_BEHAVIOR_DEVICE_DEFAULT_EXT\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (pipeline_robustness_info.uniformBuffers != VK_PIPELINE_ROBUSTNESS_BUFFER_BEHAVIOR_DEVICE_DEFAULT_EXT) {\n    skip |= LogError(\"VUID-VkPipelineRobustnessCreateInfoEXT-pipelineRobustness-06927\", device,\n                     loc.pNext(Struct::VkPipelineRobustnessCreateInfoEXT, Field::uniformBuffers),\n                     \"is %s but the pipelineRobustness feature was not enabled.\",\n                     string_VkPipelineRobustnessBufferBehaviorEXT(pipeline_robustness_info.uniformBuffers));\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkPipelineRobustnessCreateInfoEXT-pipelineRobustness-06928\", \"If the pipelineRobustness feature is not enabled, vertexInputs must be VK_PIPELINE_ROBUSTNESS_BUFFER_BEHAVIOR_DEVICE_DEFAULT_EXT\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (pipeline_robustness_info.vertexInputs != VK_PIPELINE_ROBUSTNESS_BUFFER_BEHAVIOR_DEVICE_DEFAULT_EXT) {\n    skip |= LogError(\"VUID-VkPipelineRobustnessCreateInfoEXT-pipelineRobustness-06928\", device,\n                     loc.pNext(Struct::VkPipelineRobustnessCreateInfoEXT, Field::vertexInputs),\n                     \"is %s but the pipelineRobustness feature was not enabled.\",\n                     string_VkPipelineRobustnessBufferBehaviorEXT(pipeline_robustness_info.vertexInputs));\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkPipelineRobustnessCreateInfoEXT-pipelineRobustness-06929\", \"If the pipelineRobustness feature is not enabled, images must be VK_PIPELINE_ROBUSTNESS_IMAGE_BEHAVIOR_DEVICE_DEFAULT_EXT\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (pipeline_robustness_info.images != VK_PIPELINE_ROBUSTNESS_IMAGE_BEHAVIOR_DEVICE_DEFAULT_EXT) {\n    skip |= LogError(\"VUID-VkPipelineRobustnessCreateInfoEXT-pipelineRobustness-06929\", device,\n                     loc.pNext(Struct::VkPipelineRobustnessCreateInfoEXT, Field::images),\n                     \"is %s but the pipelineRobustness feature was not enabled.\",\n                     string_VkPipelineRobustnessImageBehaviorEXT(pipeline_robustness_info.images));\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkPipelineExecutableInfoKHR-executableIndex-03275\", \"executableIndex must be less than the number of pipeline executables associated with pipeline as returned in the pExecutableCount parameter of vkGetPipelineExecutablePropertiesKHR\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (pExecutableInfo->executableIndex >= executable_count) {\n    skip |= LogError(\"VUID-VkPipelineExecutableInfoKHR-executableIndex-03275\", pExecutableInfo->pipeline,\n                     loc.dot(Field::pExecutableInfo).dot(Field::executableIndex),\n                     \"(%\" PRIu32\n                     \") must be less than the number of executables associated with \"\n                     \"the pipeline (%\" PRIu32 \") as returned by vkGetPipelineExecutablePropertiessKHR.\",\n                     pExecutableInfo->executableIndex, executable_count);\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-vkGetPipelineExecutableStatisticsKHR-pipeline-03274\", \"The pipeline member of pExecutableInfo must have been created with VK_PIPELINE_CREATE_CAPTURE_STATISTICS_BIT_KHR\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (!(pipeline_state->create_flags & VK_PIPELINE_CREATE_CAPTURE_STATISTICS_BIT_KHR)) {\n    skip |= LogError(\"VUID-vkGetPipelineExecutableStatisticsKHR-pipeline-03274\", pExecutableInfo->pipeline, error_obj.location,\n                     \"called on a pipeline created without the \"\n                     \"VK_PIPELINE_CREATE_CAPTURE_STATISTICS_BIT_KHR flag set.\");\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-vkGetPipelineExecutableInternalRepresentationsKHR-pipeline-03278\", \"The pipeline member of pExecutableInfo must have been created with VK_PIPELINE_CREATE_CAPTURE_INTERNAL_REPRESENTATIONS_BIT_KHR\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (!(pipeline_state->create_flags & VK_PIPELINE_CREATE_CAPTURE_INTERNAL_REPRESENTATIONS_BIT_KHR)) {\n    skip |= LogError(\"VUID-vkGetPipelineExecutableInternalRepresentationsKHR-pipeline-03278\", pExecutableInfo->pipeline,\n                     error_obj.location,\n                     \"called on a pipeline created without the \"\n                     \"VK_PIPELINE_CREATE_CAPTURE_INTERNAL_REPRESENTATIONS_BIT_KHR flag set.\");\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-vkDestroyPipeline-pipeline-00765\", \"All submitted commands that refer to pipeline must have completed execution\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (auto pipeline_state = Get<vvl::Pipeline>(pipeline)) {\n    skip |= ValidateObjectNotInUse(pipeline_state.get(), error_obj.location, \"VUID-vkDestroyPipeline-pipeline-00765\");\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-vkCmdBindPipeline-pipelineBindPoint-00780\", \"If pipelineBindPoint is VK_PIPELINE_BIND_POINT_GRAPHICS, pipeline must be a graphics pipeline\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "} else if (pipelineBindPoint == VK_PIPELINE_BIND_POINT_COMPUTE) {\n    const LogObjectList objlist(cb_state->Handle(), pipeline);\n    skip |= LogError(\"VUID-vkCmdBindPipeline-pipelineBindPoint-00780\", objlist, error_obj.location,\n                     \"Cannot bind a pipeline of type %s to the compute pipeline bind point\",\n                     string_VkPipelineBindPoint(pipeline_state.pipeline_type));\n"
        },
        {
            "role": "user",
            "content": "{\"VUID-vkCmdBindPipeline-pipelineBindPoint-02392\", \"If pipelineBindPoint is VK_PIPELINE_BIND_POINT_RAY_TRACING_KHR, pipeline must be a ray tracing pipeline\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "} else if (pipelineBindPoint == VK_PIPELINE_BIND_POINT_RAY_TRACING_KHR) {\n    const LogObjectList objlist(cb_state->Handle(), pipeline);\n    skip |= LogError(\"VUID-vkCmdBindPipeline-pipelineBindPoint-02392\", objlist, error_obj.location,\n                     \"Cannot bind a pipeline of type %s to the ray-tracing pipeline bind point\",\n                     string_VkPipelineBindPoint(pipeline_state.pipeline_type));\n"
        },
        {
            "role": "user",
            "content": "{\"VUID-vkCmdBindPipeline-pipelineBindPoint-04881\", \"If pipelineBindPoint is VK_PIPELINE_BIND_POINT_GRAPHICS and the provokingVertexModePerPipeline limit is VK_FALSE, then pipeline's VkPipelineRasterizationProvokingVertexStateCreateInfoEXT::provokingVertexMode must be the same as that of any other pipelines previously bound to this bind point within the current render pass instance, including any pipeline already bound when beginning the render pass instance\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (last_bound_provoking_vertex_state_ci && !current_provoking_vertex_state_ci) {\n    const LogObjectList objlist(cb_state->Handle(), pipeline);\n    skip |= LogError(\"VUID-vkCmdBindPipeline-pipelineBindPoint-04881\", objlist, error_obj.location,\n                     \"Previous %s's provokingVertexMode is %s, but %s doesn't chain \"\n                     \"VkPipelineRasterizationProvokingVertexStateCreateInfoEXT.\",\n                     FormatHandle(last_bound.pipeline_state->Handle()).c_str(),\n                     string_VkProvokingVertexModeEXT(last_bound_provoking_vertex_state_ci->provokingVertexMode),\n                     FormatHandle(pipeline).c_str());\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-vkCmdBindPipeline-pipelineBindPoint-04881\", \"If pipelineBindPoint is VK_PIPELINE_BIND_POINT_GRAPHICS and the provokingVertexModePerPipeline limit is VK_FALSE, then pipeline's VkPipelineRasterizationProvokingVertexStateCreateInfoEXT::provokingVertexMode must be the same as that of any other pipelines previously bound to this bind point within the current render pass instance, including any pipeline already bound when beginning the render pass instance\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "const LogObjectList objlist(cb_state->Handle(), pipeline);\nskip |= LogError(\"VUID-vkCmdBindPipeline-pipelineBindPoint-04881\", objlist, error_obj.location,\n                 \"%s's provokingVertexMode is %s, but previous %s doesn't chain \"\n                 \"VkPipelineRasterizationProvokingVertexStateCreateInfoEXT.\",\n                 FormatHandle(pipeline).c_str(),\n                 string_VkProvokingVertexModeEXT(current_provoking_vertex_state_ci->provokingVertexMode),\n                 FormatHandle(last_bound.pipeline_state->Handle()).c_str());\n"
        },
        {
            "role": "user",
            "content": "{\"VUID-vkCmdBindPipeline-pipelineBindPoint-06721\", \"If pipelineBindPoint is VK_PIPELINE_BIND_POINT_RAY_TRACING_KHR, commandBuffer must not be a protected command buffer\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (!cb_state->unprotected) {\n    const LogObjectList objlist(cb_state->Handle(), pipeline);\n    skip |= LogError(\"VUID-vkCmdBindPipeline-pipelineBindPoint-06721\", objlist, error_obj.location,\n                     \"Binding pipeline to VK_PIPELINE_BIND_POINT_RAY_TRACING_KHR in a protected command buffer.\");\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-vkCmdBindPipeline-pipeline-03382\", \"pipeline must not have been created with VK_PIPELINE_CREATE_LIBRARY_BIT_KHR set\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (pipeline_state.create_flags & VK_PIPELINE_CREATE_LIBRARY_BIT_KHR) {\n    const LogObjectList objlist(cb_state->Handle(), pipeline);\n    skip |= LogError(\"VUID-vkCmdBindPipeline-pipeline-03382\", objlist, error_obj.location,\n                     \"Cannot bind a pipeline that was created with the VK_PIPELINE_CREATE_LIBRARY_BIT_KHR flag.\");\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-vkCmdBindPipeline-None-02323\", \"This command must not be recorded when transform feedback is active\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (cb_state->transform_feedback_active) {\n    const LogObjectList objlist(cb_state->Handle(), pipeline);\n    skip |= LogError(\"VUID-vkCmdBindPipeline-None-02323\", objlist, error_obj.location, \"transform feedback is active.\");\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-vkCmdBindPipeline-pipelineProtectedAccess-07409\", \"If the pipelineProtectedAccess feature is enabled, and commandBuffer is not a protected command buffer, pipeline must have been created without VK_PIPELINE_CREATE_PROTECTED_ACCESS_ONLY_BIT_EXT\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (pipeline_state.create_flags & VK_PIPELINE_CREATE_PROTECTED_ACCESS_ONLY_BIT_EXT) {\n    skip |= LogError(\"VUID-vkCmdBindPipeline-pipelineProtectedAccess-07409\", objlist, error_obj.location,\n                     \"Binding pipeline created with \"\n                     \"VK_PIPELINE_CREATE_PROTECTED_ACCESS_ONLY_BIT_EXT in an unprotected command buffer.\");\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkPipelineShaderStageCreateInfo-flags-02784\", \"If flags has the VK_PIPELINE_SHADER_STAGE_CREATE_ALLOW_VARYING_SUBGROUP_SIZE_BIT flag set, the subgroupSizeControl feature must be enabled\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if ((flags & VK_PIPELINE_SHADER_STAGE_CREATE_ALLOW_VARYING_SUBGROUP_SIZE_BIT_EXT) != 0 &&\n    skip |= LogError(\"VUID-VkPipelineShaderStageCreateInfo-flags-02784\", device, loc.dot(Field::flags),\n                     \"includes \"\n                     \"VK_PIPELINE_SHADER_STAGE_CREATE_ALLOW_VARYING_SUBGROUP_SIZE_BIT_EXT, \"\n                     \"but the subgroupSizeControl feature was not enabled.\");\n"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkPipelineShaderStageCreateInfo-flags-08988\", \"If flags includes VK_PIPELINE_SHADER_STAGE_CREATE_REQUIRE_FULL_SUBGROUPS_BIT, stage must be one of VK_SHADER_STAGE_MESH_BIT_EXT, VK_SHADER_STAGE_TASK_BIT_EXT, or VK_SHADER_STAGE_COMPUTE_BIT\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "skip |= LogError(\"VUID-VkPipelineShaderStageCreateInfo-flags-08988\", device, loc.dot(Field::flags),\n                 \"includes \"\n                 \"VK_PIPELINE_SHADER_STAGE_CREATE_REQUIRE_FULL_SUBGROUPS_BIT_EXT, but the stage is %s.\",\n                 string_VkShaderStageFlagBits(stage));\n"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkShaderCreateInfoEXT-flags-08992\", \"If flags includes VK_SHADER_CREATE_REQUIRE_FULL_SUBGROUPS_BIT_EXT, stage must be one of VK_SHADER_STAGE_MESH_BIT_EXT, VK_SHADER_STAGE_TASK_BIT_EXT, or VK_SHADER_STAGE_COMPUTE_BIT\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if ((stage & (VK_SHADER_STAGE_MESH_BIT_EXT | VK_SHADER_STAGE_TASK_BIT_EXT | VK_SHADER_STAGE_COMPUTE_BIT)) == 0) {\n    skip |= LogError(\"VUID-VkShaderCreateInfoEXT-flags-08992\", device, loc.dot(Field::flags),\n                     \"includes VK_PIPELINE_SHADER_STAGE_CREATE_REQUIRE_FULL_SUBGROUPS_BIT_EXT, but the stage is %s.\",\n                     string_VkShaderStageFlagBits(stage));\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkShaderCreateInfoEXT-flags-08992\", \"If flags includes VK_SHADER_CREATE_REQUIRE_FULL_SUBGROUPS_BIT_EXT, stage must be one of VK_SHADER_STAGE_MESH_BIT_EXT, VK_SHADER_STAGE_TASK_BIT_EXT, or VK_SHADER_STAGE_COMPUTE_BIT\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (((createInfo.flags & VK_SHADER_CREATE_REQUIRE_FULL_SUBGROUPS_BIT_EXT) != 0) &&\n    skip |= LogError(\"VUID-VkShaderCreateInfoEXT-flags-08992\", device, create_info_loc.dot(Field::flags),\n                     \"is %s, but stage is %s.\", string_VkShaderCreateFlagsEXT(createInfo.flags).c_str(),\n                     string_VkShaderStageFlagBits(createInfo.stage));\n"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkSpecializationInfo-pMapEntries-00774\", \"The size member of each element of pMapEntries must be less than or equal to dataSize minus offset\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (map_entry.offset + map_entry.size > spec->dataSize) {\n    skip |= LogError(\"VUID-VkSpecializationInfo-pMapEntries-00774\", device, map_loc.dot(Field::size),\n                     \"(%zu) plus offset (%\" PRIu32 \") is greater than dataSize (%zu) (for constantID %\" PRIu32 \").\",\n                     map_entry.size, map_entry.offset, spec->dataSize, map_entry.constantID);\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkSpecializationInfo-constantID-04911\", \"The constantID value of each element of pMapEntries must be unique within pMapEntries\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (map_entry.constantID == spec->pMapEntries[j].constantID) {\n    skip |= LogError(\"VUID-VkSpecializationInfo-constantID-04911\", device, map_loc,\n                     \"and pMapEntries[%\" PRIu32 \"] both have constantID (%\" PRIu32 \").\", j, map_entry.constantID);\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkPipelineShaderStageModuleIdentifierCreateInfoEXT-pNext-06851\", \"If this struct is included in a pNext chain of VkPipelineShaderStageCreateInfo and identifierSize is not equal to 0, the pipeline must be created with the VK_PIPELINE_CREATE_FAIL_ON_PIPELINE_COMPILE_REQUIRED_BIT flag set\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (!(pipeline.create_flags & VK_PIPELINE_CREATE_2_FAIL_ON_PIPELINE_COMPILE_REQUIRED_BIT_KHR)) {\n    skip |= LogError(\"VUID-VkPipelineShaderStageModuleIdentifierCreateInfoEXT-pNext-06851\", pipeline.Handle(),\n                     loc.pNext(Struct::VkPipelineShaderStageModuleIdentifierCreateInfoEXT, Field::identifierSize),\n                     \"(%\" PRIu32 \"), but the pipeline was created with %s. (stage %s)\",\n                     module_identifier->identifierSize, string_VkPipelineCreateFlags2KHR(pipeline.create_flags).c_str(),\n                     string_VkShaderStageFlagBits(stage_ci.stage));\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkPipelineShaderStageModuleIdentifierCreateInfoEXT-identifierSize-06852\", \"identifierSize must be less-or-equal to VK_MAX_SHADER_MODULE_IDENTIFIER_SIZE_EXT\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (module_identifier->identifierSize > VK_MAX_SHADER_MODULE_IDENTIFIER_SIZE_EXT) {\n    skip |= LogError(\"VUID-VkPipelineShaderStageModuleIdentifierCreateInfoEXT-identifierSize-06852\", device,\n                     loc.pNext(Struct::VkPipelineShaderStageModuleIdentifierCreateInfoEXT, Field::identifierSize),\n                     \"(%\" PRIu32 \") is larger than VK_MAX_SHADER_MODULE_IDENTIFIER_SIZE_EXT (%\" PRIu32 \"). (stage %s).\",\n                     module_identifier->identifierSize, VK_MAX_SHADER_MODULE_IDENTIFIER_SIZE_EXT,\n                     string_VkShaderStageFlagBits(stage_ci.stage));\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkPipelineShaderStageCreateInfo-stage-06844\", \"If a shader module identifier is specified for this stage, the pNext chain must not include a VkShaderModuleCreateInfo structure\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (module_create_info) {\n    skip |= LogError(\"VUID-VkPipelineShaderStageCreateInfo-stage-06844\", device, loc.dot(Field::pNext),\n                     \"has both a \"\n                     \"VkPipelineShaderStageModuleIdentifierCreateInfoEXT \"\n                     \"struct and a VkShaderModuleCreateInfo struct in the pNext chain. (stage %s).\",\n                     string_VkShaderStageFlagBits(stage_ci.stage));\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkPipelineShaderStageCreateInfo-stage-08771\", \"If a shader module identifier is not specified for this stage, module must be a valid VkShaderModule , or the pNext chain of the parent Vk*CreateInfo structure must set VkPipelineBinaryInfoKHR::binaryCount to a value greater than 0, if none of the following features are enabled: graphicsPipelineLibrary maintenance5\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (!enabled_features.maintenance5 && !enabled_features.graphicsPipelineLibrary) {\n    skip |= LogError(\"VUID-VkPipelineShaderStageCreateInfo-stage-08771\", device, loc.dot(Field::module),\n                     \"is VK_NULL_HANDLE and both the graphicsPipelineLibrary and maintenance5 \"\n                     \"features were not enabled. (stage %s).\",\n                     string_VkShaderStageFlagBits(stage_ci.stage));\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkPipelineShaderStageCreateInfo-stage-06845\", \"If a shader module identifier is not specified for this stage, module must be a valid VkShaderModule, or there must be a valid VkShaderModuleCreateInfo structure in the pNext chain , or the pNext chain of the parent Vk*CreateInfo structure must set VkPipelineBinaryInfoKHR::binaryCount to a value greater than 0,\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "\"features were not enabled. (stage %s).\",\nstring_VkShaderStageFlagBits(stage_ci.stage));\nskip |= LogError(\"VUID-VkPipelineShaderStageCreateInfo-stage-06845\", device, loc.dot(Field::module),\n\"is VK_NULL_HANDLE, but no \"\n\"VkPipelineShaderStageModuleIdentifierCreateInfoEXT or VkShaderModuleCreateInfo found in the \"\n\"pNext chain. (stage %s).\",\nstring_VkShaderStageFlagBits(stage_ci.stage));\n"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkPipelineInputAssemblyStateCreateInfo-triangleFans-04452\", \"If the VK_KHR_portability_subset extension is enabled, and VkPhysicalDevicePortabilitySubsetFeaturesKHR::triangleFans is VK_FALSE, topology must not be VK_PRIMITIVE_TOPOLOGY_TRIANGLE_FAN\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (!enabled_features.triangleFans && (pipeline.topology_at_rasterizer == VK_PRIMITIVE_TOPOLOGY_TRIANGLE_FAN)) {\n    skip |= LogError(\"VUID-VkPipelineInputAssemblyStateCreateInfo-triangleFans-04452\", device, create_info_loc,\n                     \"(portability error): VK_PRIMITIVE_TOPOLOGY_TRIANGLE_FAN is not supported.\");\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkPipelineRasterizationStateCreateInfo-pointPolygons-04458\", \"If the VK_KHR_portability_subset extension is enabled, and VkPhysicalDevicePortabilitySubsetFeaturesKHR::pointPolygons is VK_FALSE, and rasterizerDiscardEnable is VK_FALSE, polygonMode must not be VK_POLYGON_MODE_POINT\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (!enabled_features.pointPolygons && !raster_state_ci->rasterizerDiscardEnable &&\n    skip |= LogError(\"VUID-VkPipelineRasterizationStateCreateInfo-pointPolygons-04458\", device, create_info_loc,\n                     \"(portability error): point polygons are not supported.\");\n"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkPipelineDepthStencilStateCreateInfo-separateStencilMaskRef-04453\", \"If the VK_KHR_portability_subset extension is enabled, and VkPhysicalDevicePortabilitySubsetFeaturesKHR::separateStencilMaskRef is VK_FALSE, and the value of VkPipelineDepthStencilStateCreateInfo::stencilTestEnable is VK_TRUE, and the value of VkPipelineRasterizationStateCreateInfo::cullMode is VK_CULL_MODE_NONE, the value of reference in each of the VkStencilOpState structs in front and back must be the same\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (ds_state && ds_state->stencilTestEnable && (ds_state->front.reference != ds_state->back.reference)) {\n    skip |= LogError(\"VUID-VkPipelineDepthStencilStateCreateInfo-separateStencilMaskRef-04453\", device, create_info_loc,\n                     \"(portability error): VkStencilOpState::reference must be the \"\n                     \"same for front and back.\");\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkPipelineColorBlendAttachmentState-constantAlphaColorBlendFactors-04454\", \"If the VK_KHR_portability_subset extension is enabled, and VkPhysicalDevicePortabilitySubsetFeaturesKHR::constantAlphaColorBlendFactors is VK_FALSE, srcColorBlendFactor must not be VK_BLEND_FACTOR_CONSTANT_ALPHA or VK_BLEND_FACTOR_ONE_MINUS_CONSTANT_ALPHA\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if ((attachments[color_attachment_index].srcColorBlendFactor == VK_BLEND_FACTOR_CONSTANT_ALPHA) ||\n    skip |= LogError(\"VUID-VkPipelineColorBlendAttachmentState-constantAlphaColorBlendFactors-04454\", device,\n                     create_info_loc,\n                     \"(portability error): srcColorBlendFactor for color attachment %\" PRIu32\n                     \" must \"\n                     \"not be VK_BLEND_FACTOR_CONSTANT_ALPHA or VK_BLEND_FACTOR_ONE_MINUS_CONSTANT_ALPHA\",\n                     color_attachment_index);\n"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkPipelineColorBlendAttachmentState-constantAlphaColorBlendFactors-04455\", \"If the VK_KHR_portability_subset extension is enabled, and VkPhysicalDevicePortabilitySubsetFeaturesKHR::constantAlphaColorBlendFactors is VK_FALSE, dstColorBlendFactor must not be VK_BLEND_FACTOR_CONSTANT_ALPHA or VK_BLEND_FACTOR_ONE_MINUS_CONSTANT_ALPHA\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if ((attachments[color_attachment_index].dstColorBlendFactor == VK_BLEND_FACTOR_CONSTANT_ALPHA) ||\n    skip |= LogError(\"VUID-VkPipelineColorBlendAttachmentState-constantAlphaColorBlendFactors-04455\", device,\n                     create_info_loc,\n                     \"(portability error): dstColorBlendFactor for color attachment %\" PRIu32\n                     \" must \"\n                     \"not be VK_BLEND_FACTOR_CONSTANT_ALPHA or VK_BLEND_FACTOR_ONE_MINUS_CONSTANT_ALPHA\",\n                     color_attachment_index);\n"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkGraphicsPipelineCreateInfo-flags-06610\", \"If flags includes VK_PIPELINE_CREATE_RETAIN_LINK_TIME_OPTIMIZATION_INFO_BIT_EXT, pipeline libraries included via VkPipelineLibraryCreateInfoKHR must have been created with VK_PIPELINE_CREATE_RETAIN_LINK_TIME_OPTIMIZATION_INFO_BIT_EXT\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (has_retain_link_time_opt && !lib_has_retain_link_time_opt) {\n    const LogObjectList objlist(device, lib->Handle());\n    skip |= LogError(\"VUID-VkGraphicsPipelineCreateInfo-flags-06610\", objlist, library_loc,\n                     \"(%s) was created with %s, which is missing \"\n                     \"VK_PIPELINE_CREATE_RETAIN_LINK_TIME_OPTIMIZATION_INFO_BIT_EXT, %s is %s.\",\n                     string_VkGraphicsPipelineLibraryFlagsEXT(lib->graphics_lib_type).c_str(),\n                     string_VkPipelineCreateFlags2KHR(lib_pipeline_flags).c_str(),\n                     create_info_loc.dot(Field::flags).Fields().c_str(),\n                     string_VkPipelineCreateFlags2KHR(pipeline_flags).c_str());\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkGraphicsPipelineCreateInfo-pLibraries-06647\", \"If VkPipelineLibraryCreateInfoKHR::pLibraries includes at least one library, VkGraphicsPipelineLibraryCreateInfoEXT::flags is non-zero, and any library was created with VK_PIPELINE_CREATE_CAPTURE_INTERNAL_REPRESENTATIONS_BIT_KHR, flags must include VK_PIPELINE_CREATE_CAPTURE_INTERNAL_REPRESENTATIONS_BIT_KHR\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (!has_capture_internal && non_zero_gpl) {\n    const LogObjectList objlist(device, lib->Handle());\n    skip |= LogError(\"VUID-VkGraphicsPipelineCreateInfo-pLibraries-06647\", objlist, library_loc,\n                     \"(%s) was created with %s\\n\"\n                     \"%s is %s\\n\"\n                     \"%s is %s.\",\n                     string_VkGraphicsPipelineLibraryFlagsEXT(lib->graphics_lib_type).c_str(),\n                     string_VkPipelineCreateFlags2KHR(lib_pipeline_flags).c_str(), gpl_flags_loc.Fields().c_str(),\n                     string_VkPipelineCreateFlags2KHR(gpl_info->flags).c_str(),\n                     create_info_loc.dot(Field::flags).Fields().c_str(),\n                     string_VkPipelineCreateFlags2KHR(pipeline_flags).c_str());\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkGraphicsPipelineCreateInfo-flags-06645\", \"If VkGraphicsPipelineLibraryCreateInfoEXT::flags is non-zero, if flags includes VK_PIPELINE_CREATE_CAPTURE_INTERNAL_REPRESENTATIONS_BIT_KHR, any libraries must have also been created with VK_PIPELINE_CREATE_CAPTURE_INTERNAL_REPRESENTATIONS_BIT_KHR\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "const Location &gpl_flags_loc = create_info_loc.pNext(Struct::VkGraphicsPipelineLibraryCreateInfoEXT, Field::flags);\nconst LogObjectList objlist(device, lib->Handle());\nskip |= LogError(\"VUID-VkGraphicsPipelineCreateInfo-flags-06645\", objlist, library_loc,\n                 \"(%s) was created with %s\\n\"\n                 \"%s is %s\\n\"\n                 \"%s is %s.\",\n                 string_VkGraphicsPipelineLibraryFlagsEXT(lib->graphics_lib_type).c_str(),\n                 string_VkPipelineCreateFlags2KHR(lib_pipeline_flags).c_str(), gpl_flags_loc.Fields().c_str(),\n                 string_VkPipelineCreateFlags2KHR(gpl_info->flags).c_str(),\n                 create_info_loc.dot(Field::flags).Fields().c_str(),\n                 string_VkPipelineCreateFlags2KHR(pipeline_flags).c_str());\n"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkPipelineLibraryCreateInfoKHR-pLibraries-06855\", \"If any library in pLibraries was created with a shader stage with VkPipelineShaderStageModuleIdentifierCreateInfoEXT and identifierSize not equal to 0, the pipeline must be created with the VK_PIPELINE_CREATE_FAIL_ON_PIPELINE_COMPILE_REQUIRED_BIT flag set\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if ((lib->uses_shader_module_id) && !(pipeline_flags & VK_PIPELINE_CREATE_2_FAIL_ON_PIPELINE_COMPILE_REQUIRED_BIT_KHR)) {\n    const LogObjectList objlist(device);\n    skip |= LogError(\"VUID-VkPipelineLibraryCreateInfoKHR-pLibraries-06855\", objlist, library_loc,\n                     \"(%s) was created with %s but VkPipelineShaderStageModuleIdentifierCreateInfoEXT::identifierSize was \"\n                     \"not equal to 0 for the pipeline\",\n                     string_VkGraphicsPipelineLibraryFlagsEXT(lib->graphics_lib_type).c_str(),\n                     string_VkPipelineCreateFlags2KHR(lib_pipeline_flags).c_str());\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkGraphicsPipelineCreateInfo-flags-08898\", \"If VkGraphicsPipelineLibraryCreateInfoEXT::flags includes VK_GRAPHICS_PIPELINE_LIBRARY_VERTEX_INPUT_INTERFACE_BIT_EXT, and pre-rasterization shader state is not specified, the pipeline must define vertex input state\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (!pipeline.pre_raster_state) {\n    skip |= LogError(\"VUID-VkGraphicsPipelineCreateInfo-flags-08898\", device, create_info_loc,\n                     \"pVertexInputState and pInputAssemblyState are both NULL so this is an invalid Vertex Input State (no \"\n                     \"dynamic state or mesh shaders were used to ignore them).\");\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkGraphicsPipelineCreateInfo-flags-08897\", \"If VkGraphicsPipelineLibraryCreateInfoEXT::flags includes VK_GRAPHICS_PIPELINE_LIBRARY_VERTEX_INPUT_INTERFACE_BIT_EXT, pre-rasterization shader state is specified either in a library or by the inclusion of VK_GRAPHICS_PIPELINE_LIBRARY_PRE_RASTERIZATION_SHADERS_BIT_EXT, and that state includes a vertex shader stage in pStages, the pipeline must define vertex input state\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "skip |= LogError(\"VUID-VkGraphicsPipelineCreateInfo-flags-08897\", device, create_info_loc,\n                 \"pVertexInputState and pInputAssemblyState are both NULL so this is an invalid Vertex Input State (no \"\n                 \"dynamic state were used to ignore them).\");\n"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkGraphicsPipelineCreateInfo-pStages-02097\", \"If the pipeline requires vertex input state, and pVertexInputState is not dynamic, then pVertexInputState must be a valid pointer to a valid VkPipelineVertexInputStateCreateInfo structure\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "skip |= LogError(\"VUID-VkGraphicsPipelineCreateInfo-pStages-02097\", device, create_info_loc.dot(Field::pVertexInputState),\n                 \"is NULL.\");\n"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkGraphicsPipelineCreateInfo-dynamicPrimitiveTopologyUnrestricted-09031\", \"If the pipeline requires vertex input state, and related dynamic state is not set, pInputAssemblyState must be a valid pointer to a valid VkPipelineInputAssemblyStateCreateInfo structure\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "skip |= LogError(\"VUID-VkGraphicsPipelineCreateInfo-pStages-02097\", device, create_info_loc.dot(Field::pVertexInputState),\nskip |= LogError(\"VUID-VkGraphicsPipelineCreateInfo-dynamicPrimitiveTopologyUnrestricted-09031\", device,\n                 create_info_loc.dot(Field::pInputAssemblyState), \"is NULL.\");\n"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkGraphicsPipelineCreateInfo-pStages-06894\", \"If the pipeline requires pre-rasterization shader state but not fragment shader state, elements of pStages must not have stage set to VK_SHADER_STAGE_FRAGMENT_BIT\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (pipeline.OwnsSubState(pipeline.pre_raster_state) && !pipeline.OwnsSubState(pipeline.fragment_shader_state) &&\n    skip |= LogError(\"VUID-VkGraphicsPipelineCreateInfo-pStages-06894\", device, create_info_loc,\n                     \"does not have fragment shader state, but stages (%s) contains VK_SHADER_STAGE_FRAGMENT_BIT.\",\n                     string_VkShaderStageFlags(pipeline.create_info_shaders).c_str());\n"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkGraphicsPipelineCreateInfo-stageCount-09587\", \"If the pipeline does not require pre-rasterization shader state or fragment shader state, stageCount must be zero\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (!pipeline.OwnsSubState(pipeline.fragment_shader_state) && !pipeline.OwnsSubState(pipeline.pre_raster_state) &&\n    skip |= LogError(\"VUID-VkGraphicsPipelineCreateInfo-stageCount-09587\", device, create_info_loc.dot(Field::stageCount),\n                     \"is %zu, but the pipeline does not have a pre-rasterization or fragment shader state.\",\n                     pipeline.shader_stages_ci.size());\n"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkGraphicsPipelineCreateInfo-graphicsPipelineLibrary-06606\", \"If the graphicsPipelineLibrary feature is not enabled, flags must not include VK_PIPELINE_CREATE_LIBRARY_BIT_KHR\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (!enabled_features.graphicsPipelineLibrary) {\n    skip |= LogError(\"VUID-VkGraphicsPipelineCreateInfo-graphicsPipelineLibrary-06606\", device,\n                     create_info_loc.dot(Field::flags),\n                     \"(%s) includes VK_PIPELINE_CREATE_LIBRARY_BIT_KHR, but \"\n                     \"graphicsPipelineLibrary feature is not enabled.\",\n                     string_VkPipelineCreateFlags2KHR(pipeline_flags).c_str());\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkGraphicsPipelineCreateInfo-graphicsPipelineLibrary-06606\", \"If the graphicsPipelineLibrary feature is not enabled, flags must not include VK_PIPELINE_CREATE_LIBRARY_BIT_KHR\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (!enabled_features.graphicsPipelineLibrary) {\n    skip |= LogError(\"VUID-VkGraphicsPipelineCreateInfo-graphicsPipelineLibrary-06606\", device, flags_loc,\n                     \"(%s) contains VK_PIPELINE_CREATE_LIBRARY_BIT_KHR, but graphicsPipelineLibrary was not enabled.\",\n                     string_VkPipelineCreateFlags2KHR(flags).c_str());\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkGraphicsPipelineCreateInfo-flags-08909\", \"If flags does not include VK_PIPELINE_CREATE_LIBRARY_BIT_KHR, pre-rasterization shader state is specified either in a library or by the inclusion of VK_GRAPHICS_PIPELINE_LIBRARY_PRE_RASTERIZATION_SHADERS_BIT_EXT, and that state either includes VK_DYNAMIC_STATE_RASTERIZER_DISCARD_ENABLE or has pRasterizationState->rasterizerDiscardEnable set to VK_FALSE, the pipeline must define fragment output interface state and fragment shader state or include those states in linked pipeline libraries\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (!pipeline.fragment_shader_state) {\n    skip |= LogError(\"VUID-VkGraphicsPipelineCreateInfo-flags-08909\", device, create_info_loc,\n                     \"Attempting to link pipeline libraries without a fragment shader state (did you forget to add \"\n                     \"VK_PIPELINE_CREATE_LIBRARY_BIT_KHR to your intermediate pipeline?).\");\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkGraphicsPipelineCreateInfo-flags-08909\", \"If flags does not include VK_PIPELINE_CREATE_LIBRARY_BIT_KHR, pre-rasterization shader state is specified either in a library or by the inclusion of VK_GRAPHICS_PIPELINE_LIBRARY_PRE_RASTERIZATION_SHADERS_BIT_EXT, and that state either includes VK_DYNAMIC_STATE_RASTERIZER_DISCARD_ENABLE or has pRasterizationState->rasterizerDiscardEnable set to VK_FALSE, the pipeline must define fragment output interface state and fragment shader state or include those states in linked pipeline libraries\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "skip |= LogError(\"VUID-VkGraphicsPipelineCreateInfo-flags-08909\", device, create_info_loc,\n                 \"Attempting to link pipeline libraries without a fragment output state (did you forget to add \"\n                 \"VK_PIPELINE_CREATE_LIBRARY_BIT_KHR to your intermediate pipeline?).\");\n"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkGraphicsPipelineCreateInfo-pStages-06895\", \"If the pipeline requires fragment shader state but not pre-rasterization shader state, elements of pStages must not have stage set to a shader stage which participates in pre-rasterization\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (pipeline.OwnsSubState(pipeline.fragment_shader_state) && !pipeline.OwnsSubState(pipeline.pre_raster_state) &&\n    skip |= LogError(\"VUID-VkGraphicsPipelineCreateInfo-pStages-06895\", device, create_info_loc,\n                     \"does not have pre-raster state, but stages (%s) contains pre-raster shader stages.\",\n                     string_VkShaderStageFlags(pipeline.create_info_shaders).c_str());\n"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkGraphicsPipelineCreateInfo-flags-06608\", \"If the pipeline defines, or includes as libraries, all the state subsets required for a complete graphics pipeline, flags must not include VK_PIPELINE_CREATE_LIBRARY_BIT_KHR\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (is_create_library) {\n    skip |= LogError(\"VUID-VkGraphicsPipelineCreateInfo-flags-06608\", device, create_info_loc.dot(Field::flags),\n                     \"(%s) includes VK_PIPELINE_CREATE_LIBRARY_BIT_KHR, but defines a complete set of state.\",\n                     string_VkPipelineCreateFlags2KHR(pipeline_flags).c_str());\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkGraphicsPipelineCreateInfo-layout-07827\", \"If the pipeline includes a complete set of state specified entirely by libraries, and each library was created with a VkPipelineLayout created without VK_PIPELINE_LAYOUT_CREATE_INDEPENDENT_SETS_BIT_EXT, then layout must be compatible with the layouts in those libraries\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "\"is incompatible with the layout specified in the fragment shader library: %s\", err_msg.c_str());\nskip |= LogError(\"VUID-VkGraphicsPipelineCreateInfo-layout-07827\", device, create_info_loc.dot(Field::layout),\n         \"is null/invalid and therefore not compatible with the libraries layout\");\n"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkGraphicsPipelineCreateInfo-flags-06730\", \"If flags does not include VK_PIPELINE_CREATE_LINK_TIME_OPTIMIZATION_BIT_EXT, the pipeline includes a complete set of state specified entirely by libraries, and each library was created with a VkPipelineLayout created with VK_PIPELINE_LAYOUT_CREATE_INDEPENDENT_SETS_BIT_EXT, then layout must be compatible with the union of the libraries' pipeline layouts\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "skip |= LogError(\"VUID-VkGraphicsPipelineCreateInfo-flags-06730\", device, create_info_loc.dot(Field::layout),\n                 \"is null/invalid and therefore not compatible with the union of libraries layout\");\n"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkGraphicsPipelineCreateInfo-flags-06683\", \"If VkGraphicsPipelineLibraryCreateInfoEXT::flags includes VK_GRAPHICS_PIPELINE_LIBRARY_PRE_RASTERIZATION_SHADERS_BIT_EXT and pRasterizationState->rasterizerDiscardEnable is VK_TRUE, layout must have been created with no elements of the pSetLayouts array set to VK_NULL_HANDLE\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (!pipeline.IsDynamic(CB_DYNAMIC_STATE_RASTERIZER_DISCARD_ENABLE) && pipeline.RasterizationDisabled()) {\n    skip |= LogError(\"VUID-VkGraphicsPipelineCreateInfo-flags-06683\", device,\n                     create_info_loc.pNext(Struct::VkGraphicsPipelineLibraryCreateInfoEXT, Field::flags),\n                     \"is %s, but layout was created with pSetLayouts[%\" PRIu32 \"] == VK_NULL_HANDLE\",\n                     string_VkGraphicsPipelineLibraryFlagsEXT(gpl_info->flags).c_str(), i);\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkGraphicsPipelineCreateInfo-flags-06682\", \"If VkGraphicsPipelineLibraryCreateInfoEXT::flags includes both VK_GRAPHICS_PIPELINE_LIBRARY_PRE_RASTERIZATION_SHADERS_BIT_EXT and VK_GRAPHICS_PIPELINE_LIBRARY_FRAGMENT_SHADER_BIT_EXT, layout must have been created with no elements of the pSetLayouts array set to VK_NULL_HANDLE\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "string_VkGraphicsPipelineLibraryFlagsEXT(gpl_info->flags).c_str(), i);\nskip |= LogError(\"VUID-VkGraphicsPipelineCreateInfo-flags-06682\", device,\ncreate_info_loc.pNext(Struct::VkGraphicsPipelineLibraryCreateInfoEXT, Field::flags),\n\"is %s, but layout was created with pSetLayouts[%\" PRIu32 \"] == VK_NULL_HANDLE\",\nstring_VkGraphicsPipelineLibraryFlagsEXT(gpl_info->flags).c_str(), i);\n"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkGraphicsPipelineCreateInfo-pStages-09631\", \"If the pipeline requires pre-rasterization shader state and pStages contains both VK_SHADER_STAGE_TASK_BIT_EXT and VK_SHADER_STAGE_MESH_BIT_EXT, then the mesh shader's entry point must not declare a variable with a DrawIndex BuiltIn decoration\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (stage.GetStage() == VK_SHADER_STAGE_MESH_BIT_EXT && stage.spirv_state &&\n    skip |= LogError(\"VUID-VkGraphicsPipelineCreateInfo-pStages-09631\", device, create_info_loc,\n                     \"The pipeline is being created with a Task and Mesh shader bound, but the Mesh Shader \"\n                     \"uses DrawIndex (gl_DrawID) which will be an undefined value when reading.\");\n"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkGraphicsPipelineCreateInfo-externalFormatResolve-09313\", \"If the externalFormatResolve feature is enabled, the pipeline requires fragment output interface state, renderPass is not VK_NULL_HANDLE, subpass includes an external format resolve attachment, and rasterizationSamples is not dynamic, VkPipelineMultisampleStateCreateInfo::rasterizationSamples must be VK_SAMPLE_COUNT_1_BIT\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (multisample_state->rasterizationSamples != VK_SAMPLE_COUNT_1_BIT) {\n    skip |= LogError(\"VUID-VkGraphicsPipelineCreateInfo-externalFormatResolve-09313\", device,\n                     create_info_loc.dot(Field::pMultisampleState).dot(Field::rasterizationSamples),\n                     \"is %\" PRIu32 \", but externalFormat is %\" PRIu64 \" for subpass %\" PRIu32 \".\",\n                     multisample_state->rasterizationSamples, external_format, pipeline.Subpass());\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkGraphicsPipelineCreateInfo-externalFormatResolve-09314\", \"If the externalFormatResolve feature is enabled, the pipeline requires fragment output interface state, renderPass is not VK_NULL_HANDLE, subpass includes an external format resolve attachment, and blendEnable is not dynamic, the blendEnable member of each element of pColorBlendState->pAttachments must be VK_FALSE\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (color_blend_state->pAttachments[i].blendEnable) {\n    skip |= LogError(\"VUID-VkGraphicsPipelineCreateInfo-externalFormatResolve-09314\", device,\n                     create_info_loc.dot(Field::pColorBlendState).dot(Field::pAttachments, i).dot(Field::blendEnable),\n                     \"is VK_TRUE, but externalFormat is %\" PRIu64 \" for subpass %\" PRIu32 \".\", external_format,\n                     pipeline.Subpass());\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkGraphicsPipelineCreateInfo-externalFormatResolve-09315\", \"If the externalFormatResolve feature is enabled, the pipeline requires fragment output interface state, renderPass is not VK_NULL_HANDLE, subpass includes an external format resolve attachment, and pDynamicState->pDynamicStates does not include VK_DYNAMIC_STATE_FRAGMENT_SHADING_RATE_KHR, VkPipelineFragmentShadingRateStateCreateInfoKHR::width must be 1\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (fragment_shading_rate->fragmentSize.width != 1) {\n    skip |= LogError(\"VUID-VkGraphicsPipelineCreateInfo-externalFormatResolve-09315\", device,\n                     create_info_loc.pNext(Struct::VkPipelineFragmentShadingRateStateCreateInfoKHR, Field::fragmentSize)\n                         .dot(Field::width),\n                     \"is %\" PRIu32 \", but externalFormat is %\" PRIu64 \" for subpass %\" PRIu32 \".\",\n                     fragment_shading_rate->fragmentSize.width, external_format, pipeline.Subpass());\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkGraphicsPipelineCreateInfo-externalFormatResolve-09301\", \"If the externalFormatResolve feature is enabled, the pipeline requires fragment output interface state, renderPass is VK_NULL_HANDLE, and VkExternalFormatANDROID::externalFormat is not 0, VkPipelineRenderingCreateInfo::viewMask must be 0\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (rendering_struct->viewMask != 0) {\n    skip |= LogError(\"VUID-VkGraphicsPipelineCreateInfo-externalFormatResolve-09301\", device,\n                     create_info_loc.pNext(Struct::VkPipelineRenderingCreateInfo, Field::viewMask),\n                     \"is 0x%\" PRIx32 \", but externalFormat is %\" PRIu64 \".\", rendering_struct->viewMask, external_format);\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkGraphicsPipelineCreateInfo-externalFormatResolve-09310\", \"If the externalFormatResolve feature is enabled, the pipeline requires fragment shader state and fragment output interface state, renderPass is VK_NULL_HANDLE, and VkExternalFormatANDROID::externalFormat is not 0, the fragment shader must not declare the DepthReplacing or StencilRefReplacingEXT execution modes\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (entrypoint->execution_mode.Has(spirv::ExecutionModeSet::depth_replacing_bit)) {\n    skip |= LogError(\"VUID-VkGraphicsPipelineCreateInfo-externalFormatResolve-09310\", device,\n                     create_info_loc.pNext(Struct::VkExternalFormatANDROID, Field::externalFormat),\n                     \"is %\" PRIu64 \" but the fragment shader declares DepthReplacing.\", external_format);\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkGraphicsPipelineCreateInfo-externalFormatResolve-09310\", \"If the externalFormatResolve feature is enabled, the pipeline requires fragment shader state and fragment output interface state, renderPass is VK_NULL_HANDLE, and VkExternalFormatANDROID::externalFormat is not 0, the fragment shader must not declare the DepthReplacing or StencilRefReplacingEXT execution modes\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "skip |= LogError(\"VUID-VkGraphicsPipelineCreateInfo-externalFormatResolve-09310\", device,\n                 create_info_loc.pNext(Struct::VkExternalFormatANDROID, Field::externalFormat),\n                 \"is %\" PRIu64 \" but the fragment shader declares StencilRefReplacingEXT.\", external_format);\n"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkGraphicsPipelineCreateInfo-externalFormatResolve-09304\", \"If the externalFormatResolve feature is enabled, the pipeline requires fragment output interface state, renderPass is VK_NULL_HANDLE, VkExternalFormatANDROID::externalFormat is not 0, and rasterizationSamples is not dynamic, VkPipelineMultisampleStateCreateInfo::rasterizationSamples must be 1\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (multisample_state->rasterizationSamples != VK_SAMPLE_COUNT_1_BIT) {\n    skip |= LogError(\"VUID-VkGraphicsPipelineCreateInfo-externalFormatResolve-09304\", device,\n                     create_info_loc.dot(Field::pMultisampleState).dot(Field::rasterizationSamples),\n                     \"is %s, but externalFormat is %\" PRIu64 \".\",\n                     string_VkSampleCountFlagBits(multisample_state->rasterizationSamples), external_format);\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkGraphicsPipelineCreateInfo-externalFormatResolve-09306\", \"If the externalFormatResolve feature is enabled, the pipeline requires fragment output interface state, renderPass is VK_NULL_HANDLE, and VkExternalFormatANDROID::externalFormat is not 0, and pDynamicState->pDynamicStates does not include VK_DYNAMIC_STATE_FRAGMENT_SHADING_RATE_KHR, VkPipelineFragmentShadingRateStateCreateInfoKHR::width must be 1\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (fragment_shading_rate->fragmentSize.width != 1) {\n    skip |= LogError(\"VUID-VkGraphicsPipelineCreateInfo-externalFormatResolve-09306\", device,\n                     create_info_loc.pNext(Struct::VkPipelineFragmentShadingRateStateCreateInfoKHR, Field::fragmentSize)\n                         .dot(Field::width),\n                     \"is %\" PRIu32 \", but externalFormat is %\" PRIu64 \".\", fragment_shading_rate->fragmentSize.width,\n                     external_format);\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkGraphicsPipelineCreateInfo-externalFormatResolve-09307\", \"If the externalFormatResolve feature is enabled, the pipeline requires fragment output interface state, renderPass is VK_NULL_HANDLE, and VkExternalFormatANDROID::externalFormat is not 0, and pDynamicState->pDynamicStates does not include VK_DYNAMIC_STATE_FRAGMENT_SHADING_RATE_KHR, VkPipelineFragmentShadingRateStateCreateInfoKHR::height must be 1\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (fragment_shading_rate->fragmentSize.height != 1) {\n    skip |= LogError(\"VUID-VkGraphicsPipelineCreateInfo-externalFormatResolve-09307\", device,\n                     create_info_loc.pNext(Struct::VkPipelineFragmentShadingRateStateCreateInfoKHR, Field::fragmentSize)\n                         .dot(Field::height),\n                     \"is %\" PRIu32 \", but externalFormat is %\" PRIu64 \".\", fragment_shading_rate->fragmentSize.height,\n                     external_format);\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkPipelineInputAssemblyStateCreateInfo-topology-06253\", \"If the primitiveTopologyPatchListRestart feature is not enabled, and topology is VK_PRIMITIVE_TOPOLOGY_PATCH_LIST, primitiveRestartEnable must be VK_FALSE\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (!enabled_features.primitiveTopologyPatchListRestart) {\n    skip |= LogError(\"VUID-VkPipelineInputAssemblyStateCreateInfo-topology-06253\", device, ia_loc,\n                     \"topology is %s and primitiveRestartEnable is VK_TRUE and the \"\n                     \"primitiveTopologyPatchListRestart feature was not enabled.\",\n                     string_VkPrimitiveTopology(topology));\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkPipelineInputAssemblyStateCreateInfo-topology-00429\", \"If the geometryShader feature is not enabled, topology must not be any of VK_PRIMITIVE_TOPOLOGY_LINE_LIST_WITH_ADJACENCY, VK_PRIMITIVE_TOPOLOGY_LINE_STRIP_WITH_ADJACENCY, VK_PRIMITIVE_TOPOLOGY_TRIANGLE_LIST_WITH_ADJACENCY or VK_PRIMITIVE_TOPOLOGY_TRIANGLE_STRIP_WITH_ADJACENCY\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "IsValueIn(topology,\nskip |= LogError( \"VUID-VkPipelineInputAssemblyStateCreateInfo-topology-00429\", device, ia_loc,\n                 \"topology is %s and geometryShader feature was not enabled.\",\n                 string_VkPrimitiveTopology(topology));\n"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkGraphicsPipelineCreateInfo-pStages-08888\", \"If the pipeline is being created with pre-rasterization shader state and vertex input state and pStages includes tessellation shader stages, and either VK_DYNAMIC_STATE_PRIMITIVE_TOPOLOGY dynamic state is not enabled or dynamicPrimitiveTopologyUnrestricted is VK_FALSE, the topology member of pInputAssembly must be VK_PRIMITIVE_TOPOLOGY_PATCH_LIST\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (has_tessellation && (!ia_state || ia_state->topology != VK_PRIMITIVE_TOPOLOGY_PATCH_LIST)) {\n    skip |= LogError(\"VUID-VkGraphicsPipelineCreateInfo-pStages-08888\", device, ia_loc.dot(Field::topology),\n                     \"is %s for tessellation shaders in pipeline (needs to be VK_PRIMITIVE_TOPOLOGY_PATCH_LIST).\",\n                     ia_state ? string_VkPrimitiveTopology(ia_state->topology) : \"null\");\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkGraphicsPipelineCreateInfo-topology-08889\", \"If the pipeline is being created with pre-rasterization shader state and vertex input state and the topology member of pInputAssembly is VK_PRIMITIVE_TOPOLOGY_PATCH_LIST, and either VK_DYNAMIC_STATE_PRIMITIVE_TOPOLOGY dynamic state is not enabled or dynamicPrimitiveTopologyUnrestricted is VK_FALSE, then pStages must include tessellation shader stages\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (!has_tessellation && (ia_state && ia_state->topology == VK_PRIMITIVE_TOPOLOGY_PATCH_LIST)) {\n    skip |= LogError(\"VUID-VkGraphicsPipelineCreateInfo-topology-08889\", device,  ia_loc.dot(Field::topology),\n                     \"is VK_PRIMITIVE_TOPOLOGY_PATCH_LIST but no tessellation shaders.\");\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkGraphicsPipelineCreateInfo-pStages-09022\", \"If the pipeline requires pre-rasterization shader state and pStages includes a tessellation control shader stage, and the VK_EXT_extended_dynamic_state3 extension is not enabled or the VK_DYNAMIC_STATE_PATCH_CONTROL_POINTS_EXT dynamic state is not set, pTessellationState must be a valid pointer to a valid VkPipelineTessellationStateCreateInfo structure\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (!pipeline.TessellationState() && (!pipeline.IsDynamic(CB_DYNAMIC_STATE_PATCH_CONTROL_POINTS_EXT) ||\n    skip |= LogError(\"VUID-VkGraphicsPipelineCreateInfo-pStages-09022\", device, create_info_loc.dot(Field::pStages),\n                     \"includes a tessellation control shader stage, but pTessellationState is NULL.\");\n"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkGraphicsPipelineCreateInfo-pStages-06896\", \"If the pipeline requires pre-rasterization shader state, all elements of pStages must have a stage set to a shader stage which participates in fragment shader state or pre-rasterization shader state\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if ((stages & PreRasterState::ValidShaderStages()) == 0) {\n    skip |= LogError(\"VUID-VkGraphicsPipelineCreateInfo-pStages-06896\", device, create_info_loc,\n                     \"contains pre-raster state, but stages (%s) does not contain any pre-raster shaders.\",\n                     string_VkShaderStageFlags(stages).c_str());\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkPipelineShaderStageCreateInfo-stage-00705\", \"If the tessellationShader feature is not enabled, stage must not be VK_SHADER_STAGE_TESSELLATION_CONTROL_BIT or VK_SHADER_STAGE_TESSELLATION_EVALUATION_BIT\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (!enabled_features.tessellationShader &&\n    skip |= LogError(\"VUID-VkPipelineShaderStageCreateInfo-stage-00705\", device, create_info_loc,\n                     \"pStages include Tessellation Shader but tessellationShader feature was not enabled.\");\n"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkGraphicsPipelineCreateInfo-stage-02096\", \"If the pipeline requires pre-rasterization shader state the stage member of one element of pStages must be VK_SHADER_STAGE_VERTEX_BIT or VK_SHADER_STAGE_MESH_BIT_EXT\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (!(stages & (VK_SHADER_STAGE_VERTEX_BIT | VK_SHADER_STAGE_MESH_BIT_EXT))) {\n    skip |= LogError(\"VUID-VkGraphicsPipelineCreateInfo-stage-02096\", device, create_info_loc,\n                     \"no stage in pStages contains a Vertex Shader or Mesh Shader.\");\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkGraphicsPipelineCreateInfo-pStages-02095\", \"If the pipeline requires pre-rasterization shader state the geometric shader stages provided in pStages must be either from the mesh shading pipeline (stage is VK_SHADER_STAGE_TASK_BIT_EXT or VK_SHADER_STAGE_MESH_BIT_EXT) or from the primitive shading pipeline (stage is VK_SHADER_STAGE_VERTEX_BIT, VK_SHADER_STAGE_TESSELLATION_CONTROL_BIT, VK_SHADER_STAGE_TESSELLATION_EVALUATION_BIT, or VK_SHADER_STAGE_GEOMETRY_BIT)\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if ((stages & (VK_SHADER_STAGE_MESH_BIT_EXT | VK_SHADER_STAGE_TASK_BIT_EXT)) &&\n    skip |= LogError(\"VUID-VkGraphicsPipelineCreateInfo-pStages-02095\", device, create_info_loc,\n                     \"in pStages, Geometric shader stages must either be all mesh (mesh | task) \"\n                     \"or all VTG (vertex, tess control, tess eval, geom).\");\n"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkPipelineShaderStageCreateInfo-stage-02091\", \"If the meshShaders feature is not enabled, stage must not be VK_SHADER_STAGE_MESH_BIT_EXT\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (!(enabled_features.meshShader) && (stages & VK_SHADER_STAGE_MESH_BIT_EXT)) {\n    skip |= LogError(\"VUID-VkPipelineShaderStageCreateInfo-stage-02091\", device, create_info_loc,\n                     \"pStages include Mesh Shader but meshShader feature was not enabled.\");\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkGraphicsPipelineCreateInfo-pStages-00729\", \"If the pipeline requires pre-rasterization shader state and pStages includes a tessellation control shader stage, it must include a tessellation evaluation shader stage\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (has_control && !has_eval) {\n    skip |= LogError(\"VUID-VkGraphicsPipelineCreateInfo-pStages-00729\", device, create_info_loc,\n                     \"pStages include a VK_SHADER_STAGE_TESSELLATION_CONTROL_BIT but no \"\n                     \"VK_SHADER_STAGE_TESSELLATION_EVALUATION_BIT stage.\");\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkGraphicsPipelineCreateInfo-pStages-00730\", \"If the pipeline requires pre-rasterization shader state and pStages includes a tessellation evaluation shader stage, it must include a tessellation control shader stage\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (!has_control && has_eval) {\n    skip |= LogError(\"VUID-VkGraphicsPipelineCreateInfo-pStages-00730\", device, create_info_loc,\n                     \"pStages include a VK_SHADER_STAGE_TESSELLATION_EVALUATION_BIT but no \"\n                     \"VK_SHADER_STAGE_TESSELLATION_CONTROL_BIT stage.\");\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkPipelineColorBlendStateCreateInfo-pAttachments-00605\", \"If the independentBlend feature is not enabled, all elements of pAttachments must be identical\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (!ComparePipelineColorBlendAttachmentState(attachment_states[0], attachment_states[i])) {\n    skip |= LogError(\"VUID-VkPipelineColorBlendStateCreateInfo-pAttachments-00605\", device,\n                     color_loc.dot(Field::pAttachments, (uint32_t)i),\n                     \"is different than pAttachments[0] and independentBlend feature was not enabled.\");\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkPipelineColorBlendAttachmentState-srcColorBlendFactor-00608\", \"If the dualSrcBlend feature is not enabled, srcColorBlendFactor must not be VK_BLEND_FACTOR_SRC1_COLOR, VK_BLEND_FACTOR_ONE_MINUS_SRC1_COLOR, VK_BLEND_FACTOR_SRC1_ALPHA, or VK_BLEND_FACTOR_ONE_MINUS_SRC1_ALPHA\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (!enabled_features.dualSrcBlend) {\n    skip |= LogError(\"VUID-VkPipelineColorBlendAttachmentState-srcColorBlendFactor-00608\", device,\n                     attachment_loc.dot(Field::srcColorBlendFactor),\n                     \"(%s) is a dual-source blend factor, but dualSrcBlend feature was not enabled.\",\n                     string_VkBlendFactor(attachment_state.srcColorBlendFactor));\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkPipelineColorBlendAttachmentState-srcAlphaBlendFactor-00610\", \"If the dualSrcBlend feature is not enabled, srcAlphaBlendFactor must not be VK_BLEND_FACTOR_SRC1_COLOR, VK_BLEND_FACTOR_ONE_MINUS_SRC1_COLOR, VK_BLEND_FACTOR_SRC1_ALPHA, or VK_BLEND_FACTOR_ONE_MINUS_SRC1_ALPHA\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (!enabled_features.dualSrcBlend) {\n    skip |= LogError(\"VUID-VkPipelineColorBlendAttachmentState-srcAlphaBlendFactor-00610\", device,\n                     attachment_loc.dot(Field::srcAlphaBlendFactor),\n                     \"(%s) is a dual-source blend factor, but dualSrcBlend feature was not enabled.\",\n                     string_VkBlendFactor(attachment_state.srcAlphaBlendFactor));\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkPipelineColorBlendAttachmentState-dstAlphaBlendFactor-00611\", \"If the dualSrcBlend feature is not enabled, dstAlphaBlendFactor must not be VK_BLEND_FACTOR_SRC1_COLOR, VK_BLEND_FACTOR_ONE_MINUS_SRC1_COLOR, VK_BLEND_FACTOR_SRC1_ALPHA, or VK_BLEND_FACTOR_ONE_MINUS_SRC1_ALPHA\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (!enabled_features.dualSrcBlend) {\n    skip |= LogError(\"VUID-VkPipelineColorBlendAttachmentState-dstAlphaBlendFactor-00611\", device,\n                     attachment_loc.dot(Field::dstAlphaBlendFactor),\n                     \"(%s) is a dual-source blend factor, but dualSrcBlend feature was not enabled.\",\n                     string_VkBlendFactor(attachment_state.dstAlphaBlendFactor));\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkPipelineColorBlendAttachmentState-advancedBlendAllOperations-01409\", \"If VkPhysicalDeviceBlendOperationAdvancedPropertiesEXT::advancedBlendAllOperations is VK_FALSE, then colorBlendOp must not be VK_BLEND_OP_ZERO_EXT, VK_BLEND_OP_SRC_EXT, VK_BLEND_OP_DST_EXT, VK_BLEND_OP_SRC_OVER_EXT, VK_BLEND_OP_DST_OVER_EXT, VK_BLEND_OP_SRC_IN_EXT, VK_BLEND_OP_DST_IN_EXT, VK_BLEND_OP_SRC_OUT_EXT, VK_BLEND_OP_DST_OUT_EXT, VK_BLEND_OP_SRC_ATOP_EXT, VK_BLEND_OP_DST_ATOP_EXT, VK_BLEND_OP_XOR_EXT, VK_BLEND_OP_INVERT_EXT, VK_BLEND_OP_INVERT_RGB_EXT, VK_BLEND_OP_LINEARDODGE_EXT, VK_BLEND_OP_LINEARBURN_EXT, VK_BLEND_OP_VIVIDLIGHT_EXT, VK_BLEND_OP_LINEARLIGHT_EXT, VK_BLEND_OP_PINLIGHT_EXT, VK_BLEND_OP_HARDMIX_EXT, VK_BLEND_OP_PLUS_EXT, VK_BLEND_OP_PLUS_CLAMPED_EXT, VK_BLEND_OP_PLUS_CLAMPED_ALPHA_EXT, VK_BLEND_OP_PLUS_DARKER_EXT, VK_BLEND_OP_MINUS_EXT, VK_BLEND_OP_MINUS_CLAMPED_EXT, VK_BLEND_OP_CONTRAST_EXT, VK_BLEND_OP_INVERT_OVG_EXT, VK_BLEND_OP_RED_EXT, VK_BLEND_OP_GREEN_EXT, or VK_BLEND_OP_BLUE_EXT\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "skip |= LogError(\"VUID-VkPipelineColorBlendAttachmentState-advancedBlendAllOperations-01409\", device,\n                 attachment_loc.dot(Field::colorBlendOp),\n                 \"(%s) but \"\n                 \"VkPhysicalDeviceBlendOperationAdvancedPropertiesEXT::\"\n                 \"advancedBlendAllOperations is \"\n                 \"VK_FALSE\",\n                 string_VkBlendOp(attachment_state.colorBlendOp));\n"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkPipelineColorBlendAttachmentState-advancedBlendIndependentBlend-01407\", \"If VkPhysicalDeviceBlendOperationAdvancedPropertiesEXT::advancedBlendIndependentBlend is VK_FALSE and colorBlendOp is an advanced blend operation, then colorBlendOp must be the same for all attachments\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (phys_dev_ext_props.blend_operation_advanced_props.advancedBlendIndependentBlend == VK_FALSE &&\n    skip |= LogError(\"VUID-VkPipelineColorBlendAttachmentState-advancedBlendIndependentBlend-01407\", device,\n                     attachment_loc.dot(Field::colorBlendOp), \"(%s) is not same the other attachments (%s).\",\n                     string_VkBlendOp(attachment_state.colorBlendOp), string_VkBlendOp(first_color_blend_op));\n"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkPipelineColorBlendAttachmentState-colorBlendOp-01410\", \"If colorBlendOp or alphaBlendOp is an advanced blend operation, then colorAttachmentCount of the subpass this pipeline is compiled against must be less than or equal to VkPhysicalDeviceBlendOperationAdvancedPropertiesEXT::advancedBlendMaxColorAttachments\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "skip |= LogError(\"VUID-VkPipelineColorBlendAttachmentState-colorBlendOp-01410\", device, attachment_loc,\n                 \"has an advance blend operation (%s) but the colorAttachmentCount (%\" PRIu32\n                 \") is larger than advancedBlendMaxColorAttachments (%\" PRIu32 \").\",\n                 string_VkBlendOp(attachment_state.colorBlendOp), color_attachment_count,\n                 phys_dev_ext_props.blend_operation_advanced_props.advancedBlendMaxColorAttachments);\n"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkPipelineColorBlendAdvancedStateCreateInfoEXT-blendOverlap-01426\", \"If the correlated overlap property is not supported, blendOverlap must be VK_BLEND_OVERLAP_UNCORRELATED_EXT\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (!prop.advancedBlendCorrelatedOverlap && color_blend_advanced.blendOverlap != VK_BLEND_OVERLAP_UNCORRELATED_EXT) {\n    skip |= LogError(\"VUID-VkPipelineColorBlendAdvancedStateCreateInfoEXT-blendOverlap-01426\", device,\n                     color_loc.pNext(Struct::VkPipelineColorBlendAdvancedStateCreateInfoEXT, Field::blendOverlap),\n                     \"is %s, but advancedBlendCorrelatedOverlap was not enabled.\",\n                     string_VkBlendOverlapEXT(color_blend_advanced.blendOverlap));\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkPipelineColorBlendAdvancedStateCreateInfoEXT-dstPremultiplied-01425\", \"If the non-premultiplied destination color property is not supported, dstPremultiplied must be VK_TRUE\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (!prop.advancedBlendNonPremultipliedDstColor && color_blend_advanced.dstPremultiplied != VK_TRUE) {\n    skip |= LogError(\"VUID-VkPipelineColorBlendAdvancedStateCreateInfoEXT-dstPremultiplied-01425\", device,\n                     color_loc.pNext(Struct::VkPipelineColorBlendAdvancedStateCreateInfoEXT, Field::dstPremultiplied),\n                     \"is VK_FALSE, but advancedBlendNonPremultipliedDstColor was not enabled.\");\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkPipelineColorBlendAdvancedStateCreateInfoEXT-srcPremultiplied-01424\", \"If the non-premultiplied source color property is not supported, srcPremultiplied must be VK_TRUE\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (!prop.advancedBlendNonPremultipliedSrcColor && color_blend_advanced.srcPremultiplied != VK_TRUE) {\n    skip |= LogError(\"VUID-VkPipelineColorBlendAdvancedStateCreateInfoEXT-srcPremultiplied-01424\", device,\n                     color_loc.pNext(Struct::VkPipelineColorBlendAdvancedStateCreateInfoEXT, Field::srcPremultiplied),\n                     \"is VK_FALSE, but advancedBlendNonPremultipliedSrcColor was not enabled.\");\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkGraphicsPipelineCreateInfo-renderPass-07609\", \"If renderPass is not VK_NULL_HANDLE, the pipeline is being created with fragment output interface state, the pColorBlendState pointer is not NULL, the attachmentCount member of pColorBlendState is not ignored, and the subpass uses color attachments, the attachmentCount member of pColorBlendState must be equal to the colorAttachmentCount used to create subpass\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (!IsColorBlendStateAttachmentCountIgnore(pipeline)) {\n    skip |= LogError(\"VUID-VkGraphicsPipelineCreateInfo-renderPass-07609\", device, color_loc.dot(Field::attachmentCount),\n                     \"(%\" PRIu32 \") is different than %s pSubpasses[%\" PRIu32 \"].colorAttachmentCount (%\" PRIu32 \").\",\n                     color_blend_state->attachmentCount, FormatHandle(rp_state->Handle()).c_str(), pipeline.Subpass(),\n                     subpass_desc->colorAttachmentCount);\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkPipelineColorBlendStateCreateInfo-logicOpEnable-00606\", \"If the logicOp feature is not enabled, logicOpEnable must be VK_FALSE\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (!enabled_features.logicOp && (color_blend_state->logicOpEnable == VK_TRUE) &&\n    skip |= LogError(\"VUID-VkPipelineColorBlendStateCreateInfo-logicOpEnable-00606\", device,\n                     color_loc.dot(Field::logicOpEnable), \"is VK_TRUE, but the logicOp feature was not enabled.\");\n"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkPipelineColorWriteCreateInfoEXT-attachmentCount-06655\", \"attachmentCount must be less than or equal to the maxColorAttachments member of VkPhysicalDeviceLimits\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (color_write->attachmentCount > phys_dev_props.limits.maxColorAttachments) {\n    skip |= LogError(\"VUID-VkPipelineColorWriteCreateInfoEXT-attachmentCount-06655\", device,\n                     color_loc.pNext(Struct::VkPipelineColorWriteCreateInfoEXT, Field::attachmentCount),\n                     \"(%\" PRIu32 \") is larger than the maxColorAttachments limit (%\" PRIu32 \").\",\n                     color_write->attachmentCount, phys_dev_props.limits.maxColorAttachments);\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkPipelineColorWriteCreateInfoEXT-pAttachments-04801\", \"If the colorWriteEnable feature is not enabled, all elements of pColorWriteEnables must be VK_TRUE\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (color_write->pColorWriteEnables[i] != VK_TRUE) {\n    skip |= LogError(\"VUID-VkPipelineColorWriteCreateInfoEXT-pAttachments-04801\", device,\n                     color_loc.pNext(Struct::VkPipelineColorWriteCreateInfoEXT, Field::pColorWriteEnables, i),\n                     \"is VK_FALSE, but colorWriteEnable feature was not enabled.\");\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkPipelineRasterizationStateStreamCreateInfoEXT-rasterizationStream-02326\", \"rasterizationStream must be zero if VkPhysicalDeviceTransformFeedbackPropertiesEXT::transformFeedbackRasterizationStreamSelect is VK_FALSE\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (props.transformFeedbackRasterizationStreamSelect == VK_FALSE &&\n    rasterization_state_stream_ci.rasterizationStream != 0) {\n    skip |= LogError(\"VUID-VkPipelineRasterizationStateStreamCreateInfoEXT-rasterizationStream-02326\", device,\n                     raster_loc.pNext(Struct::VkPipelineRasterizationStateStreamCreateInfoEXT, Field::rasterizationStream),\n                     \"is (%\" PRIu32 \") but transformFeedbackRasterizationStreamSelect is VK_FALSE.\",\n                     rasterization_state_stream_ci.rasterizationStream);\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkPipelineRasterizationStateStreamCreateInfoEXT-rasterizationStream-02325\", \"rasterizationStream must be less than VkPhysicalDeviceTransformFeedbackPropertiesEXT::maxTransformFeedbackStreams\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "rasterization_state_stream_ci.rasterizationStream);\n} else if (rasterization_state_stream_ci.rasterizationStream >= props.maxTransformFeedbackStreams) {\nskip |= LogError(\"VUID-VkPipelineRasterizationStateStreamCreateInfoEXT-rasterizationStream-02325\", device,\nraster_loc.pNext(Struct::VkPipelineRasterizationStateStreamCreateInfoEXT, Field::rasterizationStream),\n\"(%\" PRIu32 \") is not less than maxTransformFeedbackStreams (%\" PRIu32 \").\",\nrasterization_state_stream_ci.rasterizationStream, props.maxTransformFeedbackStreams);\n"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkGraphicsPipelineCreateInfo-conservativePointAndLineRasterization-06760\", \"If conservativePointAndLineRasterization is not supported, the pipeline requires pre-rasterization shader state, and the pipeline includes a geometry shader with either the OutputPoints or OutputLineStrip execution modes, VkPipelineRasterizationConservativeStateCreateInfoEXT::conservativeRasterizationMode must be VK_CONSERVATIVE_RASTERIZATION_MODE_DISABLED_EXT\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if ((pipeline.create_info_shaders & VK_SHADER_STAGE_GEOMETRY_BIT) != 0) {\n    skip |= LogError(\"VUID-VkGraphicsPipelineCreateInfo-conservativePointAndLineRasterization-06760\", device,\n                     raster_loc.pNext(Struct::VkPipelineRasterizationConservativeStateCreateInfoEXT,\n                                      Field::conservativeRasterizationMode),\n                     \"is %s, but geometry shader output primitive is %s and \"\n                     \"VkPhysicalDeviceConservativeRasterizationPropertiesEXT::\"\n                     \"conservativePointAndLineRasterization is false.\",\n                     string_VkConservativeRasterizationModeEXT(\n                         rasterization_conservative_state_ci.conservativeRasterizationMode),\n                     string_VkPrimitiveTopology(pipeline.topology_at_rasterizer));\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkGraphicsPipelineCreateInfo-conservativePointAndLineRasterization-06761\", \"If conservativePointAndLineRasterization is not supported, the pipeline requires pre-rasterization shader state, and the pipeline includes a mesh shader with either the OutputPoints or OutputLinesNV execution modes, VkPipelineRasterizationConservativeStateCreateInfoEXT::conservativeRasterizationMode must be VK_CONSERVATIVE_RASTERIZATION_MODE_DISABLED_EXT\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if ((pipeline.create_info_shaders & VK_SHADER_STAGE_MESH_BIT_EXT) != 0) {\n    skip |= LogError(\"VUID-VkGraphicsPipelineCreateInfo-conservativePointAndLineRasterization-06761\", device,\n                     raster_loc.pNext(Struct::VkPipelineRasterizationConservativeStateCreateInfoEXT,\n                                      Field::conservativeRasterizationMode),\n                     \"is %s, but mesh shader output primitive is %s and \"\n                     \"VkPhysicalDeviceConservativeRasterizationPropertiesEXT::\"\n                     \"conservativePointAndLineRasterization is false.\",\n                     string_VkConservativeRasterizationModeEXT(\n                         rasterization_conservative_state_ci.conservativeRasterizationMode),\n                     string_VkPrimitiveTopology(pipeline.topology_at_rasterizer));\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkGraphicsPipelineCreateInfo-pDynamicStates-00754\", \"If the pipeline requires pre-rasterization shader state, the depthBiasClamp feature is not enabled, no element of the pDynamicStates member of pDynamicState is VK_DYNAMIC_STATE_DEPTH_BIAS, and the depthBiasEnable member of pRasterizationState is VK_TRUE, the depthBiasClamp member of pRasterizationState must be 0.0\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (!pipeline.IsDynamic(CB_DYNAMIC_STATE_DEPTH_BIAS) && (raster_state->depthBiasClamp != 0.0) &&\n    !enabled_features.depthBiasClamp) {\n    skip |= LogError(\"VUID-VkGraphicsPipelineCreateInfo-pDynamicStates-00754\", device, raster_loc.dot(Field::depthBiasClamp),\n                     \"is %f, but the depthBiasClamp feature was not enabled\", raster_state->depthBiasClamp);\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkPipelineMultisampleStateCreateInfo-alphaToOneEnable-00785\", \"If the alphaToOne feature is not enabled, alphaToOneEnable must be VK_FALSE\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (ms_state && (ms_state->alphaToOneEnable == VK_TRUE) && !enabled_features.alphaToOne &&\n    skip |= LogError(\"VUID-VkPipelineMultisampleStateCreateInfo-alphaToOneEnable-00785\", device,\n                     create_info_loc.dot(Field::pMultisampleState).dot(Field::alphaToOneEnable),\n                     \"is VK_TRUE, but the alphaToOne feature was not enabled.\");\n"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkGraphicsPipelineCreateInfo-pDynamicState-09639\", \"If the pipeline requires pre-rasterization shader state, pDynamicState includes VK_DYNAMIC_STATE_CONSERVATIVE_RASTERIZATION_MODE_EXT, and pDynamicState does not include VK_DYNAMIC_STATE_EXTRA_PRIMITIVE_OVERESTIMATION_SIZE_EXT, pRasterizationState must include a VkPipelineRasterizationConservativeStateCreateInfoEXT in its pNext chain\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (pipeline.IsDynamic(CB_DYNAMIC_STATE_CONSERVATIVE_RASTERIZATION_MODE_EXT) &&\n    skip |= LogError(\"VUID-VkGraphicsPipelineCreateInfo-pDynamicState-09639\", device, raster_loc.dot(Field::pNext),\n                     \"is missing VkPipelineRasterizationConservativeStateCreateInfoEXT which it needs because this \"\n                     \"pipeline has VK_DYNAMIC_STATE_CONSERVATIVE_RASTERIZATION_MODE_EXT but not \"\n                     \"VK_DYNAMIC_STATE_EXTRA_PRIMITIVE_OVERESTIMATION_SIZE_EXT.\");\n"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkGraphicsPipelineCreateInfo-renderPass-09028\", \"If renderPass is not VK_NULL_HANDLE, the pipeline is being created with fragment shader state, and subpass uses a depth/stencil attachment, and related dynamic state is not set, pDepthStencilState must be a valid pointer to a valid VkPipelineDepthStencilStateCreateInfo structure\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (!pipeline.IsDepthStencilStateDynamic() || !IsExtEnabled(device_extensions.vk_ext_extended_dynamic_state3)) {\n    skip |= LogError(\"VUID-VkGraphicsPipelineCreateInfo-renderPass-09028\", rp_state.Handle(), ds_loc,\n                     \"is NULL when rasterization is enabled \"\n                     \"and subpass %\" PRIu32 \" uses a depth/stencil attachment.\",\n                     pipeline.Subpass());\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkGraphicsPipelineCreateInfo-pDynamicStates-02510\", \"If the pipeline requires fragment shader state, the VK_EXT_depth_range_unrestricted extension is not enabled and no element of the pDynamicStates member of pDynamicState is VK_DYNAMIC_STATE_DEPTH_BOUNDS, and the depthBoundsTestEnable member of pDepthStencilState is VK_TRUE, the minDepthBounds and maxDepthBounds members of pDepthStencilState must be between 0.0 and 1.0, inclusive\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (!(maxDepthBounds >= 0.0) || !(maxDepthBounds <= 1.0)) {\n    skip |= LogError(\"VUID-VkGraphicsPipelineCreateInfo-pDynamicStates-02510\", device,\n                     ds_loc.dot(Field::minDepthBounds),\n                     \"is %f, depthBoundsTestEnable is VK_TRUE, but VK_EXT_depth_range_unrestricted extension \"\n                     \"is not enabled (and not using VK_DYNAMIC_STATE_DEPTH_BOUNDS).\",\n                     maxDepthBounds);\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkGraphicsPipelineCreateInfo-renderPass-09030\", \"If renderPass is not VK_NULL_HANDLE, the pipeline is being created with fragment output interface state, and subpass uses color attachments, and related dynamic state is not set, pColorBlendState must be a valid pointer to a valid VkPipelineColorBlendStateCreateInfo structure\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (subpass_desc.pColorAttachments[i].attachment != VK_ATTACHMENT_UNUSED) {\n    skip |= LogError(\"VUID-VkGraphicsPipelineCreateInfo-renderPass-09030\", rp_state.Handle(),\n                     create_info_loc.dot(Field::pColorBlendState),\n                     \"is NULL when rasterization is enabled and \"\n                     \"pSubpasses[%\" PRIu32 \"].pColorAttachments[%\" PRIu32 \"].attachment (%\" PRIu32\n                     \") is a color attachments.\",\n                     pipeline.Subpass(), i, subpass_desc.pColorAttachments[i].attachment);\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkSampleLocationsInfoEXT-sampleLocationsCount-01527\", \"sampleLocationsCount must equal sampleLocationsPerPixel \u00d7 sampleLocationGridSize.width \u00d7 sampleLocationGridSize.height\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (sample_location_info.sampleLocationsCount != sample_total_size) {\n    skip |= LogError(\"VUID-VkSampleLocationsInfoEXT-sampleLocationsCount-01527\", device, loc.dot(Field::sampleLocationsCount),\n                     \"(%\" PRIu32\n                     \") must equal grid width * grid height * pixel \"\n                     \"sample rate which currently is (%\" PRIu32 \" * %\" PRIu32 \" * %\" PRIu32 \").\",\n                     sample_location_info.sampleLocationsCount, sample_location_info.sampleLocationGridSize.width,\n                     sample_location_info.sampleLocationGridSize.height, SampleCountSize(sample_count));\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkGraphicsPipelineCreateInfo-multisampledRenderToSingleSampled-06853\", \"If the pipeline requires fragment output interface state, and none of the VK_AMD_mixed_attachment_samples extension, the VK_NV_framebuffer_mixed_samples extension, or the multisampledRenderToSingleSampled feature are enabled, rasterizationSamples is not dynamic, and if subpass uses color and/or depth/stencil attachments, then the rasterizationSamples member of pMultisampleState must be the same as the sample count for those subpass attachments\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (subpass_num_samples && (!IsPowerOfTwo(subpass_num_samples) || (subpass_num_samples != raster_samples))) {\n    skip |= LogError(\"VUID-VkGraphicsPipelineCreateInfo-multisampledRenderToSingleSampled-06853\", device,\n                     ms_loc.dot(Field::rasterizationSamples),\n                     \"(%\" PRIu32\n                     \") does not match the number of samples of the RenderPass color and/or depth attachment (%\" PRIu32\n                     \").\",\n                     raster_samples, subpass_num_samples);\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkPipelineMultisampleStateCreateInfo-rasterizationSamples-01415\", \"If the VK_NV_framebuffer_mixed_samples extension is enabled, and if the subpass has any color attachments and rasterizationSamples is greater than the number of color samples, then sampleShadingEnable must be VK_FALSE\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if ((raster_samples > subpass_color_samples) && (multisample_state->sampleShadingEnable == VK_TRUE)) {\n    skip |= LogError(\"VUID-VkPipelineMultisampleStateCreateInfo-rasterizationSamples-01415\", device,\n                     ms_loc.dot(Field::rasterizationSamples),\n                     \"(%\" PRIu32\n                     \") is greater than the number of \"\n                     \"samples of the \"\n                     \"subpass color attachment (%\" PRIu32 \") and sampleShadingEnable is VK_TRUE.\",\n                     raster_samples, subpass_color_samples);\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkGraphicsPipelineCreateInfo-coverageReductionMode-02722\", \"If the pipeline requires fragment output interface state, the VK_NV_coverage_reduction_mode extension is enabled, and rasterizationSamples is not dynamic, the coverage reduction mode specified by VkPipelineCoverageReductionStateCreateInfoNV::coverageReductionMode, the rasterizationSamples member of pMultisampleState and the sample counts for the color and depth/stencil attachments (if the subpass has them) must be a valid combination returned by vkGetPhysicalDeviceSupportedFramebufferMixedSamplesCombinationsNV\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (!combination_found) {\n    skip |= LogError(\"VUID-VkGraphicsPipelineCreateInfo-coverageReductionMode-02722\", device, create_info_loc,\n                     \"specifies a combination of coverage \"\n                     \"reduction mode (%s), pMultisampleState->rasterizationSamples (%\" PRIu32\n                     \"), sample counts for \"\n                     \"the subpass color and depth/stencil attachments is not a valid combination returned by \"\n                     \"vkGetPhysicalDeviceSupportedFramebufferMixedSamplesCombinationsNV.\",\n                     string_VkCoverageReductionModeNV(coverage_reduction_mode), raster_samples);\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkGraphicsPipelineCreateInfo-subpass-00758\", \"If the pipeline requires fragment output interface state, rasterizationSamples is not dynamic, and subpass does not use any color and/or depth/stencil attachments, then the rasterizationSamples member of pMultisampleState must follow the rules for a zero-attachment subpass\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if ((multisample_state->rasterizationSamples & phys_dev_props.limits.framebufferNoAttachmentsSampleCounts) == 0) {\n    skip |= LogError(\"VUID-VkGraphicsPipelineCreateInfo-subpass-00758\", rp_state.Handle(),\n                     ms_loc.dot(Field::rasterizationSamples),\n                     \"(%s) is not in \"\n                     \"framebufferNoAttachmentsSampleCounts (%s) but attempting to use a zero-attachment subpass.\",\n                     string_VkSampleCountFlagBits(multisample_state->rasterizationSamples),\n                     string_VkSampleCountFlags(phys_dev_props.limits.framebufferNoAttachmentsSampleCounts).c_str());\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkPipelineCoverageToColorStateCreateInfoNV-coverageToColorEnable-01404\", \"If coverageToColorEnable is VK_TRUE, then the render pass subpass indicated by VkGraphicsPipelineCreateInfo::renderPass and VkGraphicsPipelineCreateInfo::subpass must have a color attachment at the location selected by coverageToColorLocation, with a VkFormat of VK_FORMAT_R8_UINT, VK_FORMAT_R8_SINT, VK_FORMAT_R16_UINT, VK_FORMAT_R16_SINT, VK_FORMAT_R32_UINT, or VK_FORMAT_R32_SINT\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (!attachment_is_valid) {\n    skip |= LogError(\"VUID-VkPipelineCoverageToColorStateCreateInfoNV-coverageToColorEnable-01404\", device,\n                     ms_loc.pNext(Struct::VkPipelineCoverageToColorStateCreateInfoNV, Field::coverageToColorLocation),\n                     \"is %\" PRIu32 \", but %s\", coverage_to_color_state->coverageToColorLocation, error_detail.c_str());\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkGraphicsPipelineCreateInfo-rasterizationSamples-04899\", \"If the pipeline requires fragment shader state, and the VK_QCOM_render_pass_shader_resolve extension is enabled, rasterizationSamples is not dynamic, and if subpass has any input attachments, and if the subpass description contains VK_SUBPASS_DESCRIPTION_FRAGMENT_REGION_BIT_QCOM, then the sample count of the input attachments must equal rasterizationSamples\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if ((raster_samples != subpass_input_attachment_samples) &&\n    skip |= LogError(\"VUID-VkGraphicsPipelineCreateInfo-rasterizationSamples-04899\", device,\n                     ms_loc.dot(Field::rasterizationSamples),\n                     \"%s is different then pSubpasses[%\" PRIu32 \"] input attachment samples (%\" PRIu32\n                     \") but flags include VK_SUBPASS_DESCRIPTION_FRAGMENT_REGION_BIT_QCOM.\",\n                     string_VkSampleCountFlagBits(multisample_state->rasterizationSamples), pipeline.Subpass(),\n                     subpass_input_attachment_samples);\n"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkGraphicsPipelineCreateInfo-sampleShadingEnable-04900\", \"If the pipeline requires fragment shader state, and the VK_QCOM_render_pass_shader_resolve extension is enabled, and if the subpass description contains VK_SUBPASS_DESCRIPTION_FRAGMENT_REGION_BIT_QCOM, then sampleShadingEnable must be false\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (multisample_state->sampleShadingEnable == VK_TRUE) {\n    skip |= LogError(\"VUID-VkGraphicsPipelineCreateInfo-sampleShadingEnable-04900\", device,\n                     ms_loc.dot(Field::sampleShadingEnable),\n                     \"is VK_TRUE, but pSubpasses[%\" PRIu32\n                     \"] includes \"\n                     \"VK_SUBPASS_DESCRIPTION_FRAGMENT_REGION_BIT_QCOM. \",\n                     pipeline.Subpass());\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkGraphicsPipelineCreateInfo-renderPass-09035\", \"If renderPass is VK_NULL_HANDLE and the pipeline is being created with fragment shader state but not fragment output interface state, and the VK_EXT_extended_dynamic_state3 extension is not enabled, or any of the VK_DYNAMIC_STATE_DEPTH_TEST_ENABLE, VK_DYNAMIC_STATE_DEPTH_WRITE_ENABLE, VK_DYNAMIC_STATE_DEPTH_COMPARE_OP, VK_DYNAMIC_STATE_DEPTH_BOUNDS_TEST_ENABLE, VK_DYNAMIC_STATE_STENCIL_TEST_ENABLE, VK_DYNAMIC_STATE_STENCIL_OP, or VK_DYNAMIC_STATE_DEPTH_BOUNDS dynamic states are not set, pDepthStencilState must be a valid pointer to a valid VkPipelineDepthStencilStateCreateInfo structure\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (!pipeline.IsDepthStencilStateDynamic() || !IsExtEnabled(device_extensions.vk_ext_extended_dynamic_state3)) {\n    skip |= LogError(\"VUID-VkGraphicsPipelineCreateInfo-renderPass-09035\", device,\n                     create_info_loc.dot(Field::pDepthStencilState), \"is NULL.\");\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkGraphicsPipelineCreateInfo-renderpass-06631\", \"If renderPass is not VK_NULL_HANDLE, the pipeline requires fragment shader state, and the VK_EXT_extended_dynamic_state3 extension is not enabled or any of the VK_DYNAMIC_STATE_RASTERIZATION_SAMPLES_EXT, VK_DYNAMIC_STATE_SAMPLE_MASK_EXT, or VK_DYNAMIC_STATE_ALPHA_TO_COVERAGE_ENABLE_EXT dynamic states is not set, or alphaToOne is enabled on the device and VK_DYNAMIC_STATE_ALPHA_TO_ONE_ENABLE_EXT is not set, then pMultisampleState must be a valid pointer to a valid VkPipelineMultisampleStateCreateInfo structure\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (!null_rp) {\n    skip |= LogError(\"VUID-VkGraphicsPipelineCreateInfo-renderpass-06631\", device,\n                     create_info_loc.dot(Field::pMultisampleState),\n                     \"is NULL, but pipeline is being created with fragment shader that uses samples.\");\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkGraphicsPipelineCreateInfo-pRasterizationState-06601\", \"If the pipeline requires pre-rasterization shader state, and related dynamic state is not set, pRasterizationState must be a valid pointer to a valid VkPipelineRasterizationStateCreateInfo structure\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "skip |= LogError(\"VUID-VkGraphicsPipelineCreateInfo-pRasterizationState-06601\", device,\n                 create_info_loc.dot(Field::pRasterizationState), \"is NULL.\");\n"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkGraphicsPipelineCreateInfo-None-09526\", \"If the dynamicRenderingLocalRead feature is not enabled, the pipeline requires fragment output interface state, and the flags member of VkPipelineDepthStencilStateCreateInfo includes VK_PIPELINE_DEPTH_STENCIL_STATE_CREATE_RASTERIZATION_ORDER_ATTACHMENT_DEPTH_ACCESS_BIT_EXT or VK_PIPELINE_DEPTH_STENCIL_STATE_CREATE_RASTERIZATION_ORDER_ATTACHMENT_STENCIL_ACCESS_BIT_EXT, renderPass must not be VK_NULL_HANDLE\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (!enabled_features.dynamicRenderingLocalRead && (raster_order_attach_depth || raster_order_attach_stencil)) {\n    skip |= LogError(\"VUID-VkGraphicsPipelineCreateInfo-None-09526\", device, ds_loc.dot(Field::flags),\n                     \"is %s but renderPass is VK_NULL_HANDLE.\",\n                     string_VkPipelineDepthStencilStateCreateFlags(ds_state->flags).c_str());\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkPipelineDepthStencilStateCreateInfo-rasterizationOrderDepthAttachmentAccess-06463\", \"If the rasterizationOrderDepthAttachmentAccess feature is not enabled, flags must not include VK_PIPELINE_DEPTH_STENCIL_STATE_CREATE_RASTERIZATION_ORDER_ATTACHMENT_DEPTH_ACCESS_BIT_EXT\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (!enabled_features.rasterizationOrderDepthAttachmentAccess) {\n    skip |= LogError(\"VUID-VkPipelineDepthStencilStateCreateInfo-rasterizationOrderDepthAttachmentAccess-06463\",\n                     device, ds_loc.dot(Field::flags),\n                     \"is (%s) but rasterizationOrderDepthAttachmentAccess feature was not enabled\",\n                     string_VkPipelineDepthStencilStateCreateFlags(ds_state->flags).c_str());\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkPipelineDepthStencilStateCreateInfo-rasterizationOrderStencilAttachmentAccess-06464\", \"If the rasterizationOrderStencilAttachmentAccess feature is not enabled, flags must not include VK_PIPELINE_DEPTH_STENCIL_STATE_CREATE_RASTERIZATION_ORDER_ATTACHMENT_STENCIL_ACCESS_BIT_EXT\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (!enabled_features.rasterizationOrderStencilAttachmentAccess) {\n    skip |= LogError(\"VUID-VkPipelineDepthStencilStateCreateInfo-rasterizationOrderStencilAttachmentAccess-06464\",\n                     device, ds_loc.dot(Field::flags),\n                     \"is (%s) but rasterizationOrderStencilAttachmentAccess feature was not enabled\",\n                     string_VkPipelineDepthStencilStateCreateFlags(ds_state->flags).c_str());\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkGraphicsPipelineCreateInfo-renderPass-09527\", \"If the pipeline requires fragment output interface state, renderPass is not VK_NULL_HANDLE, and the flags member of VkPipelineColorBlendStateCreateInfo includes VK_PIPELINE_COLOR_BLEND_STATE_CREATE_RASTERIZATION_ORDER_ATTACHMENT_ACCESS_BIT_EXT subpass must have been created with VK_SUBPASS_DESCRIPTION_RASTERIZATION_ORDER_ATTACHMENT_COLOR_ACCESS_BIT_EXT\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (!null_rp && subpass_desc &&\n    skip |= LogError(\"VUID-VkGraphicsPipelineCreateInfo-renderPass-09527\", rp_state->Handle(),\n                     color_loc.dot(Field::flags), \"(%s) but VkRenderPassCreateInfo::VkSubpassDescription::flags == %s\",\n                     string_VkPipelineColorBlendStateCreateFlags(color_blend_state->flags).c_str(),\n                     string_VkSubpassDescriptionFlags(subpass_desc->flags).c_str());\n"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkGraphicsPipelineCreateInfo-pDynamicStates-07065\", \"If the pipeline requires pre-rasterization shader state, and includes a mesh shader, there must be no element of the pDynamicStates member of pDynamicState set to VK_DYNAMIC_STATE_PRIMITIVE_TOPOLOGY, or VK_DYNAMIC_STATE_VERTEX_INPUT_BINDING_STRIDE\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (pipeline.IsDynamic(CB_DYNAMIC_STATE_PRIMITIVE_TOPOLOGY)) {\n    skip |= LogError(\"VUID-VkGraphicsPipelineCreateInfo-pDynamicStates-07065\", device,\n                     create_info_loc.dot(Field::pDynamicState)\n                         .dot(Field::pDynamicStates, get_state_index(VK_DYNAMIC_STATE_PRIMITIVE_TOPOLOGY)),\n                     \"is VK_DYNAMIC_STATE_PRIMITIVE_TOPOLOGY, but the pipeline contains a mesh shader.\");\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkGraphicsPipelineCreateInfo-pDynamicStates-07065\", \"If the pipeline requires pre-rasterization shader state, and includes a mesh shader, there must be no element of the pDynamicStates member of pDynamicState set to VK_DYNAMIC_STATE_PRIMITIVE_TOPOLOGY, or VK_DYNAMIC_STATE_VERTEX_INPUT_BINDING_STRIDE\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": ".dot(Field::pDynamicStates, get_state_index(VK_DYNAMIC_STATE_PRIMITIVE_TOPOLOGY)),\nskip |= LogError(\"VUID-VkGraphicsPipelineCreateInfo-pDynamicStates-07065\", device,\ncreate_info_loc.dot(Field::pDynamicState)\n.dot(Field::pDynamicStates, get_state_index(VK_DYNAMIC_STATE_VERTEX_INPUT_BINDING_STRIDE)),\n\"is VK_DYNAMIC_STATE_VERTEX_INPUT_BINDING_STRIDE, but the pipeline contains a mesh shader.\");\n"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkGraphicsPipelineCreateInfo-pDynamicStates-07066\", \"If the pipeline requires pre-rasterization shader state, and includes a mesh shader, there must be no element of the pDynamicStates member of pDynamicState set to VK_DYNAMIC_STATE_PRIMITIVE_RESTART_ENABLE, or VK_DYNAMIC_STATE_PATCH_CONTROL_POINTS_EXT\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (pipeline.IsDynamic(CB_DYNAMIC_STATE_PRIMITIVE_RESTART_ENABLE)) {\n    skip |= LogError(\"VUID-VkGraphicsPipelineCreateInfo-pDynamicStates-07066\", device,\n                     create_info_loc.dot(Field::pDynamicState)\n                         .dot(Field::pDynamicStates, get_state_index(VK_DYNAMIC_STATE_PRIMITIVE_RESTART_ENABLE)),\n                     \"is VK_DYNAMIC_STATE_PRIMITIVE_RESTART_ENABLE, but the pipeline contains a mesh shader.\");\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkGraphicsPipelineCreateInfo-pDynamicStates-07067\", \"If the pipeline requires pre-rasterization shader state, and includes a mesh shader, there must be no element of the pDynamicStates member of pDynamicState set to VK_DYNAMIC_STATE_VERTEX_INPUT_EXT\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (pipeline.IsDynamic(CB_DYNAMIC_STATE_VERTEX_INPUT_EXT)) {\n    skip |= LogError(\"VUID-VkGraphicsPipelineCreateInfo-pDynamicStates-07067\", device,\n                     create_info_loc.dot(Field::pDynamicState)\n                         .dot(Field::pDynamicStates, get_state_index(VK_DYNAMIC_STATE_VERTEX_INPUT_EXT)),\n                     \"is VK_DYNAMIC_STATE_VERTEX_INPUT_EXT, but the pipeline contains a mesh shader.\");\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkGraphicsPipelineCreateInfo-pDynamicStates-04868\", \"If the extendedDynamicState2 feature is not enabled, and the value of VkApplicationInfo::apiVersion used to create the VkInstance is less than Version 1.3 there must be no element of the pDynamicStates member of pDynamicState set to VK_DYNAMIC_STATE_DEPTH_BIAS_ENABLE, VK_DYNAMIC_STATE_PRIMITIVE_RESTART_ENABLE, or VK_DYNAMIC_STATE_RASTERIZER_DISCARD_ENABLE\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": ".dot(Field::pDynamicStates, get_state_index(VK_DYNAMIC_STATE_RASTERIZER_DISCARD_ENABLE)),\nskip |= LogError(\"VUID-VkGraphicsPipelineCreateInfo-pDynamicStates-04868\", device,\ncreate_info_loc.dot(Field::pDynamicState)\n    .dot(Field::pDynamicStates, get_state_index(VK_DYNAMIC_STATE_DEPTH_BIAS_ENABLE)),\n\"is VK_DYNAMIC_STATE_DEPTH_BIAS_ENABLE, but the extendedDynamicState2 feature was not enabled.\");\n"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkGraphicsPipelineCreateInfo-pDynamicStates-04870\", \"If the extendedDynamicState2PatchControlPoints feature is not enabled, there must be no element of the pDynamicStates member of pDynamicState set to VK_DYNAMIC_STATE_PATCH_CONTROL_POINTS_EXT\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (!enabled_features.extendedDynamicState2PatchControlPoints &&\n    skip |= LogError(\"VUID-VkGraphicsPipelineCreateInfo-pDynamicStates-04870\", device,\n                     create_info_loc.dot(Field::pDynamicState)\n                         .dot(Field::pDynamicStates, get_state_index(VK_DYNAMIC_STATE_PATCH_CONTROL_POINTS_EXT)),\n                     \"is VK_DYNAMIC_STATE_PATCH_CONTROL_POINTS_EXT, but the extendedDynamicState2PatchControlPoints feature \"\n                     \"was not enabled.\");\n"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkGraphicsPipelineCreateInfo-extendedDynamicState3TessellationDomainOrigin-07370\", \"If the extendedDynamicState3TessellationDomainOrigin feature is not enabled, there must be no element of the pDynamicStates member of pDynamicState set to VK_DYNAMIC_STATE_TESSELLATION_DOMAIN_ORIGIN_EXT\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (!enabled_features.extendedDynamicState3TessellationDomainOrigin &&\n    skip |= LogError(\"VUID-VkGraphicsPipelineCreateInfo-extendedDynamicState3TessellationDomainOrigin-07370\", device,\n                     create_info_loc.dot(Field::pDynamicState)\n                         .dot(Field::pDynamicStates, get_state_index(VK_DYNAMIC_STATE_TESSELLATION_DOMAIN_ORIGIN_EXT)),\n                     \"is VK_DYNAMIC_STATE_TESSELLATION_DOMAIN_ORIGIN_EXT, but the \"\n                     \"extendedDynamicState3TessellationDomainOrigin feature was not enabled.\");\n"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkGraphicsPipelineCreateInfo-extendedDynamicState3RasterizationSamples-07373\", \"If the extendedDynamicState3RasterizationSamples feature is not enabled, there must be no element of the pDynamicStates member of pDynamicState set to VK_DYNAMIC_STATE_RASTERIZATION_SAMPLES_EXT\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (!enabled_features.extendedDynamicState3RasterizationSamples &&\n    skip |= LogError(\"VUID-VkGraphicsPipelineCreateInfo-extendedDynamicState3RasterizationSamples-07373\", device,\n                     create_info_loc.dot(Field::pDynamicState)\n                         .dot(Field::pDynamicStates, get_state_index(VK_DYNAMIC_STATE_RASTERIZATION_SAMPLES_EXT)),\n                     \"is VK_DYNAMIC_STATE_RASTERIZATION_SAMPLES_EXT but the extendedDynamicState3RasterizationSamples feature \"\n                     \"is not enabled.\");\n"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkGraphicsPipelineCreateInfo-extendedDynamicState3AlphaToCoverageEnable-07375\", \"If the extendedDynamicState3AlphaToCoverageEnable feature is not enabled, there must be no element of the pDynamicStates member of pDynamicState set to VK_DYNAMIC_STATE_ALPHA_TO_COVERAGE_ENABLE_EXT\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (!enabled_features.extendedDynamicState3AlphaToCoverageEnable &&\n    skip |= LogError(\"VUID-VkGraphicsPipelineCreateInfo-extendedDynamicState3AlphaToCoverageEnable-07375\", device,\n                     create_info_loc.dot(Field::pDynamicState)\n                         .dot(Field::pDynamicStates, get_state_index(VK_DYNAMIC_STATE_ALPHA_TO_COVERAGE_ENABLE_EXT)),\n                     \"is VK_DYNAMIC_STATE_ALPHA_TO_COVERAGE_ENABLE_EXT but the extendedDynamicState3AlphaToCoverageEnable \"\n                     \"feature is not enabled.\");\n"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkGraphicsPipelineCreateInfo-extendedDynamicState3RasterizationStream-07381\", \"If the extendedDynamicState3RasterizationStream feature is not enabled, there must be no element of the pDynamicStates member of pDynamicState set to VK_DYNAMIC_STATE_RASTERIZATION_STREAM_EXT\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (!enabled_features.extendedDynamicState3RasterizationStream &&\n    skip |= LogError(\"VUID-VkGraphicsPipelineCreateInfo-extendedDynamicState3RasterizationStream-07381\", device,\n                     create_info_loc.dot(Field::pDynamicState)\n                         .dot(Field::pDynamicStates, get_state_index(VK_DYNAMIC_STATE_RASTERIZATION_STREAM_EXT)),\n                     \"is VK_DYNAMIC_STATE_RASTERIZATION_STREAM_EXT but the extendedDynamicState3RasterizationStream feature is \"\n                     \"not enabled.\");\n"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkGraphicsPipelineCreateInfo-extendedDynamicState3ConservativeRasterizationMode-07382\", \"If the extendedDynamicState3ConservativeRasterizationMode feature is not enabled, there must be no element of the pDynamicStates member of pDynamicState set to VK_DYNAMIC_STATE_CONSERVATIVE_RASTERIZATION_MODE_EXT\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (!enabled_features.extendedDynamicState3ConservativeRasterizationMode &&\n    skip |= LogError(\"VUID-VkGraphicsPipelineCreateInfo-extendedDynamicState3ConservativeRasterizationMode-07382\", device,\n                     create_info_loc.dot(Field::pDynamicState)\n                         .dot(Field::pDynamicStates, get_state_index(VK_DYNAMIC_STATE_CONSERVATIVE_RASTERIZATION_MODE_EXT)),\n                     \"is VK_DYNAMIC_STATE_CONSERVATIVE_RASTERIZATION_MODE_EXT but the \"\n                     \"extendedDynamicState3ConservativeRasterizationMode feature is not enabled.\");\n"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkGraphicsPipelineCreateInfo-extendedDynamicState3SampleLocationsEnable-07385\", \"If the extendedDynamicState3SampleLocationsEnable feature is not enabled, there must be no element of the pDynamicStates member of pDynamicState set to VK_DYNAMIC_STATE_SAMPLE_LOCATIONS_ENABLE_EXT\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (!enabled_features.extendedDynamicState3SampleLocationsEnable &&\n    skip |= LogError(\"VUID-VkGraphicsPipelineCreateInfo-extendedDynamicState3SampleLocationsEnable-07385\", device,\n                     create_info_loc.dot(Field::pDynamicState)\n                         .dot(Field::pDynamicStates, get_state_index(VK_DYNAMIC_STATE_SAMPLE_LOCATIONS_ENABLE_EXT)),\n                     \"is VK_DYNAMIC_STATE_SAMPLE_LOCATIONS_ENABLE_EXT but the extendedDynamicState3SampleLocationsEnable \"\n                     \"feature is not enabled.\");\n"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkGraphicsPipelineCreateInfo-extendedDynamicState3ProvokingVertexMode-07387\", \"If the extendedDynamicState3ProvokingVertexMode feature is not enabled, there must be no element of the pDynamicStates member of pDynamicState set to VK_DYNAMIC_STATE_PROVOKING_VERTEX_MODE_EXT\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (!enabled_features.extendedDynamicState3ProvokingVertexMode &&\n    skip |= LogError(\"VUID-VkGraphicsPipelineCreateInfo-extendedDynamicState3ProvokingVertexMode-07387\", device,\n                     create_info_loc.dot(Field::pDynamicState)\n                         .dot(Field::pDynamicStates, get_state_index(VK_DYNAMIC_STATE_PROVOKING_VERTEX_MODE_EXT)),\n                     \"is VK_DYNAMIC_STATE_PROVOKING_VERTEX_MODE_EXT but the extendedDynamicState3ProvokingVertexMode feature \"\n                     \"is not enabled.\");\n"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkGraphicsPipelineCreateInfo-extendedDynamicState3LineRasterizationMode-07388\", \"If the extendedDynamicState3LineRasterizationMode feature is not enabled, there must be no element of the pDynamicStates member of pDynamicState set to VK_DYNAMIC_STATE_LINE_RASTERIZATION_MODE_EXT\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (!enabled_features.extendedDynamicState3LineRasterizationMode &&\n    skip |= LogError(\"VUID-VkGraphicsPipelineCreateInfo-extendedDynamicState3LineRasterizationMode-07388\", device,\n                     create_info_loc.dot(Field::pDynamicState)\n                         .dot(Field::pDynamicStates, get_state_index(VK_DYNAMIC_STATE_LINE_RASTERIZATION_MODE_EXT)),\n                     \"is VK_DYNAMIC_STATE_LINE_RASTERIZATION_MODE_EXT but the extendedDynamicState3LineRasterizationMode \"\n                     \"feature is not enabled.\");\n"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkGraphicsPipelineCreateInfo-extendedDynamicState3DepthClipNegativeOneToOne-07390\", \"If the extendedDynamicState3DepthClipNegativeOneToOne feature is not enabled, there must be no element of the pDynamicStates member of pDynamicState set to VK_DYNAMIC_STATE_DEPTH_CLIP_NEGATIVE_ONE_TO_ONE_EXT\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (!enabled_features.extendedDynamicState3DepthClipNegativeOneToOne &&\n    skip |= LogError(\"VUID-VkGraphicsPipelineCreateInfo-extendedDynamicState3DepthClipNegativeOneToOne-07390\", device,\n                     create_info_loc.dot(Field::pDynamicState)\n                         .dot(Field::pDynamicStates, get_state_index(VK_DYNAMIC_STATE_DEPTH_CLIP_NEGATIVE_ONE_TO_ONE_EXT)),\n                     \"is VK_DYNAMIC_STATE_DEPTH_CLIP_NEGATIVE_ONE_TO_ONE_EXT but the \"\n                     \"extendedDynamicState3DepthClipNegativeOneToOne feature is not enabled.\");\n"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkGraphicsPipelineCreateInfo-extendedDynamicState3CoverageToColorEnable-07393\", \"If the extendedDynamicState3CoverageToColorEnable feature is not enabled, there must be no element of the pDynamicStates member of pDynamicState set to VK_DYNAMIC_STATE_COVERAGE_TO_COLOR_ENABLE_NV\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (!enabled_features.extendedDynamicState3CoverageToColorEnable &&\n    skip |= LogError(\"VUID-VkGraphicsPipelineCreateInfo-extendedDynamicState3CoverageToColorEnable-07393\", device,\n                     create_info_loc.dot(Field::pDynamicState)\n                         .dot(Field::pDynamicStates, get_state_index(VK_DYNAMIC_STATE_COVERAGE_TO_COLOR_ENABLE_NV)),\n                     \"is VK_DYNAMIC_STATE_COVERAGE_TO_COLOR_ENABLE_NV but the extendedDynamicState3CoverageToColorEnable \"\n                     \"feature is not enabled.\");\n"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkGraphicsPipelineCreateInfo-extendedDynamicState3CoverageToColorLocation-07394\", \"If the extendedDynamicState3CoverageToColorLocation feature is not enabled, there must be no element of the pDynamicStates member of pDynamicState set to VK_DYNAMIC_STATE_COVERAGE_TO_COLOR_LOCATION_NV\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (!enabled_features.extendedDynamicState3CoverageToColorLocation &&\n    skip |= LogError(\"VUID-VkGraphicsPipelineCreateInfo-extendedDynamicState3CoverageToColorLocation-07394\", device,\n                     create_info_loc.dot(Field::pDynamicState)\n                         .dot(Field::pDynamicStates, get_state_index(VK_DYNAMIC_STATE_COVERAGE_TO_COLOR_LOCATION_NV)),\n                     \"is VK_DYNAMIC_STATE_COVERAGE_TO_COLOR_LOCATION_NV but the extendedDynamicState3CoverageToColorLocation \"\n                     \"feature is not enabled.\");\n"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkGraphicsPipelineCreateInfo-extendedDynamicState3CoverageModulationMode-07395\", \"If the extendedDynamicState3CoverageModulationMode feature is not enabled, there must be no element of the pDynamicStates member of pDynamicState set to VK_DYNAMIC_STATE_COVERAGE_MODULATION_MODE_NV\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (!enabled_features.extendedDynamicState3CoverageModulationMode &&\n    skip |= LogError(\"VUID-VkGraphicsPipelineCreateInfo-extendedDynamicState3CoverageModulationMode-07395\", device,\n                     create_info_loc.dot(Field::pDynamicState)\n                         .dot(Field::pDynamicStates, get_state_index(VK_DYNAMIC_STATE_COVERAGE_MODULATION_MODE_NV)),\n                     \"is VK_DYNAMIC_STATE_COVERAGE_MODULATION_MODE_NV but the extendedDynamicState3CoverageModulationMode \"\n                     \"feature is not enabled.\");\n"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkGraphicsPipelineCreateInfo-extendedDynamicState3CoverageModulationTableEnable-07396\", \"If the extendedDynamicState3CoverageModulationTableEnable feature is not enabled, there must be no element of the pDynamicStates member of pDynamicState set to VK_DYNAMIC_STATE_COVERAGE_MODULATION_TABLE_ENABLE_NV\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (!enabled_features.extendedDynamicState3CoverageModulationTableEnable &&\n    skip |= LogError(\"VUID-VkGraphicsPipelineCreateInfo-extendedDynamicState3CoverageModulationTableEnable-07396\", device,\n                     create_info_loc.dot(Field::pDynamicState)\n                         .dot(Field::pDynamicStates, get_state_index(VK_DYNAMIC_STATE_COVERAGE_MODULATION_TABLE_ENABLE_NV)),\n                     \"is VK_DYNAMIC_STATE_COVERAGE_MODULATION_TABLE_ENABLE_NV but the \"\n                     \"extendedDynamicState3CoverageModulationTableEnable feature is not enabled.\");\n"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkGraphicsPipelineCreateInfo-extendedDynamicState3CoverageReductionMode-07398\", \"If the extendedDynamicState3CoverageReductionMode feature is not enabled, there must be no element of the pDynamicStates member of pDynamicState set to VK_DYNAMIC_STATE_COVERAGE_REDUCTION_MODE_NV\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (!enabled_features.extendedDynamicState3CoverageReductionMode &&\n    skip |= LogError(\"VUID-VkGraphicsPipelineCreateInfo-extendedDynamicState3CoverageReductionMode-07398\", device,\n                     create_info_loc.dot(Field::pDynamicState)\n                         .dot(Field::pDynamicStates, get_state_index(VK_DYNAMIC_STATE_COVERAGE_REDUCTION_MODE_NV)),\n                     \"is VK_DYNAMIC_STATE_COVERAGE_REDUCTION_MODE_NV but the extendedDynamicState3CoverageReductionMode \"\n                     \"feature is not enabled.\");\n"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkGraphicsPipelineCreateInfo-extendedDynamicState3RepresentativeFragmentTestEnable-07399\", \"If the extendedDynamicState3RepresentativeFragmentTestEnable feature is not enabled, there must be no element of the pDynamicStates member of pDynamicState set to VK_DYNAMIC_STATE_REPRESENTATIVE_FRAGMENT_TEST_ENABLE_NV\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (!enabled_features.extendedDynamicState3RepresentativeFragmentTestEnable &&\n    skip |= LogError(\"VUID-VkGraphicsPipelineCreateInfo-extendedDynamicState3RepresentativeFragmentTestEnable-07399\", device,\n                     create_info_loc.dot(Field::pDynamicState)\n                         .dot(Field::pDynamicStates, get_state_index(VK_DYNAMIC_STATE_REPRESENTATIVE_FRAGMENT_TEST_ENABLE_NV)),\n                     \"is VK_DYNAMIC_STATE_REPRESENTATIVE_FRAGMENT_TEST_ENABLE_NV but the \"\n                     \"extendedDynamicState3RepresentativeFragmentTestEnable feature is not enabled.\");\n"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkGraphicsPipelineCreateInfo-extendedDynamicState3ShadingRateImageEnable-07400\", \"If the extendedDynamicState3ShadingRateImageEnable feature is not enabled, there must be no element of the pDynamicStates member of pDynamicState set to VK_DYNAMIC_STATE_SHADING_RATE_IMAGE_ENABLE_NV\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (!enabled_features.extendedDynamicState3ShadingRateImageEnable &&\n    skip |= LogError(\"VUID-VkGraphicsPipelineCreateInfo-extendedDynamicState3ShadingRateImageEnable-07400\", device,\n                     create_info_loc.dot(Field::pDynamicState)\n                         .dot(Field::pDynamicStates, get_state_index(VK_DYNAMIC_STATE_SHADING_RATE_IMAGE_ENABLE_NV)),\n                     \"is VK_DYNAMIC_STATE_SHADING_RATE_IMAGE_ENABLE_NV but the extendedDynamicState3ShadingRateImageEnable \"\n                     \"feature is not enabled.\");\n"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkGraphicsPipelineCreateInfo-pDynamicStates-04807\", \"If the pipeline requires pre-rasterization shader state and the vertexInputDynamicState feature is not enabled, there must be no element of the pDynamicStates member of pDynamicState set to VK_DYNAMIC_STATE_VERTEX_INPUT_EXT\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (!enabled_features.vertexInputDynamicState && pipeline.IsDynamic(CB_DYNAMIC_STATE_VERTEX_INPUT_EXT)) {\n    skip |= LogError(\"VUID-VkGraphicsPipelineCreateInfo-pDynamicStates-04807\", device,\n                     create_info_loc.dot(Field::pDynamicState)\n                         .dot(Field::pDynamicStates, get_state_index(VK_DYNAMIC_STATE_VERTEX_INPUT_EXT)),\n                     \"is VK_DYNAMIC_STATE_VERTEX_INPUT_EXT but the vertexInputDynamicState feature is not enabled.\");\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkGraphicsPipelineCreateInfo-pDynamicState-04496\", \"If the pipeline requires pre-rasterization shader state or fragment shader state and VK_DYNAMIC_STATE_FRAGMENT_SHADING_RATE_KHR is not included in pDynamicState->pDynamicStates, VkPipelineFragmentShadingRateStateCreateInfoKHR::fragmentSize.width must be a power-of-two value\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (fragment_shading_rate_state.fragmentSize.width != 0 && !IsPowerOfTwo(fragment_shading_rate_state.fragmentSize.width)) {\n    skip |= LogError(\"VUID-VkGraphicsPipelineCreateInfo-pDynamicState-04496\", device, fragment_loc.dot(Field::width),\n                     \"is %\" PRIu32 \".\", fragment_shading_rate_state.fragmentSize.width);\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkGraphicsPipelineCreateInfo-pDynamicState-04497\", \"If the pipeline requires pre-rasterization shader state or fragment shader state and VK_DYNAMIC_STATE_FRAGMENT_SHADING_RATE_KHR is not included in pDynamicState->pDynamicStates, VkPipelineFragmentShadingRateStateCreateInfoKHR::fragmentSize.height must be a power-of-two value\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (fragment_shading_rate_state.fragmentSize.height != 0 && !IsPowerOfTwo(fragment_shading_rate_state.fragmentSize.height)) {\n    skip |= LogError(\"VUID-VkGraphicsPipelineCreateInfo-pDynamicState-04497\", device, fragment_loc.dot(Field::height),\n                     \"is %\" PRIu32 \".\", fragment_shading_rate_state.fragmentSize.height);\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkGraphicsPipelineCreateInfo-pDynamicState-04498\", \"If the pipeline requires pre-rasterization shader state or fragment shader state and VK_DYNAMIC_STATE_FRAGMENT_SHADING_RATE_KHR is not included in pDynamicState->pDynamicStates, VkPipelineFragmentShadingRateStateCreateInfoKHR::fragmentSize.width must be less than or equal to 4\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (fragment_shading_rate_state.fragmentSize.width > 4) {\n    skip |= LogError(\"VUID-VkGraphicsPipelineCreateInfo-pDynamicState-04498\", device, fragment_loc.dot(Field::width),\n                     \"is %\" PRIu32 \".\", fragment_shading_rate_state.fragmentSize.width);\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkGraphicsPipelineCreateInfo-pDynamicState-04499\", \"If the pipeline requires pre-rasterization shader state or fragment shader state and VK_DYNAMIC_STATE_FRAGMENT_SHADING_RATE_KHR is not included in pDynamicState->pDynamicStates, VkPipelineFragmentShadingRateStateCreateInfoKHR::fragmentSize.height must be less than or equal to 4\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (fragment_shading_rate_state.fragmentSize.height > 4) {\n    skip |= LogError(\"VUID-VkGraphicsPipelineCreateInfo-pDynamicState-04499\", device, fragment_loc.dot(Field::height),\n                     \"is %\" PRIu32 \".\", fragment_shading_rate_state.fragmentSize.height);\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkGraphicsPipelineCreateInfo-pDynamicState-04500\", \"If the pipeline requires pre-rasterization shader state or fragment shader state and VK_DYNAMIC_STATE_FRAGMENT_SHADING_RATE_KHR is not included in pDynamicState->pDynamicStates, and the pipelineFragmentShadingRate feature is not enabled, VkPipelineFragmentShadingRateStateCreateInfoKHR::fragmentSize.width and VkPipelineFragmentShadingRateStateCreateInfoKHR::fragmentSize.height must both be equal to 1\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (!enabled_features.pipelineFragmentShadingRate && fragment_shading_rate_state.fragmentSize.height != 1) {\n    skip |= LogError(\"VUID-VkGraphicsPipelineCreateInfo-pDynamicState-04500\", device, fragment_loc.dot(Field::height),\n                     \"is %\" PRIu32 \", but the pipelineFragmentShadingRate feature was not enabled.\",\n                     fragment_shading_rate_state.fragmentSize.height);\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkGraphicsPipelineCreateInfo-pDynamicState-04501\", \"If the pipeline requires pre-rasterization shader state or fragment shader state and VK_DYNAMIC_STATE_FRAGMENT_SHADING_RATE_KHR is not included in pDynamicState->pDynamicStates, and the primitiveFragmentShadingRate feature is not enabled, VkPipelineFragmentShadingRateStateCreateInfoKHR::combinerOps[0] must be VK_FRAGMENT_SHADING_RATE_COMBINER_OP_KEEP_KHR\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (!enabled_features.primitiveFragmentShadingRate &&\n    skip |= LogError(\"VUID-VkGraphicsPipelineCreateInfo-pDynamicState-04501\", device,\n                     create_info_loc.pNext(Struct::VkPipelineFragmentShadingRateStateCreateInfoKHR, Field::combinerOps, 0),\n                     \"is %s, but the primitiveFragmentShadingRate feature was not enabled.\",\n                     string_VkFragmentShadingRateCombinerOpKHR(fragment_shading_rate_state.combinerOps[0]));\n"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkGraphicsPipelineCreateInfo-pDynamicState-04502\", \"If the pipeline requires pre-rasterization shader state or fragment shader state and VK_DYNAMIC_STATE_FRAGMENT_SHADING_RATE_KHR is not included in pDynamicState->pDynamicStates, and the attachmentFragmentShadingRate feature is not enabled, VkPipelineFragmentShadingRateStateCreateInfoKHR::combinerOps[1] must be VK_FRAGMENT_SHADING_RATE_COMBINER_OP_KEEP_KHR\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (!enabled_features.attachmentFragmentShadingRate &&\n    skip |= LogError(\"VUID-VkGraphicsPipelineCreateInfo-pDynamicState-04502\", device,\n                     create_info_loc.pNext(Struct::VkPipelineFragmentShadingRateStateCreateInfoKHR, Field::combinerOps, 1),\n                     \"is %s, but the attachmentFragmentShadingRate feature was not enabled.\",\n                     string_VkFragmentShadingRateCombinerOpKHR(fragment_shading_rate_state.combinerOps[1]));\n"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkGraphicsPipelineCreateInfo-fragmentShadingRateNonTrivialCombinerOps-04506\", \"If the pipeline requires pre-rasterization shader state or fragment shader state, the fragmentShadingRateNonTrivialCombinerOps limit is not supported, and VK_DYNAMIC_STATE_FRAGMENT_SHADING_RATE_KHR is not included in pDynamicState->pDynamicStates, elements of VkPipelineFragmentShadingRateStateCreateInfoKHR::combinerOps must be VK_FRAGMENT_SHADING_RATE_COMBINER_OP_KEEP_KHR or VK_FRAGMENT_SHADING_RATE_COMBINER_OP_REPLACE_KHR\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (!phys_dev_ext_props.fragment_shading_rate_props.fragmentShadingRateNonTrivialCombinerOps &&\n    skip |= LogError(\"VUID-VkGraphicsPipelineCreateInfo-fragmentShadingRateNonTrivialCombinerOps-04506\", device,\n                     create_info_loc.pNext(Struct::VkPipelineFragmentShadingRateStateCreateInfoKHR, Field::combinerOps, 0),\n                     \"is %s, but the fragmentShadingRateNonTrivialCombinerOps feature is not enabled.\",\n                     string_VkFragmentShadingRateCombinerOpKHR(fragment_shading_rate_state.combinerOps[0]));\n"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkGraphicsPipelineCreateInfo-pDynamicState-06567\", \"If the pipeline requires pre-rasterization shader state or fragment shader state and VK_DYNAMIC_STATE_FRAGMENT_SHADING_RATE_KHR is not included in pDynamicState->pDynamicStates, VkPipelineFragmentShadingRateStateCreateInfoKHR::combinerOps[0] must be a valid VkFragmentShadingRateCombinerOpKHR value\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (!is_valid_enum_value(combiner_ops[0])) {\n    skip |= LogError(\"VUID-VkGraphicsPipelineCreateInfo-pDynamicState-06567\", device,\n                     create_info_loc.pNext(Struct::VkPipelineFragmentShadingRateStateCreateInfoKHR, Field::combinerOps, 0),\n                     \"(0x%\" PRIx32 \") is invalid.\", combiner_ops[0]);\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkGraphicsPipelineCreateInfo-pDynamicState-06568\", \"If the pipeline requires pre-rasterization shader state or fragment shader state and VK_DYNAMIC_STATE_FRAGMENT_SHADING_RATE_KHR is not included in pDynamicState->pDynamicStates, VkPipelineFragmentShadingRateStateCreateInfoKHR::combinerOps[1] must be a valid VkFragmentShadingRateCombinerOpKHR value\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (!is_valid_enum_value(combiner_ops[1])) {\n    skip |= LogError(\"VUID-VkGraphicsPipelineCreateInfo-pDynamicState-06568\", device,\n                     create_info_loc.pNext(Struct::VkPipelineFragmentShadingRateStateCreateInfoKHR, Field::combinerOps, 1),\n                     \"(0x%\" PRIx32 \") is invalid.\", combiner_ops[1]);\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkGraphicsPipelineCreateInfo-renderPass-06585\", \"If the pipeline requires fragment output interface state, renderPass is VK_NULL_HANDLE, and VkPipelineRenderingCreateInfo::depthAttachmentFormat is not VK_FORMAT_UNDEFINED, it must be a format with potential format features that include VK_FORMAT_FEATURE_DEPTH_STENCIL_ATTACHMENT_BIT\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if ((format_features & VK_FORMAT_FEATURE_2_DEPTH_STENCIL_ATTACHMENT_BIT) == 0) {\n    skip |= LogError(\"VUID-VkGraphicsPipelineCreateInfo-renderPass-06585\", device,\n                     create_info_loc.pNext(Struct::VkPipelineRenderingCreateInfo, Field::depthAttachmentFormat),\n                     \"(%s) potential format features are %s.\", string_VkFormat(rendering_struct->depthAttachmentFormat),\n                     string_VkFormatFeatureFlags2(format_features).c_str());\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkGraphicsPipelineCreateInfo-renderPass-06589\", \"If the pipeline requires fragment output interface state, renderPass is VK_NULL_HANDLE, VkPipelineRenderingCreateInfo::depthAttachmentFormat is not VK_FORMAT_UNDEFINED, and VkPipelineRenderingCreateInfo::stencilAttachmentFormat is not VK_FORMAT_UNDEFINED, depthAttachmentFormat must equal stencilAttachmentFormat\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if ((rendering_struct->depthAttachmentFormat != VK_FORMAT_UNDEFINED) &&\n    skip |= LogError(\"VUID-VkGraphicsPipelineCreateInfo-renderPass-06589\", device,\n                     create_info_loc.pNext(Struct::VkPipelineRenderingCreateInfo, Field::depthAttachmentFormat),\n                     \"(%s) is not equal to stencilAttachmentFormat (%s).\",\n                     string_VkFormat(rendering_struct->depthAttachmentFormat),\n                     string_VkFormat(rendering_struct->stencilAttachmentFormat));\n"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkGraphicsPipelineCreateInfo-multiview-06577\", \"If the multiview feature is not enabled, the pipeline requires pre-rasterization shader state, fragment shader state, or fragment output interface state, and renderPass is VK_NULL_HANDLE, VkPipelineRenderingCreateInfo::viewMask must be 0\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if ((enabled_features.multiview == VK_FALSE) && (rendering_struct->viewMask != 0)) {\n    skip |= LogError(\"VUID-VkGraphicsPipelineCreateInfo-multiview-06577\", device,\n                     create_info_loc.pNext(Struct::VkPipelineRenderingCreateInfo, Field::viewMask),\n                     \"is %\" PRIu32 \", but the multiview feature was not enabled.\", rendering_struct->viewMask);\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkGraphicsPipelineCreateInfo-renderPass-06578\", \"If the pipeline requires pre-rasterization shader state, fragment shader state, or fragment output interface state, and renderPass is VK_NULL_HANDLE, the index of the most significant bit in VkPipelineRenderingCreateInfo::viewMask must be less than maxMultiviewViewCount\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (MostSignificantBit(rendering_struct->viewMask) >= static_cast<int32_t>(phys_dev_props_core11.maxMultiviewViewCount)) {\n    skip |= LogError(\"VUID-VkGraphicsPipelineCreateInfo-renderPass-06578\", device,\n                     create_info_loc.pNext(Struct::VkPipelineRenderingCreateInfo, Field::viewMask),\n                     \"is 0x%\" PRIx32 \", but maxMultiviewViewCount is %\" PRIu32 \"\", rendering_struct->viewMask,\n                     phys_dev_props_core11.maxMultiviewViewCount);\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-vkCmdBindPipeline-commandBuffer-04808\", \"If commandBuffer is a secondary command buffer with VkCommandBufferInheritanceViewportScissorInfoNV::viewportScissor2D enabled and pipelineBindPoint is VK_PIPELINE_BIND_POINT_GRAPHICS, then the pipeline must have been created with VK_DYNAMIC_STATE_VIEWPORT_WITH_COUNT or VK_DYNAMIC_STATE_VIEWPORT, and VK_DYNAMIC_STATE_SCISSOR_WITH_COUNT or VK_DYNAMIC_STATE_SCISSOR enabled\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (!dyn_viewport || !dyn_scissor) {\n    const LogObjectList objlist(cb_state.Handle(), pipeline.Handle());\n    skip |= LogError(\"VUID-vkCmdBindPipeline-commandBuffer-04808\", objlist, loc,\n                     \"Graphics pipeline incompatible with viewport/scissor inheritance.\");\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkVertexInputBindingDivisorDescriptionKHR-binding-01869\", \"binding must be less than VkPhysicalDeviceLimits::maxVertexInputBindings\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (vibdd->binding >= device_limits->maxVertexInputBindings) {\n    skip |= LogError(\"VUID-VkVertexInputBindingDivisorDescriptionKHR-binding-01869\", device,\n                     divisor_loc.dot(Field::binding), \"(%\" PRIu32 \") exceeds device maxVertexInputBindings (%\" PRIu32 \").\",\n                     vibdd->binding, device_limits->maxVertexInputBindings);\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkVertexInputBindingDivisorDescriptionKHR-vertexAttributeInstanceRateDivisor-02229\", \"If the vertexAttributeInstanceRateDivisor feature is not enabled, divisor must be 1\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if ((1 != vibdd->divisor) && !enabled_features.vertexAttributeInstanceRateDivisor) {\n    skip |= LogError(\"VUID-VkVertexInputBindingDivisorDescriptionKHR-vertexAttributeInstanceRateDivisor-02229\", device,\n                     divisor_loc.dot(Field::divisor),\n                     \"is (%\" PRIu32 \") but vertexAttributeInstanceRateDivisor feature was not enabled.\", vibdd->divisor);\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkGraphicsPipelineCreateInfo-renderpass-06625\", \"If renderpass is VK_NULL_HANDLE, VkGraphicsPipelineLibraryCreateInfoEXT::flags includes at least one of and no more than two of VK_GRAPHICS_PIPELINE_LIBRARY_PRE_RASTERIZATION_SHADERS_BIT_EXT, VK_GRAPHICS_PIPELINE_LIBRARY_FRAGMENT_SHADER_BIT_EXT, or VK_GRAPHICS_PIPELINE_LIBRARY_FRAGMENT_OUTPUT_INTERFACE_BIT_EXT, and an element of VkPipelineLibraryCreateInfoKHR::pLibraries includes one of the other flags, the value of renderPass used to create that library must also be VK_NULL_HANDLE\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (lib->GraphicsCreateInfo().renderPass != VK_NULL_HANDLE) {\n    skip |= LogError(\"VUID-VkGraphicsPipelineCreateInfo-renderpass-06625\", device, loc.dot(Field::renderPass),\n                     \"is VK_NULL_HANDLE and includes \"\n                     \"VkGraphicsPipelineLibraryCreateInfoEXT::flags (%s), but pLibraries[%\" PRIu32\n                     \"] includes VkGraphicsPipelineLibraryCreateInfoEXT::flags (%s) and \"\n                     \"render pass is not VK_NULL_HANDLE.\",\n                     string_VkGraphicsPipelineLibraryFlagsEXT(lib_flags).c_str(), i,\n                     string_VkGraphicsPipelineLibraryFlagsEXT(lib->graphics_lib_type).c_str());\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-vkCreateGraphicsPipelines-flags-00720\", \"If the flags member of any element of pCreateInfos contains the VK_PIPELINE_CREATE_DERIVATIVE_BIT flag, and the basePipelineIndex member of that same element is not -1, basePipelineIndex must be less than the index into pCreateInfos that corresponds to that element\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (static_cast<uint32_t>(base_index) >= pipe_index) {\n    skip |= LogError(\"VUID-vkCreateGraphicsPipelines-flags-00720\", base_handle, loc,\n                     \"base pipeline (index %\" PRId32\n                     \") must occur earlier in array than derivative pipeline (index %\" PRIu32 \").\",\n                     base_index, pipe_index);\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-vkCreateGraphicsPipelines-flags-00721\", \"If the flags member of any element of pCreateInfos contains the VK_PIPELINE_CREATE_DERIVATIVE_BIT flag, the base pipeline must have been created with the VK_PIPELINE_CREATE_ALLOW_DERIVATIVES_BIT flag set\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (base_pipeline && !(base_pipeline->create_flags & VK_PIPELINE_CREATE_2_ALLOW_DERIVATIVES_BIT_KHR)) {\n    skip |= LogError(\"VUID-vkCreateGraphicsPipelines-flags-00721\", base_pipeline->Handle(), loc,\n                     \"base pipeline does not allow derivatives.\");\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkPipelineDiscardRectangleStateCreateInfoEXT-discardRectangleCount-00582\", \"discardRectangleCount must be less than or equal to VkPhysicalDeviceDiscardRectanglePropertiesEXT::maxDiscardRectangles\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (!pipeline.IsDynamic(CB_DYNAMIC_STATE_DISCARD_RECTANGLE_ENABLE_EXT) &&\n    discard_rectangle_state.discardRectangleCount > phys_dev_ext_props.discard_rectangle_props.maxDiscardRectangles) {\n    skip |= LogError(\"VUID-VkPipelineDiscardRectangleStateCreateInfoEXT-discardRectangleCount-00582\", device,\n                     create_info_loc.pNext(Struct::VkPipelineDiscardRectangleStateCreateInfoEXT, Field::discardRectangleCount),\n                     \"(%\" PRIu32 \") is not less than maxDiscardRectangles (%\" PRIu32 \").\",\n                     discard_rectangle_state.discardRectangleCount,\n                     phys_dev_ext_props.discard_rectangle_props.maxDiscardRectangles);\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkGraphicsPipelineCreateInfo-depthStencilAttachmentSamples-06593\", \"If the fragment output interface state and the depthStencilAttachmentSamples member of VkAttachmentSampleCountInfoAMD or VkAttachmentSampleCountInfoNV is not 0, it must be a valid VkSampleCountFlagBits value\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (pipeline.fragment_output_state && attachment_sample_count_info.depthStencilAttachmentSamples != 0 &&\n    ((attachment_sample_count_info.depthStencilAttachmentSamples & AllVkSampleCountFlagBits) == 0 || bits > 1)) {\n    skip |= LogError(\"VUID-VkGraphicsPipelineCreateInfo-depthStencilAttachmentSamples-06593\", device,\n                     create_info_loc.pNext(Struct::VkAttachmentSampleCountInfoAMD, Field::depthStencilAttachmentSamples),\n                     \"(0x%\" PRIx32 \") is invalid.\", attachment_sample_count_info.depthStencilAttachmentSamples);\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkRayTracingPipelineCreateInfoKHR-pLibraries-03591\", \"Each element of pLibraryInfo->pLibraries must have been created with the value of maxPipelineRayRecursionDepth equal to that in this pipeline\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (library_create_info.maxPipelineRayRecursionDepth != create_info.maxPipelineRayRecursionDepth) {\n    skip |= LogError(\"VUID-VkRayTracingPipelineCreateInfoKHR-pLibraries-03591\", device, library_loc,\n                     \"was created with maxPipelineRayRecursionDepth (%\" PRIu32 \") which is not equal %s (%\" PRIu32\n                     \") .\",\n                     library_create_info.maxPipelineRayRecursionDepth,\n                     create_info_loc.dot(Field::maxPipelineRayRecursionDepth).Fields().c_str(),\n                     create_info.maxPipelineRayRecursionDepth);\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkRayTracingPipelineCreateInfoKHR-pLibraryInfo-03593\", \"If pLibraryInfo is not NULL, each element of its pLibraries member must have been created with values of the maxPipelineRayPayloadSize and maxPipelineRayHitAttributeSize members of pLibraryInterface equal to those in this pipeline\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "skip |= LogError(\"VUID-VkRayTracingPipelineCreateInfoKHR-pLibraryInfo-03593\", device, library_loc,\n                 \"was created with maxPipelineRayPayloadSize (%\" PRIu32\n                 \") and \"\n                 \"maxPipelineRayHitAttributeSize (%\" PRIu32 \") which is not equal to %s values of (%\" PRIu32\n                 \") and (%\" PRIu32 \").\",\n                 library_create_info.pLibraryInterface->maxPipelineRayPayloadSize,\n                 library_create_info.pLibraryInterface->maxPipelineRayHitAttributeSize,\n                 create_info_loc.dot(Field::pLibraryInterface).Fields().c_str(),\n                 create_info.pLibraryInterface->maxPipelineRayPayloadSize,\n                 create_info.pLibraryInterface->maxPipelineRayHitAttributeSize);\n"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkRayTracingPipelineCreateInfoKHR-flags-06546\", \"flags must not include both VK_PIPELINE_CREATE_RAY_TRACING_SKIP_TRIANGLES_BIT_KHR and VK_PIPELINE_CREATE_RAY_TRACING_SKIP_AABBS_BIT_KHR\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if ((flags & VK_PIPELINE_CREATE_RAY_TRACING_SKIP_TRIANGLES_BIT_KHR) != 0 &&\n    (flags & VK_PIPELINE_CREATE_RAY_TRACING_SKIP_AABBS_BIT_KHR) != 0) {\n    skip |= LogError(\"VUID-VkRayTracingPipelineCreateInfoKHR-flags-06546\", device, create_info_loc.dot(Field::flags),\n                     \"is %s (contains both SKIP_TRIANGLES and SKIP_AABBS).\", string_VkPipelineCreateFlags(flags).c_str());\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkRayTracingShaderGroupCreateInfoKHR-type-03474\", \"If type is VK_RAY_TRACING_SHADER_GROUP_TYPE_GENERAL_KHR then generalShader must be a valid index into VkRayTracingPipelineCreateInfoKHR::pStages referring to a shader of VK_SHADER_STAGE_RAYGEN_BIT_KHR, VK_SHADER_STAGE_MISS_BIT_KHR, or VK_SHADER_STAGE_CALLABLE_BIT_KHR\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (!GroupHasValidIndex(\n    skip |= LogError(isKHR ? \"VUID-VkRayTracingShaderGroupCreateInfoKHR-type-03474\"\n                           : \"VUID-VkRayTracingShaderGroupCreateInfoNV-type-02413\",\n                     device, group_loc.dot(Field::generalShader), \"is %\" PRIu32 \".\", group.generalShader);\n"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkRayTracingShaderGroupCreateInfoKHR-type-03475\", \"If type is VK_RAY_TRACING_SHADER_GROUP_TYPE_GENERAL_KHR then closestHitShader, anyHitShader, and intersectionShader must be VK_SHADER_UNUSED_KHR\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (group.anyHitShader != VK_SHADER_UNUSED_NV || group.closestHitShader != VK_SHADER_UNUSED_NV ||\n    skip |= LogError(isKHR ? \"VUID-VkRayTracingShaderGroupCreateInfoKHR-type-03475\"\n                           : \"VUID-VkRayTracingShaderGroupCreateInfoNV-type-02414\",\n                     device, group_loc,\n                     \"anyHitShader is %\" PRIu32 \", closestHitShader is %\" PRIu32 \", intersectionShader is %\" PRIu32 \".\",\n                     group.anyHitShader, group.closestHitShader, group.intersectionShader);\n"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkRayTracingShaderGroupCreateInfoKHR-type-03476\", \"If type is VK_RAY_TRACING_SHADER_GROUP_TYPE_PROCEDURAL_HIT_GROUP_KHR then intersectionShader must be a valid index into VkRayTracingPipelineCreateInfoKHR::pStages referring to a shader of VK_SHADER_STAGE_INTERSECTION_BIT_KHR\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (!GroupHasValidIndex(pipeline, group.intersectionShader, VK_SHADER_STAGE_INTERSECTION_BIT_NV)) {\n    skip |= LogError(isKHR ? \"VUID-VkRayTracingShaderGroupCreateInfoKHR-type-03476\"\n                           : \"VUID-VkRayTracingShaderGroupCreateInfoNV-type-02415\",\n                     device, group_loc.dot(Field::intersectionShader), \"is %\" PRIu32 \".\", group.intersectionShader);\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkRayTracingShaderGroupCreateInfoKHR-anyHitShader-03479\", \"anyHitShader must be either VK_SHADER_UNUSED_KHR or a valid index into VkRayTracingPipelineCreateInfoKHR::pStages referring to a shader of VK_SHADER_STAGE_ANY_HIT_BIT_KHR\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (!GroupHasValidIndex(pipeline, group.anyHitShader, VK_SHADER_STAGE_ANY_HIT_BIT_KHR)) {\n    skip |= LogError(isKHR ? \"VUID-VkRayTracingShaderGroupCreateInfoKHR-anyHitShader-03479\"\n                           : \"VUID-VkRayTracingShaderGroupCreateInfoNV-anyHitShader-02418\",\n                     device, group_loc.dot(Field::anyHitShader), \"is %\" PRIu32 \".\", group.anyHitShader);\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkRayTracingShaderGroupCreateInfoKHR-closestHitShader-03478\", \"closestHitShader must be either VK_SHADER_UNUSED_KHR or a valid index into VkRayTracingPipelineCreateInfoKHR::pStages referring to a shader of VK_SHADER_STAGE_CLOSEST_HIT_BIT_KHR\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (!GroupHasValidIndex(pipeline, group.closestHitShader, VK_SHADER_STAGE_CLOSEST_HIT_BIT_KHR)) {\n    skip |= LogError(isKHR ? \"VUID-VkRayTracingShaderGroupCreateInfoKHR-closestHitShader-03478\"\n                           : \"VUID-VkRayTracingShaderGroupCreateInfoNV-closestHitShader-02417\",\n                     device, group_loc.dot(Field::closestHitShader), \"is %\" PRIu32 \".\", group.closestHitShader);\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkPipelineLibraryCreateInfoKHR-pLibraries-03381\", \"Each element of pLibraries must have been created with VK_PIPELINE_CREATE_LIBRARY_BIT_KHR\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if ((lib->create_flags & VK_PIPELINE_CREATE_LIBRARY_BIT_KHR) == 0) {\n    skip |= LogError(\"VUID-VkPipelineLibraryCreateInfoKHR-pLibraries-03381\", device, library_loc,\n                     \"was created with %s.\", string_VkPipelineCreateFlags2KHR(lib->create_flags).c_str());\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-vkDestroyQueryPool-queryPool-00793\", \"All submitted commands that refer to queryPool must have completed execution\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (!completed_by_get_results) {\n    skip |= ValidateObjectNotInUse(query_pool_state.get(), error_obj.location, \"VUID-vkDestroyQueryPool-queryPool-00793\");\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-vkGetQueryPoolResults-flags-00815\", \"If VK_QUERY_RESULT_64_BIT is set in flags then pData and stride must be multiples of 8\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (query_pool_state->create_info.queryType != VK_QUERY_TYPE_PERFORMANCE_QUERY_KHR) {\n    skip |= ValidateQueryPoolStride(\"VUID-vkGetQueryPoolResults-flags-02828\", \"VUID-vkGetQueryPoolResults-flags-00815\", stride,\n                                    Field::dataSize, dataSize, flags, device, error_obj.location.dot(Field::stride));\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-vkGetQueryPoolResults-flags-02828\", \"If VK_QUERY_RESULT_64_BIT is not set in flags and the queryType used to create queryPool was not VK_QUERY_TYPE_PERFORMANCE_QUERY_KHR, then pData and stride must be multiples of 4\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (query_pool_state->create_info.queryType != VK_QUERY_TYPE_PERFORMANCE_QUERY_KHR) {\n    skip |= ValidateQueryPoolStride(\"VUID-vkGetQueryPoolResults-flags-02828\", \"VUID-vkGetQueryPoolResults-flags-00815\", stride,\n                                    Field::dataSize, dataSize, flags, device, error_obj.location.dot(Field::stride));\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-vkGetQueryPoolResults-queryType-09439\", \"If the queryType used to create queryPool was VK_QUERY_TYPE_TIMESTAMP, flags must not contain VK_QUERY_RESULT_PARTIAL_BIT\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if ((query_pool_state->create_info.queryType == VK_QUERY_TYPE_TIMESTAMP) && (flags & VK_QUERY_RESULT_PARTIAL_BIT)) {\n    skip |= LogError(\"VUID-vkGetQueryPoolResults-queryType-09439\", queryPool, error_obj.location.dot(Field::flags),\n                     \"(%s) includes VK_QUERY_RESULT_PARTIAL_BIT, but queryPool (%s) was created with a queryType of \"\n                     \"VK_QUERY_TYPE_TIMESTAMP.\",\n                     string_VkQueryResultFlags(flags).c_str(), FormatHandle(queryPool).c_str());\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-vkGetQueryPoolResults-queryType-09442\", \"If the queryType used to create queryPool was VK_QUERY_TYPE_RESULT_STATUS_ONLY_KHR, then flags must include VK_QUERY_RESULT_WITH_STATUS_BIT_KHR\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (query_pool_state->create_info.queryType == VK_QUERY_TYPE_RESULT_STATUS_ONLY_KHR &&\n    (flags & VK_QUERY_RESULT_WITH_STATUS_BIT_KHR) == 0) {\n    skip |= LogError(\"VUID-vkGetQueryPoolResults-queryType-09442\", queryPool, error_obj.location.dot(Field::flags),\n                     \"(%s) doesn't have VK_QUERY_RESULT_WITH_STATUS_BIT_KHR, but queryPool %s was created with \"\n                     \"VK_QUERY_TYPE_RESULT_STATUS_ONLY_KHR \"\n                     \"queryType.\",\n                     string_VkQueryResultFlags(flags).c_str(), FormatHandle(queryPool).c_str());\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-vkGetQueryPoolResults-queryType-03229\", \"If the queryType used to create queryPool was VK_QUERY_TYPE_PERFORMANCE_QUERY_KHR, then pData and stride must be multiples of the size of VkPerformanceCounterResultKHR\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if ((((uintptr_t)pData) % sizeof(VkPerformanceCounterResultKHR)) != 0 ||\n    skip |= LogError(\"VUID-vkGetQueryPoolResults-queryType-03229\", queryPool, error_obj.location.dot(Field::queryPool),\n                     \"(%s) was created with a queryType of \"\n                     \"VK_QUERY_TYPE_PERFORMANCE_QUERY_KHR but pData & stride are not multiple of the \"\n                     \"size of VkPerformanceCounterResultKHR.\",\n                     FormatHandle(queryPool).c_str());\n"
        },
        {
            "role": "user",
            "content": "{\"VUID-vkGetQueryPoolResults-dataSize-00817\", \"dataSize must be large enough to contain the result of each query, as described here\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (query_size && (((queryCount - 1) * stride + query_size) > dataSize)) {\n    skip |= LogError(\"VUID-vkGetQueryPoolResults-dataSize-00817\", queryPool, error_obj.location.dot(Field::queryPool),\n                     \"(%s) specified dataSize %zu which is \"\n                     \"incompatible with the specified query type and options.\",\n                     FormatHandle(queryPool).c_str(), dataSize);\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkQueryPoolPerformanceCreateInfoKHR-queueFamilyIndex-03236\", \"queueFamilyIndex must be a valid queue family index of the device\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (perf_counter_iter == physical_device_state->perf_counters.end()) {\n    skip |= LogError(\"VUID-VkQueryPoolPerformanceCreateInfoKHR-queueFamilyIndex-03236\", device,\n                     create_info_loc.pNext(Struct::VkQueryPoolPerformanceCreateInfoKHR, Field::queueFamilyIndex),\n                     \"(%\" PRIu32 \") is not a valid queue family index.\", perf_ci->queueFamilyIndex);\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkQueryPoolCreateInfo-queryType-07133\", \"If queryType is VK_QUERY_TYPE_VIDEO_ENCODE_FEEDBACK_KHR, then the pNext chain must include a VkVideoProfileInfoKHR structure with videoCodecOperation specifying an encode operation\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (video_profile == nullptr) {\n    skip |= LogError(\"VUID-VkQueryPoolCreateInfo-queryType-07133\", device, create_info_loc.dot(Field::queryType),\n                     pnext_chain_msg, \"VkVideoProfileInfoKHR\");\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkQueryPoolCreateInfo-queryType-07906\", \"If queryType is VK_QUERY_TYPE_VIDEO_ENCODE_FEEDBACK_KHR, then the pNext chain must include a VkQueryPoolVideoEncodeFeedbackCreateInfoKHR structure\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (encode_feedback_info == nullptr) {\n    skip |= LogError(\"VUID-VkQueryPoolCreateInfo-queryType-07906\", device, create_info_loc.dot(Field::queryType),\n                     pnext_chain_msg, \"VkQueryPoolVideoEncodeFeedbackCreateInfoKHR\");\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-vkCmdBeginQueryIndexedEXT-queryType-07071\", \"The queryType used to create queryPool must not be VK_QUERY_TYPE_MESH_PRIMITIVES_GENERATED_EXT\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (is_indexed) {\n    const LogObjectList objlist(cb_state.Handle(), query_obj.pool);\n    skip |= LogError(\"VUID-vkCmdBeginQueryIndexedEXT-queryType-07071\", objlist, loc.dot(Field::queryPool),\n                     \"(%s) was created with queryType %s.\", FormatHandle(query_obj.pool).c_str(),\n                     string_VkQueryType(query_pool_ci.queryType));\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-vkCmdBeginQuery-queryType-07070\", \"If the queryType used to create queryPool was VK_QUERY_TYPE_MESH_PRIMITIVES_GENERATED_EXT the VkCommandPool that commandBuffer was allocated from must support graphics operations\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "string_VkQueryType(query_pool_ci.queryType));\nconst LogObjectList objlist(cb_state.Handle(), cb_state.command_pool->Handle());\nskip |= LogError(\"VUID-vkCmdBeginQuery-queryType-07070\", objlist, loc, \"%s\",\nDescribeRequiredQueueFlag(cb_state, *physical_device_state, VK_QUEUE_GRAPHICS_BIT).c_str());\n"
        },
        {
            "role": "user",
            "content": "{\"VUID-vkCmdBeginQuery-queryType-06688\", \"If the queryType used to create queryPool was VK_QUERY_TYPE_PRIMITIVES_GENERATED_EXT then primitivesGeneratedQuery must be enabled\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (!enabled_features.primitivesGeneratedQuery) {\n    const LogObjectList objlist(commandBuffer, queryPool);\n    skip |= LogError(\"VUID-vkCmdBeginQuery-queryType-06688\", objlist, error_obj.location.dot(Field::queryPool),\n                     \"was created with a queryType VK_QUERY_TYPE_PRIMITIVES_GENERATED_EXT, but \"\n                     \"primitivesGeneratedQuery feature was not enabled.\");\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-vkQueueSubmit-pCommandBuffers-03220\", \"If a command recorded into any element of pCommandBuffers was a vkCmdBeginQuery whose queryPool was created with a queryType of VK_QUERY_TYPE_PERFORMANCE_QUERY_KHR, the profiling lock must have been held continuously on the VkDevice that queue was retrieved from, throughout recording of those command buffers\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (!cb_state.performance_lock_acquired || cb_state.performance_lock_released) {\n    const LogObjectList objlist(cb_state.Handle(), query_obj.pool);\n    skip |= state_data.LogError(\"VUID-vkQueueSubmit-pCommandBuffers-03220\", objlist, loc,\n                                \"Commandbuffer %s was submitted and contains a performance query but the\"\n                                \"profiling lock was not held continuously throughout the recording of commands.\",\n                                state_data.FormatHandle(cb_state).c_str());\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-vkCmdEndQuery-queryPool-03227\", \"If queryPool was created with a queryType of VK_QUERY_TYPE_PERFORMANCE_QUERY_KHR and one or more of the counters used to create queryPool was VK_PERFORMANCE_COUNTER_SCOPE_COMMAND_BUFFER_KHR, the vkCmdEndQuery must be the last recorded command in commandBuffer\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (query_pool_state->has_perf_scope_command_buffer && (cb_state_arg.command_count - 1) != query_obj.end_command_index) {\n    const LogObjectList objlist(cb_state_arg.Handle(), query_pool_state->Handle());\n    const Location loc(command);\n    skip |= LogError(\"VUID-vkCmdEndQuery-queryPool-03227\", objlist, loc,\n                     \"Query pool %s was created with a counter of scope \"\n                     \"VK_QUERY_SCOPE_COMMAND_BUFFER_KHR but the end of the query is not the last \"\n                     \"command in the command buffer %s.\",\n                     FormatHandle(query_obj.pool).c_str(), FormatHandle(cb_state_arg).c_str());\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-vkCmdEndQuery-queryPool-03228\", \"If queryPool was created with a queryType of VK_QUERY_TYPE_PERFORMANCE_QUERY_KHR and one or more of the counters used to create queryPool was VK_PERFORMANCE_COUNTER_SCOPE_RENDER_PASS_KHR, the vkCmdEndQuery must not be recorded within a render pass instance\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (query_pool_state->has_perf_scope_render_pass && cb_state.activeRenderPass) {\n    const LogObjectList objlist(cb_state.Handle(), queryPool);\n    skip |= LogError(\"VUID-vkCmdEndQuery-queryPool-03228\", objlist, loc,\n                     \"Query pool %s was created with a counter of scope \"\n                     \"VK_QUERY_SCOPE_RENDER_PASS_KHR but %s is inside a render pass.\",\n                     FormatHandle(queryPool).c_str(), loc.StringFunc());\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-vkCmdEndQuery-query-00810\", \"query must be less than the number of queries in queryPool\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (slot >= available_query_count) {\n    const LogObjectList objlist(commandBuffer, queryPool);\n    skip |= LogError(\"VUID-vkCmdEndQuery-query-00810\", objlist, error_obj.location.dot(Field::query),\n                     \"(%u) is greater or equal to the queryPool size (%u).\", slot, available_query_count);\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-vkCmdCopyQueryPoolResults-dstOffset-00819\", \"dstOffset must be less than the size of dstBuffer\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (dstOffset >= dst_buff_state->requirements.size) {\n    skip |= LogError(\"VUID-vkCmdCopyQueryPoolResults-dstOffset-00819\", buffer_objlist, error_obj.location.dot(Field::dstOffset),\n                     \"(%\" PRIu64 \") is not less than the size (%\" PRIu64 \") of buffer (%s).\", dstOffset,\n                     dst_buff_state->requirements.size, FormatHandle(dst_buff_state->Handle()).c_str());\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-vkCmdCopyQueryPoolResults-dstBuffer-00824\", \"dstBuffer must have enough storage, from dstOffset, to contain the result of each query, as described here\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "skip |= LogError(\"VUID-vkCmdCopyQueryPoolResults-dstBuffer-00824\", buffer_objlist, error_obj.location,\n                 \"storage required (%\" PRIu64\n                 \") equal to dstOffset + (queryCount * stride) is greater than the size (%\" PRIu64 \") of buffer (%s).\",\n                 dstOffset + (queryCount * stride), dst_buff_state->requirements.size,\n                 FormatHandle(dst_buff_state->Handle()).c_str());\n"
        },
        {
            "role": "user",
            "content": "{\"VUID-vkCmdCopyQueryPoolResults-flags-09443\", \"If flags includes VK_QUERY_RESULT_WITH_STATUS_BIT_KHR, then it must not include VK_QUERY_RESULT_WITH_AVAILABILITY_BIT\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if ((flags & VK_QUERY_RESULT_WITH_STATUS_BIT_KHR) && (flags & VK_QUERY_RESULT_WITH_AVAILABILITY_BIT)) {\n    skip |= LogError(\"VUID-vkCmdCopyQueryPoolResults-flags-09443\", commandBuffer, error_obj.location.dot(Field::flags),\n                     \"(%s) include both STATUS_BIT and AVAILABILITY_BIT.\", string_VkQueryResultFlags(flags).c_str());\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-vkCmdCopyQueryPoolResults-queryCount-09438\", \"If queryCount is greater than 1, stride must not be zero\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (queryCount > 1 && stride == 0) {\n    const LogObjectList objlist(commandBuffer, queryPool);\n    skip |= LogError(\"VUID-vkCmdCopyQueryPoolResults-queryCount-09438\", objlist, error_obj.location.dot(Field::queryCount),\n                     \"is %\" PRIu32 \" but stride is zero.\", queryCount);\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-vkCmdCopyQueryPoolResults-queryType-09439\", \"If the queryType used to create queryPool was VK_QUERY_TYPE_TIMESTAMP, flags must not contain VK_QUERY_RESULT_PARTIAL_BIT\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if ((query_pool_state->create_info.queryType == VK_QUERY_TYPE_TIMESTAMP) && ((flags & VK_QUERY_RESULT_PARTIAL_BIT) != 0)) {\n    const LogObjectList objlist(commandBuffer, queryPool);\n    skip |= LogError(\"VUID-vkCmdCopyQueryPoolResults-queryType-09439\", objlist, error_obj.location.dot(Field::flags),\n                     \"(%s) includes VK_QUERY_RESULT_PARTIAL_BIT, but %s was created with VK_QUERY_TYPE_TIMESTAMP.\",\n                     string_VkQueryResultFlags(flags).c_str(), FormatHandle(queryPool).c_str());\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-vkCmdCopyQueryPoolResults-queryType-02734\", \"vkCmdCopyQueryPoolResults must not be called if the queryType used to create queryPool was VK_QUERY_TYPE_PERFORMANCE_QUERY_INTEL\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (query_pool_state->create_info.queryType == VK_QUERY_TYPE_PERFORMANCE_QUERY_INTEL) {\n    const LogObjectList objlist(commandBuffer, queryPool);\n    skip |= LogError(\"VUID-vkCmdCopyQueryPoolResults-queryType-02734\", objlist, error_obj.location.dot(Field::queryPool),\n                     \"(%s) was created with queryType VK_QUERY_TYPE_PERFORMANCE_QUERY_INTEL.\", FormatHandle(queryPool).c_str());\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-vkCmdCopyQueryPoolResults-queryType-09442\", \"If the queryType used to create queryPool was VK_QUERY_TYPE_RESULT_STATUS_ONLY_KHR, then flags must include VK_QUERY_RESULT_WITH_STATUS_BIT_KHR\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (query_pool_state->create_info.queryType == VK_QUERY_TYPE_RESULT_STATUS_ONLY_KHR &&\n    (flags & VK_QUERY_RESULT_WITH_STATUS_BIT_KHR) == 0) {\n    const LogObjectList objlist(commandBuffer, queryPool);\n    skip |= LogError(\"VUID-vkCmdCopyQueryPoolResults-queryType-09442\", objlist, error_obj.location.dot(Field::flags),\n                     \"(%s) does not include VK_QUERY_RESULT_WITH_STATUS_BIT_KHR, but %s was created with queryType \"\n                     \"VK_QUERY_TYPE_RESULT_STATUS_ONLY_KHR.\",\n                     string_VkQueryResultFlags(flags).c_str(), FormatHandle(queryPool).c_str());\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-vkCmdCopyQueryPoolResults-None-08752\", \"All queries used by the command must have been made available by prior executed commands\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (result_type != QUERYRESULT_SOME_DATA && result_type != QUERYRESULT_UNKNOWN) {\n    const LogObjectList objlist(cb_state_arg.Handle(), queryPool);\n    skip |= state_data.LogError(\"VUID-vkCmdCopyQueryPoolResults-None-08752\", objlist, record_obj.location,\n                                \"Requesting a copy from query to buffer on %s query %\" PRIu32 \": %s\",\n                                state_data.FormatHandle(queryPool).c_str(), firstQuery + i,\n                                string_QueryResultType(result_type));\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-vkCmdWriteTimestamp2-stage-03859\", \"stage must only include a single pipeline stage\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if ((stage & (stage - 1)) != 0) {\n    skip |= LogError(\"VUID-vkCmdWriteTimestamp2-stage-03859\", commandBuffer, stage_loc,\n                     \"(%s) must only set a single pipeline stage.\", string_VkPipelineStageFlags2(stage).c_str());\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-vkCmdBeginQueryIndexedEXT-queryType-06693\", \"If the queryType used to create queryPool was VK_QUERY_TYPE_PRIMITIVES_GENERATED_EXT then primitivesGeneratedQuery must be enabled\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (!enabled_features.primitivesGeneratedQuery) {\n    const LogObjectList objlist(commandBuffer, queryPool);\n    skip |= LogError(\"VUID-vkCmdBeginQueryIndexedEXT-queryType-06693\", objlist, error_obj.location.dot(Field::queryPool),\n                     \"was created with queryType of VK_QUERY_TYPE_PRIMITIVES_GENERATED_EXT, \"\n                     \"but the primitivesGeneratedQuery feature is not enabled.\");\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-vkCmdBeginQueryIndexedEXT-queryType-06690\", \"If the queryType used to create queryPool was VK_QUERY_TYPE_PRIMITIVES_GENERATED_EXT the index parameter must be less than VkPhysicalDeviceTransformFeedbackPropertiesEXT::maxTransformFeedbackStreams\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (index >= phys_dev_ext_props.transform_feedback_props.maxTransformFeedbackStreams) {\n    const LogObjectList objlist(commandBuffer, queryPool);\n    skip |= LogError(\"VUID-vkCmdBeginQueryIndexedEXT-queryType-06690\", objlist, error_obj.location.dot(Field::queryPool),\n                     \"was created with queryType of VK_QUERY_TYPE_PRIMITIVES_GENERATED_EXT, but \"\n                     \"index (%\" PRIu32\n                     \") is greater than or equal to \"\n                     \"VkPhysicalDeviceTransformFeedbackPropertiesEXT::maxTransformFeedbackStreams (%\" PRIu32 \")\",\n                     index, phys_dev_ext_props.transform_feedback_props.maxTransformFeedbackStreams);\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-vkCmdBeginQueryIndexedEXT-queryType-06691\", \"If the queryType used to create queryPool was VK_QUERY_TYPE_PRIMITIVES_GENERATED_EXT and the primitivesGeneratedQueryWithNonZeroStreams feature is not enabled, the index parameter must be zero\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if ((index != 0) && (!enabled_features.primitivesGeneratedQueryWithNonZeroStreams)) {\n    const LogObjectList objlist(commandBuffer, queryPool);\n    skip |= LogError(\"VUID-vkCmdBeginQueryIndexedEXT-queryType-06691\", objlist, error_obj.location.dot(Field::queryPool),\n                     \"was created with queryType of VK_QUERY_TYPE_PRIMITIVES_GENERATED_EXT, but \"\n                     \"index (%\" PRIu32\n                     \") is not zero and the primitivesGeneratedQueryWithNonZeroStreams feature is not enabled\",\n                     index);\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-vkCmdEndQueryIndexedEXT-query-02343\", \"query must be less than the number of queries in queryPool\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (slot >= available_query_count) {\n    const LogObjectList objlist(commandBuffer, queryPool);\n    skip |= LogError(\"VUID-vkCmdEndQueryIndexedEXT-query-02343\", objlist, error_obj.location.dot(Field::index),\n                     \"(%\" PRIu32 \") is greater or equal to the queryPool size (%\" PRIu32 \").\", index, available_query_count);\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-vkCmdEndQueryIndexedEXT-queryType-06694\", \"If the queryType used to create queryPool was VK_QUERY_TYPE_TRANSFORM_FEEDBACK_STREAM_EXT or VK_QUERY_TYPE_PRIMITIVES_GENERATED_EXT, the index parameter must be less than VkPhysicalDeviceTransformFeedbackPropertiesEXT::maxTransformFeedbackStreams\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (index >= phys_dev_ext_props.transform_feedback_props.maxTransformFeedbackStreams) {\n    skip |= LogError(\"VUID-vkCmdEndQueryIndexedEXT-queryType-06694\", commandBuffer, error_obj.location.dot(Field::index),\n                     \"(%\" PRIu32\n                     \") must be less than \"\n                     \"VkPhysicalDeviceTransformFeedbackPropertiesEXT::maxTransformFeedbackStreams %\" PRIu32 \".\",\n                     index, phys_dev_ext_props.transform_feedback_props.maxTransformFeedbackStreams);\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-vkCmdEndQueryIndexedEXT-queryType-06696\", \"If the queryType used to create queryPool was VK_QUERY_TYPE_TRANSFORM_FEEDBACK_STREAM_EXT or VK_QUERY_TYPE_PRIMITIVES_GENERATED_EXT, index must equal the index used to begin the query\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (query_object.index != index) {\n    const LogObjectList objlist(commandBuffer, queryPool);\n    skip |= LogError(\"VUID-vkCmdEndQueryIndexedEXT-queryType-06696\", objlist, error_obj.location,\n                     \"queryPool is of type %s, but \"\n                     \"index (%\" PRIu32 \") is not equal to the index used to begin the query (%\" PRIu32 \")\",\n                     string_VkQueryType(query_pool_ci.queryType), index, query_object.index);\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-vkCmdEndQueryIndexedEXT-queryType-06695\", \"If the queryType used to create queryPool was not VK_QUERY_TYPE_TRANSFORM_FEEDBACK_STREAM_EXT and not VK_QUERY_TYPE_PRIMITIVES_GENERATED_EXT, the index must be zero\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "} else if (index != 0) {\n    const LogObjectList objlist(commandBuffer, queryPool);\n    skip |= LogError(\"VUID-vkCmdEndQueryIndexedEXT-queryType-06695\", objlist, error_obj.location.dot(Field::index),\n                     \"(%\" PRIu32\n                     \") must be zero if %s was not created with type VK_QUERY_TYPE_TRANSFORM_FEEDBACK_STREAM_EXT and not\"\n                     \" VK_QUERY_TYPE_PRIMITIVES_GENERATED_EXT.\",\n                     index, FormatHandle(queryPool).c_str());\n"
        },
        {
            "role": "user",
            "content": "{\"VUID-vkResetQueryPool-firstQuery-09436\", \"firstQuery must be less than the number of queries in queryPool\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (firstQuery >= query_pool_state->create_info.queryCount) {\n    skip |= LogError(\"VUID-vkResetQueryPool-firstQuery-09436\", queryPool, error_obj.location.dot(Field::firstQuery),\n                     \"(%\" PRIu32 \") is greater than or equal to query pool count (%\" PRIu32 \") for %s.\", firstQuery,\n                     query_pool_state->create_info.queryCount, FormatHandle(queryPool).c_str());\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-vkResetQueryPool-firstQuery-09437\", \"The sum of firstQuery and queryCount must be less than or equal to the number of queries in queryPool\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if ((firstQuery + queryCount) > query_pool_state->create_info.queryCount) {\n    skip |= LogError(\"VUID-vkResetQueryPool-firstQuery-09437\", queryPool, error_obj.location,\n                     \"Query range [%\" PRIu32 \", %\" PRIu32 \") goes beyond query pool count (%\" PRIu32 \") for %s.\", firstQuery,\n                     firstQuery + queryCount, query_pool_state->create_info.queryCount, FormatHandle(queryPool).c_str());\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-vkReleaseProfilingLockKHR-device-03235\", \"The profiling lock of device must have been held via a previous successful call to vkAcquireProfilingLockKHR\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (!performance_lock_acquired) {\n    skip |= LogError(\"VUID-vkReleaseProfilingLockKHR-device-03235\", device, error_obj.location,\n                     \"The profiling lock of device must have been held via a previous successful \"\n                     \"call to vkAcquireProfilingLockKHR.\");\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-vkCmdEndDebugUtilsLabelEXT-commandBuffer-01912\", \"There must be an outstanding vkCmdBeginDebugUtilsLabelEXT command prior to the vkCmdEndDebugUtilsLabelEXT on the queue that commandBuffer is submitted to\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "skip |= core.LogError(\"VUID-vkCmdEndDebugUtilsLabelEXT-commandBuffer-01912\", cb_state.Handle(), loc,\n                      \"(%s) contains vkCmdEndDebugUtilsLabelEXT that does not have a matching \"\n                      \"vkCmdBeginDebugUtilsLabelEXT in this or one of the previously submitted command buffers. %s\",\n                      core.FormatHandle(cb_state).c_str(), previous_debug_region.c_str());\n"
        },
        {
            "role": "user",
            "content": "{\"VUID-vkQueueSubmit-fence-00064\", \"If fence is not VK_NULL_HANDLE, fence must not be associated with any other queue command that has not yet completed execution on that queue\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (auto fence_state = Get<vvl::Fence>(fence)) {\n    const LogObjectList objlist(queue, fence);\n    skip |= ValidateFenceForSubmit(*fence_state, \"VUID-vkQueueSubmit-fence-00064\", \"VUID-vkQueueSubmit-fence-00063\", objlist,\n                                   error_obj.location);\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkSubmitInfo-pCommandBuffers-06016\", \"If pCommandBuffers contains any suspended render pass instances, there must be no render pass instances between that render pass instance and the render pass instance that resumes it\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (suspended_render_pass_instance && cb_state->hasRenderPassInstance && !cb_state->resumesRenderPassInstance) {\n    skip |= LogError(\"VUID-VkSubmitInfo-pCommandBuffers-06016\", queue, submit_loc,\n                     \"has a suspended render pass instance, but pCommandBuffers[%\" PRIu32\n                     \"] has its own render pass instance that does not resume it.\",\n                     i);\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkSubmitInfo-pCommandBuffers-06014\", \"If pCommandBuffers contains any suspended render pass instances, they must be resumed by a render pass instance later in submission order within pCommandBuffers\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (suspended_render_pass_instance) {\n    skip |= LogError(\"VUID-VkSubmitInfo-pCommandBuffers-06014\", queue, submit_loc,\n                     \"has a suspended render pass instance that was not resumed.\");\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkDeviceGroupSubmitInfo-signalSemaphoreCount-00084\", \"signalSemaphoreCount must equal VkSubmitInfo::signalSemaphoreCount\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (chained_device_group_struct->signalSemaphoreCount != submit.signalSemaphoreCount) {\n    skip |= LogError(\"VUID-VkDeviceGroupSubmitInfo-signalSemaphoreCount-00084\", queue,\n                     submit_loc.pNext(Struct::VkDeviceGroupSubmitInfo, Field::signalSemaphoreCount),\n                     \"(%\" PRIu32 \") is different than signalSemaphoreCount (%\" PRIu32 \").\",\n                     chained_device_group_struct->signalSemaphoreCount, submit.signalSemaphoreCount);\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkDeviceGroupSubmitInfo-commandBufferCount-00083\", \"commandBufferCount must equal VkSubmitInfo::commandBufferCount\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (chained_device_group_struct->commandBufferCount != submit.commandBufferCount) {\n    skip |= LogError(\"VUID-VkDeviceGroupSubmitInfo-commandBufferCount-00083\", queue,\n                     submit_loc.pNext(Struct::VkDeviceGroupSubmitInfo, Field::commandBufferCount),\n                     \"(%\" PRIu32 \") is different than commandBufferCount (%\" PRIu32 \").\",\n                     chained_device_group_struct->commandBufferCount, submit.commandBufferCount);\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-vkQueueSubmit-queue-06448\", \"If queue was not created with VK_DEVICE_QUEUE_CREATE_PROTECTED_BIT, there must be no element of pSubmits that includes a VkProtectedSubmitInfo structure in its pNext chain with protectedSubmit equal to VK_TRUE\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if ((protected_submit == true) && ((queue_state->create_flags & VK_DEVICE_QUEUE_CREATE_PROTECTED_BIT) == 0)) {\n    skip |= LogError(\"VUID-vkQueueSubmit-queue-06448\", queue, submit_loc,\n                     \"contains a protected submission to %s which was not created with \"\n                     \"VK_DEVICE_QUEUE_CREATE_PROTECTED_BIT\",\n                     FormatHandle(queue).c_str());\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkSubmitInfo-pNext-04148\", \"If the pNext chain of this structure includes a VkProtectedSubmitInfo structure with protectedSubmit set to VK_TRUE, then each element of the pCommandBuffers array must be a protected command buffer\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if ((cb_state->unprotected == true) && (protected_submit == true)) {\n    const LogObjectList objlist(cb_state->Handle(), queue);\n    skip |= LogError(\"VUID-VkSubmitInfo-pNext-04148\", objlist, cb_loc,\n                     \"(%s) is unprotected while queue %s pSubmits[%u] has \"\n                     \"VkProtectedSubmitInfo:protectedSubmit set to VK_TRUE\",\n                     FormatHandle(cb_state->Handle()).c_str(), FormatHandle(queue).c_str(), submit_idx);\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkSubmitInfo-pNext-04120\", \"If the pNext chain of this structure does not include a VkProtectedSubmitInfo structure with protectedSubmit set to VK_TRUE, then each element of the pCommandBuffers array must be an unprotected command buffer\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if ((cb_state->unprotected == false) && (protected_submit == false)) {\n    const LogObjectList objlist(cb_state->Handle(), queue);\n    skip |= LogError(\"VUID-VkSubmitInfo-pNext-04120\", objlist, cb_loc,\n                     \"(%s) is protected while queue %s pSubmits[%u] has %s\",\n                     FormatHandle(cb_state->Handle()).c_str(), FormatHandle(queue).c_str(), submit_idx,\n                     protected_submit_info ? \"VkProtectedSubmitInfo:protectedSubmit set to VK_FALSE\"\n                                           : \"no VkProtectedSubmitInfo in the pNext chain\");\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkCommandBufferSubmitInfo-pNext-09446\", \"If a VkRenderPassStripeSubmitInfoARM is included in the pNext chain, the value of VkRenderPassStripeSubmitInfoARM::stripeSemaphoreInfoCount must be equal to the sum of the VkRenderPassStripeBeginInfoARM::stripeInfoCount parameters provided to render pass instances recorded in commandBuffer that did not specify the VK_RENDERING_RESUMING_BIT flag\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (rp_submit_info->stripeSemaphoreInfoCount != cb_state.striped_count && !cb_state.resumesRenderPassInstance) {\n    skip |= LogError(\"VUID-VkCommandBufferSubmitInfo-pNext-09446\", objlist,\n                     loc.pNext(Struct::VkRenderPassStripeSubmitInfoARM, Field::stripeSemaphoreInfoCount),\n                     \"= %\" PRIu32 \" must be equal to  VkRenderPassStripeBeginInfoARM::stripeInfoCount = %\" PRIu32 \".\",\n                     rp_submit_info->stripeSemaphoreInfoCount, cb_state.striped_count);\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkRenderPassStripeSubmitInfoARM-semaphore-09447\", \"The semaphore member of each element of pStripeSemaphoreInfos must have been created with a VkSemaphoreType of VK_SEMAPHORE_TYPE_BINARY\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (semaphore_state->type != VK_SEMAPHORE_TYPE_BINARY) {\n    objlist.add(semaphore);\n    skip |= LogError(\"VUID-VkRenderPassStripeSubmitInfoARM-semaphore-09447\", objlist,\n                     loc.pNext(Struct::VkRenderPassStripeSubmitInfoARM, Field::pStripeSemaphoreInfos, count),\n                     \"is not a VK_SEMAPHORE_TYPE_BINARY.\");\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-vkQueueSubmit2-fence-04894\", \"If fence is not VK_NULL_HANDLE, fence must be unsignaled\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (auto fence_state = Get<vvl::Fence>(fence)) {\n    const LogObjectList objlist(queue, fence);\n    skip |= ValidateFenceForSubmit(*fence_state, \"VUID-vkQueueSubmit2-fence-04895\", \"VUID-vkQueueSubmit2-fence-04894\", objlist,\n                                   error_obj.location);\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-vkQueueSubmit2-fence-04895\", \"If fence is not VK_NULL_HANDLE, fence must not be associated with any other queue command that has not yet completed execution on that queue\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (auto fence_state = Get<vvl::Fence>(fence)) {\n    const LogObjectList objlist(queue, fence);\n    skip |= ValidateFenceForSubmit(*fence_state, \"VUID-vkQueueSubmit2-fence-04895\", \"VUID-vkQueueSubmit2-fence-04894\", objlist,\n                                   error_obj.location);\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-vkQueueSubmit2-queue-06447\", \"If queue was not created with VK_DEVICE_QUEUE_CREATE_PROTECTED_BIT, the flags member of any element of pSubmits must not include VK_SUBMIT_PROTECTED_BIT_KHR\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if ((protected_submit == true) && ((queue_state->create_flags & VK_DEVICE_QUEUE_CREATE_PROTECTED_BIT)) == 0) {\n    skip |= LogError(\"VUID-vkQueueSubmit2-queue-06447\", queue, submit_loc,\n                     \"contains a protected submission to %s which was not created with \"\n                     \"VK_DEVICE_QUEUE_CREATE_PROTECTED_BIT\",\n                     FormatHandle(queue).c_str());\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkSubmitInfo2-flags-03886\", \"If flags includes VK_SUBMIT_PROTECTED_BIT, all elements of pCommandBuffers must be protected command buffers\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if ((cb_state->unprotected == true) && (protected_submit == true)) {\n    const LogObjectList objlist(cb_state->Handle(), queue);\n    skip |= LogError(\"VUID-VkSubmitInfo2-flags-03886\", objlist, info_loc.dot(Field::commandBuffer),\n                     \"is unprotected while %s.flags (%s) has VK_SUBMIT_PROTECTED_BIT_KHR set\",\n                     submit_loc.Fields().c_str(), string_VkSubmitFlags(submit.flags).c_str());\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkSubmitInfo2-flags-03887\", \"If flags does not include VK_SUBMIT_PROTECTED_BIT, each element of pCommandBuffers must not be a protected command buffer\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if ((cb_state->unprotected == false) && (protected_submit == false)) {\n    const LogObjectList objlist(cb_state->Handle(), queue);\n    skip |= LogError(\"VUID-VkSubmitInfo2-flags-03887\", objlist, info_loc.dot(Field::commandBuffer),\n                     \"is protected while %s.flags (%s) has VK_SUBMIT_PROTECTED_BIT_KHR not set\",\n                     submit_loc.Fields().c_str(), string_VkSubmitFlags(submit.flags).c_str());\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkSubmitInfo2KHR-commandBuffer-06012\", \"If any commandBuffer member of an element of pCommandBufferInfos contains any suspended render pass instances, there must be no render pass instances between that render pass instance and the render pass instance that resumes it\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (suspended_render_pass_instance && cb_state->hasRenderPassInstance && !cb_state->resumesRenderPassInstance) {\n    skip |= LogError(\"VUID-VkSubmitInfo2KHR-commandBuffer-06012\", queue, submit_loc,\n                     \"has a suspended render pass instance, but pCommandBuffers[%\" PRIu32\n                     \"] has its own render pass instance that does not resume it.\",\n                     i);\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkSubmitInfo2KHR-commandBuffer-06010\", \"If any commandBuffer member of an element of pCommandBufferInfos contains any suspended render pass instances, they must be resumed by a render pass instance later in submission order within pCommandBufferInfos\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (suspended_render_pass_instance) {\n    skip |= LogError(\"VUID-VkSubmitInfo2KHR-commandBuffer-06010\", queue, submit_loc,\n                     \"has a suspended render pass instance that was not resumed.\");\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-vkQueueSubmit-pSubmits-04626\", \"Any resource created with VK_SHARING_MODE_CONCURRENT that is accessed by an operation specified by pSubmits must have included the queue family of queue at resource creation time\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (!found) {\n    const LogObjectList objlist(cb_state.Handle(), object);\n    skip |= LogError(\"VUID-vkQueueSubmit-pSubmits-04626\", objlist, loc,\n                     \"%s contains %s which was not created allowing concurrent access to \"\n                     \"this queue family %d.\",\n                     FormatHandle(cb_state).c_str(), FormatHandle(object).c_str(), queueFamilyIndex);\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-vkQueueBindSparse-fence-01113\", \"If fence is not VK_NULL_HANDLE, fence must be unsignaled\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (auto fence_state = Get<vvl::Fence>(fence)) {\n    const LogObjectList objlist(queue, fence);\n    skip |= ValidateFenceForSubmit(*fence_state, \"VUID-vkQueueBindSparse-fence-01114\", \"VUID-vkQueueBindSparse-fence-01113\",\n                                   objlist, error_obj.location);\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-vkQueueBindSparse-fence-01114\", \"If fence is not VK_NULL_HANDLE, fence must not be associated with any other queue command that has not yet completed execution on that queue\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (auto fence_state = Get<vvl::Fence>(fence)) {\n    const LogObjectList objlist(queue, fence);\n    skip |= ValidateFenceForSubmit(*fence_state, \"VUID-vkQueueBindSparse-fence-01114\", \"VUID-vkQueueBindSparse-fence-01113\",\n                                   objlist, error_obj.location);\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkAccelerationStructureCreateInfoKHR-buffer-03614\", \"buffer must have been created with a usage value containing VK_BUFFER_USAGE_ACCELERATION_STRUCTURE_STORAGE_BIT_KHR\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (!(buffer_state->usage & VK_BUFFER_USAGE_ACCELERATION_STRUCTURE_STORAGE_BIT_KHR)) {\n    skip |= LogError(\"VUID-VkAccelerationStructureCreateInfoKHR-buffer-03614\", buffer_state->Handle(),\n                     error_obj.location.dot(Field::pCreateInfo).dot(Field::buffer), \"was created with %s.\",\n                     string_VkBufferUsageFlags2KHR(buffer_state->usage).c_str());\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkAccelerationStructureCreateInfoKHR-buffer-03615\", \"buffer must not have been created with VK_BUFFER_CREATE_SPARSE_RESIDENCY_BIT\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (buffer_state->create_info.flags & VK_BUFFER_CREATE_SPARSE_RESIDENCY_BIT) {\n    skip |= LogError(\"VUID-VkAccelerationStructureCreateInfoKHR-buffer-03615\", buffer_state->Handle(),\n                     error_obj.location.dot(Field::pCreateInfo).dot(Field::buffer), \"was created with %s.\",\n                     string_VkBufferCreateFlags(buffer_state->create_info.flags).c_str());\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkAccelerationStructureCreateInfoKHR-offset-03616\", \"The sum of offset and size must be less than the size of buffer\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (pCreateInfo->offset + pCreateInfo->size > buffer_state->create_info.size) {\n    skip |= LogError(\"VUID-VkAccelerationStructureCreateInfoKHR-offset-03616\", buffer_state->Handle(),\n                     error_obj.location.dot(Field::pCreateInfo).dot(Field::offset),\n                     \"(%\" PRIu64 \") plus size (%\" PRIu64 \") must be less than the size of buffer (%\" PRIu64 \").\",\n                     pCreateInfo->offset, pCreateInfo->size, buffer_state->create_info.size);\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkBindAccelerationStructureMemoryInfoNV-accelerationStructure-03620\", \"accelerationStructure must not already be backed by a memory object\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (as_state->HasFullRangeBound()) {\n    skip |= LogError(\"VUID-VkBindAccelerationStructureMemoryInfoNV-accelerationStructure-03620\", info.accelerationStructure,\n                     bind_info_loc.dot(Field::accelerationStructure), \"must not already be backed by a memory object.\");\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkBindAccelerationStructureMemoryInfoNV-size-03624\", \"The size member of the VkMemoryRequirements structure returned from a call to vkGetAccelerationStructureMemoryRequirementsNV with accelerationStructure and type of VK_ACCELERATION_STRUCTURE_MEMORY_REQUIREMENTS_TYPE_OBJECT_NV must be less than or equal to the size of memory minus memoryOffset\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (as_state->memory_requirements.size > (mem_info->allocate_info.allocationSize - info.memoryOffset)) {\n    skip |= LogError(\"VUID-VkBindAccelerationStructureMemoryInfoNV-size-03624\", info.accelerationStructure,\n                     bind_info_loc.dot(Field::memory),\n                     \"'s size (%\" PRIu64 \") minus %s (%\" PRIu64 \") is %\" PRIu64\n                     \", but the size member of the VkMemoryRequirements structure returned from a call to \"\n                     \"vkGetAccelerationStructureMemoryRequirementsNV with accelerationStructure %s and type of \"\n                     \"VK_ACCELERATION_STRUCTURE_MEMORY_REQUIREMENTS_TYPE_OBJECT_NV is %\" PRIu64 \".\",\n                     as_state->memory_requirements.size, bind_info_loc.dot(Field::memoryOffset).Fields().c_str(),\n                     info.memoryOffset, mem_info->allocate_info.allocationSize - info.memoryOffset,\n                     FormatHandle(info.accelerationStructure).c_str(), as_state->memory_requirements.size);\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-vkGetAccelerationStructureDeviceAddressKHR-accelerationStructure-08935\", \"The VkPhysicalDeviceAccelerationStructureFeaturesKHR::accelerationStructure feature must be enabled\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (!enabled_features.accelerationStructure) {\n    skip |= LogError(\"VUID-vkGetAccelerationStructureDeviceAddressKHR-accelerationStructure-08935\", device, error_obj.location,\n                     \"accelerationStructure feature was not enabled.\");\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-vkGetAccelerationStructureDeviceAddressKHR-device-03504\", \"If device was created with multiple physical devices, then the bufferDeviceAddressMultiDevice feature must be enabled\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (physical_device_count > 1 && !enabled_features.bufferDeviceAddressMultiDevice &&\n    skip |= LogError(\"VUID-vkGetAccelerationStructureDeviceAddressKHR-device-03504\", device, error_obj.location,\n                     \"bufferDeviceAddressMultiDevice feature was not enabled.\");\n"
        },
        {
            "role": "user",
            "content": "{\"VUID-vkGetAccelerationStructureDeviceAddressKHR-pInfo-09542\", \"The buffer on which pInfo->accelerationStructure was placed must have been created with the VK_BUFFER_USAGE_SHADER_DEVICE_ADDRESS_BIT usage flag\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (!(accel_struct->buffer_state->usage & VK_BUFFER_USAGE_SHADER_DEVICE_ADDRESS_BIT)) {\n    skip |= LogError(\"VUID-vkGetAccelerationStructureDeviceAddressKHR-pInfo-09542\", LogObjectList(device),\n                     info_loc.dot(Field::accelerationStructure).dot(Field::buffer), \"was created with usage flag(s) %s.\",\n                     string_VkBufferUsageFlags2KHR(accel_struct->buffer_state->usage).c_str());\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-vkCmdBuildAccelerationStructuresKHR-pInfos-03806\", \"For any element of pInfos[i].pGeometries or pInfos[i].ppGeometries with a geometryType of VK_GEOMETRY_TYPE_TRIANGLES_KHR, if geometry.triangles.indexType is not VK_INDEX_TYPE_NONE_KHR, geometry.triangles.indexData.deviceAddress must be a valid device address obtained from vkGetBufferDeviceAddress\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (index_buffer_states.empty() && geometry_build_ranges[geom_i].primitiveCount > 0) {\n    skip |= LogError(pick_vuid(\"VUID-vkCmdBuildAccelerationStructuresKHR-pInfos-03806\",\n                               \"VUID-vkCmdBuildAccelerationStructuresIndirectKHR-pInfos-03806\"),\n                     cmd_buffer, p_geom_geom_triangles_loc.dot(Field::indexData).dot(Field::deviceAddress),\n                     \"(0x%\" PRIx64 \") is not an address belonging to an existing buffer. %s is %s.\",\n                     geom_data.geometry.triangles.indexData.deviceAddress,\n                     p_geom_geom_triangles_loc.dot(Field::indexType).Fields().c_str(),\n                     string_VkIndexType(geom_data.geometry.triangles.indexType));\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-vkCmdBuildAccelerationStructuresKHR-primitiveCount-03769\", \"For each element of pInfos, if its mode member is VK_BUILD_ACCELERATION_STRUCTURE_MODE_UPDATE_KHR, then for each VkAccelerationStructureGeometryKHR structure referred to by its pGeometries or ppGeometries members, the primitiveCount member of its corresponding VkAccelerationStructureBuildRangeInfoKHR structure must have the same value which was specified when srcAccelerationStructure was last built\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "src_as_state->build_range_infos[geom_i].primitiveCount;\nrecorded_primitive_count != geometry_build_ranges[geom_i].primitiveCount) {\nconst LogObjectList objlist(cmd_buffer, info.srcAccelerationStructure);\nskip |= LogError(\"VUID-vkCmdBuildAccelerationStructuresKHR-primitiveCount-03769\", objlist,\n             p_geom_loc,\n             \" has corresponding VkAccelerationStructureBuildRangeInfoKHR %s[%\" PRIu32\n             \"], but this build range has its primitiveCount member set to (%\" PRIu32\n             \") when it was last specified as (%\" PRIu32 \").\",\n             pp_build_range_info_loc.Fields().c_str(), geom_i,\n             geometry_build_ranges[geom_i].primitiveCount, recorded_primitive_count);\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-vkCmdBuildAccelerationStructuresKHR-primitiveCount-03769\", \"For each element of pInfos, if its mode member is VK_BUILD_ACCELERATION_STRUCTURE_MODE_UPDATE_KHR, then for each VkAccelerationStructureGeometryKHR structure referred to by its pGeometries or ppGeometries members, the primitiveCount member of its corresponding VkAccelerationStructureBuildRangeInfoKHR structure must have the same value which was specified when srcAccelerationStructure was last built\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (const uint32_t recorded_primitive_count = src_as_state->build_range_infos[geom_i].primitiveCount;\n    recorded_primitive_count != ppBuildRangeInfos[info_i][geom_i].primitiveCount) {\n    const LogObjectList objlist(info->srcAccelerationStructure);\n    skip |= LogError(\"VUID-vkCmdBuildAccelerationStructuresKHR-primitiveCount-03769\", objlist, geometry_loc,\n                     \" has corresponding VkAccelerationStructureBuildRangeInfoKHR %s[%\" PRIu32\n                     \"], but this build range has its primitiveCount member set to (%\" PRIu32\n                     \") when it was last specified as (%\" PRIu32 \").\",\n                     error_obj.location.dot(Field::ppBuildRangeInfos, info_i).Fields().c_str(), geom_i,\n                     ppBuildRangeInfos[info_i][geom_i].primitiveCount, recorded_primitive_count);\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkAccelerationStructureGeometryTrianglesDataKHR-vertexFormat-03797\", \"The format features of vertexFormat must contain VK_FORMAT_FEATURE_ACCELERATION_STRUCTURE_VERTEX_BUFFER_BIT_KHR\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (!(format_properties.bufferFeatures & VK_FORMAT_FEATURE_ACCELERATION_STRUCTURE_VERTEX_BUFFER_BIT_KHR)) {\n    skip |= LogError(\"VUID-VkAccelerationStructureGeometryTrianglesDataKHR-vertexFormat-03797\", cmd_buffer,\n                     p_geom_geom_triangles_loc.dot(Field::vertexFormat),\n                     \"is %s which doesn't support VK_FORMAT_FEATURE_ACCELERATION_STRUCTURE_VERTEX_BUFFER_BIT_KHR.\\n\"\n                     \"(supported bufferFeatures: %s)\",\n                     string_VkFormat(geom_data.geometry.triangles.vertexFormat),\n                     string_VkFormatFeatureFlags2(format_properties.bufferFeatures).c_str());\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkAccelerationStructureGeometryTrianglesDataKHR-vertexStride-03735\", \"vertexStride must be a multiple of the size in bytes of the smallest component of vertexFormat\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (SafeModulo(geom_data.geometry.triangles.vertexStride, min_component_byte_size) != 0) {\n    skip |= LogError(\"VUID-VkAccelerationStructureGeometryTrianglesDataKHR-vertexStride-03735\", cmd_buffer,\n                     p_geom_geom_triangles_loc.dot(Field::vertexStride),\n                     \"is %\" PRIu64 \" and is not aligned to the minimum component byte size (%\" PRIu32\n                     \") of its corresponding vertex \"\n                     \"format (%s).\",\n                     geom_data.geometry.triangles.vertexStride, min_component_byte_size,\n                     string_VkFormat(geom_data.geometry.triangles.vertexFormat));\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-vkCmdBuildAccelerationStructuresKHR-pInfos-03808\", \"For any element of pInfos[i].pGeometries or pInfos[i].ppGeometries with a geometryType of VK_GEOMETRY_TYPE_TRIANGLES_KHR, if geometry.triangles.transformData.deviceAddress is not 0, it must be a valid device address obtained from vkGetBufferDeviceAddress\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (tranform_buffer_states.empty() && geometry_build_ranges[geom_i].primitiveCount > 0) {\n    skip |= LogError(pick_vuid(\"VUID-vkCmdBuildAccelerationStructuresKHR-pInfos-03808\",\n                               \"VUID-vkCmdBuildAccelerationStructuresIndirectKHR-pInfos-03808\"),\n                     cmd_buffer, p_geom_geom_triangles_loc.dot(Field::transformData).dot(Field::deviceAddress),\n                     \"(0x%\" PRIx64 \") is not an address belonging to an existing buffer.\",\n                     geom_data.geometry.triangles.transformData.deviceAddress);\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-vkCmdBuildAccelerationStructuresKHR-pInfos-03813\", \"For any element of pInfos[i].pGeometries or pInfos[i].ppGeometries with a geometryType of VK_GEOMETRY_TYPE_INSTANCES_KHR, geometry.instances.data.deviceAddress must be a valid device address obtained from vkGetBufferDeviceAddress\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (buffer_states.empty() && geometry_build_ranges[geom_i].primitiveCount > 0) {\n    skip |= LogError(pick_vuid(\"VUID-vkCmdBuildAccelerationStructuresKHR-pInfos-03813\",\n                               \"VUID-vkCmdBuildAccelerationStructuresIndirectKHR-pInfos-03813\"),\n                     cmd_buffer, instances_data_loc.dot(Field::deviceAddress),\n                     \"(%\" PRIu64 \") is not an address belonging to an existing buffer.\",\n                     geom_data.geometry.instances.data.deviceAddress);\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-vkCmdBuildAccelerationStructuresKHR-pInfos-03811\", \"For any element of pInfos[i].pGeometries or pInfos[i].ppGeometries with a geometryType of VK_GEOMETRY_TYPE_AABBS_KHR, geometry.aabbs.data.deviceAddress must be a valid device address obtained from vkGetBufferDeviceAddress\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (aabb_buffer_states.empty() && geometry_build_ranges[geom_i].primitiveCount > 0) {\n    skip |= LogError(pick_vuid(\"VUID-vkCmdBuildAccelerationStructuresKHR-pInfos-03811\",\n                               \"VUID-vkCmdBuildAccelerationStructuresIndirectKHR-pInfos-03811\"),\n                     cmd_buffer, p_geom_geom_loc.dot(Field::aabbs).dot(Field::data).dot(Field::deviceAddress),\n                     \"(0x%\" PRIx64 \") is not an address belonging to an existing buffer.\",\n                     geom_data.geometry.aabbs.data.deviceAddress);\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-vkCmdBuildAccelerationStructuresKHR-pInfos-03708\", \"For each element of pInfos, if its mode member is VK_BUILD_ACCELERATION_STRUCTURE_MODE_UPDATE_KHR the buffer used to create its srcAccelerationStructure member must be bound to device memory\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (!src_as_state->buffer_state) {\n    const LogObjectList objlist(device, commandBuffer, info->srcAccelerationStructure);\n    skip |= LogError(\"VUID-vkCmdBuildAccelerationStructuresKHR-pInfos-03708\", objlist, info_loc.dot(Field::mode),\n                     \"is VK_BUILD_ACCELERATION_STRUCTURE_MODE_UPDATE_KHR but the buffer associated with \"\n                     \"srcAccelerationStructure is not valid.\");\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-vkBuildAccelerationStructuresKHR-pInfos-03700\", \"For each element of pInfos, if its type member is VK_ACCELERATION_STRUCTURE_TYPE_BOTTOM_LEVEL_KHR, its dstAccelerationStructure member must have been created with a value of VkAccelerationStructureCreateInfoKHR::type equal to either VK_ACCELERATION_STRUCTURE_TYPE_BOTTOM_LEVEL_KHR or VK_ACCELERATION_STRUCTURE_TYPE_GENERIC_KHR\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (dst_as_state->create_info.type != VK_ACCELERATION_STRUCTURE_TYPE_BOTTOM_LEVEL_KHR &&\n    skip |= LogError(\"VUID-vkBuildAccelerationStructuresKHR-pInfos-03700\", info->dstAccelerationStructure,\n                     info_loc.dot(Field::type),\n                     \"is VK_ACCELERATION_STRUCTURE_TYPE_BOTTOM_LEVEL_KHR, but its dstAccelerationStructure was \"\n                     \"built with type %s.\",\n                     string_VkAccelerationStructureTypeKHR(dst_as_state->create_info.type));\n"
        },
        {
            "role": "user",
            "content": "{\"VUID-vkCmdBuildAccelerationStructuresIndirectKHR-commandBuffer-09547\", \"commandBuffer must not be a protected command buffer\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (!cb_state->unprotected) {\n    skip |= LogError(\"VUID-vkCmdBuildAccelerationStructuresIndirectKHR-commandBuffer-09547\", commandBuffer, error_obj.location,\n                     \"called in a protected command buffer.\");\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-vkCmdBuildAccelerationStructuresIndirectKHR-pInfos-03700\", \"For each element of pInfos, if its type member is VK_ACCELERATION_STRUCTURE_TYPE_BOTTOM_LEVEL_KHR, its dstAccelerationStructure member must have been created with a value of VkAccelerationStructureCreateInfoKHR::type equal to either VK_ACCELERATION_STRUCTURE_TYPE_BOTTOM_LEVEL_KHR or VK_ACCELERATION_STRUCTURE_TYPE_GENERIC_KHR\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (dst_as_state->create_info.type != VK_ACCELERATION_STRUCTURE_TYPE_BOTTOM_LEVEL_KHR &&\n    skip |= LogError(\"VUID-vkCmdBuildAccelerationStructuresIndirectKHR-pInfos-03700\",\n                     info->dstAccelerationStructure, info_loc.dot(Field::type),\n                     \"is VK_ACCELERATION_STRUCTURE_TYPE_BOTTOM_LEVEL_KHR, but its dstAccelerationStructure was \"\n                     \"built with type %s.\",\n                     string_VkAccelerationStructureTypeKHR(dst_as_state->create_info.type));\n"
        },
        {
            "role": "user",
            "content": "{\"VUID-vkCmdBuildAccelerationStructureNV-geometryCount-02241\", \"geometryCount must be less than or equal to VkPhysicalDeviceRayTracingPropertiesNV::maxGeometryCount\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (info.geometryCount > phys_dev_ext_props.ray_tracing_props_nv.maxGeometryCount) {\n    skip |= LogError(is_cmd ? \"VUID-vkCmdBuildAccelerationStructureNV-geometryCount-02241\"\n                            : \"VUID-VkAccelerationStructureInfoNV-geometryCount-02422\",\n                     object_handle, loc,\n                     \"geometryCount must be less than or equal to \"\n                     \"VkPhysicalDeviceRayTracingPropertiesNV::maxGeometryCount.\");\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-vkCmdBuildAccelerationStructureNV-dst-02488\", \"dst must have been created with compatible VkAccelerationStructureInfoNV where VkAccelerationStructureInfoNV::type and VkAccelerationStructureInfoNV::flags are identical, VkAccelerationStructureInfoNV::instanceCount and VkAccelerationStructureInfoNV::geometryCount for dst are greater than or equal to the build size and each geometry in VkAccelerationStructureInfoNV::pGeometries for dst has greater than or equal to the number of vertices, indices, and AABBs\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (dst_as_state->create_info.info.type != pInfo->type) {\n    skip |= LogError(\"VUID-vkCmdBuildAccelerationStructureNV-dst-02488\", commandBuffer, error_obj.location,\n                     \"create info VkAccelerationStructureInfoNV::type\"\n                     \"[%s] must be identical to build info VkAccelerationStructureInfoNV::type [%s].\",\n                     string_VkAccelerationStructureTypeKHR(dst_as_state->create_info.info.type),\n                     string_VkAccelerationStructureTypeKHR(pInfo->type));\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-vkCmdBuildAccelerationStructureNV-dst-02488\", \"dst must have been created with compatible VkAccelerationStructureInfoNV where VkAccelerationStructureInfoNV::type and VkAccelerationStructureInfoNV::flags are identical, VkAccelerationStructureInfoNV::instanceCount and VkAccelerationStructureInfoNV::geometryCount for dst are greater than or equal to the build size and each geometry in VkAccelerationStructureInfoNV::pGeometries for dst has greater than or equal to the number of vertices, indices, and AABBs\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (dst_as_state->create_info.info.flags != pInfo->flags) {\n    skip |= LogError(\"VUID-vkCmdBuildAccelerationStructureNV-dst-02488\", commandBuffer, error_obj.location,\n                     \"create info VkAccelerationStructureInfoNV::flags\"\n                     \"[%s] must be identical to build info VkAccelerationStructureInfoNV::flags [%s].\",\n                     string_VkBuildAccelerationStructureFlagsKHR(dst_as_state->create_info.info.flags).c_str(),\n                     string_VkBuildAccelerationStructureFlagsKHR(pInfo->flags).c_str());\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-vkCmdBuildAccelerationStructureNV-dst-02488\", \"dst must have been created with compatible VkAccelerationStructureInfoNV where VkAccelerationStructureInfoNV::type and VkAccelerationStructureInfoNV::flags are identical, VkAccelerationStructureInfoNV::instanceCount and VkAccelerationStructureInfoNV::geometryCount for dst are greater than or equal to the build size and each geometry in VkAccelerationStructureInfoNV::pGeometries for dst has greater than or equal to the number of vertices, indices, and AABBs\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (dst_as_state->create_info.info.instanceCount < pInfo->instanceCount) {\n    skip |= LogError(\"VUID-vkCmdBuildAccelerationStructureNV-dst-02488\", commandBuffer, error_obj.location,\n                     \"create info VkAccelerationStructureInfoNV::instanceCount \"\n                     \"[%\" PRIu32\n                     \"] must be greater than or equal to build info VkAccelerationStructureInfoNV::instanceCount [%\" PRIu32\n                     \"].\",\n                     dst_as_state->create_info.info.instanceCount, pInfo->instanceCount);\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-vkCmdBuildAccelerationStructureNV-dst-02488\", \"dst must have been created with compatible VkAccelerationStructureInfoNV where VkAccelerationStructureInfoNV::type and VkAccelerationStructureInfoNV::flags are identical, VkAccelerationStructureInfoNV::instanceCount and VkAccelerationStructureInfoNV::geometryCount for dst are greater than or equal to the build size and each geometry in VkAccelerationStructureInfoNV::pGeometries for dst has greater than or equal to the number of vertices, indices, and AABBs\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (create_geometry_data.triangles.vertexCount < build_geometry_data.triangles.vertexCount) {\n    skip |= LogError(\"VUID-vkCmdBuildAccelerationStructureNV-dst-02488\", commandBuffer, error_obj.location,\n                     \"create info pGeometries[%\" PRIu32 \"].geometry.triangles.vertexCount [%\" PRIu32\n                     \"]\"\n                     \"must be greater than or equal to build info pGeometries[%\" PRIu32\n                     \"].geometry.triangles.vertexCount [%\" PRIu32 \"].\",\n                     i, create_geometry_data.triangles.vertexCount, i, build_geometry_data.triangles.vertexCount);\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-vkCmdBuildAccelerationStructureNV-dst-02488\", \"dst must have been created with compatible VkAccelerationStructureInfoNV where VkAccelerationStructureInfoNV::type and VkAccelerationStructureInfoNV::flags are identical, VkAccelerationStructureInfoNV::instanceCount and VkAccelerationStructureInfoNV::geometryCount for dst are greater than or equal to the build size and each geometry in VkAccelerationStructureInfoNV::pGeometries for dst has greater than or equal to the number of vertices, indices, and AABBs\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (create_geometry_data.triangles.indexCount < build_geometry_data.triangles.indexCount) {\n    skip |= LogError(\"VUID-vkCmdBuildAccelerationStructureNV-dst-02488\", commandBuffer, error_obj.location,\n                     \"create info pGeometries[%\" PRIu32 \"].geometry.triangles.indexCount [%\" PRIu32\n                     \"]\"\n                     \"must be greater than or equal to build info pGeometries[%\" PRIu32\n                     \"].geometry.triangles.indexCount [%\" PRIu32 \"].\",\n                     i, create_geometry_data.triangles.indexCount, i, build_geometry_data.triangles.indexCount);\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-vkCmdBuildAccelerationStructureNV-dst-02488\", \"dst must have been created with compatible VkAccelerationStructureInfoNV where VkAccelerationStructureInfoNV::type and VkAccelerationStructureInfoNV::flags are identical, VkAccelerationStructureInfoNV::instanceCount and VkAccelerationStructureInfoNV::geometryCount for dst are greater than or equal to the build size and each geometry in VkAccelerationStructureInfoNV::pGeometries for dst has greater than or equal to the number of vertices, indices, and AABBs\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (create_geometry_data.aabbs.numAABBs < build_geometry_data.aabbs.numAABBs) {\n    skip |= LogError(\"VUID-vkCmdBuildAccelerationStructureNV-dst-02488\", commandBuffer, error_obj.location,\n                     \"create info pGeometries[%\" PRIu32 \"].geometry.aabbs.numAABBs [%\" PRIu32\n                     \"]\"\n                     \"must be greater than or equal to build info pGeometries[%\" PRIu32\n                     \"].geometry.aabbs.numAABBs [%\" PRIu32 \"].\",\n                     i, create_geometry_data.aabbs.numAABBs, i, build_geometry_data.aabbs.numAABBs);\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-vkCmdBuildAccelerationStructureNV-update-02489\", \"If update is VK_TRUE, src must not be VK_NULL_HANDLE\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (src == VK_NULL_HANDLE) {\n    skip |= LogError(\"VUID-vkCmdBuildAccelerationStructureNV-update-02489\", commandBuffer, error_obj.location,\n                     \"If update is VK_TRUE, src must not be VK_NULL_HANDLE.\");\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-vkCmdBuildAccelerationStructureNV-update-02492\", \"If update is VK_TRUE, the size member of the VkMemoryRequirements structure returned from a call to vkGetAccelerationStructureMemoryRequirementsNV with VkAccelerationStructureMemoryRequirementsInfoNV::accelerationStructure set to dst and VkAccelerationStructureMemoryRequirementsInfoNV::type set to VK_ACCELERATION_STRUCTURE_MEMORY_REQUIREMENTS_TYPE_UPDATE_SCRATCH_NV must be less than or equal to the size of scratch minus scratchOffset\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (scratch_buffer_state && dst_as_state &&\n    skip |= LogError(\"VUID-vkCmdBuildAccelerationStructureNV-update-02492\", commandBuffer, error_obj.location,\n                     \"If update is VK_TRUE, The size member of the \"\n                     \"VkMemoryRequirements structure returned from a call to \"\n                     \"vkGetAccelerationStructureMemoryRequirementsNV with \"\n                     \"VkAccelerationStructureMemoryRequirementsInfoNV::accelerationStructure set to dst and \"\n                     \"VkAccelerationStructureMemoryRequirementsInfoNV::type set to \"\n                     \"VK_ACCELERATION_STRUCTURE_MEMORY_REQUIREMENTS_TYPE_UPDATE_SCRATCH_NV must be less than \"\n                     \"or equal to the size of scratch minus scratchOffset\");\n"
        },
        {
            "role": "user",
            "content": "{\"VUID-vkCmdBuildAccelerationStructureNV-update-02491\", \"If update is VK_FALSE, the size member of the VkMemoryRequirements structure returned from a call to vkGetAccelerationStructureMemoryRequirementsNV with VkAccelerationStructureMemoryRequirementsInfoNV::accelerationStructure set to dst and VkAccelerationStructureMemoryRequirementsInfoNV::type set to VK_ACCELERATION_STRUCTURE_MEMORY_REQUIREMENTS_TYPE_BUILD_SCRATCH_NV must be less than or equal to the size of scratch minus scratchOffset\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (scratch_buffer_state && dst_as_state &&\n    skip |= LogError(\"VUID-vkCmdBuildAccelerationStructureNV-update-02491\", commandBuffer, error_obj.location,\n                     \"If update is VK_FALSE, The size member of the \"\n                     \"VkMemoryRequirements structure returned from a call to \"\n                     \"vkGetAccelerationStructureMemoryRequirementsNV with \"\n                     \"VkAccelerationStructureMemoryRequirementsInfoNV::accelerationStructure set to dst and \"\n                     \"VkAccelerationStructureMemoryRequirementsInfoNV::type set to \"\n                     \"VK_ACCELERATION_STRUCTURE_MEMORY_REQUIREMENTS_TYPE_BUILD_SCRATCH_NV must be less than \"\n                     \"or equal to the size of scratch minus scratchOffset\");\n"
        },
        {
            "role": "user",
            "content": "{\"VUID-vkCmdCopyAccelerationStructureNV-src-04963\", \"The source acceleration structure src must have been constructed prior to the execution of this command\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (!src_as_state->built) {\n    skip |= LogError(\"VUID-vkCmdCopyAccelerationStructureNV-src-04963\", commandBuffer, error_obj.location,\n                     \"The source acceleration structure src has not yet been built.\");\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-vkCmdCopyAccelerationStructureNV-src-03411\", \"If mode is VK_COPY_ACCELERATION_STRUCTURE_MODE_COMPACT_KHR, src must have been constructed with VK_BUILD_ACCELERATION_STRUCTURE_ALLOW_COMPACTION_BIT_KHR in the build\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (src_as_state &&\n    skip |= LogError(\"VUID-vkCmdCopyAccelerationStructureNV-src-03411\", commandBuffer, error_obj.location,\n                     \"src must have been built with \"\n                     \"VK_BUILD_ACCELERATION_STRUCTURE_ALLOW_COMPACTION_BIT_NV if mode is \"\n                     \"VK_COPY_ACCELERATION_STRUCTURE_MODE_COMPACT_NV.\");\n"
        },
        {
            "role": "user",
            "content": "{\"VUID-vkWriteAccelerationStructuresPropertiesKHR-pAccelerationStructures-04964\", \"All acceleration structures in pAccelerationStructures must have been built prior to the execution of this command\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (!as_state->built) {\n    skip |= LogError(\"VUID-vkWriteAccelerationStructuresPropertiesKHR-pAccelerationStructures-04964\", device, as_loc,\n                     \"has not been built.\");\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-vkWriteAccelerationStructuresPropertiesKHR-accelerationStructures-03431\", \"All acceleration structures in pAccelerationStructures must have been built with VK_BUILD_ACCELERATION_STRUCTURE_ALLOW_COMPACTION_BIT_KHR if queryType is VK_QUERY_TYPE_ACCELERATION_STRUCTURE_COMPACTED_SIZE_KHR\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (!(as_info.flags & VK_BUILD_ACCELERATION_STRUCTURE_ALLOW_COMPACTION_BIT_KHR)) {\n    const LogObjectList objlist(device, pAccelerationStructures[i]);\n    skip |= LogError(\"VUID-vkWriteAccelerationStructuresPropertiesKHR-accelerationStructures-03431\", objlist,\n                     as_loc, \"has flags %s.\", string_VkBuildAccelerationStructureFlagsKHR(as_info.flags).c_str());\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-vkCmdWriteAccelerationStructuresPropertiesKHR-queryPool-02493\", \"queryPool must have been created with a queryType matching queryType\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (query_pool_ci.queryType != queryType) {\n    skip |= LogError(\"VUID-vkCmdWriteAccelerationStructuresPropertiesKHR-queryPool-02493\", commandBuffer,\n                     error_obj.location.dot(Field::queryType),\n                     \"was created with %s which is different from the type queryPool was created with (%s).\",\n                     string_VkQueryType(queryType), string_VkQueryType(query_pool_ci.queryType));\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-vkCmdWriteAccelerationStructuresPropertiesKHR-pAccelerationStructures-04964\", \"All acceleration structures in pAccelerationStructures must have been built prior to the execution of this command\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (!as_state->built) {\n    skip |= LogError(\"VUID-vkCmdWriteAccelerationStructuresPropertiesKHR-pAccelerationStructures-04964\", commandBuffer,\n                     as_loc, \"has not been built.\");\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-vkCmdWriteAccelerationStructuresPropertiesNV-queryPool-03755\", \"queryPool must have been created with a queryType matching queryType\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (query_pool_ci.queryType != queryType) {\n    skip |= LogError(\"VUID-vkCmdWriteAccelerationStructuresPropertiesNV-queryPool-03755\", commandBuffer,\n                     error_obj.location.dot(Field::queryType),\n                     \"was created with %s which is differnent from the type queryPool was created with %s.\",\n                     string_VkQueryType(queryType), string_VkQueryType(query_pool_ci.queryType));\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-vkCmdWriteAccelerationStructuresPropertiesNV-pAccelerationStructures-06215\", \"All acceleration structures in pAccelerationStructures must have been built with VK_BUILD_ACCELERATION_STRUCTURE_ALLOW_COMPACTION_BIT_KHR if queryType is VK_QUERY_TYPE_ACCELERATION_STRUCTURE_COMPACTED_SIZE_NV\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (!(as_state->build_info.flags & VK_BUILD_ACCELERATION_STRUCTURE_ALLOW_COMPACTION_BIT_KHR)) {\n    skip |= LogError(\"VUID-vkCmdWriteAccelerationStructuresPropertiesNV-pAccelerationStructures-06215\", commandBuffer,\n                     error_obj.location.dot(Field::pAccelerationStructures, i),\n                     \"was built with %s, but queryType is VK_QUERY_TYPE_ACCELERATION_STRUCTURE_COMPACTED_SIZE_KHR.\",\n                     string_VkBuildAccelerationStructureFlagsKHR(as_state->build_info.flags).c_str());\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkCopyAccelerationStructureInfoKHR-src-04963\", \"The source acceleration structure src must have been constructed prior to the execution of this command\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (!src_accel_state->built) {\n    skip |= LogError(\"VUID-VkCopyAccelerationStructureInfoKHR-src-04963\", device, info_loc.dot(Field::src),\n                     \"has not been built.\");\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkCopyAccelerationStructureInfoKHR-src-03411\", \"If mode is VK_COPY_ACCELERATION_STRUCTURE_MODE_COMPACT_KHR, src must have been constructed with VK_BUILD_ACCELERATION_STRUCTURE_ALLOW_COMPACTION_BIT_KHR in the build\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (!(src_accel_state->build_info_khr.flags & VK_BUILD_ACCELERATION_STRUCTURE_ALLOW_COMPACTION_BIT_KHR)) {\n    const LogObjectList objlist(handle, as_info.src);\n    skip |= LogError(\"VUID-VkCopyAccelerationStructureInfoKHR-src-03411\", objlist, info_loc.dot(Field::src),\n                     \"(%s) must have been built with VK_BUILD_ACCELERATION_STRUCTURE_ALLOW_COMPACTION_BIT_KHR\"\n                     \"if mode is VK_COPY_ACCELERATION_STRUCTURE_MODE_COMPACT_KHR.\",\n                     FormatHandle(as_info.src).c_str());\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-vkCmdCopyAccelerationStructureToMemoryKHR-pInfo-03739\", \"pInfo->dst.deviceAddress must be a valid device address for a buffer bound to device memory\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (buffer_states.empty()) {\n    skip |= LogError(\"VUID-vkCmdCopyAccelerationStructureToMemoryKHR-pInfo-03739\", commandBuffer,\n                     error_obj.location.dot(Field::pInfo).dot(Field::dst).dot(Field::deviceAddress),\n                     \"(0x%\" PRIx64 \") is not a valid buffer address.\", dst_address);\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-vkCmdCopyMemoryToAccelerationStructureKHR-pInfo-03742\", \"pInfo->src.deviceAddress must be a valid device address for a buffer bound to device memory\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (buffer_states.empty()) {\n    skip |= LogError(\"VUID-vkCmdCopyMemoryToAccelerationStructureKHR-pInfo-03742\", commandBuffer,\n                     error_obj.location.dot(Field::pInfo).dot(Field::src).dot(Field::deviceAddress),\n                     \"(0x%\" PRIx64 \") is not a valid buffer address.\", src_address);\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-vkGetRayTracingShaderGroupHandlesKHR-pipeline-07828\", \"If the pipelineLibraryGroupHandles feature is not enabled, pipeline must not have been created with VK_PIPELINE_CREATE_LIBRARY_BIT_KHR\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (!enabled_features.pipelineLibraryGroupHandles) {\n    skip |= LogError(\"VUID-vkGetRayTracingShaderGroupHandlesKHR-pipeline-07828\", pipeline,\n                     error_obj.location.dot(Field::pipeline),\n                     \"was created with %s, but the pipelineLibraryGroupHandles feature was not enabled.\",\n                     string_VkPipelineCreateFlags2KHR(pipeline_state.create_flags).c_str());\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-vkGetRayTracingShaderGroupHandlesKHR-firstGroup-04050\", \"firstGroup must be less than the number of shader groups in pipeline\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (firstGroup >= total_group_count) {\n    skip |= LogError(\"VUID-vkGetRayTracingShaderGroupHandlesKHR-firstGroup-04050\", device,\n                     error_obj.location.dot(Field::firstGroup),\n                     \"(%\" PRIu32 \") must be less than the number of shader groups in pipeline (%\" PRIu32 \").\", firstGroup,\n                     total_group_count);\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-vkGetRayTracingCaptureReplayShaderGroupHandlesKHR-dataSize-03484\", \"dataSize must be at least VkPhysicalDeviceRayTracingPipelinePropertiesKHR::shaderGroupHandleCaptureReplaySize \u00d7 groupCount\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (dataSize < (phys_dev_ext_props.ray_tracing_props_khr.shaderGroupHandleCaptureReplaySize * groupCount)) {\n    skip |= LogError(\"VUID-vkGetRayTracingCaptureReplayShaderGroupHandlesKHR-dataSize-03484\", device,\n                     error_obj.location.dot(Field::dataSize),\n                     \"(%zu) must be at least \"\n                     \"shaderGroupHandleCaptureReplaySize (%\" PRIu32 \") * groupCount (%\" PRIu32 \").\",\n                     dataSize, phys_dev_ext_props.ray_tracing_props_khr.shaderGroupHandleCaptureReplaySize, groupCount);\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-vkGetRayTracingCaptureReplayShaderGroupHandlesKHR-pipeline-04620\", \"pipeline must be a ray tracing pipeline\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (pipeline_state->pipeline_type != VK_PIPELINE_BIND_POINT_RAY_TRACING_KHR) {\n    skip |= LogError(\"VUID-vkGetRayTracingCaptureReplayShaderGroupHandlesKHR-pipeline-04620\", pipeline,\n                     error_obj.location.dot(Field::pipeline), \"is a %s pipeline.\",\n                     string_VkPipelineBindPoint(pipeline_state->pipeline_type));\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-vkGetRayTracingCaptureReplayShaderGroupHandlesKHR-pipeline-07829\", \"If the pipelineLibraryGroupHandles feature is not enabled, pipeline must not have been created with VK_PIPELINE_CREATE_LIBRARY_BIT_KHR\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (!enabled_features.pipelineLibraryGroupHandles) {\n    skip |= LogError(\"VUID-vkGetRayTracingCaptureReplayShaderGroupHandlesKHR-pipeline-07829\", pipeline,\n                     error_obj.location.dot(Field::pipeline),\n                     \"was created with %s, but the pipelineLibraryGroupHandles feature was not enabled.\",\n                     string_VkPipelineCreateFlags(create_info.flags).c_str());\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-vkGetRayTracingCaptureReplayShaderGroupHandlesKHR-firstGroup-04051\", \"firstGroup must be less than the number of shader groups in pipeline\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (firstGroup >= total_group_count) {\n    skip |= LogError(\"VUID-vkGetRayTracingCaptureReplayShaderGroupHandlesKHR-firstGroup-04051\", device,\n                     error_obj.location.dot(Field::firstGroup),\n                     \"(%\" PRIu32\n                     \") must be less than the number of shader \"\n                     \"groups in pipeline (%\" PRIu32 \").\",\n                     firstGroup, total_group_count);\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-vkGetRayTracingCaptureReplayShaderGroupHandlesKHR-pipeline-03607\", \"pipeline must have been created with a flags that included VK_PIPELINE_CREATE_RAY_TRACING_SHADER_GROUP_HANDLE_CAPTURE_REPLAY_BIT_KHR\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (!(create_info.flags & VK_PIPELINE_CREATE_RAY_TRACING_SHADER_GROUP_HANDLE_CAPTURE_REPLAY_BIT_KHR)) {\n    skip |= LogError(\"VUID-vkGetRayTracingCaptureReplayShaderGroupHandlesKHR-pipeline-03607\", pipeline,\n                     error_obj.location.dot(Field::pipeline), \"was created with %s.\",\n                     string_VkPipelineCreateFlags(create_info.flags).c_str());\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-vkGetRayTracingShaderGroupStackSizeKHR-pipeline-04622\", \"pipeline must be a ray tracing pipeline\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (pipeline_state->pipeline_type != VK_PIPELINE_BIND_POINT_RAY_TRACING_KHR) {\n    skip |= LogError(\"VUID-vkGetRayTracingShaderGroupStackSizeKHR-pipeline-04622\", pipeline,\n                     error_obj.location.dot(Field::pipeline), \"is a %s pipeline.\",\n                     string_VkPipelineBindPoint(pipeline_state->pipeline_type));\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-vkGetRayTracingShaderGroupStackSizeKHR-groupShader-03609\", \"The shader identified by groupShader in group must not be VK_SHADER_UNUSED_KHR\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (unused_group) {\n    const LogObjectList objlist(device, pipeline);\n    skip |= LogError(\"VUID-vkGetRayTracingShaderGroupStackSizeKHR-groupShader-03609\", objlist,\n                     error_obj.location.dot(Field::groupShader),\n                     \"is %s but the corresponding shader in shader group (%\" PRIu32 \") is VK_SHADER_UNUSED_KHR.\",\n                     string_VkShaderGroupShaderKHR(groupShader), group);\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkGeometryTrianglesNV-vertexOffset-02428\", \"vertexOffset must be less than the size of vertexData\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (vb_state && vb_state->create_info.size <= triangles.vertexOffset) {\n    skip |= LogError(\"VUID-VkGeometryTrianglesNV-vertexOffset-02428\", device, loc, \"is invalid.\");\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkGeometryTrianglesNV-transformOffset-02437\", \"transformOffset must be less than the size of transformData\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (td_state && td_state->create_info.size <= triangles.transformOffset) {\n    skip |= LogError(\"VUID-VkGeometryTrianglesNV-transformOffset-02437\", device, loc, \"is invalid.\");\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkGeometryAABBNV-offset-02439\", \"offset must be less than the size of aabbData\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (aabb_state && aabb_state->create_info.size > 0 && aabb_state->create_info.size <= aabbs.offset) {\n    skip |= LogError(\"VUID-VkGeometryAABBNV-offset-02439\", device, loc, \"is invalid.\");\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkStridedDeviceAddressRegionKHR-size-04631\", \"If size is not zero, all addresses between deviceAddress and deviceAddress + size - 1 must be in the buffer device address range of the same buffer\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (buffer_states.empty()) {\n    skip |= LogError(\"VUID-VkStridedDeviceAddressRegionKHR-size-04631\", commandBuffer, table_loc.dot(Field::deviceAddress),\n                     \"(0x%\" PRIx64 \") has no buffer associated with it.\", binding_table.deviceAddress);\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-vkDestroyRenderPass-renderPass-00873\", \"All submitted commands that refer to renderPass must have completed execution\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (auto rp_state = Get<vvl::RenderPass>(renderPass)) {\n    skip |= ValidateObjectNotInUse(rp_state.get(), error_obj.location, \"VUID-vkDestroyRenderPass-renderPass-00873\");\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkDeviceGroupRenderPassBeginInfo-deviceRenderAreaCount-00908\", \"deviceRenderAreaCount must either be zero or equal to the number of physical devices in the logical device\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (device_group_begin_info->deviceRenderAreaCount != 0 &&\n    device_group_begin_info->deviceRenderAreaCount != physical_device_count) {\n    skip |= LogError(\"VUID-VkDeviceGroupRenderPassBeginInfo-deviceRenderAreaCount-00908\", objlist,\n                     rp_begin_loc.pNext(Struct::VkDeviceGroupRenderPassBeginInfo, Field::deviceRenderAreaCount),\n                     \"is %\" PRIu32 \" but the physical device count is %\" PRIu32 \".\",\n                     device_group_begin_info->deviceRenderAreaCount, physical_device_count);\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkRenderPassBeginInfo-None-08996\", \"If the pNext chain does not contain VkDeviceGroupRenderPassBeginInfo or its deviceRenderAreaCount member is equal to 0, renderArea.extent.width must be greater than 0\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (pRenderPassBegin->renderArea.extent.width == 0) {\n    skip |= LogError(\"VUID-VkRenderPassBeginInfo-None-08996\", commandBuffer,\n                     rp_begin_loc.dot(Field::renderArea).dot(Field::extent).dot(Field::width), \"is zero.\");\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkRenderPassBeginInfo-None-08997\", \"If the pNext chain does not contain VkDeviceGroupRenderPassBeginInfo or its deviceRenderAreaCount member is equal to 0, renderArea.extent.height must be greater than 0\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "skip |= LogError(\"VUID-VkRenderPassBeginInfo-None-08996\", commandBuffer,\nskip |= LogError(\"VUID-VkRenderPassBeginInfo-None-08997\", commandBuffer,\n                 rp_begin_loc.dot(Field::renderArea).dot(Field::extent).dot(Field::height), \"is zero.\");\n"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkSubpassFragmentDensityMapOffsetEndInfoQCOM-fragmentDensityMapOffsets-06503\", \"If the fragmentDensityMapOffset feature is not enabled or fragment density map is not enabled in the render pass, fragmentDensityOffsetCount must equal 0\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if ((!enabled_features.fragmentDensityMapOffset) || (!enabled_features.fragmentDensityMap)) {\n    const LogObjectList objlist(commandBuffer, rp_state.Handle());\n    skip |= LogError(\"VUID-VkSubpassFragmentDensityMapOffsetEndInfoQCOM-fragmentDensityMapOffsets-06503\", objlist,\n                     error_obj.location.pNext(Struct::VkSubpassFragmentDensityMapOffsetEndInfoQCOM,\n                                              Field::fragmentDensityOffsetCount),\n                     \"is %\" PRIu32 \" but must be 0 when feature is not enabled.\",\n                     fdm_offset_info->fragmentDensityOffsetCount);\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkSubpassFragmentDensityMapOffsetEndInfoQCOM-fragmentDensityMapAttachment-06504\", \"If VkSubpassDescription::fragmentDensityMapAttachment is not is not VK_ATTACHMENT_UNUSED and was not created with VK_IMAGE_CREATE_FRAGMENT_DENSITY_MAP_OFFSET_BIT_QCOM, fragmentDensityOffsetCount must equal 0\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if ((ici.flags & VK_IMAGE_CREATE_FRAGMENT_DENSITY_MAP_OFFSET_BIT_QCOM) == 0) {\n    skip |= LogError(\"VUID-VkSubpassFragmentDensityMapOffsetEndInfoQCOM-fragmentDensityMapAttachment-06504\",\n                     objlist, error_obj.location,\n                     \"Fragment density map attachment %\" PRIu32\n                     \" is not created with\"\n                     \" VK_IMAGE_CREATE_FRAGMENT_DENSITY_MAP_OFFSET_BIT_QCOM and fragmentDensityOffsetCount\"\n                     \" is %\" PRIu32 \" but must be 0 due to missing fragmentDensityOffset feature bit.\",\n                     i, fdm_offset_info->fragmentDensityOffsetCount);\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkSubpassFragmentDensityMapOffsetEndInfoQCOM-fragmentDensityOffsetCount-06510\", \"If fragmentDensityOffsetCount is not 0 and multiview is enabled for the render pass, fragmentDensityOffsetCount must equal the layerCount that was specified in creating the fragment density map attachment view\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if ((subpass.viewMask != 0) &&\n    (view_state->create_info.subresourceRange.layerCount != fdm_offset_info->fragmentDensityOffsetCount)) {\n    skip |= LogError(\"VUID-VkSubpassFragmentDensityMapOffsetEndInfoQCOM-fragmentDensityOffsetCount-06510\",\n                     objlist, error_obj.location,\n                     \"fragmentDensityOffsetCount %\" PRIu32\n                     \" does not match the fragment density map attachment (%\" PRIu32\n                     \") view layer count (%\" PRIu32 \").\",\n                     fdm_offset_info->fragmentDensityOffsetCount, i,\n                     view_state->create_info.subresourceRange.layerCount);\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkSubpassFragmentDensityMapOffsetEndInfoQCOM-fragmentDensityOffsetCount-06511\", \"If fragmentDensityOffsetCount is not 0 and multiview is not enabled for the render pass, fragmentDensityOffsetCount must equal 1\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if ((subpass.viewMask == 0) && (fdm_offset_info->fragmentDensityOffsetCount != 1)) {\n    skip |= LogError(\"VUID-VkSubpassFragmentDensityMapOffsetEndInfoQCOM-fragmentDensityOffsetCount-06511\",\n                     objlist, error_obj.location,\n                     \"fragmentDensityOffsetCount %\" PRIu32 \" should be 1 when multiview is not enabled.\",\n                     fdm_offset_info->fragmentDensityOffsetCount);\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkSubpassFragmentDensityMapOffsetEndInfoQCOM-pDepthStencilAttachment-06505\", \"If VkSubpassDescription::pDepthStencilAttachment is not is not VK_ATTACHMENT_UNUSED and was not created with VK_IMAGE_CREATE_FRAGMENT_DENSITY_MAP_OFFSET_BIT_QCOM, fragmentDensityOffsetCount must equal 0\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "(subpass.pDepthStencilAttachment->attachment == i) &&\nconst LogObjectList objlist(commandBuffer, rp_state.Handle(), view_state->Handle());\nskip |= LogError(\"VUID-VkSubpassFragmentDensityMapOffsetEndInfoQCOM-pDepthStencilAttachment-06505\", objlist,\n                 error_obj.location,\n                 \"pDepthStencilAttachment[%\" PRIu32\n                 \"] is not created with\"\n                 \" VK_IMAGE_CREATE_FRAGMENT_DENSITY_MAP_OFFSET_BIT_QCOM and fragmentDensityOffsetCount\"\n                 \" is %\" PRIu32 \" but must be 0 due to missing fragmentDensityOffset feature bit.\",\n                 i, fdm_offset_info->fragmentDensityOffsetCount);\n"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkSubpassFragmentDensityMapOffsetEndInfoQCOM-pColorAttachments-06507\", \"If any element of VkSubpassDescription::pColorAttachments is not is not VK_ATTACHMENT_UNUSED and was not created with VK_IMAGE_CREATE_FRAGMENT_DENSITY_MAP_OFFSET_BIT_QCOM, fragmentDensityOffsetCount must equal 0\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if ((attachment != VK_ATTACHMENT_UNUSED) && (attachment == i) &&\n    const LogObjectList objlist(commandBuffer, rp_state.Handle(), view_state->Handle());\n    skip |= LogError(\"VUID-VkSubpassFragmentDensityMapOffsetEndInfoQCOM-pColorAttachments-06507\", objlist,\n                     error_obj.location,\n                     \"pColorAttachments[%\" PRIu32\n                     \"] is not created with\"\n                     \" VK_IMAGE_CREATE_FRAGMENT_DENSITY_MAP_OFFSET_BIT_QCOM and fragmentDensityOffsetCount\"\n                     \" is %\" PRIu32 \" but must be 0 due to missing fragmentDensityOffset feature bit.\",\n                     i, fdm_offset_info->fragmentDensityOffsetCount);\n"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkSubpassFragmentDensityMapOffsetEndInfoQCOM-pResolveAttachments-06508\", \"If any element of VkSubpassDescription::pResolveAttachments is not is not VK_ATTACHMENT_UNUSED and was not created with VK_IMAGE_CREATE_FRAGMENT_DENSITY_MAP_OFFSET_BIT_QCOM, fragmentDensityOffsetCount must equal 0\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if ((attachment != VK_ATTACHMENT_UNUSED) && (attachment == i) &&\n    const LogObjectList objlist(commandBuffer, rp_state.Handle(), view_state->Handle());\n    skip |= LogError(\"VUID-VkSubpassFragmentDensityMapOffsetEndInfoQCOM-pResolveAttachments-06508\", objlist,\n                     error_obj.location,\n                     \"pResolveAttachments[%\" PRIu32\n                     \"] is not created with\"\n                     \" VK_IMAGE_CREATE_FRAGMENT_DENSITY_MAP_OFFSET_BIT_QCOM and fragmentDensityOffsetCount\"\n                     \" is %\" PRIu32 \" but must be 0 due to missing fragmentDensityOffset feature bit.\",\n                     i, fdm_offset_info->fragmentDensityOffsetCount);\n"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkSubpassFragmentDensityMapOffsetEndInfoQCOM-pPreserveAttachments-06509\", \"If any element of VkSubpassDescription::pPreserveAttachments is not is not VK_ATTACHMENT_UNUSED and was not created with VK_IMAGE_CREATE_FRAGMENT_DENSITY_MAP_OFFSET_BIT_QCOM, fragmentDensityOffsetCount must equal 0\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if ((attachment != VK_ATTACHMENT_UNUSED) && (attachment == i) &&\n    const LogObjectList objlist(commandBuffer, rp_state.Handle(), view_state->Handle());\n    skip |= LogError(\"VUID-VkSubpassFragmentDensityMapOffsetEndInfoQCOM-pPreserveAttachments-06509\", objlist,\n                     error_obj.location,\n                     \"pPreserveAttachments[%\" PRIu32\n                     \"] is not created with\"\n                     \" VK_IMAGE_CREATE_FRAGMENT_DENSITY_MAP_OFFSET_BIT_QCOM and fragmentDensityOffsetCount\"\n                     \" is %\" PRIu32 \" but must be 0 due to missing fragmentDensityOffset feature bit.\",\n                     i, fdm_offset_info->fragmentDensityOffsetCount);\n"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkDeviceGroupRenderPassBeginInfo-offset-06166\", \"The offset.x member of any element of pDeviceRenderAreas must be greater than or equal to 0\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (deviceRenderArea.offset.x < 0) {\n    skip |= LogError(\"VUID-VkDeviceGroupRenderPassBeginInfo-offset-06166\", begin_info.renderPass,\n                     render_area_loc.dot(Field::offset).dot(Field::x), \"is negative (%\" PRId32 \").\",\n                     deviceRenderArea.offset.x);\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkDeviceGroupRenderPassBeginInfo-offset-06167\", \"The offset.y member of any element of pDeviceRenderAreas must be greater than or equal to 0\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (deviceRenderArea.offset.y < 0) {\n    skip |= LogError(\"VUID-VkDeviceGroupRenderPassBeginInfo-offset-06167\", begin_info.renderPass,\n                     render_area_loc.dot(Field::offset).dot(Field::y), \"is negative (%\" PRId32 \").\",\n                     deviceRenderArea.offset.y);\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkDeviceGroupRenderPassBeginInfo-offset-06167\", \"The offset.y member of any element of pDeviceRenderAreas must be greater than or equal to 0\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "skip |= LogError(\"VUID-VkDeviceGroupRenderPassBeginInfo-offset-06166\", commandBuffer,\n                 group_loc.dot(Field::offset).dot(Field::x), \"is %\" PRId32 \" (offset can't be negative).\", offset_x);\nskip |= LogError(\"VUID-VkDeviceGroupRenderPassBeginInfo-offset-06167\", commandBuffer,\n                 group_loc.dot(Field::offset).dot(Field::y), \"is %\" PRId32 \" (offset can't be negative).\", offset_y);\n"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkRenderPassBeginInfo-pNext-02857\", \"If the pNext chain contains VkDeviceGroupRenderPassBeginInfo, offset.y + extent.height of each element of pDeviceRenderAreas must be less than or equal to VkFramebufferCreateInfo::height the framebuffer was created with\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if ((deviceRenderArea.offset.y + deviceRenderArea.extent.height) > framebuffer_info->height) {\n    const LogObjectList objlist(begin_info.renderPass, framebuffer_state->Handle());\n    skip |= LogError(\"VUID-VkRenderPassBeginInfo-pNext-02857\", objlist, render_area_loc,\n                     \"offset.y (%\" PRId32 \") + extent.height (%\" PRId32 \") is greater than framebuffer height (%\" PRId32\n                     \").\",\n                     deviceRenderArea.offset.y, deviceRenderArea.extent.height, framebuffer_info->height);\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkRenderPassBeginInfo-pNext-02850\", \"If the pNext chain does not contain VkDeviceGroupRenderPassBeginInfo or its deviceRenderAreaCount member is equal to 0, renderArea.offset.x must be greater than or equal to 0\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (begin_info.renderArea.offset.x < 0) {\n    skip |= LogError(\"VUID-VkRenderPassBeginInfo-pNext-02850\", begin_info.renderPass,\n                     render_area_loc.dot(Field::offset).dot(Field::x), \"is %\" PRId32 \" (offset can't be negative).\",\n                     begin_info.renderArea.offset.x);\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkRenderPassBeginInfo-pNext-02852\", \"If the pNext chain does not contain VkDeviceGroupRenderPassBeginInfo or its deviceRenderAreaCount member is equal to 0, renderArea.offset.x + renderArea.extent.width must be less than or equal to VkFramebufferCreateInfo::width the framebuffer was created with\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (x_adjusted_extent > static_cast<int64_t>(framebuffer_info->width)) {\n    const LogObjectList objlist(begin_info.renderPass, framebuffer_state->Handle());\n    skip |= LogError(\"VUID-VkRenderPassBeginInfo-pNext-02852\", objlist, render_area_loc,\n                     \"offset.x (%\" PRId32 \") + extent.width (%\" PRId32 \") is greater than framebuffer width (%\" PRId32 \").\",\n                     begin_info.renderArea.offset.x, begin_info.renderArea.extent.width, framebuffer_info->width);\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkRenderPassBeginInfo-framebuffer-03207\", \"If framebuffer was created with a VkFramebufferCreateInfo::flags value that did not include VK_FRAMEBUFFER_CREATE_IMAGELESS_BIT, and the pNext chain includes a VkRenderPassAttachmentBeginInfo structure, its attachmentCount must be zero\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if ((framebuffer_create_info.flags & VK_FRAMEBUFFER_CREATE_IMAGELESS_BIT) == 0) {\n    const LogObjectList objlist(begin_info.renderPass, begin_info.framebuffer);\n    skip |= LogError(\"VUID-VkRenderPassBeginInfo-framebuffer-03207\", objlist,\n                     begin_info_loc.pNext(Struct::VkRenderPassAttachmentBeginInfo, Field::attachmentCount),\n                     \"is %\" PRIu32 \", but the VkFramebuffer create flags (%s) has no VK_FRAMEBUFFER_CREATE_IMAGELESS_BIT.\",\n                     render_pass_attachment_begin_info->attachmentCount,\n                     string_VkFramebufferCreateFlags(framebuffer_create_info.flags).c_str());\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkRenderPassBeginInfo-framebuffer-03209\", \"If framebuffer was created with a VkFramebufferCreateInfo::flags value that included VK_FRAMEBUFFER_CREATE_IMAGELESS_BIT, each element of the pAttachments member of a VkRenderPassAttachmentBeginInfo structure included in the pNext chain must be a VkImageView of an image created with a value of VkImageCreateInfo::flags equal to the flags member of the corresponding element of VkFramebufferAttachmentsCreateInfo::pAttachmentImageInfos used to create framebuffer\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (framebuffer_attachment_image_info->flags != image_create_info->flags) {\n    skip |= LogError(\"VUID-VkRenderPassBeginInfo-framebuffer-03209\", objlist, attachment_loc.dot(Field::flags),\n                     \"is %s, but the VkFramebuffer was created with \"\n                     \"VkFramebufferAttachmentsCreateInfo::pAttachmentImageInfos[%\" PRIu32 \"].flags = %s\",\n                     string_VkImageCreateFlags(image_create_info->flags).c_str(), i,\n                     string_VkImageCreateFlags(framebuffer_attachment_image_info->flags).c_str());\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkRenderPassBeginInfo-framebuffer-04627\", \"If framebuffer was created with a VkFramebufferCreateInfo::flags value that included VK_FRAMEBUFFER_CREATE_IMAGELESS_BIT, each element of the pAttachments member of a VkRenderPassAttachmentBeginInfo structure included in the pNext chain must be a VkImageView with an inherited usage equal to the usage member of the corresponding element of VkFramebufferAttachmentsCreateInfo::pAttachmentImageInfos used to create framebuffer\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (image_create_info->usage == image_view_state->inherited_usage) {\n    skip |= LogError(\"VUID-VkRenderPassBeginInfo-framebuffer-04627\", objlist, attachment_loc.dot(Field::usage),\n                     \"is (%s), but the VkFramebuffer was created with \"\n                     \"vkFramebufferAttachmentsCreateInfo::pAttachmentImageInfos[%\" PRIu32 \"].usage = %s.\",\n                     string_VkImageUsageFlags(image_create_info->usage).c_str(), i,\n                     string_VkImageUsageFlags(framebuffer_attachment_image_info->usage).c_str());\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkRenderPassBeginInfo-framebuffer-03211\", \"If framebuffer was created with a VkFramebufferCreateInfo::flags value that included VK_FRAMEBUFFER_CREATE_IMAGELESS_BIT, each element of the pAttachments member of a VkRenderPassAttachmentBeginInfo structure included in the pNext chain must be a VkImageView with a width equal to the width member of the corresponding element of VkFramebufferAttachmentsCreateInfo::pAttachmentImageInfos used to create framebuffer\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (framebuffer_attachment_image_info->width != view_width) {\n    skip |= LogError(\"VUID-VkRenderPassBeginInfo-framebuffer-03211\", objlist, attachment_loc,\n                     \"has VkImageView width (%\" PRIu32 \") at mip level %\" PRIu32 \" (%\" PRIu32\n                     \") != VkFramebufferAttachmentsCreateInfo::pAttachments[%\" PRIu32 \"].width (%\" PRIu32 \").\",\n                     image_create_info->extent.width, subresource_range.baseMipLevel, view_width, i,\n                     framebuffer_attachment_image_info->width);\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkRenderPassBeginInfo-framebuffer-03212\", \"If framebuffer was created with a VkFramebufferCreateInfo::flags value that included VK_FRAMEBUFFER_CREATE_IMAGELESS_BIT, each element of the pAttachments member of a VkRenderPassAttachmentBeginInfo structure included in the pNext chain must be a VkImageView with a height equal to the height member of the corresponding element of VkFramebufferAttachmentsCreateInfo::pAttachmentImageInfos used to create framebuffer\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (framebuffer_attachment_image_info->height != view_height) {\n    skip |= LogError(\"VUID-VkRenderPassBeginInfo-framebuffer-03212\", objlist, attachment_loc,\n                     \"has VkImageView height (%\" PRIu32 \") at mip level %\" PRIu32 \" (%\" PRIu32\n                     \") != VkFramebufferAttachmentsCreateInfo::pAttachments[%\" PRIu32 \"].height (%\" PRIu32 \").\",\n                     image_create_info->extent.height, subresource_range.baseMipLevel, view_height, i,\n                     framebuffer_attachment_image_info->height);\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkRenderPassBeginInfo-framebuffer-03213\", \"If framebuffer was created with a VkFramebufferCreateInfo::flags value that included VK_FRAMEBUFFER_CREATE_IMAGELESS_BIT, each element of the pAttachments member of a VkRenderPassAttachmentBeginInfo structure included in the pNext chain must be a VkImageView of an image created with a value of VkImageViewCreateInfo::subresourceRange.layerCount equal to the layerCount member of the corresponding element of VkFramebufferAttachmentsCreateInfo::pAttachmentImageInfos used to create framebuffer\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (framebuffer_attachment_image_info->layerCount != layerCount) {\n    skip |= LogError(\"VUID-VkRenderPassBeginInfo-framebuffer-03213\", objlist, attachment_loc,\n                     \"has a subresource range with a layerCount of %\" PRIu32\n                     \", but VkFramebufferAttachmentsCreateInfo::pAttachments[%\" PRIu32 \"].layerCount is %\" PRIu32 \".\",\n                     layerCount, i, framebuffer_attachment_image_info->layerCount);\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkRenderPassBeginInfo-framebuffer-03215\", \"If framebuffer was created with a VkFramebufferCreateInfo::flags value that included VK_FRAMEBUFFER_CREATE_IMAGELESS_BIT, each element of the pAttachments member of a VkRenderPassAttachmentBeginInfo structure included in the pNext chain must be a VkImageView of an image created with a set of elements in VkImageFormatListCreateInfo::pViewFormats equal to the set of elements in the pViewFormats member of the corresponding element of VkFramebufferAttachmentsCreateInfo::pAttachmentImageInfos used to create framebuffer\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (!format_found) {\n    skip |= LogError(\"VUID-VkRenderPassBeginInfo-framebuffer-03215\", objlist, attachment_loc,\n                     \"internal VkImage was created with VkImageFormatListCreateInfo::pViewFormats[%\" PRIu32\n                     \"] = %s,\"\n                     \"but now found in vkFramebufferAttachmentsCreateInfo::pAttachmentImageInfos[%\" PRIu32\n                     \"].pViewFormats.\",\n                     j, string_VkFormat(image_format_list_create_info->pViewFormats[j]), i);\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkRenderPassBeginInfo-framebuffer-09354\", \"If framebuffer was created with a VkFramebufferCreateInfo::flags value that included VK_FRAMEBUFFER_CREATE_IMAGELESS_BIT, each element of the pAttachments member of a VkRenderPassAttachmentBeginInfo structure included in the pNext chain must be a VkImageView of an image created with a value of VkExternalFormatANDROID::externalFormat equal to VkExternalFormatANDROID::externalFormat in the pNext chain of the corresponding VkAttachmentDescription2 structure used to create renderPass\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (image_view_state->image_state->ahb_format != attachment_external_format) {\n    skip |= LogError(\"VUID-VkRenderPassBeginInfo-framebuffer-09354\", objlist, attachment_loc,\n                     \"externalFormat is %\" PRIu64 \", but the VkRenderPass was created with a pAttachments[%\" PRIu32\n                     \"] with externalFormat of %\" PRIu64 \".\",\n                     image_view_state->image_state->ahb_format, i, attachment_external_format);\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkRenderPassBeginInfo-framebuffer-09047\", \"If framebuffer was created with a VkFramebufferCreateInfo::flags value that included VK_FRAMEBUFFER_CREATE_IMAGELESS_BIT, each element of the pAttachments member of a VkRenderPassAttachmentBeginInfo structure included in the pNext chain must be a VkImageView of an image created with a value of VkImageCreateInfo::samples equal to the corresponding value of VkAttachmentDescription::samples in renderPass , or VK_SAMPLE_COUNT_1_BIT if renderPass was created with VkMultisampledRenderToSingleSampledInfoEXT structure in the pNext chain with multisampledRenderToSingleSampledEnable equal to VK_TRUE\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (attachment_samples != image_create_info->samples && !single_sample_enabled) {\n    skip |= LogError(\"VUID-VkRenderPassBeginInfo-framebuffer-09047\", objlist, attachment_loc,\n                     \"internal VkImage was created with %s samples, \"\n                     \"but the VkRenderPass was created with a pAttachments[%\" PRIu32 \"].samples of %s.\",\n                     string_VkSampleCountFlagBits(image_create_info->samples), i,\n                     string_VkSampleCountFlagBits(render_pass_create_info->pAttachments[i].samples));\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkRenderPassAttachmentBeginInfo-pAttachments-03218\", \"Each element of pAttachments must only specify a single mip level\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (subresource_range.levelCount != 1) {\n    skip |= LogError(\"VUID-VkRenderPassAttachmentBeginInfo-pAttachments-03218\", objlist, attachment_loc,\n                     \"was created with multiple mip levels (%\" PRIu32 \").\", subresource_range.levelCount);\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkRenderPassAttachmentBeginInfo-pAttachments-03219\", \"Each element of pAttachments must have been created with the identity swizzle\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (IsIdentitySwizzle(image_view_create_info->components) == false) {\n    skip |= LogError(\"VUID-VkRenderPassAttachmentBeginInfo-pAttachments-03219\", objlist, attachment_loc,\n                     \"was created with non-identity swizzle. All \"\n                     \"framebuffer attachments must have been created with the identity swizzle. Here are the actual \"\n                     \"swizzle values:\\n\"\n                     \"r swizzle = %s\\n\"\n                     \"g swizzle = %s\\n\"\n                     \"b swizzle = %s\\n\"\n                     \"a swizzle = %s\\n\",\n                     string_VkComponentSwizzle(image_view_create_info->components.r),\n                     string_VkComponentSwizzle(image_view_create_info->components.g),\n                     string_VkComponentSwizzle(image_view_create_info->components.b),\n                     string_VkComponentSwizzle(image_view_create_info->components.a));\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkAttachmentReferenceStencilLayout-stencilLayout-03318\", \"stencilLayout must not be VK_IMAGE_LAYOUT_UNDEFINED, VK_IMAGE_LAYOUT_PREINITIALIZED, VK_IMAGE_LAYOUT_COLOR_ATTACHMENT_OPTIMAL, VK_IMAGE_LAYOUT_DEPTH_ATTACHMENT_OPTIMAL, VK_IMAGE_LAYOUT_DEPTH_READ_ONLY_OPTIMAL, VK_IMAGE_LAYOUT_DEPTH_STENCIL_ATTACHMENT_OPTIMAL, VK_IMAGE_LAYOUT_DEPTH_STENCIL_READ_ONLY_OPTIMAL, VK_IMAGE_LAYOUT_DEPTH_ATTACHMENT_STENCIL_READ_ONLY_OPTIMAL, VK_IMAGE_LAYOUT_DEPTH_READ_ONLY_STENCIL_ATTACHMENT_OPTIMAL, or VK_IMAGE_LAYOUT_PRESENT_SRC_KHR\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "skip |= LogError(\"VUID-VkAttachmentReferenceStencilLayout-stencilLayout-03318\", device,\n                 loc.pNext(Struct::VkAttachmentReferenceStencilLayout, Field::stencilLayout),\n                 \"(%s) is not a valid VkImageLayout.\", string_VkImageLayout(stencil_layout));\n"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkRenderPassFragmentDensityMapCreateInfoEXT-fragmentDensityMapAttachment-02548\", \"If fragmentDensityMapAttachment is not VK_ATTACHMENT_UNUSED, fragmentDensityMapAttachment must not be an element of VkSubpassDescription::pInputAttachments, VkSubpassDescription::pColorAttachments, VkSubpassDescription::pResolveAttachments, VkSubpassDescription::pDepthStencilAttachment, or VkSubpassDescription::pPreserveAttachments for any subpass\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if ((fdm_attachment_index != VK_ATTACHMENT_UNUSED) && (attachment_index == fdm_attachment_index)) {\n    skip |= LogError(\"VUID-VkRenderPassFragmentDensityMapCreateInfoEXT-fragmentDensityMapAttachment-02548\", device,\n                     input_loc,\n                     \"is also referenced by \"\n                     \"VkRenderPassFragmentDensityMapCreateInfoEXT::fragmentDensityMapAttachment\");\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkRenderPassFragmentDensityMapCreateInfoEXT-fragmentDensityMapAttachment-02548\", \"If fragmentDensityMapAttachment is not VK_ATTACHMENT_UNUSED, fragmentDensityMapAttachment must not be an element of VkSubpassDescription::pInputAttachments, VkSubpassDescription::pColorAttachments, VkSubpassDescription::pResolveAttachments, VkSubpassDescription::pDepthStencilAttachment, or VkSubpassDescription::pPreserveAttachments for any subpass\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if ((fdm_attachment_index != VK_ATTACHMENT_UNUSED) && (attachment == fdm_attachment_index)) {\n    skip |= LogError(\"VUID-VkRenderPassFragmentDensityMapCreateInfoEXT-fragmentDensityMapAttachment-02548\",\n                     device, preserve_loc,\n                     \"is also referenced by \"\n                     \"VkRenderPassFragmentDensityMapCreateInfoEXT::fragmentDensityMapAttachment\");\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkRenderPassFragmentDensityMapCreateInfoEXT-fragmentDensityMapAttachment-02548\", \"If fragmentDensityMapAttachment is not VK_ATTACHMENT_UNUSED, fragmentDensityMapAttachment must not be an element of VkSubpassDescription::pInputAttachments, VkSubpassDescription::pColorAttachments, VkSubpassDescription::pResolveAttachments, VkSubpassDescription::pDepthStencilAttachment, or VkSubpassDescription::pPreserveAttachments for any subpass\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if ((fdm_attachment_index != VK_ATTACHMENT_UNUSED) && (attachment_ref.attachment == fdm_attachment_index)) {\n    skip |= LogError(\"VUID-VkRenderPassFragmentDensityMapCreateInfoEXT-fragmentDensityMapAttachment-02548\", device,\n                     resolve_loc,\n                     \"is also referenced by \"\n                     \"VkRenderPassFragmentDensityMapCreateInfoEXT::fragmentDensityMapAttachment\");\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkRenderPassFragmentDensityMapCreateInfoEXT-fragmentDensityMapAttachment-02548\", \"If fragmentDensityMapAttachment is not VK_ATTACHMENT_UNUSED, fragmentDensityMapAttachment must not be an element of VkSubpassDescription::pInputAttachments, VkSubpassDescription::pColorAttachments, VkSubpassDescription::pResolveAttachments, VkSubpassDescription::pDepthStencilAttachment, or VkSubpassDescription::pPreserveAttachments for any subpass\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if ((fdm_attachment_index != VK_ATTACHMENT_UNUSED) && (attachment_index == fdm_attachment_index)) {\n    skip |= LogError(\"VUID-VkRenderPassFragmentDensityMapCreateInfoEXT-fragmentDensityMapAttachment-02548\",\n                     device, color_loc,\n                     \"is also referenced by \"\n                     \"VkRenderPassFragmentDensityMapCreateInfoEXT::fragmentDensityMapAttachment\");\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkSubpassDescription2-attachment-02800\", \"If the attachment member of any element of pInputAttachments is not VK_ATTACHMENT_UNUSED, then the aspectMask member must not be 0\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (aspect_mask == 0) {\n    skip |= LogError(\"VUID-VkSubpassDescription2-attachment-02800\", device, input_loc.dot(Field::aspectMask),\n                     \"is zero.\");\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkSubpassDescription2-attachment-02799\", \"If the attachment member of any element of pInputAttachments is not VK_ATTACHMENT_UNUSED, then the aspectMask member must be a valid combination of VkImageAspectFlagBits\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (aspect_mask & ~valid_bits) {\n    skip |= LogError(\"VUID-VkSubpassDescription2-attachment-02799\", device, input_loc.dot(Field::aspectMask),\n                     \"(%s) is invalid.\", string_VkImageAspectFlags(aspect_mask).c_str());\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkSubpassDescription2-pNext-06871\", \"If the pNext chain includes a VkMultisampledRenderToSingleSampledInfoEXT structure with multisampledRenderToSingleSampledEnable equal to VK_TRUE, and pDepthStencilAttachment is not NULL, does not have the value VK_ATTACHMENT_UNUSED, and has a sample count of VK_SAMPLE_COUNT_1_BIT, the pNext chain must also include a VkSubpassDescriptionDepthStencilResolve structure with pDepthStencilResolveAttachment that is either NULL or has the value VK_ATTACHMENT_UNUSED\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "\"the VkSubpassDescription2 struct for this subpass is not NULL, and its attachment \"\nskip |= LogError(\"VUID-VkSubpassDescription2-pNext-06871\", device, ds_loc, \"%s\", message.str().c_str());\n"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkRenderPassCreateInfo2-attachment-06245\", \"If the attachment member of the pDepthStencilAttachment member of an element of pSubpasses is not VK_ATTACHMENT_UNUSED and the layout member of that same structure is either VK_IMAGE_LAYOUT_STENCIL_ATTACHMENT_OPTIMAL or VK_IMAGE_LAYOUT_STENCIL_READ_ONLY_OPTIMAL, then the element of pAttachments with an index equal to attachment must have a format that includes only a stencil component\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (!vkuFormatIsStencilOnly(attachment_format)) {\n    skip |= LogError(\"VUID-VkRenderPassCreateInfo2-attachment-06245\", device, attachment_loc.dot(Field::format),\n                     \"(%s) does not only have a stencil component (referenced by %s).\",\n                     string_VkFormat(attachment_format), ds_loc.Fields().c_str());\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkSubpassDescription2-pNext-06870\", \"If the pNext chain includes a VkMultisampledRenderToSingleSampledInfoEXT structure with multisampledRenderToSingleSampledEnable equal to VK_TRUE, then all attachments in pColorAttachments and pDepthStencilAttachment that are not VK_ATTACHMENT_UNUSED must have a sample count that is either VK_SAMPLE_COUNT_1_BIT or equal to VkMultisampledRenderToSingleSampledInfoEXT::rasterizationSamples\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (current_sample_count != VK_SAMPLE_COUNT_1_BIT &&\n    skip |= LogError(\"VUID-VkSubpassDescription2-pNext-06870\", device,\n                     create_info_loc.pNext(Struct::VkMultisampledRenderToSingleSampledInfoEXT,\n                                           Field::rasterizationSamples),\n                     \"(%s) doesn't match %s (%s) (referenced by %s).\",\n                     string_VkSampleCountFlagBits(ms_render_to_single_sample->rasterizationSamples),\n                     attachment_loc.dot(Field::samples).Fields().c_str(),\n                     string_VkSampleCountFlagBits(current_sample_count), color_loc.Fields().c_str());\n"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkSubpassDescription2-nullColorAttachmentWithExternalFormatResolve-09336\", \"If the nullColorAttachmentWithExternalFormatResolve property is VK_FALSE and pResolveAttachments is not NULL, for each resolve attachment that has a format of VK_FORMAT_UNDEFINED, the corresponding color attachment must not have the value VK_ATTACHMENT_UNUSED\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (!android_external_format_resolve_null_color_attachment_prop) {\n    skip |= LogError(\"VUID-VkSubpassDescription2-nullColorAttachmentWithExternalFormatResolve-09336\",\n                     device, resolve_loc.dot(Field::attachment),\n                     \"is %\" PRIu32 \", pAttachments[%\" PRIu32\n                     \"].format is VK_FORMAT_UNDEFINED, nullColorAttachmentWithExternalFormatResolve is \"\n                     \"VK_FALSE, but %s is VK_ATTACHMENT_UNUSED.\",\n                     resolve_attachment_index, resolve_attachment_index,\n                     color_loc.dot(Field::attachment).Fields().c_str());\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkSubpassDescription2-nullColorAttachmentWithExternalFormatResolve-09337\", \"If the nullColorAttachmentWithExternalFormatResolve property is VK_TRUE and pResolveAttachments is not NULL, for each resolve attachment that has a format of VK_FORMAT_UNDEFINED, the corresponding color attachment must have the value VK_ATTACHMENT_UNUSED\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (android_external_format_resolve_null_color_attachment_prop) {\n    skip |= LogError(\"VUID-VkSubpassDescription2-nullColorAttachmentWithExternalFormatResolve-09337\",\n                     device, resolve_loc.dot(Field::attachment),\n                     \"is %\" PRIu32 \", pAttachments[%\" PRIu32\n                     \"].format is VK_FORMAT_UNDEFINED, nullColorAttachmentWithExternalFormatResolve is \"\n                     \"VK_TRUE, but %s is %\" PRIu32 \".\",\n                     resolve_attachment_index, resolve_attachment_index,\n                     color_loc.dot(Field::attachment).Fields().c_str(), attachment_index);\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkSubpassDescription2-externalFormatResolve-09344\", \"If externalFormatResolve is enabled, pResolveAttachments is not NULL, and colorAttachmentCount is not 1, any element of pResolveAttachments that is not VK_ATTACHMENT_UNUSED, must not have a format of VK_FORMAT_UNDEFINED\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (subpass.colorAttachmentCount != 1) {\n    skip |= LogError(\"VUID-VkSubpassDescription2-externalFormatResolve-09344\", device,\n                     resolve_loc.dot(Field::attachment),\n                     \"is %\" PRIu32 \", pAttachments[%\" PRIu32\n                     \"].format is VK_FORMAT_UNDEFINED, but colorAttachmentCount is %\" PRIu32 \".\",\n                     resolve_attachment_index, resolve_attachment_index, subpass.colorAttachmentCount);\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkSubpassDescription2-externalFormatResolve-09348\", \"If externalFormatResolve is enabled, pResolveAttachments is not NULL, and any element of pResolveAttachments is not VK_ATTACHMENT_UNUSED and has a format of VK_FORMAT_UNDEFINED, elements of pInputAttachments referencing either a color attachment or resolve attachment used in this subpass must not include VK_IMAGE_ASPECT_PLANE_i_BIT for any index i in its aspectMask\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (input_attachment_index == resolve_attachment_index &&\n    skip |= LogError(\"VUID-VkSubpassDescription2-externalFormatResolve-09348\", device,\n                     resolve_loc.dot(Field::attachment),\n                     \"is %\" PRIu32 \" (reference also by pInputAttachments[%\" PRIu32\n                     \"]), but the resolve aspectMask is %s.\",\n                     resolve_attachment_index, k,\n                     string_VkImageAspectFlags(resolve_attachment_ref.aspectMask).c_str());\n"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkSubpassDescription2-externalFormatResolve-09348\", \"If externalFormatResolve is enabled, pResolveAttachments is not NULL, and any element of pResolveAttachments is not VK_ATTACHMENT_UNUSED and has a format of VK_FORMAT_UNDEFINED, elements of pInputAttachments referencing either a color attachment or resolve attachment used in this subpass must not include VK_IMAGE_ASPECT_PLANE_i_BIT for any index i in its aspectMask\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "skip |= LogError(\"VUID-VkSubpassDescription2-externalFormatResolve-09348\", device,\n                 color_loc.dot(Field::attachment),\n                 \"is %\" PRIu32 \" (reference also by pInputAttachments[%\" PRIu32\n                 \"]), but the resolve aspectMask is %s.\",\n                 attachment_index, k, string_VkImageAspectFlags(attachment_ref.aspectMask).c_str());\n"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkRenderPassCreateInfo2-viewMask-03059\", \"If the VkSubpassDescription2::viewMask member of all elements of pSubpasses is 0, the dependencyFlags member of any element of pDependencies must not include VK_DEPENDENCY_VIEW_LOCAL_BIT\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (use_rp2 && (dependency.dependencyFlags & VK_DEPENDENCY_VIEW_LOCAL_BIT) && (pCreateInfo->pSubpasses[0].viewMask == 0)) {\n    skip |= LogError(\"VUID-VkRenderPassCreateInfo2-viewMask-03059\", device, dependencies_loc,\n                     \"specifies the VK_DEPENDENCY_VIEW_LOCAL_BIT, but multiview is not enabled for this render pass.\");\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkSubpassDescription2-multiview-06558\", \"If the multiview feature is not enabled, viewMask must be 0\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (!enabled_features.multiview) {\n    skip |= LogError(\"VUID-VkSubpassDescription2-multiview-06558\", device, subpass_loc.dot(Field::viewMask),\n                     \"is %\" PRIu32 \", but multiview feature is not enabled.\", subpass.viewMask);\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkSubpassDescription2-viewMask-06706\", \"The index of the most significant bit in viewMask must be less than maxMultiviewViewCount\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (highest_view_bit > 0 && static_cast<uint32_t>(highest_view_bit) >= phys_dev_props_core11.maxMultiviewViewCount) {\n    skip |= LogError(\"VUID-VkSubpassDescription2-viewMask-06706\", device, subpass_loc,\n                     \"highest bit (%\" PRIu32\n                     \") is not less than VkPhysicalDeviceMultiviewProperties::maxMultiviewViewCount (%\" PRIu32 \").\",\n                     highest_view_bit, phys_dev_props_core11.maxMultiviewViewCount);\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkRenderPassCreateInfo2-viewMask-03058\", \"The VkSubpassDescription2::viewMask member of all elements of pSubpasses must either all be 0, or all not be 0\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (view_mask_non_zero && view_mask_zero) {\n    skip |= LogError(\"VUID-VkRenderPassCreateInfo2-viewMask-03058\", device, error_obj.location,\n                     \"Some view masks are non-zero whilst others are zero.\");\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkRenderPassCreateInfo2-viewMask-03057\", \"If the VkSubpassDescription2::viewMask member of all elements of pSubpasses is 0, correlatedViewMaskCount must be 0\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (view_mask_zero && pCreateInfo->correlatedViewMaskCount != 0) {\n    skip |= LogError(\"VUID-VkRenderPassCreateInfo2-viewMask-03057\", device, error_obj.location,\n                     \"Multiview is not enabled but correlation masks are still provided\");\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkRenderPassFragmentDensityMapCreateInfoEXT-fragmentDensityMapAttachment-02550\", \"If fragmentDensityMapAttachment is not VK_ATTACHMENT_UNUSED, fragmentDensityMapAttachment must reference an attachment with a loadOp equal to VK_ATTACHMENT_LOAD_OP_LOAD or VK_ATTACHMENT_LOAD_OP_DONT_CARE\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "pCreateInfo->pAttachments[fragment_density_map_info->fragmentDensityMapAttachment.attachment].loadOp ==\nskip |= LogError(\"VUID-VkRenderPassFragmentDensityMapCreateInfoEXT-fragmentDensityMapAttachment-02550\", device,\n               attchment_loc,\n               \"(%\" PRIu32\n               \") must reference an attachment with a loadOp \"\n               \"equal to VK_ATTACHMENT_LOAD_OP_LOAD or VK_ATTACHMENT_LOAD_OP_DONT_CARE.\",\n               fragment_density_map_info->fragmentDensityMapAttachment.attachment);\n"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkRenderPassFragmentDensityMapCreateInfoEXT-fragmentDensityMapAttachment-02551\", \"If fragmentDensityMapAttachment is not VK_ATTACHMENT_UNUSED, fragmentDensityMapAttachment must reference an attachment with a storeOp equal to VK_ATTACHMENT_STORE_OP_DONT_CARE\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (pCreateInfo->pAttachments[fragment_density_map_info->fragmentDensityMapAttachment.attachment].storeOp !=\n    skip |= LogError(\"VUID-VkRenderPassFragmentDensityMapCreateInfoEXT-fragmentDensityMapAttachment-02551\", device,\n                     attchment_loc,\n                     \"(%\" PRIu32\n                     \") must reference an attachment with a storeOp \"\n                     \"equal to VK_ATTACHMENT_STORE_OP_DONT_CARE.\",\n                     fragment_density_map_info->fragmentDensityMapAttachment.attachment);\n"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkRenderPassCreateInfo-pNext-01928\", \"If the pNext chain includes a VkRenderPassMultiviewCreateInfo structure, and its subpassCount member is not zero, that member must be equal to the value of subpassCount\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (multiview_info->subpassCount && multiview_info->subpassCount != pCreateInfo->subpassCount) {\n    skip |= LogError(\"VUID-VkRenderPassCreateInfo-pNext-01928\", device, error_obj.location,\n                     \"Subpass count is %\" PRIu32 \" but multiview info has a subpass count of %\" PRIu32 \".\",\n                     pCreateInfo->subpassCount, multiview_info->subpassCount);\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkRenderPassCreateInfo-pNext-01929\", \"If the pNext chain includes a VkRenderPassMultiviewCreateInfo structure, if its dependencyCount member is not zero, it must be equal to dependencyCount\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "skip |= LogError(\"VUID-VkRenderPassCreateInfo-pNext-01929\", device, error_obj.location,\n                 \"Dependency count is %\" PRIu32 \" but multiview info has a dependency count of %\" PRIu32 \".\",\n                 pCreateInfo->dependencyCount, multiview_info->dependencyCount);\n"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkRenderPassMultiviewCreateInfo-pViewMasks-06697\", \"The index of the most significant bit in each element of pViewMasks must be less than maxMultiviewViewCount\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (MostSignificantBit(multiview_info->pViewMasks[i]) >=\n    skip |= LogError(\"VUID-VkRenderPassMultiviewCreateInfo-pViewMasks-06697\", device, error_obj.location,\n                     \"Most significant bit in \"\n                     \"VkRenderPassMultiviewCreateInfo->pViewMask[%\" PRIu32 \"] (%\" PRIu32\n                     \") must be less than maxMultiviewViewCount(%\" PRIu32 \").\",\n                     i, multiview_info->pViewMasks[i], phys_dev_props_core11.maxMultiviewViewCount);\n"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkRenderPassCreateInfo-pNext-02513\", \"If the pNext chain includes a VkRenderPassMultiviewCreateInfo structure, elements of its pViewMasks member must either all be 0, or all not be 0\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (!all_zero && !all_not_zero) {\n    skip |= LogError(\"VUID-VkRenderPassCreateInfo-pNext-02513\", device, error_obj.location,\n                     \"elements of VkRenderPassMultiviewCreateInfo pViewMasks must all be either 0 or not 0.\");\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkRenderPassCreateInfo-pNext-02515\", \"If the pNext chain includes a VkRenderPassMultiviewCreateInfo structure, and each element of its pViewMasks member is 0, its correlationMaskCount member must be 0\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (all_zero && multiview_info->correlationMaskCount != 0) {\n    skip |= LogError(\"VUID-VkRenderPassCreateInfo-pNext-02515\", device, error_obj.location,\n                     \"VkRenderPassCreateInfo::correlationMaskCount is %\" PRIu32 \", but all elements of pViewMasks are 0.\",\n                     multiview_info->correlationMaskCount);\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkRenderPassCreateInfo-pNext-02512\", \"If the pNext chain includes a VkRenderPassMultiviewCreateInfo structure, for any element of pDependencies with a dependencyFlags member that does not include VK_DEPENDENCY_VIEW_LOCAL_BIT, the corresponding element of the pViewOffsets member of that VkRenderPassMultiviewCreateInfo instance must be 0\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (i < multiview_info->dependencyCount && multiview_info->pViewOffsets[i] != 0) {\n    skip |= LogError(\"VUID-VkRenderPassCreateInfo-pNext-02512\", device,\n                     error_obj.location.dot(Field::pDependencies, i).dot(Field::dependencyFlags),\n                     \"does not have VK_DEPENDENCY_VIEW_LOCAL_BIT bit set, but the corresponding \"\n                     \"VkRenderPassMultiviewCreateInfo::pViewOffsets[%\" PRIu32 \"] is %\" PRId32 \".\",\n                     i, multiview_info->pViewOffsets[i]);\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkSubpassDescriptionDepthStencilResolve-depthResolveMode-03183\", \"If pDepthStencilResolveAttachment is not NULL and does not have the value VK_ATTACHMENT_UNUSED and the VkFormat of pDepthStencilResolveAttachment has a depth component, then the value of depthResolveMode must be one of the bits set in VkPhysicalDeviceDepthStencilResolveProperties::supportedDepthResolveModes or VK_RESOLVE_MODE_NONE\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (!(resolve->depthResolveMode == VK_RESOLVE_MODE_NONE ||\n      resolve->depthResolveMode & phys_dev_props_core12.supportedDepthResolveModes)) {\n    skip |= LogError(\"VUID-VkSubpassDescriptionDepthStencilResolve-depthResolveMode-03183\", device,\n                     subpass_loc.pNext(Struct::VkSubpassDescriptionDepthStencilResolve, Field::depthResolveMode),\n                     \"(%s), must be VK_RESOLVE_MODE_NONE or a value from \"\n                     \"supportedDepthResolveModes (%s).\",\n                     string_VkResolveModeFlagBits(resolve->depthResolveMode),\n                     string_VkResolveModeFlags(phys_dev_props_core12.supportedDepthResolveModes).c_str());\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkSubpassDescriptionDepthStencilResolve-stencilResolveMode-03184\", \"If pDepthStencilResolveAttachment is not NULL and does not have the value VK_ATTACHMENT_UNUSED and the VkFormat of pDepthStencilResolveAttachment has a stencil component, then the value of stencilResolveMode must be one of the bits set in VkPhysicalDeviceDepthStencilResolveProperties::supportedStencilResolveModes or VK_RESOLVE_MODE_NONE\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (!(resolve->stencilResolveMode == VK_RESOLVE_MODE_NONE ||\n      resolve->stencilResolveMode & phys_dev_props_core12.supportedStencilResolveModes)) {\n    skip |= LogError(\"VUID-VkSubpassDescriptionDepthStencilResolve-stencilResolveMode-03184\", device,\n                     subpass_loc.pNext(Struct::VkSubpassDescriptionDepthStencilResolve, Field::stencilResolveMode),\n                     \"(%s), must be VK_RESOLVE_MODE_NONE or a value from \"\n                     \"supportedStencilResolveModes (%s).\",\n                     string_VkResolveModeFlagBits(resolve->stencilResolveMode),\n                     string_VkResolveModeFlags(phys_dev_props_core12.supportedStencilResolveModes).c_str());\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkSubpassDescriptionDepthStencilResolve-pDepthStencilResolveAttachment-03185\", \"If pDepthStencilResolveAttachment is not NULL and does not have the value VK_ATTACHMENT_UNUSED, the VkFormat of pDepthStencilResolveAttachment has both depth and stencil components, VkPhysicalDeviceDepthStencilResolveProperties::independentResolve is VK_FALSE, and VkPhysicalDeviceDepthStencilResolveProperties::independentResolveNone is VK_FALSE, then the values of depthResolveMode and stencilResolveMode must be identical\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (phys_dev_props_core12.independentResolve == VK_FALSE && phys_dev_props_core12.independentResolveNone == VK_FALSE &&\n    skip |= LogError(\"VUID-VkSubpassDescriptionDepthStencilResolve-pDepthStencilResolveAttachment-03185\", device,\n                     subpass_loc,\n                     \"includes a VkSubpassDescriptionDepthStencilResolve \"\n                     \"structure. The values of depthResolveMode (%s) and stencilResolveMode (%s) must be identical.\",\n                     string_VkResolveModeFlagBits(resolve->depthResolveMode),\n                     string_VkResolveModeFlagBits(resolve->stencilResolveMode));\n"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkSubpassDescriptionDepthStencilResolve-pDepthStencilResolveAttachment-03186\", \"If pDepthStencilResolveAttachment is not NULL and does not have the value VK_ATTACHMENT_UNUSED, the VkFormat of pDepthStencilResolveAttachment has both depth and stencil components, VkPhysicalDeviceDepthStencilResolveProperties::independentResolve is VK_FALSE and VkPhysicalDeviceDepthStencilResolveProperties::independentResolveNone is VK_TRUE, then the values of depthResolveMode and stencilResolveMode must be identical or one of them must be VK_RESOLVE_MODE_NONE\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (phys_dev_props_core12.independentResolve == VK_FALSE && phys_dev_props_core12.independentResolveNone == VK_TRUE &&\n    skip |= LogError(\"VUID-VkSubpassDescriptionDepthStencilResolve-pDepthStencilResolveAttachment-03186\", device,\n                     subpass_loc,\n                     \"includes a VkSubpassDescriptionDepthStencilResolve \"\n                     \"structure. The values of depthResolveMode (%s) and stencilResolveMode (%s) must be identical, or \"\n                     \"one of them must be VK_RESOLVE_MODE_NONE.\",\n                     string_VkResolveModeFlagBits(resolve->depthResolveMode),\n                     string_VkResolveModeFlagBits(resolve->stencilResolveMode));\n"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkSubpassDescriptionDepthStencilResolve-pDepthStencilResolveAttachment-03178\", \"If pDepthStencilResolveAttachment is not NULL and does not have the value VK_ATTACHMENT_UNUSED, depthResolveMode and stencilResolveMode must not both be VK_RESOLVE_MODE_NONE\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "skip |= LogError(\"VUID-VkSubpassDescriptionDepthStencilResolve-pDepthStencilResolveAttachment-03178\", device,\n                 ds_resolve_loc,\n                 \"is not NULL, but the stencil resolve mode is VK_RESOLVE_MODE_NONE (depth resolve mode is \"\n                 \"ignored due to format not having depth component).\");\n"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkSubpassDescriptionDepthStencilResolve-pDepthStencilResolveAttachment-03178\", \"If pDepthStencilResolveAttachment is not NULL and does not have the value VK_ATTACHMENT_UNUSED, depthResolveMode and stencilResolveMode must not both be VK_RESOLVE_MODE_NONE\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "skip |= LogError(\"VUID-VkSubpassDescriptionDepthStencilResolve-pDepthStencilResolveAttachment-03178\", device,\n                 ds_resolve_loc, \"is not NULL, but both depth and stencil resolve modes are VK_RESOLVE_MODE_NONE.\");\n"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkSubpassDescriptionDepthStencilResolve-pDepthStencilResolveAttachment-03180\", \"If pDepthStencilResolveAttachment is not NULL and does not have the value VK_ATTACHMENT_UNUSED, pDepthStencilResolveAttachment must have a sample count of VK_SAMPLE_COUNT_1_BIT\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (pCreateInfo->pAttachments[resolve_attachment].samples != VK_SAMPLE_COUNT_1_BIT) {\n    skip |= LogError(\"VUID-VkSubpassDescriptionDepthStencilResolve-pDepthStencilResolveAttachment-03180\", device,\n                     ds_resolve_loc, \"has sample count of VK_SAMPLE_COUNT_1_BIT.\");\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkSubpassDescriptionDepthStencilResolve-pDepthStencilResolveAttachment-02651\", \"If pDepthStencilResolveAttachment is not NULL and does not have the value VK_ATTACHMENT_UNUSED then it must have an image format whose potential format features contain VK_FORMAT_FEATURE_DEPTH_STENCIL_ATTACHMENT_BIT\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if ((potential_format_features & VK_FORMAT_FEATURE_2_DEPTH_STENCIL_ATTACHMENT_BIT_KHR) == 0) {\n    skip |= LogError(\"VUID-VkSubpassDescriptionDepthStencilResolve-pDepthStencilResolveAttachment-02651\", device,\n                     ds_resolve_loc,\n                     \"has a format (%s) whose features do not contain VK_FORMAT_FEATURE_DEPTH_STENCIL_ATTACHMENT_BIT.\",\n                     string_VkFormat(resolve_attachment_format));\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkRenderPassCreateInfo2-pAttachments-09387\", \"If any element of pAttachments is used as a fragment shading rate attachment, the loadOp for that attachment must not be VK_ATTACHMENT_LOAD_OP_CLEAR\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (pCreateInfo->pAttachments[attachment_reference.attachment].loadOp == VK_ATTACHMENT_LOAD_OP_CLEAR) {\n    skip |= LogError(\"VUID-VkRenderPassCreateInfo2-pAttachments-09387\", device, fragment_loc.dot(Field::attachment),\n                     \"(%\" PRIu32 \") has a loadOp of VK_ATTACHMENT_LOAD_OP_CLEAR\", attachment_reference.attachment);\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkFragmentShadingRateAttachmentInfoKHR-pFragmentShadingRateAttachment-04524\", \"If pFragmentShadingRateAttachment is not NULL and its attachment member is not VK_ATTACHMENT_UNUSED, its layout member must be equal to VK_IMAGE_LAYOUT_GENERAL or VK_IMAGE_LAYOUT_FRAGMENT_SHADING_RATE_ATTACHMENT_OPTIMAL_KHR\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (attachment_reference.layout != VK_IMAGE_LAYOUT_GENERAL &&\n    skip |= LogError(\"VUID-VkFragmentShadingRateAttachmentInfoKHR-pFragmentShadingRateAttachment-04524\", device,\n                     fragment_loc.dot(Field::layout), \"has a layout of %s.\",\n                     string_VkImageLayout(attachment_reference.layout));\n"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkFragmentShadingRateAttachmentInfoKHR-pFragmentShadingRateAttachment-04525\", \"If pFragmentShadingRateAttachment is not NULL and its attachment member is not VK_ATTACHMENT_UNUSED, shadingRateAttachmentTexelSize.width must be a power of two value\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (!IsPowerOfTwo(texel_size.width)) {\n    skip |= LogError(\"VUID-VkFragmentShadingRateAttachmentInfoKHR-pFragmentShadingRateAttachment-04525\", device,\n                     texel_loc.dot(Field::width), \"(%\" PRIu32 \") is a non-power-of-two.\", texel_size.width);\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkFragmentShadingRateAttachmentInfoKHR-pFragmentShadingRateAttachment-04528\", \"If pFragmentShadingRateAttachment is not NULL and its attachment member is not VK_ATTACHMENT_UNUSED, shadingRateAttachmentTexelSize.height must be a power of two value\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (!IsPowerOfTwo(texel_size.height)) {\n    skip |= LogError(\"VUID-VkFragmentShadingRateAttachmentInfoKHR-pFragmentShadingRateAttachment-04528\", device,\n                     texel_loc.dot(Field::height), \"(%\" PRIu32 \") is a non-power-of-two.\", texel_size.height);\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkRenderPassCreateInfo2-pAttachments-04585\", \"If any element of pAttachments is used as a fragment shading rate attachment in any subpass, it must not be used as any other attachment in the render pass\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (subpass_info.pResolveAttachments &&\n    skip |= LogError(\"VUID-VkRenderPassCreateInfo2-pAttachments-04585\", device,\n                     subpass_loc.dot(Field::pResolveAttachments, attachment).dot(Field::attachment),\n                     \"is also used in pAttachments[%\" PRIu32\n                     \"] as a fragment shading rate attachment in subpass(es) %s\",\n                     attachment_description, fsr_attachment_subpasses_string.c_str());\n"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkRenderPassCreateInfo2-pAttachments-04585\", \"If any element of pAttachments is used as a fragment shading rate attachment in any subpass, it must not be used as any other attachment in the render pass\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (subpass_info.pInputAttachments[attachment].attachment == attachment_description) {\n    skip |= LogError(\"VUID-VkRenderPassCreateInfo2-pAttachments-04585\", device,\n                     subpass_loc.dot(Field::pInputAttachments, attachment).dot(Field::attachment),\n                     \"is also used in pAttachments[%\" PRIu32\n                     \"] as a fragment shading rate attachment in subpass(es) %s\",\n                     attachment_description, fsr_attachment_subpasses_string.c_str());\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkRenderPassCreateInfo2-pAttachments-04585\", \"If any element of pAttachments is used as a fragment shading rate attachment in any subpass, it must not be used as any other attachment in the render pass\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (subpass_info.pDepthStencilAttachment->attachment == attachment_description) {\n    skip |= LogError(\"VUID-VkRenderPassCreateInfo2-pAttachments-04585\", device,\n                     subpass_loc.dot(Field::pDepthStencilAttachment).dot(Field::attachment),\n                     \"is also used in pAttachments[%\" PRIu32\n                     \"] as a fragment shading rate attachment in subpass(es) %s\",\n                     attachment_description, fsr_attachment_subpasses_string.c_str());\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkRenderingInfo-pNext-06079\", \"If the pNext chain does not contain VkDeviceGroupRenderPassBeginInfo or its deviceRenderAreaCount member is equal to 0, the width of the imageView member of any element of pColorAttachments, pDepthAttachment, or pStencilAttachment that is not VK_NULL_HANDLE must be greater than or equal to renderArea.offset.x + renderArea.extent.width\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (!x_extent_valid) {\n    skip |= LogError(\"VUID-VkRenderingInfo-pNext-06079\", objlist, loc,\n                     \"width (%\" PRIu32 \") is less than pRenderingInfo->renderArea.offset.x (%\" PRId32\n                     \") + pRenderingInfo->renderArea.extent.width (%\" PRIu32 \").\",\n                     image_view->image_state->create_info.extent.width, pRenderingInfo->renderArea.offset.x,\n                     pRenderingInfo->renderArea.extent.width);\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkRenderingAttachmentInfo-imageView-06145\", \"If imageView is not VK_NULL_HANDLE, imageLayout must not be VK_IMAGE_LAYOUT_PRESENT_SRC_KHR\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (attachment_info.imageLayout == VK_IMAGE_LAYOUT_PRESENT_SRC_KHR) {\n    skip |= LogError(\"VUID-VkRenderingAttachmentInfo-imageView-06145\", commandBuffer, attachment_loc.dot(Field::imageLayout),\n                     \"must not be VK_IMAGE_LAYOUT_PRESENT_SRC_KHR\");\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkRenderingAttachmentInfo-imageView-06129\", \"If imageView is not VK_NULL_HANDLE and has a non-integer color format, resolveMode must be VK_RESOLVE_MODE_NONE or VK_RESOLVE_MODE_AVERAGE_BIT\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if ((!vkuFormatIsSINT(image_view_format) && !vkuFormatIsUINT(image_view_format)) && vkuFormatIsColor(image_view_format) &&\n    !(attachment_info.resolveMode == VK_RESOLVE_MODE_NONE || attachment_info.resolveMode == VK_RESOLVE_MODE_AVERAGE_BIT)) {\n    const LogObjectList objlist(commandBuffer, attachment_info.imageView);\n    skip |= LogError(\"VUID-VkRenderingAttachmentInfo-imageView-06129\", objlist, attachment_loc.dot(Field::resolveMode),\n                     \"(%s) must be VK_RESOLVE_MODE_NONE or VK_RESOLVE_MODE_AVERAGE_BIT for non-integer formats (%s)\",\n                     string_VkResolveModeFlags(attachment_info.resolveMode).c_str(), string_VkFormat(image_view_format));\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkRenderingAttachmentInfo-imageView-06130\", \"If imageView is not VK_NULL_HANDLE and has an integer color format, resolveMode must be VK_RESOLVE_MODE_NONE or VK_RESOLVE_MODE_SAMPLE_ZERO_BIT\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if ((vkuFormatIsSINT(image_view_format) || vkuFormatIsUINT(image_view_format)) && vkuFormatIsColor(image_view_format) &&\n    !(attachment_info.resolveMode == VK_RESOLVE_MODE_NONE || attachment_info.resolveMode == VK_RESOLVE_MODE_SAMPLE_ZERO_BIT)) {\n    const LogObjectList objlist(commandBuffer, attachment_info.imageView);\n    skip |= LogError(\"VUID-VkRenderingAttachmentInfo-imageView-06130\", objlist, attachment_loc.dot(Field::resolveMode),\n                     \"(%s) must be VK_RESOLVE_MODE_NONE or VK_RESOLVE_MODE_SAMPLE_ZERO_BIT for integer formats (%s)\",\n                     string_VkResolveModeFlags(attachment_info.resolveMode).c_str(), string_VkFormat(image_view_format));\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkRenderingAttachmentInfo-imageView-06140\", \"If imageView is not VK_NULL_HANDLE, imageLayout must not be VK_IMAGE_LAYOUT_FRAGMENT_DENSITY_MAP_OPTIMAL_EXT\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (attachment_info.imageLayout == VK_IMAGE_LAYOUT_FRAGMENT_DENSITY_MAP_OPTIMAL_EXT) {\n    skip |= LogError(\"VUID-VkRenderingAttachmentInfo-imageView-06140\", commandBuffer, attachment_loc.dot(Field::imageLayout),\n                     \"must not be VK_IMAGE_LAYOUT_FRAGMENT_DENSITY_MAP_OPTIMAL_EXT\");\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkRenderingAttachmentInfo-imageView-06864\", \"If imageView is not VK_NULL_HANDLE, resolveImageView is not VK_NULL_HANDLE, and resolveMode is not VK_RESOLVE_MODE_NONE, resolveImageView must have a sample count of VK_SAMPLE_COUNT_1_BIT\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (resolve_view_state && (attachment_info.resolveMode != VK_RESOLVE_MODE_NONE) &&\n    const LogObjectList objlist(commandBuffer, attachment_info.resolveImageView);\n    skip |= LogError(\"VUID-VkRenderingAttachmentInfo-imageView-06864\", commandBuffer, attachment_loc.dot(Field::resolveMode),\n                     \"%s but resolveImageView has a sample count of %s\",\n                     string_VkResolveModeFlags(attachment_info.resolveMode).c_str(),\n                     string_VkSampleCountFlagBits(resolve_view_state->samples));\n"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkRenderingAttachmentInfo-imageView-06146\", \"If imageView is not VK_NULL_HANDLE and resolveMode is not VK_RESOLVE_MODE_NONE, resolveImageLayout must not be VK_IMAGE_LAYOUT_PRESENT_SRC_KHR\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (attachment_info.resolveImageLayout == VK_IMAGE_LAYOUT_PRESENT_SRC_KHR) {\n    skip |= LogError(\"VUID-VkRenderingAttachmentInfo-imageView-06146\", commandBuffer,\n                     attachment_loc.dot(Field::resolveImageLayout), \"must not be VK_IMAGE_LAYOUT_PRESENT_SRC_KHR\");\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkRenderingAttachmentInfo-imageView-06141\", \"If imageView is not VK_NULL_HANDLE and resolveMode is not VK_RESOLVE_MODE_NONE, resolveImageLayout must not be VK_IMAGE_LAYOUT_FRAGMENT_DENSITY_MAP_OPTIMAL_EXT\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (attachment_info.resolveImageLayout == VK_IMAGE_LAYOUT_FRAGMENT_DENSITY_MAP_OPTIMAL_EXT) {\n    skip |= LogError(\"VUID-VkRenderingAttachmentInfo-imageView-06141\", commandBuffer,\n                     attachment_loc.dot(Field::resolveImageLayout),\n                     \"must not be VK_IMAGE_LAYOUT_FRAGMENT_DENSITY_MAP_OPTIMAL_EXT\");\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkRenderingAttachmentInfo-imageView-06142\", \"If imageView is not VK_NULL_HANDLE and resolveMode is not VK_RESOLVE_MODE_NONE, resolveImageLayout must not be VK_IMAGE_LAYOUT_READ_ONLY_OPTIMAL_KHR\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (attachment_info.resolveImageLayout == VK_IMAGE_LAYOUT_READ_ONLY_OPTIMAL_KHR) {\n    skip |= LogError(\"VUID-VkRenderingAttachmentInfo-imageView-06142\", commandBuffer,\n                     attachment_loc.dot(Field::resolveImageLayout), \"must not be VK_IMAGE_LAYOUT_READ_ONLY_OPTIMAL_KHR\");\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkRenderingAttachmentInfo-imageView-06137\", \"If imageView is not VK_NULL_HANDLE and resolveMode is not VK_RESOLVE_MODE_NONE, resolveImageLayout must not be VK_IMAGE_LAYOUT_DEPTH_READ_ONLY_OPTIMAL or VK_IMAGE_LAYOUT_STENCIL_READ_ONLY_OPTIMAL\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (((attachment_info.resolveImageLayout == VK_IMAGE_LAYOUT_DEPTH_READ_ONLY_OPTIMAL) ||\n    skip |= LogError(\"VUID-VkRenderingAttachmentInfo-imageView-06137\", commandBuffer,\n                     attachment_loc.dot(Field::resolveImageLayout), \"is %s.\",\n                     string_VkImageLayout(attachment_info.resolveImageLayout));\n"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkRenderingAttachmentInfo-imageView-06135\", \"If imageView is not VK_NULL_HANDLE, imageLayout must not be VK_IMAGE_LAYOUT_UNDEFINED, VK_IMAGE_LAYOUT_SHADER_READ_ONLY_OPTIMAL, VK_IMAGE_LAYOUT_TRANSFER_SRC_OPTIMAL, VK_IMAGE_LAYOUT_TRANSFER_DST_OPTIMAL, or VK_IMAGE_LAYOUT_PREINITIALIZED\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (IsValueIn(attachment_info.imageLayout,\n    skip |= LogError(\"VUID-VkRenderingAttachmentInfo-imageView-06135\", commandBuffer, attachment_loc.dot(Field::imageLayout),\n                     \"is %s.\", string_VkImageLayout(attachment_info.imageLayout));\n"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkRenderingInfo-imageView-06107\", \"If the imageView member of a VkRenderingFragmentDensityMapAttachmentInfoEXT structure included in the pNext chain is not VK_NULL_HANDLE, and the fragmentDensityMapNonSubsampledImages feature is not enabled, valid imageView and resolveImageView members of pDepthAttachment, pStencilAttachment, and each element of pColorAttachments must be a VkImageView created with VK_IMAGE_CREATE_SUBSAMPLED_BIT_EXT\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (image_view_state && !(image_view_state->image_state->create_info.flags & VK_IMAGE_CREATE_SUBSAMPLED_BIT_EXT)) {\n    const LogObjectList objlist(commandBuffer, rendering_info.pColorAttachments[j].imageView);\n    skip |= LogError(\"VUID-VkRenderingInfo-imageView-06107\", objlist,\n                     rendering_info_loc.dot(Field::pColorAttachments, j).dot(Field::imageView),\n                     \"must be created with VK_IMAGE_CREATE_SUBSAMPLED_BIT_EXT.\");\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkRenderingInfo-imageView-06107\", \"If the imageView member of a VkRenderingFragmentDensityMapAttachmentInfoEXT structure included in the pNext chain is not VK_NULL_HANDLE, and the fragmentDensityMapNonSubsampledImages feature is not enabled, valid imageView and resolveImageView members of pDepthAttachment, pStencilAttachment, and each element of pColorAttachments must be a VkImageView created with VK_IMAGE_CREATE_SUBSAMPLED_BIT_EXT\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (depth_view_state && !(depth_view_state->image_state->create_info.flags & VK_IMAGE_CREATE_SUBSAMPLED_BIT_EXT)) {\n    const LogObjectList objlist(commandBuffer, rendering_info.pStencilAttachment->imageView);\n    skip |= LogError(\"VUID-VkRenderingInfo-imageView-06107\", objlist,\n                     rendering_info_loc.dot(Field::pDepthAttachment).dot(Field::imageView),\n                     \"must be created with VK_IMAGE_CREATE_SUBSAMPLED_BIT_EXT.\");\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkRenderingFragmentDensityMapAttachmentInfoEXT-imageView-06158\", \"If imageView is not VK_NULL_HANDLE, it must have been created with VK_IMAGE_USAGE_FRAGMENT_DENSITY_MAP_BIT_EXT\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if ((fragment_density_map_view_state->inherited_usage & VK_IMAGE_USAGE_FRAGMENT_DENSITY_MAP_BIT_EXT) == 0) {\n    const LogObjectList objlist(commandBuffer, fragment_density_map_attachment_info->imageView);\n    skip |= LogError(\"VUID-VkRenderingFragmentDensityMapAttachmentInfoEXT-imageView-06158\", objlist, view_loc,\n                     \"usage (%s) does not include VK_IMAGE_USAGE_FRAGMENT_DENSITY_MAP_BIT_EXT.\",\n                     string_VkImageUsageFlags(fragment_density_map_view_state->inherited_usage).c_str());\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkRenderingFragmentDensityMapAttachmentInfoEXT-imageView-06159\", \"If imageView is not VK_NULL_HANDLE, it must not have been created with VK_IMAGE_CREATE_SUBSAMPLED_BIT_EXT\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if ((fragment_density_map_view_state->image_state->create_info.flags & VK_IMAGE_CREATE_SUBSAMPLED_BIT_EXT) > 0) {\n    const LogObjectList objlist(commandBuffer, fragment_density_map_attachment_info->imageView,\n    skip |= LogError(\"VUID-VkRenderingFragmentDensityMapAttachmentInfoEXT-imageView-06159\", objlist, view_loc,\n                     \"internal image was created with flags %s.\",\n                     string_VkImageCreateFlags(fragment_density_map_view_state->image_state->create_info.flags).c_str());\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkRenderingFragmentDensityMapAttachmentInfoEXT-apiVersion-07908\", \"If the multiview feature is not enabled, VkPhysicalDeviceProperties::apiVersion is less than Vulkan 1.1, and imageView is not VK_NULL_HANDLE, it must have a layerCount equal to 1\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (layer_count != 1 && !enabled_features.multiview) {\n    const LogObjectList objlist(commandBuffer, fragment_density_map_attachment_info->imageView);\n    skip |= LogError(\"VUID-VkRenderingFragmentDensityMapAttachmentInfoEXT-apiVersion-07908\", objlist, view_loc,\n                     \"must have a layer count (%\" PRId32 \") equal to 1.\", layer_count);\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkRenderingInfo-imageView-06109\", \"If the imageView member of a VkRenderingFragmentDensityMapAttachmentInfoEXT structure included in the pNext chain is not VK_NULL_HANDLE, and viewMask is 0, imageView must have a layerCount equal to 1\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if ((rendering_info.viewMask == 0) && (layer_count != 1)) {\n    const LogObjectList objlist(commandBuffer, fragment_density_map_attachment_info->imageView);\n    skip |= LogError(\"VUID-VkRenderingInfo-imageView-06109\", objlist, view_loc,\n                     \"must have a layer count (%\" PRId32 \") equal to 1 when viewMask is equal to 0\", layer_count);\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkRenderingInfo-imageView-09486\", \"If the imageView member of a VkRenderingFragmentDensityMapAttachmentInfoEXT structure included in the pNext chain is not VK_NULL_HANDLE, it must have been created with the identity swizzle\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (!IsIdentitySwizzle(components)) {\n    const LogObjectList objlist(commandBuffer, fragment_density_map_view_state->Handle());\n    skip |= LogError(\"VUID-VkRenderingInfo-imageView-09486\", objlist, view_loc,\n                     \"has a non-identiy swizzle component, here are the actual swizzle values:\\n\"\n                     \"r swizzle = %s\\n\"\n                     \"g swizzle = %s\\n\"\n                     \"b swizzle = %s\\n\"\n                     \"a swizzle = %s\\n\",\n                     string_VkComponentSwizzle(components.r), string_VkComponentSwizzle(components.g),\n                     string_VkComponentSwizzle(components.b), string_VkComponentSwizzle(components.a));\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkRenderingInfo-imageView-06123\", \"If the imageView member of a VkRenderingFragmentShadingRateAttachmentInfoKHR structure included in the pNext chain is not VK_NULL_HANDLE, and viewMask is 0, imageView must have a layerCount that is either equal to 1 or greater than or equal to layerCount\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (view_state->create_info.subresourceRange.layerCount != 1 &&\n    view_state->create_info.subresourceRange.layerCount < rendering_info.layerCount) {\n    skip |= LogError(\"VUID-VkRenderingInfo-imageView-06123\", objlist, rendering_info_loc.dot(Field::layerCount),\n                     \"is (%\" PRIu32\n                     \") but VkRenderingFragmentShadingRateAttachmentInfoKHR::imageView was created with (%\" PRIu32 \").\",\n                     rendering_info.layerCount, view_state->create_info.subresourceRange.layerCount);\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkRenderingInfo-imageView-06124\", \"If the imageView member of a VkRenderingFragmentShadingRateAttachmentInfoKHR structure included in the pNext chain is not VK_NULL_HANDLE, and viewMask is not 0, imageView must have a layerCount that either equal to 1 or greater than or equal to the index of the most significant bit in viewMask\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (layer_count != 1 && layer_count < highest_view_bit) {\n    skip |= LogError(\"VUID-VkRenderingInfo-imageView-06124\", objlist,\n                     rendering_info_loc.pNext(Struct::VkRenderingFragmentShadingRateAttachmentInfoKHR, Field::imageView),\n                     \"has a layerCount (%\" PRId32\n                     \") but must either is equal to 1 or greater than \"\n                     \" or equal to the index of the most significant bit in viewMask (%d)\",\n                     layer_count, highest_view_bit);\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkRenderingFragmentShadingRateAttachmentInfoKHR-imageView-06148\", \"If imageView is not VK_NULL_HANDLE, it must have been created with VK_IMAGE_USAGE_FRAGMENT_SHADING_RATE_ATTACHMENT_BIT_KHR\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if ((view_state->inherited_usage & VK_IMAGE_USAGE_FRAGMENT_SHADING_RATE_ATTACHMENT_BIT_KHR) == 0) {\n    skip |= LogError(\"VUID-VkRenderingFragmentShadingRateAttachmentInfoKHR-imageView-06148\", objlist,\n                     rendering_info_loc.pNext(Struct::VkRenderingFragmentShadingRateAttachmentInfoKHR, Field::imageView),\n                     \"was not created with VK_IMAGE_USAGE_FRAGMENT_SHADING_RATE_ATTACHMENT_BIT_KHR.\");\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkRenderingInfo-pNext-06119\", \"If maintenance7 is not enabled or the robustFragmentShadingRateAttachmentAccess limit is VK_FALSE or the imageView member of a VkRenderingFragmentShadingRateAttachmentInfoKHR structure was created with VkImageSubresourceRange::baseMipLevel greater than 0, the pNext chain does not contain VkDeviceGroupRenderPassBeginInfo or its deviceRenderAreaCount member is equal to 0, and the imageView member of a VkRenderingFragmentShadingRateAttachmentInfoKHR structure included in the pNext chain is not VK_NULL_HANDLE, imageView must have a width greater than or equal to \\\\(\\\\left\\\\lceil{\\\\frac{renderArea_{x}+renderArea_{width}}{shadingRateAttachmentTexelSize_{width}}}\\\\right\\\\rceil\\\\)\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (static_cast<int64_t>(view_state.image_state->create_info.extent.width) <\n    skip |= LogError(\"VUID-VkRenderingInfo-pNext-06119\", objlist,\n                     rendering_info_loc.pNext(Struct::VkRenderingFragmentShadingRateAttachmentInfoKHR, Field::imageView),\n                     \"width (%\" PRIu32 \") must not be less than (pRenderingInfo->renderArea.offset.x (%\" PRId32\n                     \") + pRenderingInfo->renderArea.extent.width (%\" PRIu32\n                     \") ) / shadingRateAttachmentTexelSize.width (%\" PRIu32 \").\",\n                     view_state.image_state->create_info.extent.width, rendering_info.renderArea.offset.x,\n                     rendering_info.renderArea.extent.width, fsr_attachment_info.shadingRateAttachmentTexelSize.width);\n"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkRenderingInfo-pNext-06121\", \"If maintenance7 is not enabled or the robustFragmentShadingRateAttachmentAccess limit is VK_FALSE or the imageView member of a VkRenderingFragmentShadingRateAttachmentInfoKHR structure was created with VkImageSubresourceRange::baseMipLevel greater than 0, the pNext chain does not contain VkDeviceGroupRenderPassBeginInfo or its deviceRenderAreaCount member is equal to 0 and the imageView member of a VkRenderingFragmentShadingRateAttachmentInfoKHR structure included in the pNext chain is not VK_NULL_HANDLE, imageView must have a height greater than or equal to \\\\(\\\\left\\\\lceil{\\\\frac{renderArea_{y}+renderArea_{height}}{shadingRateAttachmentTexelSize_{height}}}\\\\right\\\\rceil\\\\)\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (static_cast<int64_t>(view_state.image_state->create_info.extent.height) <\n    skip |= LogError(\"VUID-VkRenderingInfo-pNext-06121\", objlist,\n                     rendering_info_loc.pNext(Struct::VkRenderingFragmentShadingRateAttachmentInfoKHR, Field::imageView),\n                     \"height (%\" PRIu32 \") must not be less than (pRenderingInfo->renderArea.offset.y (%\" PRId32\n                     \") + pRenderingInfo->renderArea.extent.height (%\" PRIu32\n                     \") ) / shadingRateAttachmentTexelSize.height (%\" PRIu32 \").\",\n                     view_state.image_state->create_info.extent.height, rendering_info.renderArea.offset.y,\n                     rendering_info.renderArea.extent.height, fsr_attachment_info.shadingRateAttachmentTexelSize.height);\n"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkDeviceGroupRenderPassBeginInfo-extent-08998\", \"The extent.width member of any element of pDeviceRenderAreas must be greater than 0\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "skip |= LogError(\"VUID-VkDeviceGroupRenderPassBeginInfo-offset-06167\", commandBuffer,\nskip |= LogError(\"VUID-VkDeviceGroupRenderPassBeginInfo-extent-08998\", commandBuffer,\n                 group_loc.dot(Field::extent).dot(Field::width), \"is zero.\");\n"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkDeviceGroupRenderPassBeginInfo-extent-08999\", \"The extent.height member of any element of pDeviceRenderAreas must be greater than 0\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "skip |= LogError(\"VUID-VkDeviceGroupRenderPassBeginInfo-extent-08998\", commandBuffer,\n                 group_loc.dot(Field::extent).dot(Field::width), \"is zero.\");\nskip |= LogError(\"VUID-VkDeviceGroupRenderPassBeginInfo-extent-08999\", commandBuffer,\n                 group_loc.dot(Field::extent).dot(Field::height), \"is zero.\");\n"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkDeviceGroupRenderPassBeginInfo-offset-06169\", \"The sum of the offset.y and extent.height members of any element of pDeviceRenderAreas must be less than or equal to maxFramebufferHeight\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if ((offset_y + height) > phys_dev_props.limits.maxFramebufferHeight) {\n    skip |= LogError(\"VUID-VkDeviceGroupRenderPassBeginInfo-offset-06169\", commandBuffer, group_loc,\n                     \"sum of offset.y (%\" PRId32 \") and extent.height (%\" PRIu32\n                     \") is greater than maxFramebufferHeight (%\" PRIu32 \").\",\n                     offset_y, height, phys_dev_props.limits.maxFramebufferHeight);\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkRenderingInfo-pNext-06083\", \"If the pNext chain contains VkDeviceGroupRenderPassBeginInfo, the width of the imageView member of any element of pColorAttachments, pDepthAttachment, or pStencilAttachment that is not VK_NULL_HANDLE must be greater than or equal to the sum of the offset.x and extent.width members of each element of pDeviceRenderAreas\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (image_state->create_info.extent.width < offset_x + width) {\n    const LogObjectList objlist(commandBuffer, image_view_state->Handle(), image_state->Handle());\n    skip |= LogError(\"VUID-VkRenderingInfo-pNext-06083\", objlist,\n                     rendering_info_loc.dot(Field::pColorAttachments, j).dot(Field::imageView),\n                     \"width (%\" PRIu32\n                     \") must be greater than or equal to\"\n                     \"renderArea.offset.x (%\" PRId32 \") + renderArea.extent.width (%\" PRIu32 \").\",\n                     image_state->create_info.extent.width, offset_x, width);\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkRenderingInfo-pNext-06083\", \"If the pNext chain contains VkDeviceGroupRenderPassBeginInfo, the width of the imageView member of any element of pColorAttachments, pDepthAttachment, or pStencilAttachment that is not VK_NULL_HANDLE must be greater than or equal to the sum of the offset.x and extent.width members of each element of pDeviceRenderAreas\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (image_state->create_info.extent.width < offset_x + width) {\n    const LogObjectList objlist(commandBuffer, depth_view_state->Handle(), image_state->Handle());\n    skip |= LogError(\"VUID-VkRenderingInfo-pNext-06083\", objlist,\n                     rendering_info_loc.dot(Field::pDepthAttachment).dot(Field::imageView),\n                     \"width (%\" PRIu32\n                     \") must be greater than or equal to\"\n                     \"renderArea.offset.x (%\" PRId32 \") + renderArea.extent.width (%\" PRIu32 \").\",\n                     image_state->create_info.extent.width, offset_x, width);\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkRenderingInfo-pNext-06083\", \"If the pNext chain contains VkDeviceGroupRenderPassBeginInfo, the width of the imageView member of any element of pColorAttachments, pDepthAttachment, or pStencilAttachment that is not VK_NULL_HANDLE must be greater than or equal to the sum of the offset.x and extent.width members of each element of pDeviceRenderAreas\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (image_state->create_info.extent.width < offset_x + width) {\n    const LogObjectList objlist(commandBuffer, stencil_view_state->Handle(), image_state->Handle());\n    skip |= LogError(\"VUID-VkRenderingInfo-pNext-06083\", objlist,\n                     rendering_info_loc.dot(Field::pStencilAttachment).dot(Field::imageView),\n                     \"width (%\" PRIu32\n                     \") must be greater than or equal to\"\n                     \"renderArea.offset.x (%\" PRId32 \") + renderArea.extent.width (%\" PRIu32 \").\",\n                     image_state->create_info.extent.width, offset_x, width);\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkRenderingInfo-pNext-06084\", \"If the pNext chain contains VkDeviceGroupRenderPassBeginInfo, the height of the imageView member of any element of pColorAttachments, pDepthAttachment, or pStencilAttachment that is not VK_NULL_HANDLE must be greater than or equal to the sum of the offset.y and extent.height members of each element of pDeviceRenderAreas\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (image_state->create_info.extent.height < offset_y + height) {\n    const LogObjectList objlist(commandBuffer, depth_view_state->Handle(), image_state->Handle());\n    skip |= LogError(\"VUID-VkRenderingInfo-pNext-06084\", objlist,\n                     rendering_info_loc.dot(Field::pDepthAttachment).dot(Field::imageView),\n                     \"height (%\" PRIu32\n                     \") must be greater than or equal to\"\n                     \"renderArea.offset.y (%\" PRId32 \") + renderArea.extent.height (%\" PRIu32 \").\",\n                     image_state->create_info.extent.height, offset_y, height);\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkRenderingInfo-pNext-06084\", \"If the pNext chain contains VkDeviceGroupRenderPassBeginInfo, the height of the imageView member of any element of pColorAttachments, pDepthAttachment, or pStencilAttachment that is not VK_NULL_HANDLE must be greater than or equal to the sum of the offset.y and extent.height members of each element of pDeviceRenderAreas\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (image_state->create_info.extent.height < offset_y + height) {\n    const LogObjectList objlist(commandBuffer, stencil_view_state->Handle(), image_state->Handle());\n    skip |= LogError(\"VUID-VkRenderingInfo-pNext-06084\", objlist,\n                     rendering_info_loc.dot(Field::pStencilAttachment).dot(Field::imageView),\n                     \"height (%\" PRIu32\n                     \") must be greater than or equal to\"\n                     \"renderArea.offset.y (%\" PRId32 \") + renderArea.extent.height(%\" PRIu32 \").\",\n                     image_state->create_info.extent.height, offset_y, height);\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkMultisampledRenderToSingleSampledInfoEXT-rasterizationSamples-06878\", \"The value of rasterizationSamples must not be VK_SAMPLE_COUNT_1_BIT\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (msrtss_info->rasterizationSamples == VK_SAMPLE_COUNT_1_BIT) {\n    skip |= LogError(\"VUID-VkMultisampledRenderToSingleSampledInfoEXT-rasterizationSamples-06878\", commandBuffer,\n                     rendering_info_loc.pNext(Struct::VkMultisampledRenderToSingleSampledInfoEXT, Field::rasterizationSamples),\n                     \"is VK_SAMPLE_COUNT_1_BIT.\");\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-vkCmdBeginRendering-commandBuffer-06068\", \"If commandBuffer is a secondary command buffer, and the nestedCommandBuffer feature is not enabled, pRenderingInfo->flags must not include VK_RENDERING_CONTENTS_SECONDARY_COMMAND_BUFFERS_BIT\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (cb_state->IsSecondary() && ((pRenderingInfo->flags & VK_RENDERING_CONTENTS_SECONDARY_COMMAND_BUFFERS_BIT_KHR) != 0) &&\n    skip |= LogError(\"VUID-vkCmdBeginRendering-commandBuffer-06068\", commandBuffer, rendering_info_loc.dot(Field::flags),\n                     \"must not include VK_RENDERING_CONTENTS_SECONDARY_COMMAND_BUFFERS_BIT_KHR in a secondary command buffer.\");\n"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkRenderingInfo-multisampledRenderToSingleSampled-06857\", \"imageView members of pDepthAttachment, pStencilAttachment, and elements of pColorAttachments that are not VK_NULL_HANDLE must have been created with the same sampleCount , if none of the following are enabled: The VK_AMD_mixed_attachment_samples extension The VK_NV_framebuffer_mixed_samples extension The multisampledRenderToSingleSampled feature,\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (first_sample_count_attachment != image_view->samples) {\n    skip |= LogError(\"VUID-VkRenderingInfo-multisampledRenderToSingleSampled-06857\", objlist,\n                     rendering_info_loc.dot(Field::pDepthAttachment).dot(Field::imageView),\n                     \"has sample count %s, whereas first used color attachment ref has sample count %\" PRIu32 \".\",\n                     string_VkSampleCountFlagBits(image_view->samples), (first_sample_count_attachment));\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkRenderingInfo-multisampledRenderToSingleSampled-06857\", \"imageView members of pDepthAttachment, pStencilAttachment, and elements of pColorAttachments that are not VK_NULL_HANDLE must have been created with the same sampleCount , if none of the following are enabled: The VK_AMD_mixed_attachment_samples extension The VK_NV_framebuffer_mixed_samples extension The multisampledRenderToSingleSampled feature,\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (first_sample_count_attachment != image_view->samples) {\n    skip |= LogError(\"VUID-VkRenderingInfo-multisampledRenderToSingleSampled-06857\", objlist,\n                     rendering_info_loc.dot(Field::pStencilAttachment).dot(Field::imageView),\n                     \"has sample count %s, whereas first used color attachment ref has sample count %\" PRIu32 \".\",\n                     string_VkSampleCountFlagBits(image_view->samples), (first_sample_count_attachment));\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkRenderingInfo-pNext-06077\", \"If the pNext chain does not contain VkDeviceGroupRenderPassBeginInfo or its deviceRenderAreaCount member is equal to 0, renderArea.offset.x must be greater than or equal to 0\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (pRenderingInfo->renderArea.offset.x < 0) {\n    skip |= LogError(\"VUID-VkRenderingInfo-pNext-06077\", commandBuffer,\n                     rendering_info_loc.dot(Field::renderArea).dot(Field::offset).dot(Field::x),\n                     \"is %\" PRId32 \" (offset can't be negative).\", pRenderingInfo->renderArea.offset.x);\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkRenderingInfo-pNext-06078\", \"If the pNext chain does not contain VkDeviceGroupRenderPassBeginInfo or its deviceRenderAreaCount member is equal to 0, renderArea.offset.y must be greater than or equal to 0\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "skip |= LogError(\"VUID-VkRenderingInfo-pNext-06078\", commandBuffer,\n                 rendering_info_loc.dot(Field::renderArea).dot(Field::offset).dot(Field::y),\n                 \"is %\" PRId32 \" (offset can't be negative).\", pRenderingInfo->renderArea.offset.y);\n"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkRenderingInfo-None-08995\", \"If VkDeviceGroupRenderPassBeginInfo::deviceRenderAreaCount is 0, renderArea.extent.height must be greater than 0\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "skip |= LogError(\"VUID-VkRenderingInfo-None-08994\", commandBuffer,\nskip |= LogError(\"VUID-VkRenderingInfo-None-08995\", commandBuffer,\n                 rendering_info_loc.dot(Field::renderArea).dot(Field::extent).dot(Field::height), \"is zero.\");\n"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkRenderingInfo-pNext-07815\", \"If the pNext chain does not contain VkDeviceGroupRenderPassBeginInfo or its deviceRenderAreaCount member is equal to 0, the sum of renderArea.extent.width and renderArea.offset.x must be less than or equal to maxFramebufferWidth\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (x_adjusted_extent > phys_dev_props.limits.maxFramebufferWidth) {\n    skip |= LogError(\"VUID-VkRenderingInfo-pNext-07815\", commandBuffer, rendering_info_loc.dot(Field::renderArea),\n                     \"offset.x (%\" PRId32 \") + extent.width (%\" PRIu32\n                     \") is not less than or equal to maxFramebufferWidth (%\" PRIu32 \").\",\n                     pRenderingInfo->renderArea.offset.x, pRenderingInfo->renderArea.extent.width,\n                     phys_dev_props.limits.maxFramebufferWidth);\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkRenderingInfo-pNext-07816\", \"If the pNext chain does not contain VkDeviceGroupRenderPassBeginInfo or its deviceRenderAreaCount member is equal to 0, the sum of renderArea.extent.height and renderArea.offset.y must be less than or equal to maxFramebufferHeight\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (y_adjusted_extent > phys_dev_props.limits.maxFramebufferHeight) {\n    skip |= LogError(\"VUID-VkRenderingInfo-pNext-07816\", commandBuffer, rendering_info_loc.dot(Field::renderArea),\n                     \"offset.y (%\" PRId32 \") + extent.height (%\" PRIu32\n                     \") is not less than or equal to maxFramebufferHeight (%\" PRIu32 \").\",\n                     pRenderingInfo->renderArea.offset.y, pRenderingInfo->renderArea.extent.height,\n                     phys_dev_props.limits.maxFramebufferHeight);\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkRenderingInfo-pDepthAttachment-06085\", \"If neither pDepthAttachment or pStencilAttachment are NULL and the imageView member of either structure is not VK_NULL_HANDLE, the imageView member of each structure must be the same\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (pRenderingInfo->pDepthAttachment->imageView != pRenderingInfo->pStencilAttachment->imageView) {\n    const LogObjectList objlist(commandBuffer, pRenderingInfo->pDepthAttachment->imageView,\n    skip |= LogError(\"VUID-VkRenderingInfo-pDepthAttachment-06085\", objlist, rendering_info_loc,\n                     \"imageView of pDepthAttachment and pStencilAttachment must be the same.\");\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkRenderingInfo-pDepthAttachment-06086\", \"If neither pDepthAttachment or pStencilAttachment are NULL, and the resolveMode member of each is not VK_RESOLVE_MODE_NONE, the resolveImageView member of each structure must be the same\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (pRenderingInfo->pDepthAttachment->resolveImageView != pRenderingInfo->pStencilAttachment->resolveImageView) {\n    const LogObjectList objlist(commandBuffer, pRenderingInfo->pDepthAttachment->resolveImageView,\n    skip |= LogError(\"VUID-VkRenderingInfo-pDepthAttachment-06086\", objlist, rendering_info_loc,\n                     \"resolveImageView of pDepthAttachment and pStencilAttachment must be the same.\");\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkRenderingInfo-colorAttachmentCount-06087\", \"If colorAttachmentCount is not 0 and the imageView member of an element of pColorAttachments is not VK_NULL_HANDLE, that imageView must have been created with VK_IMAGE_USAGE_COLOR_ATTACHMENT_BIT\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (!(image_state->create_info.usage & VK_IMAGE_USAGE_COLOR_ATTACHMENT_BIT)) {\n    const LogObjectList objlist(commandBuffer, image_view_state->Handle(), image_state->Handle());\n    skip |= LogError(\"VUID-VkRenderingInfo-colorAttachmentCount-06087\", objlist, color_loc.dot(Field::imageView),\n                     \"must have been created with VK_IMAGE_USAGE_COLOR_ATTACHMENT_BIT.\");\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkRenderingInfo-colorAttachmentCount-09479\", \"If colorAttachmentCount is not 0 and the imageView member of an element of pColorAttachments is not VK_NULL_HANDLE, that imageView must have been created with the identity swizzle\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (!IsIdentitySwizzle(components)) {\n    const LogObjectList objlist(commandBuffer, image_view_state->Handle());\n    skip |= LogError(\"VUID-VkRenderingInfo-colorAttachmentCount-09479\", objlist, color_loc.dot(Field::imageView),\n                     \"has a non-identiy swizzle component, here are the actual swizzle values:\\n\"\n                     \"r swizzle = %s\\n\"\n                     \"g swizzle = %s\\n\"\n                     \"b swizzle = %s\\n\"\n                     \"a swizzle = %s\\n\",\n                     string_VkComponentSwizzle(components.r), string_VkComponentSwizzle(components.g),\n                     string_VkComponentSwizzle(components.b), string_VkComponentSwizzle(components.a));\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkRenderingAttachmentInfo-externalFormatResolve-09323\", \"If externalFormatResolve is not enabled, resolveMode must not be VK_RESOLVE_MODE_EXTERNAL_FORMAT_DOWNSAMPLE_ANDROID\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (!enabled_features.externalFormatResolve) {\n    skip |= LogError(\"VUID-VkRenderingAttachmentInfo-externalFormatResolve-09323\", commandBuffer,\n                     color_loc.dot(Field::resolveMode), \"is VK_RESOLVE_MODE_EXTERNAL_FORMAT_DOWNSAMPLE_ANDROID.\");\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkRenderingAttachmentInfo-resolveMode-09324\", \"If resolveMode is VK_RESOLVE_MODE_EXTERNAL_FORMAT_DOWNSAMPLE_ANDROID, resolveImageView must be a valid image view\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (!resolve_view_state) {\n    skip |= LogError(\"VUID-VkRenderingAttachmentInfo-resolveMode-09324\", commandBuffer,\n                     color_loc.dot(Field::resolveImageView), \"is not valid (%s).\",\n                     FormatHandle(attachment_info.resolveImageView).c_str());\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkRenderingAttachmentInfo-nullColorAttachmentWithExternalFormatResolve-09325\", \"If the nullColorAttachmentWithExternalFormatResolve property is VK_TRUE and resolveMode is VK_RESOLVE_MODE_EXTERNAL_FORMAT_DOWNSAMPLE_ANDROID, resolveImageView must have been created with an image with a samples value of VK_SAMPLE_COUNT_1_BIT\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (android_external_format_resolve_null_color_attachment_prop &&\n    skip |= LogError(\"VUID-VkRenderingAttachmentInfo-nullColorAttachmentWithExternalFormatResolve-09325\",\n                     commandBuffer, color_loc.dot(Field::resolveImageView), \"image was created with %s.\",\n                     string_VkSampleCountFlagBits(resolve_view_state->image_state->create_info.samples));\n"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkRenderingAttachmentInfo-resolveMode-09326\", \"If resolveMode is VK_RESOLVE_MODE_EXTERNAL_FORMAT_DOWNSAMPLE_ANDROID, resolveImageView must have been created with an external format specified by VkExternalFormatANDROID\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (!resolve_view_state->image_state->HasAHBFormat()) {\n    skip |= LogError(\"VUID-VkRenderingAttachmentInfo-resolveMode-09326\", commandBuffer,\n                     color_loc.dot(Field::resolveImageView), \"was not created with an external format.\");\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkRenderingAttachmentInfo-resolveMode-09327\", \"If resolveMode is VK_RESOLVE_MODE_EXTERNAL_FORMAT_DOWNSAMPLE_ANDROID, resolveImageView must have been created with a subresourceRange.layerCount of 1\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (resolve_view_state->create_info.subresourceRange.layerCount != 1) {\n    skip |= LogError(\"VUID-VkRenderingAttachmentInfo-resolveMode-09327\", commandBuffer,\n                     color_loc.dot(Field::resolveImageView),\n                     \"was created with subresourceRange.layerCount of %\" PRIu32 \".\",\n                     resolve_view_state->create_info.subresourceRange.layerCount);\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkRenderingAttachmentInfo-resolveMode-09329\", \"If resolveMode is VK_RESOLVE_MODE_EXTERNAL_FORMAT_DOWNSAMPLE_ANDROID and nullColorAttachmentWithExternalFormatResolve is VK_FALSE, imageView must be a valid VkImageView\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "skip |= LogError(\"VUID-VkRenderingAttachmentInfo-resolveMode-09329\", commandBuffer,\n                 color_loc.dot(Field::imageView), \"is not valid.\");\n"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkRenderingInfo-pDepthAttachment-06088\", \"If pDepthAttachment is not NULL and pDepthAttachment->imageView is not VK_NULL_HANDLE, pDepthAttachment->imageView must have been created with VK_IMAGE_USAGE_DEPTH_STENCIL_ATTACHMENT_BIT\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (!(image_state->create_info.usage & VK_IMAGE_USAGE_DEPTH_STENCIL_ATTACHMENT_BIT)) {\n    const LogObjectList objlist(commandBuffer, depth_view_state->Handle(), image_state->Handle());\n    skip |= LogError(\"VUID-VkRenderingInfo-pDepthAttachment-06088\", objlist,\n                     rendering_info_loc.dot(Field::pDepthAttachment).dot(Field::imageView),\n                     \"internal image must have been created with VK_IMAGE_USAGE_DEPTH_STENCIL_ATTACHMENT_BIT.\");\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkRenderingInfo-pDepthAttachment-06547\", \"If pDepthAttachment is not NULL and pDepthAttachment->imageView is not VK_NULL_HANDLE, pDepthAttachment->imageView must have been created with a format that includes a depth component\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (!vkuFormatHasDepth(depth_view_state->create_info.format)) {\n    const LogObjectList objlist(commandBuffer, depth_view_state->Handle());\n    skip |= LogError(\"VUID-VkRenderingInfo-pDepthAttachment-06547\", objlist,\n                     rendering_info_loc.dot(Field::pDepthAttachment).dot(Field::imageView),\n                     \"was created with a format (%s) that does not have a depth aspect.\",\n                     string_VkFormat(depth_view_state->create_info.format));\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkRenderingInfo-pDepthAttachment-09481\", \"If pDepthAttachment is not NULL and pDepthAttachment->imageView is not VK_NULL_HANDLE, pDepthAttachment->imageView must have been created with the identity swizzle\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (!IsIdentitySwizzle(components)) {\n    const LogObjectList objlist(commandBuffer, depth_view_state->Handle());\n    skip |= LogError(\"VUID-VkRenderingInfo-pDepthAttachment-09481\", objlist,\n                     rendering_info_loc.dot(Field::pDepthAttachment).dot(Field::imageView),\n                     \"has a non-identiy swizzle component, here are the actual swizzle values:\\n\"\n                     \"r swizzle = %s\\n\"\n                     \"g swizzle = %s\\n\"\n                     \"b swizzle = %s\\n\"\n                     \"a swizzle = %s\\n\",\n                     string_VkComponentSwizzle(components.r), string_VkComponentSwizzle(components.g),\n                     string_VkComponentSwizzle(components.b), string_VkComponentSwizzle(components.a));\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkRenderingInfo-pDepthAttachment-09482\", \"If pDepthAttachment is not NULL, pDepthAttachment->imageView is not VK_NULL_HANDLE, and pDepthAttachment->resolveMode is not VK_RESOLVE_MODE_NONE, pDepthAttachment->resolveImageView must have been created with the identity swizzle\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (!IsIdentitySwizzle(components)) {\n    const LogObjectList objlist(commandBuffer, depth_resolve_view_state->Handle());\n    skip |= LogError(\"VUID-VkRenderingInfo-pDepthAttachment-09482\", objlist,\n                     rendering_info_loc.dot(Field::pDepthAttachment).dot(Field::resolveImageView),\n                     \"has a non-identiy swizzle component, here are the actual swizzle values:\\n\"\n                     \"r swizzle = %s\\n\"\n                     \"g swizzle = %s\\n\"\n                     \"b swizzle = %s\\n\"\n                     \"a swizzle = %s\\n\",\n                     string_VkComponentSwizzle(components.r), string_VkComponentSwizzle(components.g),\n                     string_VkComponentSwizzle(components.b), string_VkComponentSwizzle(components.a));\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkRenderingInfo-pDepthAttachment-09477\", \"If pDepthAttachment is not NULL and pDepthAttachment->resolveMode is not VK_RESOLVE_MODE_NONE, pDepthAttachment->resolveImageView must have been created with VK_IMAGE_USAGE_DEPTH_STENCIL_ATTACHMENT_BIT\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if ((image_usage & VK_IMAGE_USAGE_DEPTH_STENCIL_ATTACHMENT_BIT) == 0) {\n    const LogObjectList objlist(commandBuffer, depth_resolve_view_state->Handle(),\n    skip |= LogError(\"VUID-VkRenderingInfo-pDepthAttachment-09477\", objlist,\n                     rendering_info_loc.dot(Field::pDepthAttachment).dot(Field::resolveImageView),\n                     \"image was created with %s.\", string_VkImageUsageFlags(image_usage).c_str());\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkRenderingInfo-pStencilAttachment-06089\", \"If pStencilAttachment is not NULL and pStencilAttachment->imageView is not VK_NULL_HANDLE, pStencilAttachment->imageView must have been created with a stencil usage including VK_IMAGE_USAGE_DEPTH_STENCIL_ATTACHMENT_BIT\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (!(image_state->create_info.usage & VK_IMAGE_USAGE_DEPTH_STENCIL_ATTACHMENT_BIT)) {\n    const LogObjectList objlist(commandBuffer, stencil_view_state->Handle(), image_state->Handle());\n    skip |= LogError(\"VUID-VkRenderingInfo-pStencilAttachment-06089\", objlist,\n                     rendering_info_loc.dot(Field::pStencilAttachment).dot(Field::imageView),\n                     \"internal image must have been created with VK_IMAGE_USAGE_DEPTH_STENCIL_ATTACHMENT_BIT.\");\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkRenderingInfo-pStencilAttachment-06548\", \"If pStencilAttachment is not NULL and pStencilAttachment->imageView is not VK_NULL_HANDLE, pStencilAttachment->imageView must have been created with a format that includes a stencil aspect\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (!vkuFormatHasStencil(stencil_view_state->create_info.format)) {\n    const LogObjectList objlist(commandBuffer, stencil_view_state->Handle());\n    skip |= LogError(\"VUID-VkRenderingInfo-pStencilAttachment-06548\", objlist,\n                     rendering_info_loc.dot(Field::pStencilAttachment).dot(Field::imageView),\n                     \"was created with a format (%s) that does not have a stencil aspect.\",\n                     string_VkFormat(stencil_view_state->create_info.format));\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkRenderingInfo-pStencilAttachment-09319\", \"pStencilAttachment->resolveMode must not be VK_RESOLVE_MODE_EXTERNAL_FORMAT_DOWNSAMPLE_ANDROID\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (stencil_attachment_info.resolveMode == VK_RESOLVE_MODE_EXTERNAL_FORMAT_DOWNSAMPLE_ANDROID) {\n    skip |= LogError(\"VUID-VkRenderingInfo-pStencilAttachment-09319\", commandBuffer,\n                     rendering_info_loc.dot(Field::pStencilAttachment).dot(Field::resolveMode),\n                     \"is VK_RESOLVE_MODE_EXTERNAL_FORMAT_DOWNSAMPLE_ANDROID.\");\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkRenderingInfo-pStencilAttachment-09484\", \"If pStencilAttachment is not NULL, pStencilAttachment->imageView is not VK_NULL_HANDLE, and pStencilAttachment->resolveMode is not VK_RESOLVE_MODE_NONE, pStencilAttachment->resolveImageView must have been created with the identity swizzle\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (!IsIdentitySwizzle(components)) {\n    const LogObjectList objlist(commandBuffer, stencil_resolve_view_state->Handle());\n    skip |= LogError(\"VUID-VkRenderingInfo-pStencilAttachment-09484\", objlist,\n                     rendering_info_loc.dot(Field::pStencilAttachment).dot(Field::resolveImageView),\n                     \"has a non-identiy swizzle component, here are the actual swizzle values:\\n\"\n                     \"r swizzle = %s\\n\"\n                     \"g swizzle = %s\\n\"\n                     \"b swizzle = %s\\n\"\n                     \"a swizzle = %s\\n\",\n                     string_VkComponentSwizzle(components.r), string_VkComponentSwizzle(components.g),\n                     string_VkComponentSwizzle(components.b), string_VkComponentSwizzle(components.a));\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkRenderingInfo-pStencilAttachment-09478\", \"If pStencilAttachment is not NULL and pStencilAttachment->resolveMode is not VK_RESOLVE_MODE_NONE, pStencilAttachment->resolveImageView must have been created with VK_IMAGE_USAGE_DEPTH_STENCIL_ATTACHMENT_BIT\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if ((image_usage & VK_IMAGE_USAGE_DEPTH_STENCIL_ATTACHMENT_BIT) == 0) {\n    const LogObjectList objlist(commandBuffer, stencil_resolve_view_state->Handle(),\n    skip |= LogError(\"VUID-VkRenderingInfo-pStencilAttachment-09478\", objlist,\n                     rendering_info_loc.dot(Field::pStencilAttachment).dot(Field::resolveImageView),\n                     \"image was created with %s.\", string_VkImageUsageFlags(image_usage).c_str());\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkRenderingInfo-viewMask-06128\", \"The index of the most significant bit in viewMask must be less than maxMultiviewViewCount\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (MostSignificantBit(pRenderingInfo->viewMask) >= static_cast<int32_t>(phys_dev_props_core11.maxMultiviewViewCount)) {\n    skip |= LogError(\"VUID-VkRenderingInfo-viewMask-06128\", commandBuffer, rendering_info_loc.dot(Field::viewMask),\n                     \"(0x%\" PRIx32 \") most significant bit must be less maxMultiviewViewCount (%\" PRIu32 \")\",\n                     pRenderingInfo->viewMask, phys_dev_props_core11.maxMultiviewViewCount);\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-vkCmdEndRendering-commandBuffer-06162\", \"The current render pass instance must have been begun in commandBuffer\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (cb_state->activeRenderPass->use_dynamic_rendering_inherited == true) {\n    skip |= LogError(\"VUID-vkCmdEndRendering-commandBuffer-06162\", commandBuffer, error_obj.location,\n                     \"in a render pass instance that was not begun in this command buffer.\");\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-vkCmdEndRendering-None-06999\", \"If vkCmdBeginQuery* was called within the render pass, the corresponding vkCmdEndQuery* must have been called subsequently within the same subpass\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "const LogObjectList objlist(commandBuffer, query.pool);\nskip |= LogError(\"VUID-vkCmdEndRendering-None-06999\", objlist, error_obj.location,\n                 \"query %\" PRIu32 \" from %s was began in the render pass, but never ended.\", query.slot,\n                 FormatHandle(query.pool).c_str());\n"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkRenderingInfo-imageView-06858\", \"If multisampled-render-to-single-sampled is enabled, then all attachments referenced by imageView members of pDepthAttachment, pStencilAttachment, and elements of pColorAttachments that are not VK_NULL_HANDLE must have a sample count that is either VK_SAMPLE_COUNT_1_BIT or equal to VkMultisampledRenderToSingleSampledInfoEXT::rasterizationSamples\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if ((image_view_state.samples != VK_SAMPLE_COUNT_1_BIT) && (image_view_state.samples != msrtss_info.rasterizationSamples)) {\n    skip |= LogError(\"VUID-VkRenderingInfo-imageView-06858\", objlist,\n                     rendering_info_loc.pNext(Struct::VkMultisampledRenderToSingleSampledInfoEXT,\n                                              Field::multisampledRenderToSingleSampledEnable),\n                     \"is %s, but %s was created with %s, which is not VK_SAMPLE_COUNT_1_BIT.\",\n                     string_VkSampleCountFlagBits(msrtss_info.rasterizationSamples), attachment_loc.Fields().c_str(),\n                     string_VkSampleCountFlagBits(image_view_state.samples));\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkRenderingInfo-imageView-06859\", \"If multisampled-render-to-single-sampled is enabled, then all attachments referenced by imageView members of pDepthAttachment, pStencilAttachment, and elements of pColorAttachments that are not VK_NULL_HANDLE and have a sample count of VK_SAMPLE_COUNT_1_BIT must have been created with VK_IMAGE_CREATE_MULTISAMPLED_RENDER_TO_SINGLE_SAMPLED_BIT_EXT in their VkImageCreateInfo::flags\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if ((image_view_state.samples == VK_SAMPLE_COUNT_1_BIT) &&\n    skip |= LogError(\"VUID-VkRenderingInfo-imageView-06859\", objlist, attachment_loc,\n                     \"was created with VK_SAMPLE_COUNT_1_BIT but \"\n                     \"VK_IMAGE_CREATE_MULTISAMPLED_RENDER_TO_SINGLE_SAMPLED_BIT_EXT was not set in \"\n                     \"pImageCreateInfo.flags when the image used to create the imageView (%s) was created\",\n                     FormatHandle(image_state->Handle()).c_str());\n"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkFramebufferCreateInfo-samples-07009\", \"If multisampled-render-to-single-sampled is enabled for any subpass, all color, depth/stencil and input attachments used in that subpass which have VkAttachmentDescription::samples or VkAttachmentDescription2::samples equal to VK_SAMPLE_COUNT_1_BIT must have a format that supports the sample count specified in VkMultisampledRenderToSingleSampledInfoEXT::rasterizationSamples\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (!image_state->image_format_properties.sampleCounts) {\n    skip |= GetPhysicalDeviceImageFormatProperties(*image_state.get(), \"VUID-VkFramebufferCreateInfo-samples-07009\",\n                                                   create_info_loc);\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkFramebufferCreateInfo-attachmentCount-00876\", \"attachmentCount must be equal to the attachment count specified in renderPass\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (rpci->attachmentCount != pCreateInfo->attachmentCount) {\n    skip |= LogError(\"VUID-VkFramebufferCreateInfo-attachmentCount-00876\", pCreateInfo->renderPass,\n                     create_info_loc.dot(Field::attachmentCount),\n                     \"%\" PRIu32 \" does not match attachmentCount of %\" PRIu32 \" of %s being used to create Framebuffer.\",\n                     pCreateInfo->attachmentCount, rpci->attachmentCount, FormatHandle(pCreateInfo->renderPass).c_str());\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkFramebufferAttachmentImageInfo-pNext-pNext\", \"pNext must be NULL\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (attachment_image_info->pNext != nullptr) {\n    skip |= LogError(\"VUID-VkFramebufferAttachmentImageInfo-pNext-pNext\", device,\n                     attachment_image_info_loc.dot(Field::pNext), \"is not NULL.\");\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkFramebufferAttachmentImageInfo-viewFormatCount-09536\", \"If viewFormatCount is not 0, and the render pass is not being used with an external format resolve attachment, each element of pViewFormats must not be VK_FORMAT_UNDEFINED\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (*view_format == VK_FORMAT_UNDEFINED && rp_state->create_info.pAttachments[i].format != VK_FORMAT_UNDEFINED) {\n    skip |= LogError(\"VUID-VkFramebufferAttachmentImageInfo-viewFormatCount-09536\", device,\n                     attachment_image_info_loc.dot(Field::pViewFormats, j), \"is VK_FORMAT_UNDEFINED.\");\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkFramebufferCreateInfo-pAttachments-09350\", \"If flags does not include VK_FRAMEBUFFER_CREATE_IMAGELESS_BIT, then if an element of pAttachments has a format of VK_FORMAT_UNDEFINED, it must have been created with a VkExternalFormatANDROID::externalFormat value identical to that provided in the VkExternalFormatANDROID::externalFormat specified by the corresponding VkAttachmentDescription2 in renderPass\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (view_state->image_state->ahb_format != attachment_external_format) {\n    LogObjectList objlist(create_info.renderPass, image_views[i]);\n    skip |= LogError(\"VUID-VkFramebufferCreateInfo-pAttachments-09350\", objlist, attachment_loc,\n                     \"has externalFormat %\" PRIu64 \" that does not match the externalFormat of %\" PRIu64\n                     \" used by the corresponding attachment for %s.\",\n                     view_state->image_state->ahb_format, attachment_external_format,\n                     FormatHandle(create_info.renderPass).c_str());\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkFramebufferCreateInfo-pAttachments-00881\", \"If flags does not include VK_FRAMEBUFFER_CREATE_IMAGELESS_BIT, each element of pAttachments must have been created with a samples value that matches the samples value specified by the corresponding VkAttachmentDescription in renderPass\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (ici.samples != rpci.pAttachments[i].samples) {\n    LogObjectList objlist(create_info.renderPass, image_views[i], ivci.image);\n    skip |= LogError(\"VUID-VkFramebufferCreateInfo-pAttachments-00881\", objlist, attachment_loc,\n                     \"has %s samples that do not match the %s samples used by the corresponding attachment for %s.\",\n                     string_VkSampleCountFlagBits(ici.samples), string_VkSampleCountFlagBits(rpci.pAttachments[i].samples),\n                     FormatHandle(create_info.renderPass).c_str());\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkFramebufferCreateInfo-pAttachments-00883\", \"If flags does not include VK_FRAMEBUFFER_CREATE_IMAGELESS_BIT, each element of pAttachments must only specify a single mip level\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (subresource_range.levelCount != 1) {\n    LogObjectList objlist(create_info.renderPass, image_views[i], ivci.image);\n    skip |= LogError(\"VUID-VkFramebufferCreateInfo-pAttachments-00883\", objlist, attachment_loc,\n                     \"has mip levelCount of %\" PRIu32\n                     \" but only a single mip level (levelCount ==  1) is allowed when creating a Framebuffer.\",\n                     subresource_range.levelCount);\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkFramebufferCreateInfo-renderPass-04536\", \"If renderPass was specified with non-zero view masks, each element of pAttachments that is used as an input, color, resolve, or depth/stencil attachment by renderPass must have a layerCount greater than the index of the most significant bit set in any of those view masks\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (static_cast<int32_t>(subresource_range.layerCount) <= highest_view_bit) {\n    LogObjectList objlist(create_info.renderPass, image_views[i], ivci.image);\n    skip |= LogError(\"VUID-VkFramebufferCreateInfo-renderPass-04536\", objlist, attachment_loc,\n                     \"has a layer count (%\" PRIu32\n                     \") less than or equal to the highest bit in the view mask (%i) of subpass %\" PRIu32 \".\",\n                     subresource_range.layerCount, highest_view_bit, j);\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkFramebufferCreateInfo-flags-04540\", \"If maintenance7 is not enabled or the robustFragmentShadingRateAttachmentAccess limit is VK_FALSE or the imageView member of a VkRenderingFragmentShadingRateAttachmentInfoKHR structure was created with VkImageSubresourceRange::baseMipLevel greater than 0, flags does not include VK_FRAMEBUFFER_CREATE_IMAGELESS_BIT, an element of pAttachments that is used as a fragment shading rate attachment must have a height at least as large as \u2308height / texelHeight\u2309, where texelHeight is the largest value of shadingRateAttachmentTexelSize.height in a VkFragmentShadingRateAttachmentInfoKHR which references that attachment\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (validate_render_area &&\n    LogObjectList objlist(create_info.renderPass, image_views[i], ivci.image);\n    skip |= LogError(\"VUID-VkFramebufferCreateInfo-flags-04540\", objlist, attachment_loc,\n                     \"mip level %\" PRIu32\n                     \" is used as a \"\n                     \"fragment shading rate attachment in subpass %\" PRIu32\n                     \", but the product of its \"\n                     \"height (%\" PRIu32\n                     \") and the \"\n                     \"specified shading rate texel height (%\" PRIu32\n                     \") are smaller than the corresponding \"\n                     \"framebuffer height (%\" PRIu32 \").\",\n                     subresource_range.baseMipLevel, j, mip_height,\n                     fsr_attachment->shadingRateAttachmentTexelSize.height, create_info.height);\n"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkFramebufferCreateInfo-flags-04537\", \"If flags does not include VK_FRAMEBUFFER_CREATE_IMAGELESS_BIT, and renderPass was specified with non-zero view masks, each element of pAttachments that is used as a fragment shading rate attachment by renderPass must have a layerCount that is either 1, or greater than the index of the most significant bit set in any of those view masks\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (static_cast<int32_t>(subresource_range.layerCount) <= highest_view_bit &&\n    LogObjectList objlist(create_info.renderPass, image_views[i], ivci.image);\n    skip |= LogError(\"VUID-VkFramebufferCreateInfo-flags-04537\", objlist, attachment_loc,\n                     \"has a layer count (%\" PRIu32\n                     \") less than or equal to the highest bit in the view mask (%i) of subpass %\" PRIu32 \".\",\n                     subresource_range.layerCount, highest_view_bit, j);\n"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkFramebufferCreateInfo-renderPass-02746\", \"Each element of pAttachments that is referenced by fragmentDensityMapAttachment must have a layerCount equal to 1 or if renderPass was specified with non-zero view masks, greater than the index of the most significant bit set in any of those view masks\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (rp_state.has_multiview_enabled && layer_count != 1 && layer_count <= highest_view_bit) {\n    LogObjectList objlist(create_info.renderPass, image_views[i], ivci.image);\n    skip |= LogError(\"VUID-VkFramebufferCreateInfo-renderPass-02746\", objlist, attachment_loc,\n                     \"has a layer count (%\" PRId32\n                     \") different than 1 or lower than the most significant bit in viewMask (%i\"\n                     \") but renderPass (%s) was specified with non-zero view masks.\",\n                     layer_count, highest_view_bit, FormatHandle(create_info.renderPass).c_str());\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkFramebufferCreateInfo-renderPass-02746\", \"Each element of pAttachments that is referenced by fragmentDensityMapAttachment must have a layerCount equal to 1 or if renderPass was specified with non-zero view masks, greater than the index of the most significant bit set in any of those view masks\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (!rp_state.has_multiview_enabled && layer_count != 1) {\n    LogObjectList objlist(create_info.renderPass, image_views[i], ivci.image);\n    skip |= LogError(\"VUID-VkFramebufferCreateInfo-renderPass-02746\", objlist, attachment_loc,\n                     \"has a layer count (%\" PRIu32\n                     \") not equal to 1 but renderPass (%s) was not specified with non-zero view masks.\",\n                     layer_count, FormatHandle(create_info.renderPass).c_str());\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkFramebufferCreateInfo-pAttachments-02555\", \"If flags does not include VK_FRAMEBUFFER_CREATE_IMAGELESS_BIT, an element of pAttachments that is referenced by fragmentDensityMapAttachment must have a width at least as large as the ceiling of width/maxFragmentDensityTexelSize.width\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (mip_width < ceiling_width) {\n    LogObjectList objlist(create_info.renderPass, image_views[i], ivci.image);\n    skip |= LogError(\"VUID-VkFramebufferCreateInfo-pAttachments-02555\", objlist, attachment_loc,\n                     \"mip level %\" PRIu32\n                     \" has width \"\n                     \"smaller than the corresponding the ceiling of framebuffer width / \"\n                     \"maxFragmentDensityTexelSize.width \"\n                     \"Here are the respective dimensions for attachment #%\" PRIu32\n                     \", the ceiling value:\\n \"\n                     \"attachment #%\" PRIu32\n                     \", framebuffer:\\n\"\n                     \"width: %\" PRIu32 \", the ceiling value: %\" PRIu32 \"\\n\",\n                     subresource_range.baseMipLevel, i, i, mip_width, ceiling_width);\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkFramebufferCreateInfo-pAttachments-02556\", \"If flags does not include VK_FRAMEBUFFER_CREATE_IMAGELESS_BIT, an element of pAttachments that is referenced by fragmentDensityMapAttachment must have a height at least as large as the ceiling of height/maxFragmentDensityTexelSize.height\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (mip_height < ceiling_height) {\n    LogObjectList objlist(create_info.renderPass, image_views[i], ivci.image);\n    skip |= LogError(\"VUID-VkFramebufferCreateInfo-pAttachments-02556\", objlist, attachment_loc,\n                     \"mip level %\" PRIu32\n                     \" has height smaller than the corresponding the ceiling of framebuffer height / \"\n                     \"maxFragmentDensityTexelSize.height \"\n                     \"Here are the respective dimensions for attachment #%\" PRIu32\n                     \", the ceiling value:\\n \"\n                     \"attachment #%\" PRIu32\n                     \", framebuffer:\\n\"\n                     \"height: %\" PRIu32 \", the ceiling value: %\" PRIu32 \"\\n\",\n                     subresource_range.baseMipLevel, i, i, mip_height, ceiling_height);\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkFramebufferCreateInfo-pAttachments-02552\", \"Each element of pAttachments that is used as a fragment density map attachment by renderPass must not have been created with a flags value including VK_IMAGE_CREATE_SUBSAMPLED_BIT_EXT\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if ((ici.flags & VK_IMAGE_CREATE_SUBSAMPLED_BIT_EXT) != 0) {\n    LogObjectList objlist(create_info.renderPass, image_views[i], ivci.image);\n    skip |= LogError(\"VUID-VkFramebufferCreateInfo-pAttachments-02552\", objlist, attachment_loc,\n                        \"must not be created with flag value VK_IMAGE_CREATE_SUBSAMPLED_BIT_EXT if it is \"\n                        \"used as a fragment density map\");\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkFramebufferCreateInfo-renderPass-02553\", \"If renderPass has a fragment density map attachment and the fragmentDensityMapNonSubsampledImages feature is not enabled, each element of pAttachments must have been created with a flags value including VK_IMAGE_CREATE_SUBSAMPLED_BIT_EXT unless that element is the fragment density map attachment\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "LogObjectList objlist(create_info.renderPass, image_views[i], ivci.image);\nskip |= LogError(\"VUID-VkFramebufferCreateInfo-renderPass-02553\", objlist, attachment_loc,\n                 \"is not created with flag value \"\n                 \"VK_IMAGE_CREATE_SUBSAMPLED_BIT_EXT and \"\n                 \"fragmentDensityMapNonSubsampledImages is not enabled\");\n"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkFramebufferCreateInfo-flags-04534\", \"If flags does not include VK_FRAMEBUFFER_CREATE_IMAGELESS_BIT, each element of pAttachments that is used as an input, color, resolve, or depth/stencil attachment by renderPass must have been created with a VkImageCreateInfo::extent.height greater than or equal to height\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (mip_height < create_info.height) {\n    LogObjectList objlist(create_info.renderPass, image_views[i], ivci.image);\n    skip |= LogError(\"VUID-VkFramebufferCreateInfo-flags-04534\", objlist, attachment_loc,\n                     \"mip level %\" PRIu32 \" has height (%\" PRIu32\n                     \") smaller than the corresponding framebuffer height (%\" PRIu32 \").\",\n                     mip_level, mip_height, create_info.height);\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkFramebufferCreateInfo-flags-04535\", \"If flags does not include VK_FRAMEBUFFER_CREATE_IMAGELESS_BIT, each element of pAttachments that is used as an input, color, resolve, or depth/stencil attachment by renderPass must have been created with a VkImageViewCreateInfo::subresourceRange.layerCount greater than or equal to layers\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (layerCount < create_info.layers) {\n    LogObjectList objlist(create_info.renderPass, image_views[i], ivci.image);\n    skip |= LogError(\"VUID-VkFramebufferCreateInfo-flags-04535\", objlist, attachment_loc,\n                     \"has a layer count (%\" PRIu32 \") smaller than the corresponding framebuffer layer count (%\" PRIu32\n                     \").\",\n                     layerCount, create_info.layers);\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkFramebufferCreateInfo-flags-04538\", \"If flags does not include VK_FRAMEBUFFER_CREATE_IMAGELESS_BIT, and renderPass was not specified with non-zero view masks, each element of pAttachments that is used as a fragment shading rate attachment by renderPass must have a layerCount that is either 1, or greater than layers\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (subresource_range.layerCount != 1 && subresource_range.layerCount < create_info.layers) {\n    LogObjectList objlist(create_info.renderPass, image_views[i], ivci.image);\n    skip |= LogError(\"VUID-VkFramebufferCreateInfo-flags-04538\", objlist, attachment_loc,\n                     \"has a layer count (%\" PRIu32\n                     \") \"\n                     \"smaller than the corresponding framebuffer layer count (%\" PRIu32 \").\",\n                     subresource_range.layerCount, create_info.layers);\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkFramebufferCreateInfo-pAttachments-00884\", \"If flags does not include VK_FRAMEBUFFER_CREATE_IMAGELESS_BIT, each element of pAttachments must have been created with the identity swizzle\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (IsIdentitySwizzle(ivci.components) == false) {\n    LogObjectList objlist(create_info.renderPass, image_views[i]);\n    skip |= LogError(\"VUID-VkFramebufferCreateInfo-pAttachments-00884\", objlist, attachment_loc,\n                     \"has non-identy swizzle. All \"\n                     \"framebuffer attachments must have been created with the identity swizzle. Here are the actual \"\n                     \"swizzle values:\\n\"\n                     \"r swizzle = %s\\n\"\n                     \"g swizzle = %s\\n\"\n                     \"b swizzle = %s\\n\"\n                     \"a swizzle = %s\\n\",\n                     string_VkComponentSwizzle(ivci.components.r), string_VkComponentSwizzle(ivci.components.g),\n                     string_VkComponentSwizzle(ivci.components.b), string_VkComponentSwizzle(ivci.components.a));\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkFramebufferCreateInfo-flags-04113\", \"If flags does not include VK_FRAMEBUFFER_CREATE_IMAGELESS_BIT, each element of pAttachments must have been created with VkImageViewCreateInfo::viewType not equal to VK_IMAGE_VIEW_TYPE_3D\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (ivci.viewType == VK_IMAGE_VIEW_TYPE_3D) {\n    LogObjectList objlist(create_info.renderPass, image_views[i]);\n    skip |= LogError(\"VUID-VkFramebufferCreateInfo-flags-04113\", objlist, attachment_loc,\n                     \"has an image view type of VK_IMAGE_VIEW_TYPE_3D.\");\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkFramebufferCreateInfo-flags-03205\", \"If flags includes VK_FRAMEBUFFER_CREATE_IMAGELESS_BIT, at least one element of the pViewFormats member of any element of the pAttachmentImageInfos member of a VkFramebufferAttachmentsCreateInfo structure included in the pNext chain must be equal to the corresponding value of VkAttachmentDescription::format used to create renderPass\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (!format_found) {\n    skip |= LogError(\"VUID-VkFramebufferCreateInfo-flags-03205\", create_info.renderPass,\n                     create_info_loc.pNext(Struct::VkFramebufferAttachmentsCreateInfo, Field::pAttachmentImageInfos, i)\n                         .dot(Field::pViewFormats),\n                     \"does not include format %s used by the corresponding attachment for renderPass (%s).\",\n                     string_VkFormat(rpci.pAttachments[i].format), FormatHandle(create_info.renderPass).c_str());\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkFramebufferCreateInfo-flags-04543\", \"If maintenance7 is not enabled or the robustFragmentShadingRateAttachmentAccess limit is VK_FALSE or the imageView member of a VkRenderingFragmentShadingRateAttachmentInfoKHR structure was created with VkImageSubresourceRange::baseMipLevel greater than 0, and flags includes VK_FRAMEBUFFER_CREATE_IMAGELESS_BIT, the width member of any element of the pAttachmentImageInfos member of a VkFramebufferAttachmentsCreateInfo structure in the pNext chain that is used as a fragment shading rate attachment must be greater than or equal to \u2308width / texelWidth\u2309, where texelWidth is the largest value of shadingRateAttachmentTexelSize.width in a VkFragmentShadingRateAttachmentInfoKHR which references that attachment\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (validate_render_area &&\n    (aii.width * fsr_attachment->shadingRateAttachmentTexelSize.width) < create_info.width) {\n    skip |= LogError(\"VUID-VkFramebufferCreateInfo-flags-04543\", create_info.renderPass, attachment_loc,\n                     \"is used as a fragment shading rate attachment in subpass %\" PRIu32\n                     \", but the product of its width (%\" PRIu32\n                     \") and the \"\n                     \"specified shading rate texel width (%\" PRIu32\n                     \") are smaller than the corresponding framebuffer \"\n                     \"width (%\" PRIu32 \").\",\n                     j, aii.width, fsr_attachment->shadingRateAttachmentTexelSize.width, create_info.width);\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkFramebufferCreateInfo-flags-04544\", \"If maintenance7 is not enabled or the robustFragmentShadingRateAttachmentAccess limit is VK_FALSE or the imageView member of a VkRenderingFragmentShadingRateAttachmentInfoKHR structure was created with VkImageSubresourceRange::baseMipLevel greater than 0, and flags includes VK_FRAMEBUFFER_CREATE_IMAGELESS_BIT, the height member of any element of the pAttachmentImageInfos member of a VkFramebufferAttachmentsCreateInfo structure in the pNext chain that is used as a fragment shading rate attachment must be greater than or equal to \u2308height / texelHeight\u2309, where texelHeight is the largest value of shadingRateAttachmentTexelSize.height in a VkFragmentShadingRateAttachmentInfoKHR which references that attachment\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (validate_render_area &&\n    (aii.height * fsr_attachment->shadingRateAttachmentTexelSize.height) < create_info.height) {\n    skip |= LogError(\"VUID-VkFramebufferCreateInfo-flags-04544\", create_info.renderPass, attachment_loc,\n                     \"is used as a fragment shading rate attachment in subpass %\" PRIu32\n                     \", but the product of its \"\n                     \"height (%\" PRIu32\n                     \") and the \"\n                     \"specified shading rate texel height (%\" PRIu32\n                     \") are smaller than the corresponding \"\n                     \"framebuffer height (%\" PRIu32 \").\",\n                     j, aii.height, fsr_attachment->shadingRateAttachmentTexelSize.height, create_info.height);\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkFramebufferCreateInfo-flags-03196\", \"If flags includes VK_FRAMEBUFFER_CREATE_IMAGELESS_BIT, the width member of any element of the pAttachmentImageInfos member of a VkFramebufferAttachmentsCreateInfo structure in the pNext chain that is referenced by VkRenderPassFragmentDensityMapCreateInfoEXT::fragmentDensityMapAttachment in renderPass must be greater than or equal to the ceiling of width/maxFragmentDensityTexelSize.width\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (aii.width < ceiling_width) {\n    LogObjectList objlist(create_info.renderPass);\n    skip |= LogError(\"VUID-VkFramebufferCreateInfo-flags-03196\", objlist, attachment_loc,\n                     \"is used as a fragment density map attachment in subpass %\" PRIu32\n                     \", but the quotient of the framebuffer width (%\" PRIu32\n                     \") and the allowed maximum fragment density texel width (%\" PRIu32\n                     \") is greater than the corresponding fragment density attachment \"\n                     \"width (%\" PRIu32 \").\",\n                     j, create_info.width, maxFragmentDensityTexelSize.width, aii.width);\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkFramebufferCreateInfo-flags-03197\", \"If flags includes VK_FRAMEBUFFER_CREATE_IMAGELESS_BIT, the height member of any element of the pAttachmentImageInfos member of a VkFramebufferAttachmentsCreateInfo structure included in the pNext chain that is referenced by VkRenderPassFragmentDensityMapCreateInfoEXT::fragmentDensityMapAttachment in renderPass must be greater than or equal to the ceiling of height/maxFragmentDensityTexelSize.height\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (aii.height < ceiling_height) {\n    LogObjectList objlist(create_info.renderPass);\n    skip |= LogError(\"VUID-VkFramebufferCreateInfo-flags-03197\", objlist, attachment_loc,\n                     \"is used as a fragment density map attachment in subpass %\" PRIu32\n                     \", but the quotient of the framebuffer height (%\" PRIu32\n                     \") and the allowed maximum fragment density texel height (%\" PRIu32\n                     \") is greater than the corresponding fragment density attachment \"\n                     \"height (%\" PRIu32 \").\",\n                     j, create_info.height, maxFragmentDensityTexelSize.height, aii.height);\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkFramebufferCreateInfo-flags-04541\", \"If flags includes VK_FRAMEBUFFER_CREATE_IMAGELESS_BIT, the width member of any element of the pAttachmentImageInfos member of a VkFramebufferAttachmentsCreateInfo structure in the pNext chain that is used as an input, color, resolve or depth/stencil attachment in renderPass must be greater than or equal to width\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (aii.width < create_info.width) {\n    skip |= LogError(\"VUID-VkFramebufferCreateInfo-flags-04541\", create_info.renderPass, attachment_loc,\n                     \"has a width of only %\" PRIu32 \", but framebuffer has a width of %\" PRIu32 \".\", aii.width,\n                     create_info.width);\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkFramebufferCreateInfo-flags-04542\", \"If flags includes VK_FRAMEBUFFER_CREATE_IMAGELESS_BIT, the height member of any element of the pAttachmentImageInfos member of a VkFramebufferAttachmentsCreateInfo structure in the pNext chain that is used as an input, color, resolve or depth/stencil attachment in renderPass must be greater than or equal to height\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (aii.height < create_info.height) {\n    skip |= LogError(\"VUID-VkFramebufferCreateInfo-flags-04542\", create_info.renderPass, attachment_loc,\n                     \"has a height of only %\" PRIu32 \", but framebuffer has a height of %\" PRIu32 \".\", aii.height,\n                     create_info.height);\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkFramebufferCreateInfo-flags-04545\", \"If flags includes VK_FRAMEBUFFER_CREATE_IMAGELESS_BIT, the layerCount member of any element of the pAttachmentImageInfos member of a VkFramebufferAttachmentsCreateInfo structure in the pNext chain that is used as a fragment shading rate attachment must be either 1, or greater than or equal to layers\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (aii.layerCount != 1 && aii.layerCount < create_info.layers) {\n    skip |= LogError(\"VUID-VkFramebufferCreateInfo-flags-04545\", create_info.renderPass, attachment_loc,\n                     \"has a layer count (%\" PRIu32 \") smaller than the corresponding framebuffer layer count (%\" PRIu32\n                     \").\",\n                     aii.layerCount, create_info.layers);\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkFramebufferCreateInfo-renderPass-03198\", \"If multiview is enabled for renderPass and flags includes VK_FRAMEBUFFER_CREATE_IMAGELESS_BIT, the layerCount member of any element of the pAttachmentImageInfos member of a VkFramebufferAttachmentsCreateInfo structure included in the pNext chain used as an input, color, resolve, or depth/stencil attachment in renderPass must be greater than the maximum bit index set in the view mask in the subpasses in which it is used in renderPass\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (layer_count <= highest_view_bit) {\n    skip |= LogError(\"VUID-VkFramebufferCreateInfo-renderPass-03198\", create_info.renderPass,\n                     create_info_loc\n                         .pNext(Struct::VkFramebufferAttachmentsCreateInfo, Field::pAttachmentImageInfos,\n                                attachment_index)\n                         .dot(Field::layerCount),\n                     \"is %\" PRId32 \", but the view mask for subpass %\" PRIu32\n                     \" in renderPass (%s) \"\n                     \"includes layer %i, with that attachment specified as a depth/stencil resolve \"\n                     \"attachment.\",\n                     layer_count, i, FormatHandle(create_info.renderPass).c_str(), highest_view_bit);\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-vkDestroyFramebuffer-framebuffer-00892\", \"All submitted commands that refer to framebuffer must have completed execution\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (auto framebuffer_state = Get<vvl::Framebuffer>(framebuffer)) {\n    skip |= ValidateObjectNotInUse(framebuffer_state.get(), error_obj.location, \"VUID-vkDestroyFramebuffer-framebuffer-00892\");\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-vkCmdExecuteCommands-pCommandBuffers-00099\", \"If vkCmdExecuteCommands is being called within a render pass instance, and any element of pCommandBuffers was recorded with VkCommandBufferInheritanceInfo::framebuffer not equal to VK_NULL_HANDLE, that VkFramebuffer must match the VkFramebuffer used in the current render pass instance\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (primary_fb != secondary_fb) {\n    const LogObjectList objlist(primaryBuffer, secondaryBuffer, secondary_fb, primary_fb);\n    skip |= LogError(\"VUID-vkCmdExecuteCommands-pCommandBuffers-00099\", objlist, loc,\n                     \"called w/ invalid secondary %s which has a %s\"\n                     \" that is not the same as the primary command buffer's current active %s.\",\n                     FormatHandle(secondaryBuffer).c_str(), FormatHandle(secondary_fb).c_str(),\n                     FormatHandle(primary_fb).c_str());\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkRenderingAttachmentLocationInfoKHR-pColorAttachmentLocations-09513\", \"Elements of pColorAttachmentLocations that are not VK_ATTACHMENT_UNUSED must each be unique\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (unique.find(location) != unique.end()) {\n    skip |= LogError(\"VUID-VkRenderingAttachmentLocationInfoKHR-pColorAttachmentLocations-09513\", objlist, loc,\n                     \"= %\" PRIu32 \" have same value as pColorAttachmentLocations[%\" PRIu32 \"] = %\" PRIu32, location,\n                     unique[location], location);\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkRenderingAttachmentLocationInfoKHR-pColorAttachmentLocations-09515\", \"Each element of pColorAttachmentLocations must be less than maxColorAttachments\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (location >= phys_dev_props.limits.maxColorAttachments) {\n    skip |= LogError(\"VUID-VkRenderingAttachmentLocationInfoKHR-pColorAttachmentLocations-09515\", objlist, loc,\n                     \"= %\" PRIu32 \" that is greater than the maxColorAttachments limit (%\" PRIu32 \")\", location,\n                     phys_dev_props.limits.maxColorAttachments);\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkRenderingAttachmentLocationInfoKHR-colorAttachmentCount-09514\", \"colorAttachmentCount must be less than or equal to maxColorAttachments\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (location_info.colorAttachmentCount > phys_dev_props.limits.maxColorAttachments) {\n    skip |= LogError(\"VUID-VkRenderingAttachmentLocationInfoKHR-colorAttachmentCount-09514\", objlist,\n                     loc_info.dot(Field::colorAttachmentCount),\n                     \"(%\" PRIu32 \") is greater than the maxColorAttachments limit (%\" PRIu32 \").\",\n                     location_info.colorAttachmentCount, phys_dev_props.limits.maxColorAttachments);\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-vkCmdSetRenderingAttachmentLocationsKHR-dynamicRenderingLocalRead-09509\", \"dynamicRenderingLocalRead must be enabled\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (!enabled_features.dynamicRenderingLocalRead) {\n    skip |= LogError(\"VUID-vkCmdSetRenderingAttachmentLocationsKHR-dynamicRenderingLocalRead-09509\", commandBuffer, loc_info,\n                     \"dynamicRenderingLocalRead was not enabled.\");\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-vkCmdSetRenderingAttachmentLocationsKHR-pLocationInfo-09510\", \"pLocationInfo->colorAttachmentCount must be equal to the value of VkRenderingInfo::colorAttachmentCount used to begin the current render pass instance\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (pLocationInfo->colorAttachmentCount != rp_state.dynamic_rendering_begin_rendering_info.colorAttachmentCount) {\n    const LogObjectList objlist(commandBuffer, rp_state.VkHandle());\n    skip |= LogError(\"VUID-vkCmdSetRenderingAttachmentLocationsKHR-pLocationInfo-09510\", objlist,\n                     error_obj.location.dot(Field::pLocationInfo).dot(Field::colorAttachmentCount),\n                     \"= %\" PRIu32 \" is not equal to count specified in VkRenderingInfo (%\" PRIu32 \").\",\n                     pLocationInfo->colorAttachmentCount, rp_state.dynamic_rendering_begin_rendering_info.colorAttachmentCount);\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkRenderingInputAttachmentIndexInfoKHR-dynamicRenderingLocalRead-09520\", \"If the dynamicRenderingLocalRead feature is not enabled, pDepthInputAttachmentIndex must be a valid pointer to a value of VK_ATTACHMENT_UNUSED\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (*index_info.pDepthInputAttachmentIndex != VK_ATTACHMENT_UNUSED) {\n    skip |= LogError(\"VUID-VkRenderingInputAttachmentIndexInfoKHR-dynamicRenderingLocalRead-09520\", objlist,\n                     loc_info.dot(Struct::VkRenderingInputAttachmentIndexInfoKHR, Field::pDepthInputAttachmentIndex, 0),\n                     \"= %\" PRIu32 \" while must be VK_ATTACHMENT_UNUSED\", *index_info.pDepthInputAttachmentIndex);\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkRenderingInputAttachmentIndexInfoKHR-pColorAttachmentInputIndices-09523\", \"Elements of pColorAttachmentInputIndices that are not VK_ATTACHMENT_UNUSED must not take the same value as the content of pDepthInputAttachmentIndex\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (index_info.pDepthInputAttachmentIndex && *index_info.pDepthInputAttachmentIndex != VK_ATTACHMENT_UNUSED &&\n    const Location loc = loc_info.dot(Struct::VkRenderingInputAttachmentIndexInfoKHR, Field::pDepthInputAttachmentIndex, 0);\n    skip |= LogError(\"VUID-VkRenderingInputAttachmentIndexInfoKHR-pColorAttachmentInputIndices-09523\", objlist, loc,\n                     \"= %\" PRIu32 \" have same value as in pColorAttachmentInputIndices[%\" PRIu32 \"] = %\" PRIu32,\n                     *index_info.pDepthInputAttachmentIndex, unique[*index_info.pDepthInputAttachmentIndex],\n                     index_info.pColorAttachmentInputIndices[unique[*index_info.pDepthInputAttachmentIndex]]);\n"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkRenderingInputAttachmentIndexInfoKHR-pColorAttachmentInputIndices-09524\", \"Elements of pColorAttachmentInputIndices that are not VK_ATTACHMENT_UNUSED must not take the same value as the content of pStencilInputAttachmentIndex\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "const Location loc =\n    loc_info.dot(Struct::VkRenderingInputAttachmentIndexInfoKHR, Field::pStencilInputAttachmentIndex, 0);\nskip |= LogError(\"VUID-VkRenderingInputAttachmentIndexInfoKHR-pColorAttachmentInputIndices-09524\", objlist, loc,\n                 \"= %\" PRIu32 \" have same value as in pColorAttachmentInputIndices[%\" PRIu32 \"] = %\" PRIu32,\n                 *index_info.pStencilInputAttachmentIndex, unique[*index_info.pStencilInputAttachmentIndex],\n                 index_info.pColorAttachmentInputIndices[unique[*index_info.pStencilInputAttachmentIndex]]);\n"
        },
        {
            "role": "user",
            "content": "{\"VUID-vkCmdSetRenderingInputAttachmentIndicesKHR-dynamicRenderingLocalRead-09516\", \"dynamicRenderingLocalRead must be enabled\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (!enabled_features.dynamicRenderingLocalRead) {\n    skip |= LogError(\"VUID-vkCmdSetRenderingInputAttachmentIndicesKHR-dynamicRenderingLocalRead-09516\", commandBuffer, error_obj.location,\n                     \"dynamicRenderingLocalRead was not enabled.\");\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-vkCmdSetRenderingInputAttachmentIndicesKHR-commandBuffer-09518\", \"The current render pass instance must have been started or resumed by vkCmdBeginRendering in this commandBuffer\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (!rp_state.UsesDynamicRendering()) {\n    const LogObjectList objlist =\n        rp_state_ptr ? LogObjectList(commandBuffer, rp_state_ptr->VkHandle()) : LogObjectList(commandBuffer);\n    skip |= LogError(\"VUID-vkCmdSetRenderingInputAttachmentIndicesKHR-commandBuffer-09518\", objlist, error_obj.location,\n                     \"vkCmdBeginRendering was not called.\");\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-vkCmdSetRenderingInputAttachmentIndicesKHR-pInputAttachmentIndexInfo-09517\", \"pInputAttachmentIndexInfo->colorAttachmentCount must be equal to the value of VkRenderingInfo::colorAttachmentCount used to begin the current render pass instance\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "const LogObjectList objlist(commandBuffer, rp_state.VkHandle());\nconst Location loc = error_obj.location.dot(Struct::VkRenderingInputAttachmentIndexInfoKHR, Field::colorAttachmentCount);\nskip |= LogError(\"VUID-vkCmdSetRenderingInputAttachmentIndicesKHR-pInputAttachmentIndexInfo-09517\", objlist, loc,\n                 \"= %\" PRIu32 \" is not equal to the attachment count the render pass being begun (%\" PRIu32 \")\",\n                 pLocationInfo->colorAttachmentCount, rp_state.create_info.attachmentCount);\n"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkGraphicsPipelineCreateInfo-Input-07904\", \"If the pipeline is being created with vertex input state and pVertexInputState is not dynamic, then all variables with the Input storage class decorated with Location in the Vertex Execution Model OpEntryPoint must contain a location in VkVertexInputAttributeDescription::location\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "skip |= LogPerformanceWarning(\"WARNING-Shader-OutputNotConsumed\", module_state.handle(), vi_loc,\nskip |= LogError(\"VUID-VkGraphicsPipelineCreateInfo-Input-07904\", module_state.handle(),\n                 vi_loc.dot(Field::pVertexAttributeDescriptions),\n                 \"does not have a Location %\" PRIu32 \" but vertex shader has an input variable at that Location.\",\n                 location);\n"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkGraphicsPipelineCreateInfo-pStages-00739\", \"If the pipeline requires pre-rasterization shader state and pStages includes a geometry shader stage, and also includes tessellation shader stages, its shader code must contain an OpExecutionMode instruction specifying an input primitive type that is compatible with the primitive topology that is output by the tessellation stages\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (has_tess) {\n    skip |= LogError(\"VUID-VkGraphicsPipelineCreateInfo-pStages-00739\", module_state.handle(), loc,\n                     \"SPIR-V (Geometry stage) expects input topology %s, but tessellation evaluation shader output topology is %s.\",\n                     string_VkPrimitiveTopology(geom_topology), string_VkPrimitiveTopology(topology));\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkGraphicsPipelineCreateInfo-pStages-00738\", \"If the pipeline requires pre-rasterization shader state and pStages includes a geometry shader stage, and does not include any tessellation shader stages, its shader code must contain an OpExecutionMode instruction specifying an input primitive type that is compatible with the primitive topology specified in pInputAssembly\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "skip |= LogError(\"VUID-VkGraphicsPipelineCreateInfo-pStages-00738\", module_state.handle(), loc,\n                 \"SPIR-V (Geometry stage) expects input topology %s, but pipeline was created with primitive topology %s.\",\n                 string_VkPrimitiveTopology(geom_topology), string_VkPrimitiveTopology(topology));\n"
        },
        {
            "role": "user",
            "content": "{\"VUID-RuntimeSpirv-Location-06272\", \"The sum of Location and the number of locations the variable it decorates consumes must be less than or equal to the value for the matching Execution Model defined in Shader Input and Output Locations\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (total_output_components >= limits.maxVertexOutputComponents) {\n    skip |= LogError(\"VUID-RuntimeSpirv-Location-06272\", module_state.handle(), loc,\n                     \"SPIR-V (Vertex stage) output interface variable (%s) along with %\" PRIu32\n                     \" built-in components,  \"\n                     \"exceeds component limit maxVertexOutputComponents (%\" PRIu32 \").\",\n                     max_output_slot.Describe().c_str(), entrypoint.builtin_output_components,\n                     limits.maxVertexOutputComponents);\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-RuntimeSpirv-Location-06272\", \"The sum of Location and the number of locations the variable it decorates consumes must be less than or equal to the value for the matching Execution Model defined in Shader Input and Output Locations\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (max_input_slot.slot >= limits.maxTessellationControlPerVertexInputComponents) {\n    skip |= LogError(\"VUID-RuntimeSpirv-Location-06272\", module_state.handle(), loc,\n                     \"SPIR-V (Tessellation control stage) input interface variable (%s) \"\n                     \"exceeds component limit maxTessellationControlPerVertexInputComponents (%\" PRIu32 \").\",\n                     max_input_slot.Describe().c_str(), limits.maxTessellationControlPerVertexInputComponents);\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-RuntimeSpirv-Location-06272\", \"The sum of Location and the number of locations the variable it decorates consumes must be less than or equal to the value for the matching Execution Model defined in Shader Input and Output Locations\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (!entrypoint.max_input_slot_variable->is_patch &&\n    skip |= LogError(\"VUID-RuntimeSpirv-Location-06272\", module_state.handle(), loc,\n                     \"SPIR-V (Tessellation control stage) output interface variable (%s) \"\n                     \"exceeds component limit maxTessellationControlPerVertexOutputComponents (%\" PRIu32 \").\",\n                     max_output_slot.Describe().c_str(), limits.maxTessellationControlPerVertexOutputComponents);\n"
        },
        {
            "role": "user",
            "content": "{\"VUID-RuntimeSpirv-Location-06272\", \"The sum of Location and the number of locations the variable it decorates consumes must be less than or equal to the value for the matching Execution Model defined in Shader Input and Output Locations\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (max_input_slot.slot >= limits.maxTessellationEvaluationInputComponents) {\n    skip |= LogError(\"VUID-RuntimeSpirv-Location-06272\", module_state.handle(), loc,\n                     \"SPIR-V (Tessellation evaluation stage) input interface variable (%s) \"\n                     \"exceeds component limit maxTessellationEvaluationInputComponents (%\" PRIu32 \").\",\n                     max_input_slot.Describe().c_str(), limits.maxTessellationEvaluationInputComponents);\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-RuntimeSpirv-Location-06272\", \"The sum of Location and the number of locations the variable it decorates consumes must be less than or equal to the value for the matching Execution Model defined in Shader Input and Output Locations\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (max_output_slot.slot >= limits.maxTessellationEvaluationOutputComponents) {\n    skip |= LogError(\"VUID-RuntimeSpirv-Location-06272\", module_state.handle(), loc,\n                     \"SPIR-V (Tessellation evaluation stage) output interface variable (%s) \"\n                     \"exceeds component limit maxTessellationEvaluationOutputComponents (%\" PRIu32 \").\",\n                     max_output_slot.Describe().c_str(), limits.maxTessellationEvaluationOutputComponents);\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-RuntimeSpirv-Location-06272\", \"The sum of Location and the number of locations the variable it decorates consumes must be less than or equal to the value for the matching Execution Model defined in Shader Input and Output Locations\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (total_input_components >= limits.maxGeometryInputComponents) {\n    skip |= LogError(\"VUID-RuntimeSpirv-Location-06272\", module_state.handle(), loc,\n                     \"SPIR-V (Geometry stage) input interface variable (%s) along with %\" PRIu32\n                     \" built-in components,  \"\n                     \"exceeds component limit maxGeometryInputComponents (%\" PRIu32 \").\",\n                     max_input_slot.Describe().c_str(), entrypoint.builtin_input_components,\n                     limits.maxGeometryInputComponents);\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-RuntimeSpirv-Location-06272\", \"The sum of Location and the number of locations the variable it decorates consumes must be less than or equal to the value for the matching Execution Model defined in Shader Input and Output Locations\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (total_input_components >= limits.maxFragmentInputComponents) {\n    skip |= LogError(\"VUID-RuntimeSpirv-Location-06272\", module_state.handle(), loc,\n                     \"SPIR-V (Fragment stage) input interface variable (%s) along with %\" PRIu32\n                     \" built-in components,  \"\n                     \"exceeds component limit maxFragmentInputComponents (%\" PRIu32 \").\",\n                     max_input_slot.Describe().c_str(), entrypoint.builtin_input_components,\n                     limits.maxFragmentInputComponents);\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-RuntimeSpirv-tessellationShader-06326\", \"If tessellationShader is enabled, and the VK_KHR_portability_subset extension is enabled, and VkPhysicalDevicePortabilitySubsetFeaturesKHR::tessellationIsolines is VK_FALSE, then OpExecutionMode must not be set to IsoLines\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (is_iso_lines && (VK_FALSE == enabled_features.tessellationIsolines)) {\n    skip |= LogError(\"VUID-RuntimeSpirv-tessellationShader-06326\", module_state.handle(), loc,\n                     \"(portability error) SPIR-V (Tessellation evaluation stage)\"\n                     \" is using abstract patch type IsoLines, but this is not supported on this platform.\");\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-RuntimeSpirv-tessellationShader-06327\", \"If tessellationShader is enabled, and the VK_KHR_portability_subset extension is enabled, and VkPhysicalDevicePortabilitySubsetFeaturesKHR::tessellationPointMode is VK_FALSE, then OpExecutionMode must not be set to PointMode\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (is_point_mode && (VK_FALSE == enabled_features.tessellationPointMode)) {\n    skip |= LogError(\"VUID-RuntimeSpirv-tessellationShader-06327\", module_state.handle(), loc,\n                     \"(portability error) SPIR-V (Tessellation evaluation stage)\"\n                     \" is using abstract patch type PointMode, but this is not supported on this platform.\");\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-RuntimeSpirv-MeshNV-07113\", \"For mesh shaders using the MeshNV Execution Model the OutputVertices OpExecutionMode must be less than or equal to VkPhysicalDeviceMeshShaderPropertiesNV::maxMeshOutputVertices\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (num_vertices > phys_dev_ext_props.mesh_shader_props_nv.maxMeshOutputVertices) {\n    skip |= LogError(\"VUID-RuntimeSpirv-MeshNV-07113\", module_state.handle(), loc,\n                     \"SPIR-V (Mesh stage) output vertices count exceeds the \"\n                     \"maxMeshOutputVertices of %\" PRIu32 \" by %\" PRIu32 \".\",\n                     phys_dev_ext_props.mesh_shader_props_nv.maxMeshOutputVertices,\n                     num_vertices - phys_dev_ext_props.mesh_shader_props_nv.maxMeshOutputVertices);\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-RuntimeSpirv-MeshEXT-07115\", \"For mesh shaders using the MeshEXT Execution Model the OutputVertices OpExecutionMode must be less than or equal to VkPhysicalDeviceMeshShaderPropertiesEXT::maxMeshOutputVertices\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (num_vertices > phys_dev_ext_props.mesh_shader_props_ext.maxMeshOutputVertices) {\n    skip |= LogError(\"VUID-RuntimeSpirv-MeshEXT-07115\", module_state.handle(), loc,\n                     \"SPIR-V (Mesh stage) output vertices count exceeds the \"\n                     \"maxMeshOutputVertices of %\" PRIu32 \" by %\" PRIu32 \".\",\n                     phys_dev_ext_props.mesh_shader_props_ext.maxMeshOutputVertices,\n                     num_vertices - phys_dev_ext_props.mesh_shader_props_ext.maxMeshOutputVertices);\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-RuntimeSpirv-MeshEXT-07116\", \"For mesh shaders using the MeshEXT Execution Model the OutputPrimitivesEXT OpExecutionMode must be less than or equal to VkPhysicalDeviceMeshShaderPropertiesEXT::maxMeshOutputPrimitives\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (num_primitives > phys_dev_ext_props.mesh_shader_props_ext.maxMeshOutputPrimitives) {\n    skip |= LogError(\"VUID-RuntimeSpirv-MeshEXT-07116\", module_state.handle(), loc,\n                     \"SPIR-V (Mesh stage) output primitives count exceeds the \"\n                     \"maxMeshOutputPrimitives of %\" PRIu32 \" by %\" PRIu32 \".\",\n                     phys_dev_ext_props.mesh_shader_props_ext.maxMeshOutputPrimitives,\n                     num_primitives - phys_dev_ext_props.mesh_shader_props_ext.maxMeshOutputPrimitives);\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-RuntimeSpirv-Location-06428\", \"The maximum number of storage buffers, storage images, and output Location decorated color attachments written to in the Fragment Execution Model must be less than or equal to maxFragmentCombinedOutputResources\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (total_output > limits.maxFragmentCombinedOutputResources) {\n    skip |= LogError(\"VUID-RuntimeSpirv-Location-06428\", module_state.handle(), loc,\n                     \"SPIR-V (Fragment stage) output contains %zu storage buffer bindings, %zu storage image bindings, and \"\n                     \"%zu color attachments which together is %\" PRIu32\n                     \" which exceeds the limit maxFragmentCombinedOutputResources (%\" PRIu32 \").\",\n                     storage_buffers.size(), storage_images.size(), color_attachments.size(), total_output,\n                     limits.maxFragmentCombinedOutputResources);\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-RuntimeSpirv-OpEntryPoint-07754\", \"Any user-defined variables between the OpEntryPoint of two shader stages must have the same type and width for each Component\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if ((component_info.output_type != component_info.input_type) ||\n    const LogObjectList objlist(producer.handle(), consumer.handle());\n    skip |= LogError(\"VUID-RuntimeSpirv-OpEntryPoint-07754\", objlist, create_info_loc,\n                     \"(SPIR-V Interface) Type mismatch on Location %\" PRIu32 \" Component %\" PRIu32\n                     \", between\\n\\n%s stage:\\n%s%s\\n\\n%s stage:\\n%s%s\\n\\n\",\n                     location, component, string_VkShaderStageFlagBits(producer_stage),\n                     producer.DescribeVariable(output_var->id).c_str(),\n                     producer.DescribeType(output_var->type_id).c_str(),\n                     string_VkShaderStageFlagBits(consumer_stage), consumer.DescribeVariable(input_var->id).c_str(),\n                     consumer.DescribeType(input_var->type_id).c_str());\n"
        },
        {
            "role": "user",
            "content": "{\"VUID-RuntimeSpirv-OpEntryPoint-08743\", \"Any user-defined variables shared between the OpEntryPoint of two shader stages, and declared with Input as its Storage Class for the subsequent shader stage, must have all Location slots and Component words declared in the preceding shader stage's OpEntryPoint with Output as the Storage Class\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "const LogObjectList objlist(producer.handle(), consumer.handle());\nskip |= LogError(\"VUID-RuntimeSpirv-OpEntryPoint-08743\", objlist, create_info_loc,\n                 \"(SPIR-V Interface) %s declared input at Location %\" PRIu32 \" Component %\" PRIu32\n                 \" %sbut it is not an Output declared in %s\",\n                 string_VkShaderStageFlagBits(consumer_stage), location, component,\n                 input_var->is_patch ? \"(Tessellation Patch) \" : \"\", string_VkShaderStageFlagBits(producer_stage));\n"
        },
        {
            "role": "user",
            "content": "{\"VUID-RuntimeSpirv-OpVariable-08746\", \"Any OpVariable, Block-decorated OpTypeStruct, or Block-decorated OpTypeStruct members shared between the OpEntryPoint of two shader stages must have matching decorations as defined in interface matching\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "const LogObjectList objlist(producer.handle(), consumer.handle());\nskip |= LogError(\"VUID-RuntimeSpirv-OpVariable-08746\", objlist, create_info_loc,\n                 \"(SPIR-V Interface) Mismatch in BuiltIn blocks:\\n %s\", msg.str().c_str());\n"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkGraphicsPipelineCreateInfo-pStages-00732\", \"If the pipeline requires pre-rasterization shader state and pStages includes tessellation shader stages, the shader code of at least one stage must contain an OpExecutionMode instruction specifying the type of subdivision in the pipeline\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (tesc_subdivision == 0 && tese_subdivision == 0) {\n    const LogObjectList objlist(tesc_module_state.handle(), tese_module_state.handle());\n    skip |= LogError(\"VUID-VkGraphicsPipelineCreateInfo-pStages-00732\", objlist, create_info_loc,\n                     \"Subdivision type is not specified in either of tessellation stages\");\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkGraphicsPipelineCreateInfo-pStages-00733\", \"If the pipeline requires pre-rasterization shader state and pStages includes tessellation shader stages, and the shader code of both stages contain an OpExecutionMode instruction specifying the type of subdivision in the pipeline, they must both specify the same subdivision mode\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "const LogObjectList objlist(tesc_module_state.handle(), tese_module_state.handle());\nskip |= LogError(\"VUID-VkGraphicsPipelineCreateInfo-pStages-00733\", objlist, create_info_loc,\n                 \"Subdivision type specified in tessellation control shader is %s, but subdivison type specified in \"\n                 \"tessellation evaluation shader is %s\",\n                 string_SpvExecutionMode(tesc_subdivision), string_SpvExecutionMode(tese_subdivision));\n"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkGraphicsPipelineCreateInfo-pStages-00735\", \"If the pipeline requires pre-rasterization shader state and pStages includes tessellation shader stages, and the shader code of both contain an OpExecutionMode instruction specifying the out patch size in the pipeline, they must both specify the same patch size\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "const LogObjectList objlist(tesc_module_state.handle(), tese_module_state.handle());\nskip |= LogError(\"VUID-VkGraphicsPipelineCreateInfo-pStages-00735\", objlist, create_info_loc,\n                 \"Output patch size specified in tessellation control shader is %\" PRIu32\n                 \", but subdivison type specified in tessellation evaluation shader is %\" PRIu32,\n                 tesc_patch_size, tese_patch_size);\n"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkShaderCreateInfoEXT-stage-08419\", \"If the tessellationShader feature is not enabled, stage must not be VK_SHADER_STAGE_TESSELLATION_CONTROL_BIT or VK_SHADER_STAGE_TESSELLATION_EVALUATION_BIT\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (enabled_features.tessellationShader == VK_FALSE) {\n    skip |= LogError(\"VUID-VkShaderCreateInfoEXT-stage-08419\", device, create_info_loc.dot(Field::stage),\n                     \"is %s, but the tessellationShader feature was not enabled.\",\n                     string_VkShaderStageFlagBits(create_info.stage));\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkShaderCreateInfoEXT-stage-08420\", \"If the geometryShader feature is not enabled, stage must not be VK_SHADER_STAGE_GEOMETRY_BIT\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (enabled_features.geometryShader == VK_FALSE) {\n    skip |= LogError(\"VUID-VkShaderCreateInfoEXT-stage-08420\", device, create_info_loc.dot(Field::stage),\n                     \"is VK_SHADER_STAGE_GEOMETRY_BIT, but the geometryShader feature was not enabled.\");\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkShaderCreateInfoEXT-stage-08421\", \"If the taskShader feature is not enabled, stage must not be VK_SHADER_STAGE_TASK_BIT_EXT\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (enabled_features.taskShader == VK_FALSE) {\n    skip |= LogError(\"VUID-VkShaderCreateInfoEXT-stage-08421\", device, create_info_loc.dot(Field::stage),\n                     \"is VK_SHADER_STAGE_TASK_BIT_EXT, but the taskShader feature was not enabled.\");\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkShaderCreateInfoEXT-flags-08487\", \"If the attachmentFragmentShadingRate feature is not enabled, flags must not include VK_SHADER_CREATE_FRAGMENT_SHADING_RATE_ATTACHMENT_BIT_EXT\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if ((create_info.flags & VK_SHADER_CREATE_FRAGMENT_SHADING_RATE_ATTACHMENT_BIT_EXT) != 0 &&\n    skip |= LogError(\"VUID-VkShaderCreateInfoEXT-flags-08487\", device, create_info_loc.dot(Field::flags),\n                     \"is %s, but the attachmentFragmentShadingRate feature was not enabled.\",\n                     string_VkShaderCreateFlagsEXT(create_info.flags).c_str());\n"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkShaderCreateInfoEXT-flags-08489\", \"If the fragmentDensityMap feature is not enabled, flags must not include VK_SHADER_CREATE_FRAGMENT_DENSITY_MAP_ATTACHMENT_BIT_EXT\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if ((create_info.flags & VK_SHADER_CREATE_FRAGMENT_DENSITY_MAP_ATTACHMENT_BIT_EXT) != 0 &&\n    skip |= LogError(\"VUID-VkShaderCreateInfoEXT-flags-08489\", device, create_info_loc.dot(Field::flags),\n                     \"is %s, but the fragmentDensityMap feature was not enabled.\",\n                     string_VkShaderCreateFlagsEXT(create_info.flags).c_str());\n"
        },
        {
            "role": "user",
            "content": "{\"VUID-vkCreateShadersEXT-pCreateInfos-08409\", \"For each element of pCreateInfos whose flags member includes VK_SHADER_CREATE_LINK_STAGE_BIT_EXT, if there is any other element of pCreateInfos whose stage is logically later than the stage of the former and whose flags member also includes VK_SHADER_CREATE_LINK_STAGE_BIT_EXT, the nextStage of the former must be equal to the stage of the element with the logically earliest stage following the stage of the former whose flags member also includes VK_SHADER_CREATE_LINK_STAGE_BIT_EXT\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (nextStage != 0 && create_info.nextStage != nextStage) {\n    skip |= LogError(\"VUID-vkCreateShadersEXT-pCreateInfos-08409\", device, create_info_loc.dot(Field::flags),\n                     \"is %s, but nextStage (%s) does not equal the \"\n                     \"logically next stage (%s) which also has the VK_SHADER_CREATE_LINK_STAGE_BIT_EXT bit.\",\n                     string_VkShaderCreateFlagsEXT(create_info.flags).c_str(),\n                     string_VkShaderStageFlags(create_info.nextStage).c_str(),\n                     string_VkShaderStageFlags(nextStage).c_str());\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-vkCreateShadersEXT-pCreateInfos-08410\", \"The stage member of each element of pCreateInfos whose flags member includes VK_SHADER_CREATE_LINK_STAGE_BIT_EXT must be unique\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (i != j && create_info.stage == pCreateInfos[j].stage) {\n    skip |= LogError(\"VUID-vkCreateShadersEXT-pCreateInfos-08410\", device, create_info_loc,\n                     \"and pCreateInfos[%\" PRIu32\n                     \"] both contain VK_SHADER_CREATE_LINK_STAGE_BIT_EXT and have the stage %s.\",\n                     j, string_VkShaderStageFlagBits(create_info.stage));\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkShaderCreateInfoEXT-nextStage-08429\", \"If the geometryShader feature is not enabled, nextStage must not include VK_SHADER_STAGE_GEOMETRY_BIT\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (enabled_features.geometryShader == VK_FALSE && create_info.nextStage == VK_SHADER_STAGE_GEOMETRY_BIT) {\n    skip |= LogError(\"VUID-VkShaderCreateInfoEXT-nextStage-08429\", device, create_info_loc.dot(Field::nextStage),\n                     \"is VK_SHADER_STAGE_GEOMETRY_BIT, but tessellationShader feature was not enabled.\");\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkShaderCreateInfoEXT-nextStage-08430\", \"If stage is VK_SHADER_STAGE_TESSELLATION_CONTROL_BIT, nextStage must not include any bits other than VK_SHADER_STAGE_TESSELLATION_EVALUATION_BIT\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (create_info.stage == VK_SHADER_STAGE_TESSELLATION_CONTROL_BIT &&\n    (create_info.nextStage & ~VK_SHADER_STAGE_TESSELLATION_EVALUATION_BIT) > 0) {\n    skip |= LogError(\"VUID-VkShaderCreateInfoEXT-nextStage-08430\", device, create_info_loc.dot(Field::stage),\n                     \"is VK_SHADER_STAGE_TESSELLATION_CONTROL_BIT, but nextStage is %s.\",\n                     string_VkShaderStageFlags(create_info.nextStage).c_str());\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkShaderCreateInfoEXT-nextStage-08430\", \"If stage is VK_SHADER_STAGE_TESSELLATION_CONTROL_BIT, nextStage must not include any bits other than VK_SHADER_STAGE_TESSELLATION_EVALUATION_BIT\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if ((createInfo.nextStage & ~(VK_SHADER_STAGE_TESSELLATION_EVALUATION_BIT)) != 0) {\n    skip |= LogError(\"VUID-VkShaderCreateInfoEXT-nextStage-08430\", device, create_info_loc.dot(Field::stage),\n                     \"is VK_SHADER_STAGE_TESSELLATION_CONTROL_BIT, but nextStage is %s.\",\n                     string_VkShaderStageFlags(createInfo.nextStage).c_str());\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkShaderCreateInfoEXT-nextStage-08431\", \"If stage is VK_SHADER_STAGE_TESSELLATION_EVALUATION_BIT, nextStage must not include any bits other than VK_SHADER_STAGE_GEOMETRY_BIT and VK_SHADER_STAGE_FRAGMENT_BIT\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (create_info.stage == VK_SHADER_STAGE_TESSELLATION_EVALUATION_BIT &&\n    (create_info.nextStage & ~(VK_SHADER_STAGE_GEOMETRY_BIT | VK_SHADER_STAGE_FRAGMENT_BIT)) > 0) {\n    skip |= LogError(\"VUID-VkShaderCreateInfoEXT-nextStage-08431\", device, create_info_loc.dot(Field::stage),\n                     \"is VK_SHADER_STAGE_TESSELLATION_EVALUATION_BIT, but nextStage is %s.\",\n                     string_VkShaderStageFlags(create_info.nextStage).c_str());\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkShaderCreateInfoEXT-nextStage-08433\", \"If stage is VK_SHADER_STAGE_GEOMETRY_BIT, nextStage must not include any bits other than VK_SHADER_STAGE_FRAGMENT_BIT\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (create_info.stage == VK_SHADER_STAGE_GEOMETRY_BIT && (create_info.nextStage & ~VK_SHADER_STAGE_FRAGMENT_BIT) > 0) {\n    skip |= LogError(\"VUID-VkShaderCreateInfoEXT-nextStage-08433\", device, create_info_loc.dot(Field::stage),\n                     \"is VK_SHADER_STAGE_GEOMETRY_BIT, but nextStage is %s.\",\n                     string_VkShaderStageFlags(create_info.nextStage).c_str());\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkShaderCreateInfoEXT-nextStage-08433\", \"If stage is VK_SHADER_STAGE_GEOMETRY_BIT, nextStage must not include any bits other than VK_SHADER_STAGE_FRAGMENT_BIT\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if ((createInfo.nextStage & ~VK_SHADER_STAGE_FRAGMENT_BIT) != 0) {\n    skip |= LogError(\"VUID-VkShaderCreateInfoEXT-nextStage-08433\", device, create_info_loc.dot(Field::stage),\n                     \"is VK_SHADER_STAGE_GEOMETRY_BIT, but nextStage is %s.\",\n                     string_VkShaderStageFlags(createInfo.nextStage).c_str());\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkShaderCreateInfoEXT-nextStage-08434\", \"If stage is VK_SHADER_STAGE_FRAGMENT_BIT or VK_SHADER_STAGE_COMPUTE_BIT, nextStage must be 0\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if ((create_info.stage == VK_SHADER_STAGE_FRAGMENT_BIT || create_info.stage == VK_SHADER_STAGE_COMPUTE_BIT) &&\n    create_info.nextStage > 0) {\n    skip |= LogError(\"VUID-VkShaderCreateInfoEXT-nextStage-08434\", device, create_info_loc.dot(Field::stage),\n                     \"is %s, but nextStage is %s.\", string_VkShaderStageFlagBits(create_info.stage),\n                     string_VkShaderStageFlags(create_info.nextStage).c_str());\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkShaderCreateInfoEXT-nextStage-08434\", \"If stage is VK_SHADER_STAGE_FRAGMENT_BIT or VK_SHADER_STAGE_COMPUTE_BIT, nextStage must be 0\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (createInfo.nextStage != 0) {\n    skip |= LogError(\"VUID-VkShaderCreateInfoEXT-nextStage-08434\", device, create_info_loc.dot(Field::stage),\n                     \"is %s, but nextStage is %s.\", string_VkShaderStageFlagBits(createInfo.stage),\n                     string_VkShaderStageFlags(createInfo.nextStage).c_str());\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkShaderCreateInfoEXT-nextStage-08435\", \"If stage is VK_SHADER_STAGE_TASK_BIT_EXT, nextStage must not include any bits other than VK_SHADER_STAGE_MESH_BIT_EXT\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if ((createInfo.nextStage & ~VK_SHADER_STAGE_MESH_BIT_EXT) != 0) {\n    skip |= LogError(\"VUID-VkShaderCreateInfoEXT-nextStage-08435\", device, create_info_loc.dot(Field::stage),\n                     \"is VK_SHADER_STAGE_TASK_BIT_EXT, but nextStage is %s.\",\n                     string_VkShaderStageFlags(createInfo.nextStage).c_str());\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkShaderCreateInfoEXT-nextStage-08436\", \"If stage is VK_SHADER_STAGE_MESH_BIT_EXT, nextStage must not include any bits other than VK_SHADER_STAGE_FRAGMENT_BIT\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (create_info.stage == VK_SHADER_STAGE_MESH_BIT_EXT && (create_info.nextStage & ~VK_SHADER_STAGE_FRAGMENT_BIT) > 0) {\n    skip |= LogError(\"VUID-VkShaderCreateInfoEXT-nextStage-08436\", device, create_info_loc.dot(Field::stage),\n                     \"is VK_SHADER_STAGE_MESH_BIT_EXT, but nextStage is %s.\",\n                     string_VkShaderStageFlags(create_info.nextStage).c_str());\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkShaderCreateInfoEXT-nextStage-08436\", \"If stage is VK_SHADER_STAGE_MESH_BIT_EXT, nextStage must not include any bits other than VK_SHADER_STAGE_FRAGMENT_BIT\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if ((createInfo.nextStage & ~VK_SHADER_STAGE_FRAGMENT_BIT) != 0) {\n    skip |= LogError(\"VUID-VkShaderCreateInfoEXT-nextStage-08436\", device, create_info_loc.dot(Field::stage),\n                     \"is VK_SHADER_STAGE_MESH_BIT_EXT, but nextStage is %s.\",\n                     string_VkShaderStageFlags(createInfo.nextStage).c_str());\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-vkCreateShadersEXT-pCreateInfos-08402\", \"If the flags member of any element of pCreateInfos includes VK_SHADER_CREATE_LINK_STAGE_BIT_EXT, the flags member of all other elements of pCreateInfos whose stage is VK_SHADER_STAGE_VERTEX_BIT, VK_SHADER_STAGE_TESSELLATION_CONTROL_BIT, VK_SHADER_STAGE_TESSELLATION_EVALUATION_BIT, VK_SHADER_STAGE_GEOMETRY_BIT, or VK_SHADER_STAGE_FRAGMENT_BIT must also include VK_SHADER_CREATE_LINK_STAGE_BIT_EXT\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (linked_stage != invalid && non_linked_graphics_stage != invalid) {\n    skip |= LogError(\"VUID-vkCreateShadersEXT-pCreateInfos-08402\", device,\n                     loc.dot(Field::pCreateInfos, linked_stage).dot(Field::flags),\n                     \"contains VK_SHADER_CREATE_LINK_STAGE_BIT_EXT, but pCreateInfos[%\" PRIu32\n                     \"].stage is %s and does not have VK_SHADER_CREATE_LINK_STAGE_BIT_EXT.\",\n                     non_linked_graphics_stage, string_VkShaderStageFlagBits(pCreateInfos[non_linked_graphics_stage].stage));\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-vkCreateShadersEXT-pCreateInfos-08404\", \"If the flags member of any element of pCreateInfos whose stage is VK_SHADER_STAGE_TASK_BIT_EXT or VK_SHADER_STAGE_MESH_BIT_EXT includes VK_SHADER_CREATE_LINK_STAGE_BIT_EXT, there must be no member of pCreateInfos whose stage is VK_SHADER_STAGE_VERTEX_BIT and whose flags member includes VK_SHADER_CREATE_LINK_STAGE_BIT_EXT\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (linked_vert_stage != invalid && linked_task_mesh_stage != invalid) {\n    skip |= LogError(\"VUID-vkCreateShadersEXT-pCreateInfos-08404\", device,\n                     loc.dot(Field::pCreateInfos, linked_vert_stage).dot(Field::stage),\n                     \"is %s and pCreateInfos[%\" PRIu32 \"].stage is %s, but both contain VK_SHADER_CREATE_LINK_STAGE_BIT_EXT.\",\n                     string_VkShaderStageFlagBits(pCreateInfos[linked_vert_stage].stage), linked_task_mesh_stage,\n                     string_VkShaderStageFlagBits(pCreateInfos[linked_task_mesh_stage].stage));\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-vkCreateShadersEXT-pCreateInfos-08405\", \"If there is any element of pCreateInfos whose stage is VK_SHADER_STAGE_MESH_BIT_EXT and whose flags member includes both VK_SHADER_CREATE_LINK_STAGE_BIT_EXT and VK_SHADER_CREATE_NO_TASK_SHADER_BIT_EXT, there must be no element of pCreateInfos whose stage is VK_SHADER_STAGE_TASK_BIT_EXT and whose flags member includes VK_SHADER_CREATE_LINK_STAGE_BIT_EXT\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (linked_task_stage != invalid && linked_mesh_no_task_stage != invalid) {\n    skip |= LogError(\"VUID-vkCreateShadersEXT-pCreateInfos-08405\", device, loc.dot(Field::pCreateInfos, linked_task_stage),\n                     \"is a linked task shader, but pCreateInfos[%\" PRIu32\n                     \"] is a linked mesh shader with VK_SHADER_CREATE_NO_TASK_SHADER_BIT_EXT flag.\",\n                     linked_mesh_no_task_stage);\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-vkCreateShadersEXT-pCreateInfos-08411\", \"The codeType member of all elements of pCreateInfos whose flags member includes VK_SHADER_CREATE_LINK_STAGE_BIT_EXT must be the same\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (linked_spirv_index != invalid && linked_binary_index != invalid) {\n    skip |= LogError(\"VUID-vkCreateShadersEXT-pCreateInfos-08411\", device, loc.dot(Field::pCreateInfos, linked_spirv_index),\n                     \"is a linked shader with codeType VK_SHADER_CODE_TYPE_SPIRV_EXT, but pCreateInfos[%\" PRIu32\n                     \"] is a linked shader with codeType VK_SHADER_CODE_TYPE_BINARY_EXT.\",\n                     linked_binary_index);\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkShaderCreateInfoEXT-codeType-08872\", \"If codeType is VK_SHADER_CODE_TYPE_SPIRV_EXT, and stage is VK_SHADER_STAGE_TESSELLATION_EVALUATION_BIT, pCode must contain an OpExecutionMode instruction specifying the type of subdivision\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (stage_state.entrypoint->execution_mode.tessellation_subdivision == 0) {\n    skip |= LogError(\"VUID-VkShaderCreateInfoEXT-codeType-08872\", device, create_info_loc.dot(Field::stage),\n                     \"is VK_SHADER_STAGE_TESSELLATION_EVALUATION_BIT, but subdivision is not specified.\");\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkShaderCreateInfoEXT-codeType-08874\", \"If codeType is VK_SHADER_CODE_TYPE_SPIRV_EXT, and stage is VK_SHADER_STAGE_TESSELLATION_EVALUATION_BIT, pCode must contain an OpExecutionMode instruction specifying the spacing of segments on the edges of tessellated primitives\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (stage_state.entrypoint->execution_mode.tessellation_spacing == 0) {\n    skip |= LogError(\"VUID-VkShaderCreateInfoEXT-codeType-08874\", device, create_info_loc.dot(Field::stage),\n                     \"is VK_SHADER_STAGE_TESSELLATION_EVALUATION_BIT, but spacing is not specified.\");\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-vkCreateShadersEXT-pCreateInfos-08867\", \"If pCreateInfos contains elements with both VK_SHADER_STAGE_TESSELLATION_CONTROL_BIT and VK_SHADER_STAGE_TESSELLATION_EVALUATION_BIT, both elements' flags include VK_SHADER_CREATE_LINK_STAGE_BIT_EXT, both elements' codeType is VK_SHADER_CODE_TYPE_SPIRV_EXT, and the VK_SHADER_STAGE_TESSELLATION_CONTROL_BIT stage's pCode contains an OpExecutionMode instruction specifying the type of subdivision, it must match the subdivision type specified in the VK_SHADER_STAGE_TESSELLATION_EVALUATION_BIT stage\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (tesc_linked_subdivision != 0 && tese_linked_subdivision != 0 && tesc_linked_subdivision != tese_linked_subdivision) {\n    skip |= LogError(\"VUID-vkCreateShadersEXT-pCreateInfos-08867\", device, error_obj.location,\n                     \"The subdivision specified in tessellation control shader (%s) does not match the subdivision in \"\n                     \"tessellation evaluation shader (%s).\",\n                     string_SpvExecutionMode(tesc_linked_subdivision), string_SpvExecutionMode(tese_linked_subdivision));\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-vkCreateShadersEXT-pCreateInfos-08868\", \"If pCreateInfos contains elements with both VK_SHADER_STAGE_TESSELLATION_CONTROL_BIT and VK_SHADER_STAGE_TESSELLATION_EVALUATION_BIT, both elements' flags include VK_SHADER_CREATE_LINK_STAGE_BIT_EXT, both elements' codeType is VK_SHADER_CODE_TYPE_SPIRV_EXT, and the VK_SHADER_STAGE_TESSELLATION_CONTROL_BIT stage's pCode contains an OpExecutionMode instruction specifying the orientation of triangles, it must match the triangle orientation specified in the VK_SHADER_STAGE_TESSELLATION_EVALUATION_BIT stage\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (tesc_linked_orientation != 0 && tese_linked_orientation != 0 && tesc_linked_orientation != tese_linked_orientation) {\n    skip |= LogError(\"VUID-vkCreateShadersEXT-pCreateInfos-08868\", device, error_obj.location,\n                     \"The orientation specified in tessellation control shader (%s) does not match the orientation in \"\n                     \"tessellation evaluation shader (%s).\",\n                     string_SpvExecutionMode(tesc_linked_orientation), string_SpvExecutionMode(tese_linked_orientation));\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-vkCreateShadersEXT-pCreateInfos-08869\", \"If pCreateInfos contains elements with both VK_SHADER_STAGE_TESSELLATION_CONTROL_BIT and VK_SHADER_STAGE_TESSELLATION_EVALUATION_BIT, both elements' flags include VK_SHADER_CREATE_LINK_STAGE_BIT_EXT, both elements' codeType is VK_SHADER_CODE_TYPE_SPIRV_EXT, and the VK_SHADER_STAGE_TESSELLATION_CONTROL_BIT stage's pCode contains an OpExecutionMode instruction specifying PointMode, the VK_SHADER_STAGE_TESSELLATION_EVALUATION_BIT stage must also contain an OpExecutionMode instruction specifying PointMode\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (tesc_linked_point_mode && !tese_linked_point_mode) {\n    skip |= LogError(\"VUID-vkCreateShadersEXT-pCreateInfos-08869\", device, error_obj.location,\n                     \"The tessellation control shader specifies execution mode point mode, but the tessellation evaluation \"\n                     \"shader does not.\");\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-vkCmdBindShadersEXT-None-08462\", \"The shaderObject feature must be enabled\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (enabled_features.shaderObject == VK_FALSE) {\n    skip |= LogError(\"VUID-vkCmdBindShadersEXT-None-08462\", commandBuffer, error_obj.location,\n                     \"the shaderObject feature was not enabled.\");\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-vkCmdBindShadersEXT-pStages-08463\", \"Every element of pStages must be unique\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (i != j && stage == pStages[j]) {\n    skip |= LogError(\"VUID-vkCmdBindShadersEXT-pStages-08463\", commandBuffer, stage_loc,\n                     \"and pStages[%\" PRIu32 \"] are both %s.\", j, string_VkShaderStageFlagBits(stage));\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-vkCmdBindShadersEXT-pShaders-08475\", \"If the geometryShader feature is not enabled, and pStages contains VK_SHADER_STAGE_GEOMETRY_BIT, and pShaders is not NULL, the same index in pShaders must be VK_NULL_HANDLE\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "skip |= LogError(\"VUID-vkCmdBindShadersEXT-pShaders-08475\", commandBuffer, stage_loc,\n                 \"is VK_SHADER_STAGE_GEOMETRY_BIT and pShaders[%\" PRIu32\n                 \"] is not VK_NULL_HANDLE, but geometryShader feature was not enabled.\",\n                 i);\n"
        },
        {
            "role": "user",
            "content": "{\"VUID-vkCmdBindShadersEXT-pShaders-08477\", \"If pStages contains VK_SHADER_STAGE_VERTEX_BIT, VK_SHADER_STAGE_TESSELLATION_CONTROL_BIT, VK_SHADER_STAGE_TESSELLATION_EVALUATION_BIT, VK_SHADER_STAGE_GEOMETRY_BIT, or VK_SHADER_STAGE_FRAGMENT_BIT, the VkCommandPool that commandBuffer was allocated from must support graphics operations\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if ((cb_state->command_pool->queue_flags & VK_QUEUE_GRAPHICS_BIT) == 0) {\n    const LogObjectList objlist(commandBuffer, cb_state->command_pool->Handle());\n    skip |= LogError(\"VUID-vkCmdBindShadersEXT-pShaders-08477\", objlist, stage_loc,\n                     \"is %s, but the command pool the command buffer %s was allocated from \"\n                     \"does not support graphics operations (%s).\",\n                     string_VkShaderStageFlagBits(stage), FormatHandle(commandBuffer).c_str(),\n                     string_VkQueueFlags(cb_state->command_pool->queue_flags).c_str());\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-vkCmdBindShadersEXT-pShaders-08490\", \"If the taskShader feature is not enabled, and pStages contains VK_SHADER_STAGE_TASK_BIT_EXT, and pShaders is not NULL, the same index in pShaders must be VK_NULL_HANDLE\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (stage == VK_SHADER_STAGE_TASK_BIT_EXT && enabled_features.taskShader == VK_FALSE && shader != VK_NULL_HANDLE) {\n    skip |= LogError(\"VUID-vkCmdBindShadersEXT-pShaders-08490\", commandBuffer, stage_loc,\n                     \"is %s and pShaders[%\" PRIu32 \"] is not VK_NULL_HANDLE, but taskShader feature was not enabled.\",\n                     string_VkShaderStageFlagBits(stage), i);\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-vkCmdBindShadersEXT-pShaders-08491\", \"If the meshShader feature is not enabled, and pStages contains VK_SHADER_STAGE_MESH_BIT_EXT, and pShaders is not NULL, the same index in pShaders must be VK_NULL_HANDLE\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "\"is %s and pShaders[%\" PRIu32 \"] is not VK_NULL_HANDLE, but taskShader feature was not enabled.\",\nskip |= LogError(\"VUID-vkCmdBindShadersEXT-pShaders-08491\", commandBuffer, stage_loc,\n\"is %s and pShaders[%\" PRIu32 \"] is not VK_NULL_HANDLE, but meshShader feature was not enabled.\",\nstring_VkShaderStageFlagBits(stage), i);\n"
        },
        {
            "role": "user",
            "content": "{\"VUID-vkCmdBindShadersEXT-pStages-08464\", \"pStages must not contain VK_SHADER_STAGE_ALL_GRAPHICS or VK_SHADER_STAGE_ALL\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (stage == VK_SHADER_STAGE_ALL_GRAPHICS || stage == VK_SHADER_STAGE_ALL) {\n    skip |= LogError(\"VUID-vkCmdBindShadersEXT-pStages-08464\", commandBuffer, stage_loc, \"is %s.\",\n                     string_VkShaderStageFlagBits(stage));\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-vkCmdBindShadersEXT-pStages-08465\", \"pStages must not contain VK_SHADER_STAGE_RAYGEN_BIT_KHR, VK_SHADER_STAGE_ANY_HIT_BIT_KHR, VK_SHADER_STAGE_CLOSEST_HIT_BIT_KHR, VK_SHADER_STAGE_MISS_BIT_KHR, VK_SHADER_STAGE_INTERSECTION_BIT_KHR, or VK_SHADER_STAGE_CALLABLE_BIT_KHR\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (stage & kShaderStageAllRayTracing) {\n    skip |= LogError(\"VUID-vkCmdBindShadersEXT-pStages-08465\", commandBuffer, stage_loc, \"is %s.\",\n                     string_VkShaderStageFlagBits(stage));\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-vkCmdBindShadersEXT-pStages-08468\", \"pStages must not contain VK_SHADER_STAGE_CLUSTER_CULLING_BIT_HUAWEI\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (stage == VK_SHADER_STAGE_CLUSTER_CULLING_BIT_HUAWEI) {\n    skip |= LogError(\"VUID-vkCmdBindShadersEXT-pStages-08468\", commandBuffer, stage_loc, \"is %s.\",\n                     string_VkShaderStageFlagBits(stage));\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-vkCmdBindShadersEXT-pShaders-08470\", \"If pStages contains both VK_SHADER_STAGE_TASK_BIT_EXT and VK_SHADER_STAGE_VERTEX_BIT, and pShaders is not NULL, and the same index in pShaders as VK_SHADER_STAGE_TASK_BIT_EXT in pStages is not VK_NULL_HANDLE, the same index in pShaders as VK_SHADER_STAGE_VERTEX_BIT in pStages must be VK_NULL_HANDLE\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (vertexStageIndex != stageCount && taskStageIndex != stageCount) {\n    skip |= LogError(\"VUID-vkCmdBindShadersEXT-pShaders-08470\", commandBuffer, error_obj.location,\n                     \"pStages[%\" PRIu32 \"] is VK_SHADER_STAGE_VERTEX_BIT and pStages[%\" PRIu32\n                     \"] is VK_SHADER_STAGE_TASK_BIT_EXT, but neither of pShaders[%\" PRIu32 \"] and pShaders[%\" PRIu32\n                     \"] are VK_NULL_HANDLE.\",\n                     vertexStageIndex, taskStageIndex, vertexStageIndex, taskStageIndex);\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-vkCmdBindShadersEXT-pShaders-08471\", \"If pStages contains both VK_SHADER_STAGE_MESH_BIT_EXT and VK_SHADER_STAGE_VERTEX_BIT, and pShaders is not NULL, and the same index in pShaders as VK_SHADER_STAGE_MESH_BIT_EXT in pStages is not VK_NULL_HANDLE, the same index in pShaders as VK_SHADER_STAGE_VERTEX_BIT in pStages must be VK_NULL_HANDLE\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (vertexStageIndex != stageCount && meshStageIndex != stageCount) {\n    skip |= LogError(\"VUID-vkCmdBindShadersEXT-pShaders-08471\", commandBuffer, error_obj.location,\n                     \"pStages[%\" PRIu32 \"] is VK_SHADER_STAGE_VERTEX_BIT and pStages[%\" PRIu32\n                     \"] is VK_SHADER_STAGE_MESH_BIT_EXT, but neither of pShaders[%\" PRIu32 \"] and pShaders[%\" PRIu32\n                     \"] are VK_NULL_HANDLE.\",\n                     vertexStageIndex, meshStageIndex, vertexStageIndex, meshStageIndex);\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-vkGetShaderBinaryDataEXT-None-08461\", \"The shaderObject feature must be enabled\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (enabled_features.shaderObject == VK_FALSE) {\n    skip |= LogError(\"VUID-vkGetShaderBinaryDataEXT-None-08461\", device, error_obj.location,\n                     \"the shaderObject feature was not enabled.\");\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkGraphicsPipelineCreateInfo-renderPass-06038\", \"If renderPass is not VK_NULL_HANDLE and the pipeline is being created with fragment shader state the fragment shader must not read from any input attachment that is defined as VK_ATTACHMENT_UNUSED in subpass\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "const LogObjectList objlist(module_state.handle(), rp_state->Handle());\nskip |= LogError(\"VUID-VkGraphicsPipelineCreateInfo-renderPass-06038\", objlist, loc,\n                 \"SPIR-V consumes input attachment index %\" PRIu32 \" but that is not less than the pSubpasses[%\" PRIu32\n                 \"].inputAttachmentCount (%\" PRIu32 \").\",\n                 input_attachment_index, subpass, subpass_description.inputAttachmentCount);\n"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkGraphicsPipelineCreateInfo-renderPass-06038\", \"If renderPass is not VK_NULL_HANDLE and the pipeline is being created with fragment shader state the fragment shader must not read from any input attachment that is defined as VK_ATTACHMENT_UNUSED in subpass\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "const LogObjectList objlist(module_state.handle(), rp_state->Handle());\nskip |= LogError(\"VUID-VkGraphicsPipelineCreateInfo-renderPass-06038\", objlist, loc,\n                 \"SPIR-V consumes input attachment index %\" PRIu32 \" but pSubpasses[%\" PRIu32\n                 \"].pInputAttachments[%\" PRIu32 \"].attachment is VK_ATTACHMENT_UNUSED.\",\n                 input_attachment_index, subpass, input_attachment_index);\n"
        },
        {
            "role": "user",
            "content": "{\"VUID-FullyCoveredEXT-conservativeRasterizationPostDepthCoverage-04235\", \"If VkPhysicalDeviceConservativeRasterizationPropertiesEXT::conservativeRasterizationPostDepthCoverage is not supported the PostDepthCoverage Execution Mode must not be declared, when a variable with the FullyCoveredEXT decoration is declared\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (stateless_data.has_builtin_fully_covered &&\n    skip |= LogError(\"VUID-FullyCoveredEXT-conservativeRasterizationPostDepthCoverage-04235\", device, loc,\n                     \"SPIR-V (Fragment stage) has a\\nOpExecutionMode EarlyFragmentTests\\nOpDecorate BuiltIn \"\n                     \"FullyCoveredEXT\\nbut conservativeRasterizationPostDepthCoverage was not enabled.\");\n"
        },
        {
            "role": "user",
            "content": "{\"VUID-RuntimeSpirv-None-06342\", \"If subgroupQuadOperationsInAllStages is VK_FALSE, then quad subgroup operations must not be used except for in fragment and compute stages\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (!phys_dev_props_core11.subgroupQuadOperationsInAllStages) {\n    skip |= LogError(\"VUID-RuntimeSpirv-None-06342\", module_state.handle(), loc,\n                     \"Can't use for stage %s because VkPhysicalDeviceSubgroupProperties::quadOperationsInAllStages \"\n                     \"is not supported on this VkDevice\",\n                     string_VkShaderStageFlagBits(stage));\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-RuntimeSpirv-vulkanMemoryModel-06266\", \"If vulkanMemoryModel is not enabled, QueueFamily memory scope must not be used\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "} else if (!enabled_features.vulkanMemoryModel && scope_type == spv::Scope::ScopeQueueFamily) {\n    skip |= LogError(\"VUID-RuntimeSpirv-vulkanMemoryModel-06266\", module_state.handle(), loc,\n                     \"SPIR-V\\n%s\\nuses QueueFamily memory scope, but the vulkanMemoryModel feature was not enabled.\",\n                     insn.Describe().c_str());\n"
        },
        {
            "role": "user",
            "content": "{\"VUID-RuntimeSpirv-shaderSubgroupRotateClustered-09566\", \"If shaderSubgroupRotateClustered is VK_FALSE, then the ClusterSize operand to OpGroupNonUniformRotateKHR must not be used\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (!enabled_features.shaderSubgroupRotateClustered && insn.Opcode() == spv::OpGroupNonUniformRotateKHR && insn.Length() == 7) {\n    skip |= LogError(\"VUID-RuntimeSpirv-shaderSubgroupRotateClustered-09566\", module_state.handle(), loc,\n                     \"SPIR-V\\n%s\\nuses ClusterSize operand, but the shaderSubgroupRotateClustered feature was not enabled.\",\n                     insn.Describe().c_str());\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-RuntimeSpirv-OpTypeCooperativeMatrixKHR-08974\", \"For OpTypeCooperativeMatrixKHR, the component type, scope, number of rows, and number of columns must match one of the matrices in any of the supported VkCooperativeMatrixPropertiesKHR.\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (!valid) {\n    skip |= LogError(\"VUID-RuntimeSpirv-OpTypeCooperativeMatrixKHR-08974\", module_state.handle(), loc,\n                     \"SPIR-V (%s) has\\n%s (%s)\\nbut doesn't match any VkCooperativeMatrixPropertiesKHR\\n%s.\",\n                     string_VkShaderStageFlagBits(entrypoint.stage), insn.Describe().c_str(), m.Describe().c_str(),\n                     print_properties().c_str());\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-RuntimeSpirv-OpCooperativeMatrixMulAddKHR-10060\", \"For OpCooperativeMatrixMulAddKHR, the operands must match a supported VkCooperativeMatrixPropertiesKHR\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (r.is_signed_int && ((flags & spv::CooperativeMatrixOperandsMatrixResultSignedComponentsKHRMask) == 0)) {\n    skip |= LogError(\"VUID-RuntimeSpirv-OpCooperativeMatrixMulAddKHR-10060\", module_state.handle(), loc,\n                     \"SPIR-V (%s) Component type of matrix Result is signed integer type, but \"\n                     \"MatrixResultSignedComponents flag is not \"\n                     \"present in flags (%s).\",\n                     string_VkShaderStageFlagBits(entrypoint.stage),\n                     string_SpvCooperativeMatrixOperands(flags).c_str());\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-RuntimeSpirv-OpCooperativeMatrixMulAddKHR-10060\", \"For OpCooperativeMatrixMulAddKHR, the operands must match a supported VkCooperativeMatrixPropertiesKHR\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (spirv_saturating_accumulation && !props_saturating_accumulation) {\n    skip |= LogError(\"VUID-RuntimeSpirv-OpCooperativeMatrixMulAddKHR-10060\", module_state.handle(), loc,\n                     \"SPIR-V (%s) SaturatingAccumulation cooperative matrix operand is present but \"\n                     \"VkCooperativeMatrixPropertiesKHR[%\" PRIu32 \"].saturatingAccumulation is VK_FALSE.\",\n                     string_VkShaderStageFlagBits(entrypoint.stage), i);\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-RuntimeSpirv-OpCooperativeMatrixMulAddKHR-10060\", \"For OpCooperativeMatrixMulAddKHR, the operands must match a supported VkCooperativeMatrixPropertiesKHR\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "skip |= LogError(\"VUID-RuntimeSpirv-OpCooperativeMatrixMulAddKHR-10060\", module_state.handle(), loc,\n                 \"SPIR-V (%s) SaturatingAccumulation cooperative matrix operand is not present but \"\n                 \"VkCooperativeMatrixPropertiesKHR[%\" PRIu32 \"].saturatingAccumulation is VK_TRUE.\",\n                 string_VkShaderStageFlagBits(entrypoint.stage), i);\n"
        },
        {
            "role": "user",
            "content": "{\"VUID-RuntimeSpirv-OpCooperativeMatrixMulAddKHR-10060\", \"For OpCooperativeMatrixMulAddKHR, the operands must match a supported VkCooperativeMatrixPropertiesKHR\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (!valid_a) {\n    skip |= LogError(\"VUID-RuntimeSpirv-OpCooperativeMatrixMulAddKHR-10060\", module_state.handle(), loc,\n                     \"SPIR-V (%s) instruction\\n%s (%s)\\ndoesn't match a supported matrix \"\n                     \"VkCooperativeMatrixPropertiesKHR for A type\\n%s\",\n                     string_VkShaderStageFlagBits(entrypoint.stage), insn.Describe().c_str(),\n                     a.Describe().c_str(), print_properties().c_str());\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-RuntimeSpirv-OpCooperativeMatrixMulAddKHR-10060\", \"For OpCooperativeMatrixMulAddKHR, the operands must match a supported VkCooperativeMatrixPropertiesKHR\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "skip |= LogError(\"VUID-RuntimeSpirv-OpCooperativeMatrixMulAddKHR-10060\", module_state.handle(), loc,\n                 \"SPIR-V (%s) instruction\\n%s (%s)\\ndoesn't match a supported matrix \"\n                 \"VkCooperativeMatrixPropertiesKHR for B type\\n%s\",\n                 string_VkShaderStageFlagBits(entrypoint.stage), insn.Describe().c_str(),\n                 b.Describe().c_str(), print_properties().c_str());\n"
        },
        {
            "role": "user",
            "content": "{\"VUID-RuntimeSpirv-OpCooperativeMatrixMulAddKHR-10060\", \"For OpCooperativeMatrixMulAddKHR, the operands must match a supported VkCooperativeMatrixPropertiesKHR\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "skip |= LogError(\"VUID-RuntimeSpirv-OpCooperativeMatrixMulAddKHR-10060\", module_state.handle(), loc,\n                 \"SPIR-V (%s) instruction\\n%s (%s)\\ndoesn't match a supported matrix \"\n                 \"VkCooperativeMatrixPropertiesKHR for Result type\\n%s\",\n                 string_VkShaderStageFlagBits(entrypoint.stage), insn.Describe().c_str(),\n                 r.Describe().c_str(), print_properties().c_str());\n"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkPipelineShaderStageCreateInfo-module-08987\", \"If module uses the OpTypeCooperativeMatrixKHR instruction with a Scope equal to Subgroup, then the local workgroup size in the X dimension of the pipeline must be a multiple of subgroupSize\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (SafeModulo(local_size_x, phys_dev_props_core11.subgroupSize) != 0) {\n    skip |= LogError(\"VUID-VkPipelineShaderStageCreateInfo-module-08987\", module_state.handle(), loc,\n                     \"SPIR-V (compute stage) Local workgroup size in the X dimension (%\" PRIu32\n                     \") is not multiple of subgroupSize (%\" PRIu32 \")/.\",\n                     local_size_x, phys_dev_props_core11.subgroupSize);\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-RuntimeSpirv-OpTypeCooperativeMatrixNV-06316\", \"For OpTypeCooperativeMatrixNV, the component type, scope, number of rows, and number of columns must match one of the matrices in any of the supported VkCooperativeMatrixPropertiesNV\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (!valid) {\n    skip |= LogError(\"VUID-RuntimeSpirv-OpTypeCooperativeMatrixNV-06316\", module_state.handle(), loc,\n                     \"SPIR-V (%s) has an OpTypeCooperativeMatrixNV (result id = %\" PRIu32\n                     \") operand that don't match a supported matrix type (%s).\",\n                     string_VkShaderStageFlagBits(entrypoint.stage), insn.Word(1), m.Describe().c_str());\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-RuntimeSpirv-SampleRateShading-06378\", \"If the subpass description contains VK_SUBPASS_DESCRIPTION_FRAGMENT_REGION_BIT_QCOM, then the SPIR-V fragment shader Capability SampleRateShading must not be enabled\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if ((subpass_flags & VK_SUBPASS_DESCRIPTION_FRAGMENT_REGION_BIT_QCOM) != 0) {\n    const LogObjectList objlist(module_state.handle(), rp_state->Handle());\n    skip |= LogError(\"VUID-RuntimeSpirv-SampleRateShading-06378\", objlist, loc,\n                     \"SPIR-V (Fragment stage) enables SampleRateShading capability \"\n                     \"and the subpass flags includes VK_SUBPASS_DESCRIPTION_FRAGMENT_REGION_BIT_QCOM.\");\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-RuntimeSpirv-None-06278\", \"shaderBufferInt64Atomics must be enabled for 64-bit integer atomic operations to be supported on a Pointer with a Storage Class of StorageBuffer or Uniform\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (((atomic.storage_class == spv::StorageClassStorageBuffer) || (atomic.storage_class == spv::StorageClassUniform)) &&\n    skip |= LogError(\"VUID-RuntimeSpirv-None-06278\", module_state.handle(), loc,\n                     \"SPIR-V is using 64-bit int atomics operations\\n%s\\nwith %s storage class, but \"\n                     \"shaderBufferInt64Atomics was not enabled.\",\n                     atomic_def->Describe().c_str(), string_SpvStorageClass(atomic.storage_class));\n"
        },
        {
            "role": "user",
            "content": "{\"VUID-RuntimeSpirv-None-06279\", \"shaderSharedInt64Atomics must be enabled for 64-bit integer atomic operations to be supported on a Pointer with a Storage Class of Workgroup\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "skip |= LogError(\"VUID-RuntimeSpirv-None-06279\", module_state.handle(), loc,\n                 \"SPIR-V is using 64-bit int atomics operations\\n%s\\nwith Workgroup storage class, but \"\n                 \"shaderSharedInt64Atomics was not enabled.\",\n                 atomic_def->Describe().c_str());\n"
        },
        {
            "role": "user",
            "content": "{\"VUID-RuntimeSpirv-None-06288\", \"shaderImageInt64Atomics must be enabled for 64-bit integer atomic operations to be supported on a Pointer with a Storage Class of Image\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "skip |= LogError(\"VUID-RuntimeSpirv-None-06288\", module_state.handle(), loc,\n                 \"SPIR-V is using 64-bit int atomics operations\\n%s\\nwith Image storage class, but \"\n                 \"shaderImageInt64Atomics was not enabled.\",\n                 atomic_def->Describe().c_str());\n"
        },
        {
            "role": "user",
            "content": "{\"VUID-RuntimeSpirv-None-06284\", \"shaderBufferFloat32Atomics, or shaderBufferFloat32AtomicAdd, or shaderBufferFloat64Atomics, or shaderBufferFloat64AtomicAdd, or shaderBufferFloat16Atomics, or shaderBufferFloat16AtomicAdd, or shaderBufferFloat16AtomicMinMax, or shaderBufferFloat32AtomicMinMax, or shaderBufferFloat64AtomicMinMax, or shaderFloat16VectorAtomics must be enabled for floating-point atomic operations to be supported on a Pointer with a Storage Class of StorageBuffer\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (valid_storage_buffer_float == false) {\n    skip |= LogError(\"VUID-RuntimeSpirv-None-06284\", module_state.handle(), loc,\n                     \"SPIR-V is using float atomics operations\\n%s\\nwith StorageBuffer storage class, but none of \"\n                     \"the required features were enabled.\",\n                     atomic_def->Describe().c_str());\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-RuntimeSpirv-None-06337\", \"shaderBufferFloat16Atomics, or shaderBufferFloat16AtomicAdd, or shaderBufferFloat16AtomicMinMax, or shaderSharedFloat16Atomics, or shaderSharedFloat16AtomicAdd, or shaderSharedFloat16AtomicMinMax must be enabled for 16-bit floating-point atomic operations\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if ((atomic.bit_width == 16) && (enabled_features.shaderBufferFloat16AtomicMinMax == VK_FALSE)) {\n    skip |= LogError(\"VUID-RuntimeSpirv-None-06337\", module_state.handle(), loc,\n                     \"SPIR-V is using 16-bit float atomics for min/max operations\\n%s\\nwith \"\n                     \"StorageBuffer storage class, but shaderBufferFloat16AtomicMinMax was not enabled.\",\n                     atomic_def->Describe().c_str());\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-RuntimeSpirv-None-06337\", \"shaderBufferFloat16Atomics, or shaderBufferFloat16AtomicAdd, or shaderBufferFloat16AtomicMinMax, or shaderSharedFloat16Atomics, or shaderSharedFloat16AtomicAdd, or shaderSharedFloat16AtomicMinMax must be enabled for 16-bit floating-point atomic operations\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if ((atomic.bit_width == 16) && (enabled_features.shaderSharedFloat16AtomicAdd == VK_FALSE)) {\n    skip |= LogError(\"VUID-RuntimeSpirv-None-06337\", module_state.handle(), loc,\n                     \"SPIR-V is using 16-bit float atomics for add operations\\n%s\\nwith Workgroup \"\n                     \"storage class, but shaderSharedFloat16AtomicAdd was not enabled.\",\n                     atomic_def->Describe().c_str());\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-RuntimeSpirv-None-06337\", \"shaderBufferFloat16Atomics, or shaderBufferFloat16AtomicAdd, or shaderBufferFloat16AtomicMinMax, or shaderSharedFloat16Atomics, or shaderSharedFloat16AtomicAdd, or shaderSharedFloat16AtomicMinMax must be enabled for 16-bit floating-point atomic operations\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if ((atomic.bit_width == 16) && (enabled_features.shaderSharedFloat16AtomicMinMax == VK_FALSE)) {\n    skip |= LogError(\"VUID-RuntimeSpirv-None-06337\", module_state.handle(), loc,\n                     \"SPIR-V is using 16-bit float atomics for min/max operations\\n%s\\nwith \"\n                     \"Workgroup storage class, but shaderSharedFloat16AtomicMinMax was not enabled.\",\n                     atomic_def->Describe().c_str());\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-RuntimeSpirv-None-06338\", \"shaderBufferFloat32Atomics, or shaderBufferFloat32AtomicAdd, or shaderSharedFloat32Atomics, or shaderSharedFloat32AtomicAdd, or shaderImageFloat32Atomics, or shaderImageFloat32AtomicAdd or shaderBufferFloat32AtomicMinMax, or shaderSharedFloat32AtomicMinMax, or shaderImageFloat32AtomicMinMax must be enabled for 32-bit floating-point atomic operations\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "skip |= LogError(\"VUID-RuntimeSpirv-None-06338\", module_state.handle(), loc,\n                 \"SPIR-V is using 32-bit float atomics for add operations\\n%s\\nwith \"\n                 \"StorageBuffer storage class, but shaderBufferFloat32AtomicAdd was not enabled.\",\n                 atomic_def->Describe().c_str());\n"
        },
        {
            "role": "user",
            "content": "{\"VUID-RuntimeSpirv-None-06338\", \"shaderBufferFloat32Atomics, or shaderBufferFloat32AtomicAdd, or shaderSharedFloat32Atomics, or shaderSharedFloat32AtomicAdd, or shaderImageFloat32Atomics, or shaderImageFloat32AtomicAdd or shaderBufferFloat32AtomicMinMax, or shaderSharedFloat32AtomicMinMax, or shaderImageFloat32AtomicMinMax must be enabled for 32-bit floating-point atomic operations\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if ((atomic.bit_width == 16) && (enabled_features.shaderBufferFloat16Atomics == VK_FALSE)) {\n    skip |= LogError(\"VUID-RuntimeSpirv-None-06338\", module_state.handle(), loc,\n                     \"SPIR-V is using 16-bit float atomics for load/store/exhange operations\\n%s\\nwith \"\n                     \"StorageBuffer storage class, but shaderBufferFloat16Atomics was not enabled.\",\n                     atomic_def->Describe().c_str());\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-RuntimeSpirv-None-06338\", \"shaderBufferFloat32Atomics, or shaderBufferFloat32AtomicAdd, or shaderSharedFloat32Atomics, or shaderSharedFloat32AtomicAdd, or shaderImageFloat32Atomics, or shaderImageFloat32AtomicAdd or shaderBufferFloat32AtomicMinMax, or shaderSharedFloat32AtomicMinMax, or shaderImageFloat32AtomicMinMax must be enabled for 32-bit floating-point atomic operations\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "skip |= LogError(\"VUID-RuntimeSpirv-None-06338\", module_state.handle(), loc,\n                 \"SPIR-V is using 32-bit float atomics for load/store/exhange operations\\n%s\\nwith \"\n                 \"StorageBuffer storage class, but shaderBufferFloat32Atomics was not enabled.\",\n                 atomic_def->Describe().c_str());\n"
        },
        {
            "role": "user",
            "content": "{\"VUID-RuntimeSpirv-None-06338\", \"shaderBufferFloat32Atomics, or shaderBufferFloat32AtomicAdd, or shaderSharedFloat32Atomics, or shaderSharedFloat32AtomicAdd, or shaderImageFloat32Atomics, or shaderImageFloat32AtomicAdd or shaderBufferFloat32AtomicMinMax, or shaderSharedFloat32AtomicMinMax, or shaderImageFloat32AtomicMinMax must be enabled for 32-bit floating-point atomic operations\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "skip |= LogError(\"VUID-RuntimeSpirv-None-06338\", module_state.handle(), loc,\n                 \"SPIR-V is using 32-bit float atomics for add operations\\n%s\\nwith Workgroup \"\n                 \"storage class, but shaderSharedFloat32AtomicAdd was not enabled.\",\n                 atomic_def->Describe().c_str());\n"
        },
        {
            "role": "user",
            "content": "{\"VUID-RuntimeSpirv-None-06338\", \"shaderBufferFloat32Atomics, or shaderBufferFloat32AtomicAdd, or shaderSharedFloat32Atomics, or shaderSharedFloat32AtomicAdd, or shaderImageFloat32Atomics, or shaderImageFloat32AtomicAdd or shaderBufferFloat32AtomicMinMax, or shaderSharedFloat32AtomicMinMax, or shaderImageFloat32AtomicMinMax must be enabled for 32-bit floating-point atomic operations\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "skip |= LogError(\"VUID-RuntimeSpirv-None-06338\", module_state.handle(), loc,\n                 \"SPIR-V is using 32-bit float atomics for min/max operations\\n%s\\nwith \"\n                 \"Workgroup storage class, but shaderSharedFloat32AtomicMinMax was not enabled.\",\n                 atomic_def->Describe().c_str());\n"
        },
        {
            "role": "user",
            "content": "{\"VUID-RuntimeSpirv-None-06339\", \"shaderBufferFloat64Atomics, or shaderBufferFloat64AtomicAdd, or shaderSharedFloat64Atomics, or shaderSharedFloat64AtomicAdd, or shaderBufferFloat64AtomicMinMax, or shaderSharedFloat64AtomicMinMax, must be enabled for 64-bit floating-point atomic operations\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "skip |= LogError(\"VUID-RuntimeSpirv-None-06339\", module_state.handle(), loc,\n                 \"SPIR-V is using 64-bit float atomics for min/max operations\\n%s\\nwith \"\n                 \"StorageBuffer storage class, but shaderBufferFloat64AtomicMinMax was not enabled.\",\n                 atomic_def->Describe().c_str());\n"
        },
        {
            "role": "user",
            "content": "{\"VUID-RuntimeSpirv-None-06339\", \"shaderBufferFloat64Atomics, or shaderBufferFloat64AtomicAdd, or shaderSharedFloat64Atomics, or shaderSharedFloat64AtomicAdd, or shaderBufferFloat64AtomicMinMax, or shaderSharedFloat64AtomicMinMax, must be enabled for 64-bit floating-point atomic operations\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "skip |= LogError(\"VUID-RuntimeSpirv-None-06339\", module_state.handle(), loc,\n                 \"SPIR-V is using 64-bit float atomics for load/store/exhange operations\\n%s\\nwith \"\n                 \"StorageBuffer storage class, but shaderBufferFloat64Atomics was not enabled.\",\n                 atomic_def->Describe().c_str());\n"
        },
        {
            "role": "user",
            "content": "{\"VUID-RuntimeSpirv-None-06339\", \"shaderBufferFloat64Atomics, or shaderBufferFloat64AtomicAdd, or shaderSharedFloat64Atomics, or shaderSharedFloat64AtomicAdd, or shaderBufferFloat64AtomicMinMax, or shaderSharedFloat64AtomicMinMax, must be enabled for 64-bit floating-point atomic operations\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "skip |= LogError(\"VUID-RuntimeSpirv-None-06339\", module_state.handle(), loc,\n                 \"SPIR-V is using 64-bit float atomics for add operations\\n%s\\nwith Workgroup \"\n                 \"storage class, but shaderSharedFloat64AtomicAdd was not enabled.\",\n                 atomic_def->Describe().c_str());\n"
        },
        {
            "role": "user",
            "content": "{\"VUID-RuntimeSpirv-None-06339\", \"shaderBufferFloat64Atomics, or shaderBufferFloat64AtomicAdd, or shaderSharedFloat64Atomics, or shaderSharedFloat64AtomicAdd, or shaderBufferFloat64AtomicMinMax, or shaderSharedFloat64AtomicMinMax, must be enabled for 64-bit floating-point atomic operations\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "skip |= LogError(\"VUID-RuntimeSpirv-None-06339\", module_state.handle(), loc,\n                 \"SPIR-V is using 64-bit float atomics for min/max operations\\n%s\\nwith \"\n                 \"Workgroup storage class, but shaderSharedFloat64AtomicMinMax was not enabled.\",\n                 atomic_def->Describe().c_str());\n"
        },
        {
            "role": "user",
            "content": "{\"VUID-RuntimeSpirv-None-06286\", \"shaderImageFloat32Atomics, or shaderImageFloat32AtomicAdd, or shaderImageFloat32AtomicMinMax, must be enabled for 32-bit floating-point atomic operations to be supported on a Pointer with a Storage Class of Image\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "skip |= LogError(\"VUID-RuntimeSpirv-None-06286\", module_state.handle(), loc,\n                 \"SPIR-V is using float atomics operations\\n%s\\nwith Image storage class, but none of the required \"\n                 \"features were enabled.\",\n                 atomic_def->Describe().c_str());\n"
        },
        {
            "role": "user",
            "content": "{\"VUID-RuntimeSpirv-shaderSignedZeroInfNanPreserveFloat16-06293\", \"If shaderSignedZeroInfNanPreserveFloat16 is VK_FALSE, then SignedZeroInfNanPreserve for 16-bit floating-point type must not be used\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (entrypoint.execution_mode.Has(spirv::ExecutionModeSet::signed_zero_inf_nan_preserve_width_16) &&\n    !phys_dev_props_core12.shaderSignedZeroInfNanPreserveFloat16) {\n    skip |= LogError(\"VUID-RuntimeSpirv-shaderSignedZeroInfNanPreserveFloat16-06293\", module_state.handle(), loc,\n                     \"SPIR-V requires SignedZeroInfNanPreserve for bit width 16 but it is not enabled on the device.\");\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-RuntimeSpirv-shaderSignedZeroInfNanPreserveFloat32-06294\", \"If shaderSignedZeroInfNanPreserveFloat32 is VK_FALSE, then SignedZeroInfNanPreserve for 32-bit floating-point type must not be used\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "!phys_dev_props_core12.shaderSignedZeroInfNanPreserveFloat32) {\nskip |= LogError(\"VUID-RuntimeSpirv-shaderSignedZeroInfNanPreserveFloat32-06294\", module_state.handle(), loc,\n          \"SPIR-V requires SignedZeroInfNanPreserve for bit width 32 but it is not enabled on the device.\");\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-RuntimeSpirv-shaderSignedZeroInfNanPreserveFloat64-06295\", \"If shaderSignedZeroInfNanPreserveFloat64 is VK_FALSE, then SignedZeroInfNanPreserve for 64-bit floating-point type must not be used\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "!phys_dev_props_core12.shaderSignedZeroInfNanPreserveFloat64) {\nskip |= LogError(\"VUID-RuntimeSpirv-shaderSignedZeroInfNanPreserveFloat64-06295\", module_state.handle(), loc,\n          \"SPIR-V requires SignedZeroInfNanPreserve for bit width 64 but it is not enabled on the device.\");\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-RuntimeSpirv-shaderDenormPreserveFloat32-06297\", \"If shaderDenormPreserveFloat32 is VK_FALSE, then DenormPreserve for 32-bit floating-point type must not be used\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "skip |= LogError(\"VUID-RuntimeSpirv-shaderDenormPreserveFloat16-06296\", module_state.handle(), loc,\n} else if (has_denorm_preserve_width_32 && !phys_dev_props_core12.shaderDenormPreserveFloat32) {\nskip |= LogError(\"VUID-RuntimeSpirv-shaderDenormPreserveFloat32-06297\", module_state.handle(), loc,\n                 \"SPIR-V requires DenormPreserve for bit width 32 but it is not enabled on the device.\");\n"
        },
        {
            "role": "user",
            "content": "{\"VUID-RuntimeSpirv-shaderDenormPreserveFloat64-06298\", \"If shaderDenormPreserveFloat64 is VK_FALSE, then DenormPreserve for 64-bit floating-point type must not be used\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "skip |= LogError(\"VUID-RuntimeSpirv-shaderDenormPreserveFloat32-06297\", module_state.handle(), loc,\n} else if (has_denorm_preserve_width_64 && !phys_dev_props_core12.shaderDenormPreserveFloat64) {\nskip |= LogError(\"VUID-RuntimeSpirv-shaderDenormPreserveFloat64-06298\", module_state.handle(), loc,\n                 \"SPIR-V requires DenormPreserve for bit width 64 but it is not enabled on the device.\");\n"
        },
        {
            "role": "user",
            "content": "{\"VUID-RuntimeSpirv-shaderDenormFlushToZeroFloat16-06299\", \"If shaderDenormFlushToZeroFloat16 is VK_FALSE, then DenormFlushToZero for 16-bit floating-point type must not be used\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (has_denorm_flush_to_zero_width_16 && !phys_dev_props_core12.shaderDenormFlushToZeroFloat16) {\n    skip |= LogError(\"VUID-RuntimeSpirv-shaderDenormFlushToZeroFloat16-06299\", module_state.handle(), loc,\n                     \"SPIR-V requires DenormFlushToZero for bit width 16 but it is not enabled on the device.\");\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-RuntimeSpirv-shaderDenormFlushToZeroFloat32-06300\", \"If shaderDenormFlushToZeroFloat32 is VK_FALSE, then DenormFlushToZero for 32-bit floating-point type must not be used\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "skip |= LogError(\"VUID-RuntimeSpirv-shaderDenormFlushToZeroFloat16-06299\", module_state.handle(), loc,\n} else if (has_denorm_flush_to_zero_width_32 && !phys_dev_props_core12.shaderDenormFlushToZeroFloat32) {\nskip |= LogError(\"VUID-RuntimeSpirv-shaderDenormFlushToZeroFloat32-06300\", module_state.handle(), loc,\n                 \"SPIR-V requires DenormFlushToZero for bit width 32 but it is not enabled on the device.\");\n"
        },
        {
            "role": "user",
            "content": "{\"VUID-RuntimeSpirv-shaderRoundingModeRTEFloat16-06302\", \"If shaderRoundingModeRTEFloat16 is VK_FALSE, then RoundingModeRTE for 16-bit floating-point type must not be used\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (has_rounding_mode_rte_width_16 && !phys_dev_props_core12.shaderRoundingModeRTEFloat16) {\n    skip |= LogError(\"VUID-RuntimeSpirv-shaderRoundingModeRTEFloat16-06302\", module_state.handle(), loc,\n                     \"SPIR-V requires RoundingModeRTE for bit width 16 but it is not enabled on the device.\");\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-RuntimeSpirv-shaderRoundingModeRTEFloat32-06303\", \"If shaderRoundingModeRTEFloat32 is VK_FALSE, then RoundingModeRTE for 32-bit floating-point type must not be used\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "skip |= LogError(\"VUID-RuntimeSpirv-shaderRoundingModeRTEFloat16-06302\", module_state.handle(), loc,\n} else if (has_rounding_mode_rte_width_32 && !phys_dev_props_core12.shaderRoundingModeRTEFloat32) {\nskip |= LogError(\"VUID-RuntimeSpirv-shaderRoundingModeRTEFloat32-06303\", module_state.handle(), loc,\n                 \"SPIR-V requires RoundingModeRTE for bit width 32 but it is not enabled on the device.\");\n"
        },
        {
            "role": "user",
            "content": "{\"VUID-RuntimeSpirv-shaderRoundingModeRTEFloat64-06304\", \"If shaderRoundingModeRTEFloat64 is VK_FALSE, then RoundingModeRTE for 64-bit floating-point type must not be used\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "skip |= LogError(\"VUID-RuntimeSpirv-shaderRoundingModeRTEFloat32-06303\", module_state.handle(), loc,\n} else if (has_rounding_mode_rte_width_64 && !phys_dev_props_core12.shaderRoundingModeRTEFloat64) {\nskip |= LogError(\"VUID-RuntimeSpirv-shaderRoundingModeRTEFloat64-06304\", module_state.handle(), loc,\n                 \"SPIR-V requires RoundingModeRTE for bit width 64 but it is not enabled on the device.\");\n"
        },
        {
            "role": "user",
            "content": "{\"VUID-RuntimeSpirv-shaderRoundingModeRTZFloat16-06305\", \"If shaderRoundingModeRTZFloat16 is VK_FALSE, then RoundingModeRTZ for 16-bit floating-point type must not be used\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (has_rounding_mode_rtz_width_16 && !phys_dev_props_core12.shaderRoundingModeRTZFloat16) {\n    skip |= LogError(\"VUID-RuntimeSpirv-shaderRoundingModeRTZFloat16-06305\", module_state.handle(), loc,\n                     \"SPIR-V requires RoundingModeRTZ for bit width 16 but it is not enabled on the device.\");\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-RuntimeSpirv-shaderRoundingModeRTZFloat64-06307\", \"If shaderRoundingModeRTZFloat64 is VK_FALSE, then RoundingModeRTZ for 64-bit floating-point type must not be used\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "skip |= LogError(\"VUID-RuntimeSpirv-shaderRoundingModeRTZFloat32-06306\", module_state.handle(), loc,\n} else if (has_rounding_mode_rtz_width_64 && !phys_dev_props_core12.shaderRoundingModeRTZFloat64) {\nskip |= LogError(\"VUID-RuntimeSpirv-shaderRoundingModeRTZFloat64-06307\", module_state.handle(), loc,\n                 \"SPIR-V requires RoundingModeRTZ for bit width 64 but it is not enabled on the device.\");\n"
        },
        {
            "role": "user",
            "content": "{\"VUID-RuntimeSpirv-shaderSignedZeroInfNanPreserveFloat16-09559\", \"If shaderSignedZeroInfNanPreserveFloat16 is VK_FALSE then any FPFastMathDefault execution mode with a type of 16-bit float must include the NSZ, NotInf, and NotNaN flags\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (bit_width == 16 && !phys_dev_props_core12.shaderSignedZeroInfNanPreserveFloat16) {\n    skip |= LogError(\"VUID-RuntimeSpirv-shaderSignedZeroInfNanPreserveFloat16-09559\", module_state.handle(), loc,\n                     \"shaderSignedZeroInfNanPreserveFloat16 is false, but FPFastMathDefault is setting 16-bit floats \"\n                     \"with modes 0x%\" PRIx32 \".\",\n                     fast_math_mode->GetConstantValue());\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-RuntimeSpirv-shaderSignedZeroInfNanPreserveFloat32-09561\", \"If shaderSignedZeroInfNanPreserveFloat32 is VK_FALSE then any FPFastMathDefault execution mode with a type of 32-bit float must include the NSZ, NotInf, and NotNaN flags\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "} else if (bit_width == 32 && !phys_dev_props_core12.shaderSignedZeroInfNanPreserveFloat32) {\n    skip |= LogError(\"VUID-RuntimeSpirv-shaderSignedZeroInfNanPreserveFloat32-09561\", module_state.handle(), loc,\n                     \"shaderSignedZeroInfNanPreserveFloat32 is false, but FPFastMathDefault is setting 32-bit floats \"\n                     \"with modes 0x%\" PRIx32 \".\",\n                     fast_math_mode->GetConstantValue());\n"
        },
        {
            "role": "user",
            "content": "{\"VUID-RuntimeSpirv-shaderSignedZeroInfNanPreserveFloat64-09563\", \"If shaderSignedZeroInfNanPreserveFloat64 is VK_FALSE then any FPFastMathDefault execution mode with a type of 64-bit float must include the NSZ, NotInf, and NotNaN flags\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "} else if (bit_width == 64 && !phys_dev_props_core12.shaderSignedZeroInfNanPreserveFloat64) {\n    skip |= LogError(\"VUID-RuntimeSpirv-shaderSignedZeroInfNanPreserveFloat64-09563\", module_state.handle(), loc,\n                     \"shaderSignedZeroInfNanPreserveFloat64 is false, but FPFastMathDefault is setting 64-bit floats \"\n                     \"with modes 0x%\" PRIx32 \".\",\n                     fast_math_mode->GetConstantValue());\n"
        },
        {
            "role": "user",
            "content": "{\"VUID-RuntimeSpirv-shaderSignedZeroInfNanPreserveFloat32-09562\", \"If shaderSignedZeroInfNanPreserveFloat32 is VK_FALSE then any FPFastMathMode decoration on an instruction with result type or any operand type that includes a 32-bit float must include the NSZ, NotInf, and NotNaN flags\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "} else if (float_32 && !phys_dev_props_core12.shaderSignedZeroInfNanPreserveFloat32) {\n    skip |= LogError(\"VUID-RuntimeSpirv-shaderSignedZeroInfNanPreserveFloat32-09562\", module_state.handle(), loc,\n                     \"shaderSignedZeroInfNanPreserveFloat32 is false, FPFastMathMode has modes 0x%\" PRIx32\n                     \" but the target instruction\\n%s\\n is using 32-bit floats.\",\n                     modes, target_insn->Describe().c_str());\n"
        },
        {
            "role": "user",
            "content": "{\"VUID-RuntimeSpirv-shaderSignedZeroInfNanPreserveFloat64-09564\", \"If shaderSignedZeroInfNanPreserveFloat64 is VK_FALSE then any FPFastMathMode decoration on an instruction with result type or any operand type that includes a 64-bit float must include the NSZ, NotInf, and NotNaN flags\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "} else if (float_64 && !phys_dev_props_core12.shaderSignedZeroInfNanPreserveFloat64) {\n    skip |= LogError(\"VUID-RuntimeSpirv-shaderSignedZeroInfNanPreserveFloat64-09564\", module_state.handle(), loc,\n                     \"shaderSignedZeroInfNanPreserveFloat64 is false, FPFastMathMode has modes 0x%\" PRIx32\n                     \" but the target instruction\\n%s\\n is using 64-bit floats.\",\n                     modes, target_insn->Describe().c_str());\n"
        },
        {
            "role": "user",
            "content": "{\"VUID-RuntimeSpirv-LocalSizeId-06434\", \"If Execution Mode LocalSizeId is used, maintenance4 must be enabled\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (!enabled_features.maintenance4) {\n    skip |= LogError(\"VUID-RuntimeSpirv-LocalSizeId-06434\", module_state.handle(), loc,\n                     \"SPIR-V OpExecutionMode LocalSizeId is used but maintenance4 feature was not enabled.\");\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-RuntimeSpirv-LocalSizeId-06434\", \"If Execution Mode LocalSizeId is used, maintenance4 must be enabled\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (!IsExtEnabled(device_extensions.vk_khr_maintenance4)) {\n    skip |= LogError(\"VUID-RuntimeSpirv-LocalSizeId-06434\", module_state.handle(), loc,\n                     \"SPIR-V OpExecutionMode LocalSizeId is used but maintenance4 extension is not enabled and used \"\n                     \"Vulkan api version is 1.2 or less.\");\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkGraphicsPipelineCreateInfo-Geometry-07726\", \"If the pipeline is being created with a Geometry Execution Model, uses the OutputPoints Execution Mode, and shaderTessellationAndGeometryPointSize is not enabled, a PointSize decorated variable must not be written to\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "\"VUID-VkGraphicsPipelineCreateInfo-shaderTessellationAndGeometryPointSize-08776\", module_state.handle(), loc,\n\"SPIR-V (Geometry stage) PointSize is not written, but shaderTessellationAndGeometryPointSize was enabled.\");\nskip |= LogError(\"VUID-VkGraphicsPipelineCreateInfo-Geometry-07726\", module_state.handle(), loc,\n             \"SPIR-V (Geometry stage) PointSize is written to, but shaderTessellationAndGeometryPointSize was not \"\n             \"enabled (gl_PointSize must NOT be written and a default of 1.0 is assumed).\");\n"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkGraphicsPipelineCreateInfo-TessellationEvaluation-07723\", \"If the pipeline is being created with a TessellationEvaluation Execution Model, no Geometry Execution Model, uses the PointMode Execution Mode, and shaderTessellationAndGeometryPointSize is enabled, a PointSize decorated variable must be written to if maintenance5 is not enabled\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (enabled_features.shaderTessellationAndGeometryPointSize && !entrypoint.written_builtin_point_size && !maintenance5) {\n    skip |= LogError(\"VUID-VkGraphicsPipelineCreateInfo-TessellationEvaluation-07723\", module_state.handle(), loc,\n                     \"SPIR-V (Tessellation Evaluation stage) PointSize is not written, but \"\n                     \"shaderTessellationAndGeometryPointSize was enabled.\");\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkGraphicsPipelineCreateInfo-primitiveFragmentShadingRateWithMultipleViewports-04503\", \"If the pipeline requires pre-rasterization shader state and the primitiveFragmentShadingRateWithMultipleViewports limit is not supported, VK_DYNAMIC_STATE_VIEWPORT_WITH_COUNT is not included in pDynamicState->pDynamicStates, and VkPipelineViewportStateCreateInfo::viewportCount is greater than 1, entry points specified in pStages must not write to the PrimitiveShadingRateKHR built-in\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (!pipeline.IsDynamic(CB_DYNAMIC_STATE_VIEWPORT_WITH_COUNT) && viewport_state->viewportCount > 1 &&\n    skip |= LogError(\"VUID-VkGraphicsPipelineCreateInfo-primitiveFragmentShadingRateWithMultipleViewports-04503\",\n                     module_state.handle(), loc,\n                     \"SPIR-V (%s) statically writes to PrimitiveShadingRateKHR built-in, but \"\n                     \"multiple viewports \"\n                     \"are used and the primitiveFragmentShadingRateWithMultipleViewports limit is not supported.\",\n                     string_VkShaderStageFlagBits(stage));\n"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkGraphicsPipelineCreateInfo-primitiveFragmentShadingRateWithMultipleViewports-04504\", \"If the pipeline requires pre-rasterization shader state and the primitiveFragmentShadingRateWithMultipleViewports limit is not supported, and entry points specified in pStages write to the ViewportIndex built-in, they must not also write to the PrimitiveShadingRateKHR built-in\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (entrypoint.written_builtin_primitive_shading_rate_khr && entrypoint.written_builtin_viewport_index) {\n    skip |= LogError(\"VUID-VkGraphicsPipelineCreateInfo-primitiveFragmentShadingRateWithMultipleViewports-04504\",\n                     module_state.handle(), loc,\n                     \"SPIR-V (%s) statically writes to both PrimitiveShadingRateKHR and \"\n                     \"ViewportIndex built-ins, \"\n                     \"but the primitiveFragmentShadingRateWithMultipleViewports limit is not supported.\",\n                     string_VkShaderStageFlagBits(stage));\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-RuntimeSpirv-XfbStride-06313\", \"The XFB Stride value to XfbStride must be less than or equal to VkPhysicalDeviceTransformFeedbackPropertiesEXT::maxTransformFeedbackBufferDataStride\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (stride > phys_dev_ext_props.transform_feedback_props.maxTransformFeedbackBufferDataStride) {\n    skip |= LogError(\"VUID-RuntimeSpirv-XfbStride-06313\", module_state.handle(), loc,\n                     \"SPIR-V uses transform feedback with xfb_stride (%\" PRIu32\n                     \") greater than maxTransformFeedbackBufferDataStride (%\" PRIu32 \").\",\n                     stride, phys_dev_ext_props.transform_feedback_props.maxTransformFeedbackBufferDataStride);\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-RuntimeSpirv-Stream-06312\", \"The stream number value to Stream must be less than VkPhysicalDeviceTransformFeedbackPropertiesEXT::maxTransformFeedbackStreams\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (stream >= phys_dev_ext_props.transform_feedback_props.maxTransformFeedbackStreams) {\n    skip |= LogError(\"VUID-RuntimeSpirv-Stream-06312\", module_state.handle(), loc,\n                     \"SPIR-V uses transform feedback with stream (%\" PRIu32\n                     \") not less than maxTransformFeedbackStreams (%\" PRIu32 \").\",\n                     stream, phys_dev_ext_props.transform_feedback_props.maxTransformFeedbackStreams);\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-RuntimeSpirv-Workgroup-06530\", \"The sum of size in bytes for variables and padding in the Workgroup Storage Class in the GLCompute Execution Model must be less than or equal to maxComputeSharedMemorySize\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (total_workgroup_shared_memory > phys_dev_props.limits.maxComputeSharedMemorySize) {\n    skip |= LogError(\"VUID-RuntimeSpirv-Workgroup-06530\", module_state.handle(), loc,\n                     \"SPIR-V uses %\" PRIu32\n                     \" bytes of shared memory, which is more than maxComputeSharedMemorySize (%\" PRIu32 \").\",\n                     total_workgroup_shared_memory, phys_dev_props.limits.maxComputeSharedMemorySize);\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-RuntimeSpirv-maxMeshSharedMemorySize-08754\", \"The sum of size in bytes for variables and padding in the Workgroup Storage Class in the MeshEXT Execution Model must be less than or equal to maxMeshSharedMemorySize\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (total_workgroup_shared_memory > phys_dev_ext_props.mesh_shader_props_ext.maxMeshSharedMemorySize) {\n    skip |= LogError(\"VUID-RuntimeSpirv-maxMeshSharedMemorySize-08754\", module_state.handle(), loc,\n                     \"SPIR-V uses %\" PRIu32\n                     \" bytes of shared memory, which is more than maxMeshSharedMemorySize (%\" PRIu32 \").\",\n                     total_workgroup_shared_memory, phys_dev_ext_props.mesh_shader_props_ext.maxMeshSharedMemorySize);\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-RuntimeSpirv-shaderZeroInitializeWorkgroupMemory-06372\", \"If shaderZeroInitializeWorkgroupMemory is not enabled, any OpVariable with Workgroup as its Storage Class must not have an Initializer operand\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (insn->Length() > 4 && !enabled_features.shaderZeroInitializeWorkgroupMemory) {\n    skip |= LogError(\"VUID-RuntimeSpirv-shaderZeroInitializeWorkgroupMemory-06372\", module_state.handle(), loc,\n                     \"SPIR-V contains an OpVariable with Workgroup Storage Class with an Initializer operand, but \"\n                     \"shaderZeroInitializeWorkgroupMemory was not enabled.\\n%s\\n.\",\n                     insn->Describe().c_str());\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-RuntimeSpirv-storageBuffer8BitAccess-06328\", \"If storageBuffer8BitAccess is VK_FALSE, then objects containing an 8-bit integer element must not have Storage Class of StorageBuffer, ShaderRecordBufferKHR, or PhysicalStorageBuffer\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (!enabled_features.storageBuffer8BitAccess &&\n    skip |= LogError(\"VUID-RuntimeSpirv-storageBuffer8BitAccess-06328\", module_state.handle(), loc,\n                     \"SPIR-V contains an 8-bit \"\n                     \"OpVariable with %s Storage Class, but storageBuffer8BitAccess was not enabled.\\n%s\\n\",\n                     string_SpvStorageClass(storage_class), insn->Describe().c_str());\n"
        },
        {
            "role": "user",
            "content": "{\"VUID-RuntimeSpirv-storagePushConstant8-06330\", \"If storagePushConstant8 is VK_FALSE, then objects containing an 8-bit integer element must not have Storage Class of PushConstant\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (!enabled_features.storagePushConstant8 && storage_class == spv::StorageClassPushConstant) {\n    skip |= LogError(\"VUID-RuntimeSpirv-storagePushConstant8-06330\", module_state.handle(), loc,\n                     \"SPIR-V contains an 8-bit \"\n                     \"OpVariable with PushConstant Storage Class, but storagePushConstant8 was not enabled.\\n%s\\n\",\n                     insn->Describe().c_str());\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-RuntimeSpirv-storageBuffer16BitAccess-06331\", \"If storageBuffer16BitAccess is VK_FALSE, then objects containing 16-bit integer or 16-bit floating-point elements must not have Storage Class of StorageBuffer, ShaderRecordBufferKHR, or PhysicalStorageBuffer\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (!enabled_features.storageBuffer16BitAccess &&\n    skip |= LogError(\"VUID-RuntimeSpirv-storageBuffer16BitAccess-06331\", module_state.handle(), loc,\n                     \"SPIR-V contains an 16-bit \"\n                     \"OpVariable with %s Storage Class, but storageBuffer16BitAccess was not enabled.\\n%s\\n\",\n                     string_SpvStorageClass(storage_class), insn->Describe().c_str());\n"
        },
        {
            "role": "user",
            "content": "{\"VUID-RuntimeSpirv-storageInputOutput16-06334\", \"If storageInputOutput16 is VK_FALSE, then objects containing 16-bit integer or 16-bit floating-point elements must not have Storage Class of Input or Output\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (!enabled_features.storageInputOutput16 &&\n    skip |= LogError(\"VUID-RuntimeSpirv-storageInputOutput16-06334\", module_state.handle(), loc,\n                     \"SPIR-V contains an 16-bit \"\n                     \"OpVariable with %s Storage Class, but storageInputOutput16 was not enabled.\\n%s\\n\",\n                     string_SpvStorageClass(storage_class), insn->Describe().c_str());\n"
        },
        {
            "role": "user",
            "content": "{\"VUID-RuntimeSpirv-NonWritable-06340\", \"If fragmentStoresAndAtomics is not enabled, then all storage image, storage texel buffer, and storage buffer variables in the fragment stage must be decorated with the NonWritable decoration\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (!enabled_features.fragmentStoresAndAtomics) {\n    skip |= LogError(\"VUID-RuntimeSpirv-NonWritable-06340\", module_state.handle(), loc,\n                     \"SPIR-V (VK_SHADER_STAGE_FRAGMENT_BIT) uses descriptor %s (type %s) which is not \"\n                     \"marked with NonWritable, but fragmentStoresAndAtomics was not enabled.\",\n                     variable.DescribeDescriptor().c_str(),\n                     string_DescriptorTypeSet(descriptor_type_set).c_str());\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-RuntimeSpirv-NonWritable-06341\", \"If vertexPipelineStoresAndAtomics is not enabled, then all storage image, storage texel buffer, and storage buffer variables in the vertex, tessellation, and geometry stages must be decorated with the NonWritable decoration\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (!enabled_features.vertexPipelineStoresAndAtomics) {\n    skip |= LogError(\"VUID-RuntimeSpirv-NonWritable-06341\", module_state.handle(), loc,\n                     \"SPIR-V (%s) uses descriptor %s (type %s) which is not marked with NonWritable, but \"\n                     \"vertexPipelineStoresAndAtomics was not enabled.\",\n                     string_VkShaderStageFlagBits(variable.stage), variable.DescribeDescriptor().c_str(),\n                     string_DescriptorTypeSet(descriptor_type_set).c_str());\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkGraphicsPipelineCreateInfo-None-02322\", \"If the pipeline requires pre-rasterization shader state, and there are any mesh shader stages in the pipeline there must not be any shader stage in the pipeline with a Xfb execution mode\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if ((pipeline.create_info_shaders & (VK_SHADER_STAGE_MESH_BIT_EXT | VK_SHADER_STAGE_TASK_BIT_EXT)) != 0) {\n    skip |= LogError(\"VUID-VkGraphicsPipelineCreateInfo-None-02322\", module_state.handle(), loc,\n                     \"SPIR-V has OpExecutionMode of Xfb and using mesh shaders (%s).\",\n                     string_VkShaderStageFlags(pipeline.create_info_shaders).c_str());\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkGraphicsPipelineCreateInfo-geometryStreams-02321\", \"If the pipeline requires pre-rasterization shader state, and the last pre-rasterization shader stage is a geometry shader, and that geometry shader uses the GeometryStreams capability, then VkPhysicalDeviceTransformFeedbackFeaturesEXT::geometryStreams feature must be enabled\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (pipeline.pre_raster_state && (pipeline.create_info_shaders & VK_SHADER_STAGE_GEOMETRY_BIT) != 0 &&\n    module_state.HasCapability(spv::CapabilityGeometryStreams) && !enabled_features.geometryStreams) {\n    skip |= LogError(\"VUID-VkGraphicsPipelineCreateInfo-geometryStreams-02321\", module_state.handle(), loc,\n                     \"SPIR-V uses GeometryStreams capability, but \"\n                     \"VkPhysicalDeviceTransformFeedbackFeaturesEXT::geometryStreams is not enabled.\");\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-RuntimeSpirv-OpEmitStreamVertex-06310\", \"The Stream value to OpEmitStreamVertex and OpEndStreamPrimitive must be less than VkPhysicalDeviceTransformFeedbackPropertiesEXT::maxTransformFeedbackStreams\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (stream >= phys_dev_ext_props.transform_feedback_props.maxTransformFeedbackStreams) {\n    skip |= LogError(\"VUID-RuntimeSpirv-OpEmitStreamVertex-06310\", module_state.handle(), loc,\n                     \"SPIR-V uses transform feedback stream\\n%s\\nwith index %\" PRIu32\n                     \", which is not less than maxTransformFeedbackStreams (%\" PRIu32 \").\",\n                     insn->Describe().c_str(), stream,\n                     phys_dev_ext_props.transform_feedback_props.maxTransformFeedbackStreams);\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-RuntimeSpirv-transformFeedbackStreamsLinesTriangles-06311\", \"If the geometry shader emits to more than one vertex stream and VkPhysicalDeviceTransformFeedbackPropertiesEXT::transformFeedbackStreamsLinesTriangles is VK_FALSE, then Execution Mode must be OutputPoints\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (emitted_streams_size > 1 && !output_points &&\n    phys_dev_ext_props.transform_feedback_props.transformFeedbackStreamsLinesTriangles == VK_FALSE) {\n    skip |= LogError(\"VUID-RuntimeSpirv-transformFeedbackStreamsLinesTriangles-06311\", module_state.handle(), loc,\n                     \"SPIR-V emits to %\" PRIu32\n                     \" vertex streams and transformFeedbackStreamsLinesTriangles \"\n                     \"is VK_FALSE, but execution mode is not OutputPoints.\",\n                     emitted_streams_size);\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-RuntimeSpirv-OpImage-06376\", \"If an OpImage*Gather operation has an image operand of Offset, ConstOffset, or ConstOffsets the offset value must be greater than or equal to minTexelGatherOffset\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (use_signed && (signed_offset < phys_dev_props.limits.minTexelGatherOffset)) {\n    skip |= LogError(\"VUID-RuntimeSpirv-OpImage-06376\", module_state.handle(), loc,\n                     \"SPIR-V uses\\n%s\\nwith offset (%\" PRId32\n                     \") less than VkPhysicalDeviceLimits::minTexelGatherOffset (%\" PRId32 \").\",\n                     insn.Describe().c_str(), signed_offset, phys_dev_props.limits.minTexelGatherOffset);\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-RuntimeSpirv-OpImageSample-06435\", \"If an OpImageSample* or OpImageFetch* operation has an image operand of ConstOffset then the offset value must be greater than or equal to minTexelOffset\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (use_signed && (signed_offset < phys_dev_props.limits.minTexelOffset)) {\n    skip |= LogError(\"VUID-RuntimeSpirv-OpImageSample-06435\", module_state.handle(), loc,\n                     \"SPIR-V uses\\n%s\\nwith offset (%\" PRId32\n                     \") less than VkPhysicalDeviceLimits::minTexelOffset (%\" PRId32 \").\",\n                     insn.Describe().c_str(), signed_offset, phys_dev_props.limits.minTexelOffset);\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-RuntimeSpirv-OpImageSample-06436\", \"If an OpImageSample* or OpImageFetch* operation has an image operand of ConstOffset then the offset value must be less than or equal to maxTexelOffset\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "skip |= LogError(\"VUID-RuntimeSpirv-OpImageSample-06436\", module_state.handle(), loc,\n                 \"SPIR-V uses\\n%s\\nwith offset (%\" PRIu32\n                 \") greater than VkPhysicalDeviceLimits::maxTexelOffset (%\" PRIu32 \").\",\n                 insn.Describe().c_str(), offset, phys_dev_props.limits.maxTexelOffset);\n"
        },
        {
            "role": "user",
            "content": "{\"VUID-RuntimeSpirv-shaderSubgroupClock-06267\", \"If shaderSubgroupClock is not enabled, the Subgroup scope must not be used for OpReadClockKHR\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if ((scope_type == spv::ScopeSubgroup) && (enabled_features.shaderSubgroupClock == VK_FALSE)) {\n    skip |= LogError(\"VUID-RuntimeSpirv-shaderSubgroupClock-06267\", device, loc,\n                     \"SPIR-V uses\\n%s\\nwith a Subgroup scope but shaderSubgroupClock was not enabled.\",\n                     insn.Describe().c_str());\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-RuntimeSpirv-OpImageWrite-07112\", \"OpImageWrite to any Image whose Image Format is not Unknown must have the Texel operand contain at least as many components as the corresponding VkFormat as given in the SPIR-V Image Format compatibility table\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (texel_component_count < format_component_count) {\n    skip |= LogError(\"VUID-RuntimeSpirv-OpImageWrite-07112\", module_state.handle(), loc,\n                     \"SPIR-V OpImageWrite Texel operand only contains %\" PRIu32\n                     \" components, but the OpImage format mapping to %s has %\" PRIu32 \" components.\\n%s\\n%s\\n\",\n                     texel_component_count, string_VkFormat(compatible_format), format_component_count,\n                     insn.Describe().c_str(), image_def->Describe().c_str());\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkGraphicsPipelineCreateInfo-pStages-08711\", \"If pStages includes a fragment shader stage, VK_DYNAMIC_STATE_DEPTH_WRITE_ENABLE is not set in VkPipelineDynamicStateCreateInfo::pDynamicStates, and the fragment shader declares the EarlyFragmentTests execution mode and uses OpDepthAttachmentReadEXT, the depthWriteEnable member of VkPipelineDepthStencilStateCreateInfo must be VK_FALSE\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (mode_early_fragment_test && write_enabled) {\n    skip |= LogError(\"VUID-VkGraphicsPipelineCreateInfo-pStages-08711\", module_state.handle(), loc,\n                     \"SPIR-V (Fragment stage) contains OpDepthAttachmentReadEXT, and depthWriteEnable is not false.\");\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-RuntimeSpirv-minSampleShading-08732\", \"If sample shading is enabled and any of the OpColorAttachmentReadEXT, OpDepthAttachmentReadEXT, or OpStencilAttachmentReadEXT operations are used, then minSampleShading must be 1.0\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (using_tile_image_op && ms_state && ms_state->sampleShadingEnable && (ms_state->minSampleShading != 1.0)) {\n    skip |= LogError(\"VUID-RuntimeSpirv-minSampleShading-08732\", module_state.handle(), loc,\n                     \"minSampleShading (%f) is not equal to 1.0.\", ms_state->minSampleShading);\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-RuntimeSpirv-shaderTileImageDepthReadAccess-08729\", \"If shaderTileImageDepthReadAccess is not enabled, OpDepthAttachmentReadEXT operation must not be used\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (module_state.static_data_.has_shader_tile_image_depth_read && !enabled_features.shaderTileImageDepthReadAccess) {\n    skip |= LogError(\"VUID-RuntimeSpirv-shaderTileImageDepthReadAccess-08729\", module_state.handle(), loc,\n                     \"shaderTileImageDepthReadAccess was not enabled\");\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-RuntimeSpirv-shaderTileImageStencilReadAccess-08730\", \"If shaderTileImageStencilReadAccess is not enabled, OpStencilAttachmentReadEXT operation must not be used\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (module_state.static_data_.has_shader_tile_image_stencil_read && !enabled_features.shaderTileImageStencilReadAccess) {\n    skip |= LogError(\"VUID-RuntimeSpirv-shaderTileImageStencilReadAccess-08730\", module_state.handle(), loc,\n                     \"shaderTileImageStencilReadAccess was not enabled\");\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkPipelineShaderStageCreateInfo-module-parameter\", \"If module is not VK_NULL_HANDLE, module must be a valid VkShaderModule handle\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "spvtools::MessageConsumer consumer = [&skip, &module_state, &stage, loc, this](\n    skip |= LogError(\"VUID-VkPipelineShaderStageCreateInfo-module-parameter\", device, loc,\n                     \"%s failed in spirv-opt because it does not contain valid spirv for stage %s. %s\",\n                     FormatHandle(module_state.handle()).c_str(), string_VkShaderStageFlagBits(stage), message);\n"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkSpecializationMapEntry-constantID-00776\", \"For a constantID specialization constant declared in a shader, size must match the byte size of the constantID. If the specialization constant is of type boolean, size must be the byte size of VkBool32\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "skip |= LogError(\"VUID-VkSpecializationMapEntry-constantID-00776\", device, loc,\n                 \"specialization constant (ID = %\" PRIu32 \", entry = %\" PRIu32\n                 \") has invalid size %zu in %s. Expected size is %\" PRIu32 \" from shader definition.\",\n                 map_entry.constantID, spec_id, map_entry.size, FormatHandle(module_state.handle()).c_str(),\n                 spec_const_size);\n"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkGraphicsPipelineCreateInfo-renderPass-06061\", \"If the dynamicRenderingLocalRead feature is not enabled, the pipeline requires fragment shader state, and renderPass is VK_NULL_HANDLE, fragment shaders in pStages must not include the InputAttachment capability\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (stage == VK_SHADER_STAGE_FRAGMENT_BIT && pipeline->GraphicsCreateInfo().renderPass == VK_NULL_HANDLE &&\n    skip |= LogError(\"VUID-VkGraphicsPipelineCreateInfo-renderPass-06061\", device, loc,\n                     \"is being created with fragment shader state and renderPass = VK_NULL_HANDLE, but fragment \"\n                     \"shader includes InputAttachment capability.\");\n"
        },
        {
            "role": "user",
            "content": "{\"VUID-RuntimeSpirv-x-06432\", \"In compute shaders using the GLCompute Execution Model the product of x size, y size, and z size in LocalSize or LocalSizeId must be less than or equal to VkPhysicalDeviceLimits::maxComputeWorkGroupInvocations\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (fail && stage == VK_SHADER_STAGE_COMPUTE_BIT) {\n    skip |= LogError(\"VUID-RuntimeSpirv-x-06432\", module_state.handle(), loc,\n                     \"SPIR-V LocalSiz (%\" PRIu32 \", %\" PRIu32 \", %\" PRIu32\n                     \") exceeds device limit maxComputeWorkGroupInvocations (%\" PRIu32 \").\",\n                     local_size_x, local_size_y, local_size_z, phys_dev_props.limits.maxComputeWorkGroupInvocations);\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkShaderModuleCreateInfo-codeSize-08735\", \"If pCode is a pointer to SPIR-V code, codeSize must be a multiple of 4\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "} else if (SafeModulo(create_info.codeSize, 4) != 0) {\n    skip |= LogError(\"VUID-VkShaderModuleCreateInfo-codeSize-08735\", device, create_info_loc.dot(Field::codeSize),\n                     \"(%zu) must be a multiple of 4.\", create_info.codeSize);\n"
        },
        {
            "role": "user",
            "content": "{\"VUID-vkGetShaderModuleIdentifierEXT-shaderModuleIdentifier-06884\", \"shaderModuleIdentifier feature must be enabled\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (!(enabled_features.shaderModuleIdentifier)) {\n    skip |= LogError(\"VUID-vkGetShaderModuleIdentifierEXT-shaderModuleIdentifier-06884\", shaderModule, error_obj.location,\n                     \"the shaderModuleIdentifier feature was not enabled.\");\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-vkGetShaderModuleCreateInfoIdentifierEXT-shaderModuleIdentifier-06885\", \"shaderModuleIdentifier feature must be enabled\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (!(enabled_features.shaderModuleIdentifier)) {\n    skip |= LogError(\"VUID-vkGetShaderModuleCreateInfoIdentifierEXT-shaderModuleIdentifier-06885\", device, error_obj.location,\n                     \"the shaderModuleIdentifier feature was not enabled.\");\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkPipelineShaderStageCreateInfo-pNext-02755\", \"If a VkPipelineShaderStageRequiredSubgroupSizeCreateInfo structure is included in the pNext chain, the subgroupSizeControl feature must be enabled, and stage must be a valid bit specified in requiredSubgroupSizeStages\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (!enabled_features.subgroupSizeControl) {\n    skip |= LogError(\"VUID-VkPipelineShaderStageCreateInfo-pNext-02755\", module_state.handle(), pNext_loc,\n                     \"the subgroupSizeControl feature was not enabled\");\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkPipelineShaderStageCreateInfo-pNext-02757\", \"If a VkPipelineShaderStageRequiredSubgroupSizeCreateInfo structure is included in the pNext chain, and flags has the VK_PIPELINE_SHADER_STAGE_CREATE_REQUIRE_FULL_SUBGROUPS_BIT flag set, the local workgroup size in the X dimension of the pipeline must be a multiple of VkPipelineShaderStageRequiredSubgroupSizeCreateInfo::requiredSubgroupSize\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (SafeModulo(local_size_x, required_subgroup_size) != 0) {\n    skip |= LogError(\"VUID-VkPipelineShaderStageCreateInfo-pNext-02757\", module_state.handle(), loc,\n                     \"SPIR-V Local workgroup size x (%\" PRIu32\n                     \") is not a multiple of \"\n                     \"requiredSubgroupSize (%\" PRIu32 \").\",\n                     local_size_x, required_subgroup_size);\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkPipelineShaderStageRequiredSubgroupSizeCreateInfo-requiredSubgroupSize-02760\", \"requiredSubgroupSize must be a power-of-two integer\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (!IsPowerOfTwo(required_subgroup_size)) {\n    skip |= LogError(\"VUID-VkPipelineShaderStageRequiredSubgroupSizeCreateInfo-requiredSubgroupSize-02760\",\n                     module_state.handle(), pNext_loc.dot(Field::requiredSubgroupSizeStages),\n                     \"(%\" PRIu32 \") is not a power of 2.\", required_subgroup_size);\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkPipelineShaderStageRequiredSubgroupSizeCreateInfo-requiredSubgroupSize-02762\", \"requiredSubgroupSize must be less than or equal to maxSubgroupSize\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (required_subgroup_size > phys_dev_ext_props.subgroup_size_control_props.maxSubgroupSize) {\n    skip |= LogError(\"VUID-VkPipelineShaderStageRequiredSubgroupSizeCreateInfo-requiredSubgroupSize-02762\",\n                     module_state.handle(), pNext_loc.dot(Field::requiredSubgroupSizeStages),\n                     \"(%\" PRIu32 \") is greater than maxSubgroupSize (%\" PRIu32 \").\", required_subgroup_size,\n                     phys_dev_ext_props.subgroup_size_control_props.maxSubgroupSize);\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-RuntimeSpirv-x-06429\", \"In compute shaders using the GLCompute Execution Model the x size in LocalSize or LocalSizeId must be less than or equal to VkPhysicalDeviceLimits::maxComputeWorkGroupSize[0]\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (local_size_x > phys_dev_props.limits.maxComputeWorkGroupSize[0]) {\n    skip |= LogError(\"VUID-RuntimeSpirv-x-06429\", module_state.handle(), loc,\n                     \"SPIR-V LocalSize X (%\" PRIu32 \") exceeds device limit maxComputeWorkGroupSize[0] (%\" PRIu32 \").\",\n                     local_size_x, phys_dev_props.limits.maxComputeWorkGroupSize[0]);\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-RuntimeSpirv-z-06431\", \"In compute shaders using the GLCompute Execution Model the z size in LocalSize or LocalSizeId must be less than or equal to VkPhysicalDeviceLimits::maxComputeWorkGroupSize[2]\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (local_size_z > phys_dev_props.limits.maxComputeWorkGroupSize[2]) {\n    skip |= LogError(\"VUID-RuntimeSpirv-z-06431\", module_state.handle(), loc,\n                     \"SPIR-V LocalSize Z (%\" PRIu32 \") exceeds device limit maxComputeWorkGroupSize[2] (%\" PRIu32 \").\",\n                     local_size_z, phys_dev_props.limits.maxComputeWorkGroupSize[2]);\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkShaderCreateInfoEXT-flags-08417\", \"If flags includes VK_SHADER_CREATE_REQUIRE_FULL_SUBGROUPS_BIT_EXT but not VK_SHADER_CREATE_ALLOW_VARYING_SUBGROUP_SIZE_BIT_EXT and no VkShaderRequiredSubgroupSizeCreateInfoEXT structure is included in the pNext chain, the local workgroup size in the X dimension of the shader must be a multiple of subgroupSize\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (!required_subgroup_size && SafeModulo(local_size_x, phys_dev_props_core11.subgroupSize) != 0) {\n    skip |= LogError(\"VUID-VkShaderCreateInfoEXT-flags-08417\", module_state.handle(), loc.dot(Field::flags),\n                     \"(%s), but local workgroup size X dimension (%\" PRIu32\n                     \") is not a multiple of VkPhysicalDeviceVulkan11Properties::subgroupSize (%\" PRIu32 \").\",\n                     string_VkPipelineShaderStageCreateFlags(stage_state.shader_object_create_info->flags).c_str(),\n                     local_size_x, phys_dev_props_core11.subgroupSize);\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkD3D12FenceSubmitInfoKHR-waitSemaphoreValuesCount-00079\", \"waitSemaphoreValuesCount must be the same value as VkSubmitInfo::waitSemaphoreCount, where this structure is in the pNext chain of a VkSubmitInfo structure\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (d3d12_fence_submit_info->waitSemaphoreValuesCount != submit.waitSemaphoreCount) {\n    skip |= LogError(\"VUID-VkD3D12FenceSubmitInfoKHR-waitSemaphoreValuesCount-00079\", state.queue, submit_loc,\n                     \"contains an instance of VkD3D12FenceSubmitInfoKHR, but its waitSemaphoreValuesCount (%\" PRIu32\n                     \") is different than %s (%\" PRIu32 \").\",\n                     d3d12_fence_submit_info->waitSemaphoreValuesCount,\n                     submit_loc.dot(Field::waitSemaphoreCount).Fields().c_str(), submit.waitSemaphoreCount);\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkD3D12FenceSubmitInfoKHR-signalSemaphoreValuesCount-00080\", \"signalSemaphoreValuesCount must be the same value as VkSubmitInfo::signalSemaphoreCount, where this structure is in the pNext chain of a VkSubmitInfo structure\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (d3d12_fence_submit_info->signalSemaphoreValuesCount != submit.signalSemaphoreCount) {\n    skip |= LogError(\"VUID-VkD3D12FenceSubmitInfoKHR-signalSemaphoreValuesCount-00080\", state.queue, submit_loc,\n                     \"contains an instance of VkD3D12FenceSubmitInfoKHR, but its signalSemaphoreValuesCount (%\" PRIu32\n                     \") is different than %s (%\" PRIu32 \").\",\n                     d3d12_fence_submit_info->signalSemaphoreValuesCount,\n                     submit_loc.dot(Field::signalSemaphoreCount).Fields().c_str(), submit.signalSemaphoreCount);\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkSubmitInfo-pWaitSemaphores-03239\", \"If any element of pWaitSemaphores or pSignalSemaphores was created with a VkSemaphoreType of VK_SEMAPHORE_TYPE_TIMELINE, then the pNext chain must include a VkTimelineSemaphoreSubmitInfo structure\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (timeline_semaphore_submit_info == nullptr) {\n    skip |= LogError(\"VUID-VkSubmitInfo-pWaitSemaphores-03239\", semaphore, signal_semaphore_loc,\n                     \"(%s) is a timeline semaphore, but VkSubmitInfo\"\n                     \"does not include an instance of VkTimelineSemaphoreSubmitInfo\",\n                     FormatHandle(semaphore).c_str());\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkSubmitInfo2-semaphore-03881\", \"If the same semaphore is used as the semaphore member of both an element of pSignalSemaphoreInfos and pWaitSemaphoreInfos, and that semaphore is a timeline semaphore, the value member of the pSignalSemaphoreInfos element must be greater than the value member of the pWaitSemaphoreInfos element\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (wait_info.semaphore == sig_info.semaphore && wait_info.value >= sig_info.value) {\n    Location sig_loc = submit_loc.dot(Field::pSignalSemaphoreInfos, sig_index);\n    skip |= LogError(\"VUID-VkSubmitInfo2-semaphore-03881\", objlist, wait_info_loc.dot(Field::value),\n                     \"(%\" PRIu64 \") is less or equal to %s (%\" PRIu64 \").\", wait_info.value,\n                     sig_loc.dot(Field::value).Fields().c_str(), sig_info.value);\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkBindSparseInfo-pWaitSemaphores-03246\", \"If any element of pWaitSemaphores or pSignalSemaphores was created with a VkSemaphoreType of VK_SEMAPHORE_TYPE_TIMELINE then the pNext chain must include a VkTimelineSemaphoreSubmitInfo structure\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (timeline_semaphore_submit_info == nullptr) {\n    skip |= LogError(\"VUID-VkBindSparseInfo-pWaitSemaphores-03246\", semaphore, wait_semaphore_loc,\n                     \"(%s) is a timeline semaphore, but VkSubmitInfo does \"\n                     \"not include an instance of VkTimelineSemaphoreSubmitInfo\",\n                     FormatHandle(semaphore).c_str());\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkBindSparseInfo-pWaitSemaphores-03246\", \"If any element of pWaitSemaphores or pSignalSemaphores was created with a VkSemaphoreType of VK_SEMAPHORE_TYPE_TIMELINE then the pNext chain must include a VkTimelineSemaphoreSubmitInfo structure\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (timeline_semaphore_submit_info == nullptr) {\n    skip |= LogError(\"VUID-VkBindSparseInfo-pWaitSemaphores-03246\", semaphore, signal_semaphore_loc,\n                     \"(%s) is a timeline semaphore, but VkSubmitInfo\"\n                     \"does not include an instance of VkTimelineSemaphoreSubmitInfo\",\n                     FormatHandle(semaphore).c_str());\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkExportFenceCreateInfo-handleTypes-01446\", \"The bits in handleTypes must be supported and compatible, as reported by VkExternalFenceProperties\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (export_supported &&\n    (fence_export_info->handleTypes & external_properties.compatibleHandleTypes) != fence_export_info->handleTypes) {\n    skip |= LogError(\"VUID-VkExportFenceCreateInfo-handleTypes-01446\", device,\n                     create_info_loc.pNext(Struct::VkExportFenceCreateInfo, Field::handleTypes),\n                     \"(%s) are not reported as compatible by vkGetPhysicalDeviceExternalFenceProperties (%s).\",\n                     string_VkExternalFenceHandleTypeFlags(fence_export_info->handleTypes).c_str(),\n                     string_VkExternalFenceHandleTypeFlags(external_properties.compatibleHandleTypes).c_str());\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkSemaphoreTypeCreateInfo-timelineSemaphore-03252\", \"If the timelineSemaphore feature is not enabled, semaphoreType must not equal VK_SEMAPHORE_TYPE_TIMELINE\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (sem_type_create_info->semaphoreType == VK_SEMAPHORE_TYPE_TIMELINE && !enabled_features.timelineSemaphore) {\n    skip |= LogError(\"VUID-VkSemaphoreTypeCreateInfo-timelineSemaphore-03252\", device,\n                     create_info_loc.dot(Field::semaphoreType),\n                     \"is VK_SEMAPHORE_TYPE_TIMELINE, but timelineSemaphore feature was not enabled.\");\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkExportSemaphoreCreateInfo-handleTypes-01124\", \"The bits in handleTypes must be supported and compatible, as reported by VkExternalSemaphoreProperties\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if ((external_properties.externalSemaphoreFeatures & VK_EXTERNAL_SEMAPHORE_FEATURE_EXPORTABLE_BIT) == 0) {\n    skip |= LogError(\"VUID-VkExportSemaphoreCreateInfo-handleTypes-01124\", device,\n                     create_info_loc.pNext(Struct::VkExportSemaphoreCreateInfo, Field::handleTypes),\n                     \"(%s) does not support VK_EXTERNAL_SEMAPHORE_FEATURE_EXPORTABLE_BIT.\",\n                     string_VkExternalSemaphoreHandleTypeFlagBits(flag));\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkExportSemaphoreCreateInfo-handleTypes-01124\", \"The bits in handleTypes must be supported and compatible, as reported by VkExternalSemaphoreProperties\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (export_supported &&\n    (sem_export_info->handleTypes & external_properties.compatibleHandleTypes) != sem_export_info->handleTypes) {\n    skip |= LogError(\"VUID-VkExportSemaphoreCreateInfo-handleTypes-01124\", device,\n                     create_info_loc.pNext(Struct::VkExportSemaphoreCreateInfo, Field::handleTypes),\n                     \"(%s) are not reported as compatible by vkGetPhysicalDeviceExternalSemaphoreProperties (%s).\",\n                     string_VkExternalSemaphoreHandleTypeFlags(sem_export_info->handleTypes).c_str(),\n                     string_VkExternalSemaphoreHandleTypeFlags(external_properties.compatibleHandleTypes).c_str());\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-vkDestroyFence-fence-01120\", \"All queue submission commands that refer to fence must have completed execution\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (fence_state && fence_state->Scope() == vvl::Fence::kInternal && fence_state->State() == vvl::Fence::kInflight) {\n    skip |= ValidateObjectNotInUse(fence_state.get(), error_obj.location.dot(Field::fence), \"VUID-vkDestroyFence-fence-01120\");\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-vkResetFences-pFences-01123\", \"Each element of pFences must not be currently associated with any queue command that has not yet completed execution on that queue\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (fence_state->Scope() == vvl::Fence::kInternal && fence_state->State() == vvl::Fence::kInflight) {\n    skip |= LogError(\"VUID-vkResetFences-pFences-01123\", pFences[i], error_obj.location.dot(Field::pFences, i),\n                     \"(%s) is in use.\", FormatHandle(pFences[i]).c_str());\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-vkDestroyEvent-event-01145\", \"All submitted commands that refer to event must have completed execution\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (auto event_state = Get<vvl::Event>(event)) {\n    skip |= ValidateObjectNotInUse(event_state.get(), error_obj.location.dot(Field::event), \"VUID-vkDestroyEvent-event-01145\");\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-vkCmdSetEvent2-dependencyFlags-03825\", \"The dependencyFlags member of pDependencyInfo must be 0\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (pDependencyInfo->dependencyFlags != 0) {\n    skip |= LogError(\"VUID-vkCmdSetEvent2-dependencyFlags-03825\", objlist, dep_info_loc.dot(Field::dependencyFlags),\n                     \"(%s) must be 0.\", string_VkDependencyFlags(pDependencyInfo->dependencyFlags).c_str());\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-vkCmdPipelineBarrier-None-07889\", \"If vkCmdPipelineBarrier is called within a render pass instance using a VkRenderPass object, the render pass must have been created with at least one subpass dependency that expresses a dependency from the current subpass to itself, does not include VK_DEPENDENCY_BY_REGION_BIT if this command does not, does not include VK_DEPENDENCY_VIEW_LOCAL_BIT if this command does not, and has synchronization scopes and access scopes that are all supersets of the scopes defined in this command\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (state.self_dependencies.empty()) {\n    skip |= LogError(\"VUID-vkCmdPipelineBarrier-None-07889\", state.rp_handle, outer_loc,\n                     \"Barriers cannot be set during subpass %\" PRIu32 \" of %s with no self-dependency specified.\",\n                     state.active_subpass, FormatHandle(state.rp_handle).c_str());\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-vkCmdPipelineBarrier-bufferMemoryBarrierCount-01178\", \"If vkCmdPipelineBarrier is called within a render pass instance using a VkRenderPass object, it must not include any buffer memory barriers\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (0 != buffer_mem_barrier_count) {\n    skip |= LogError(\"VUID-vkCmdPipelineBarrier-bufferMemoryBarrierCount-01178\", state.rp_handle,\n                     outer_loc.dot(Field::bufferMemoryBarrierCount), \"is non-zero (%\" PRIu32 \") for subpass %\" PRIu32 \" of %s.\",\n                     buffer_mem_barrier_count, state.active_subpass, FormatHandle(rp_state->Handle()).c_str());\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-vkCmdPipelineBarrier-srcQueueFamilyIndex-01182\", \"If vkCmdPipelineBarrier is called within a render pass instance, the srcQueueFamilyIndex and dstQueueFamilyIndex members of any memory barrier included in this command must be equal\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (img_barrier.srcQueueFamilyIndex != img_barrier.dstQueueFamilyIndex) {\n    skip |= LogError(\"VUID-vkCmdPipelineBarrier-srcQueueFamilyIndex-01182\", state.rp_handle,\n                     barrier_loc.dot(Field::srcQueueFamilyIndex),\n                     \"is %\" PRIu32 \" and dstQueueFamilyIndex is %\" PRIu32 \" but they must be equal.\",\n                     img_barrier.srcQueueFamilyIndex, img_barrier.dstQueueFamilyIndex);\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-vkCmdPipelineBarrier-None-07893\", \"If vkCmdPipelineBarrier is called inside a render pass instance, and there is more than one view in the current subpass, dependency flags must include VK_DEPENDENCY_VIEW_LOCAL_BIT\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (GetBitSetCount(sub_desc.viewMask) > 1 && ((dependency_flags & VK_DEPENDENCY_VIEW_LOCAL_BIT) == 0)) {\n    skip |= LogError(\"VUID-vkCmdPipelineBarrier-None-07893\", state.rp_handle, outer_loc.dot(Field::dependencyFlags),\n                     \"%s is missing VK_DEPENDENCY_VIEW_LOCAL_BIT and subpass %\" PRIu32 \" has viewMasks 0x%\" PRIx32 \".\",\n                     string_VkDependencyFlags(dependency_flags).c_str(), state.active_subpass, sub_desc.viewMask);\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-vkCmdPipelineBarrier2-srcQueueFamilyIndex-01182\", \"If vkCmdPipelineBarrier2 is called within a render pass instance, the srcQueueFamilyIndex and dstQueueFamilyIndex members of any memory barrier included in this command must be equal\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (img_barrier.srcQueueFamilyIndex != img_barrier.dstQueueFamilyIndex) {\n    skip |= LogError(\"VUID-vkCmdPipelineBarrier2-srcQueueFamilyIndex-01182\", state.rp_handle,\n                     barrier_loc.dot(Field::srcQueueFamilyIndex),\n                     \"is %\" PRIu32 \" and dstQueueFamilyIndex is %\" PRIu32 \" but they must be equal.\",\n                     img_barrier.srcQueueFamilyIndex, img_barrier.dstQueueFamilyIndex);\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-vkCmdPipelineBarrier2-None-07893\", \"If vkCmdPipelineBarrier2 is called inside a render pass instance, and there is more than one view in the current subpass, dependency flags must include VK_DEPENDENCY_VIEW_LOCAL_BIT\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (GetBitSetCount(sub_desc.viewMask) > 1 && ((dep_info.dependencyFlags & VK_DEPENDENCY_VIEW_LOCAL_BIT) == 0)) {\n    skip |= LogError(\"VUID-vkCmdPipelineBarrier2-None-07893\", state.rp_handle, outer_loc.dot(Field::dependencyFlags),\n                     \"%s is missing VK_DEPENDENCY_VIEW_LOCAL_BIT and subpass %\" PRIu32 \" has viewMasks 0x%\" PRIx32 \".\",\n                     string_VkDependencyFlags(dep_info.dependencyFlags).c_str(), state.active_subpass, sub_desc.viewMask);\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-vkCmdWaitEvents-srcQueueFamilyIndex-02803\", \"The srcQueueFamilyIndex and dstQueueFamilyIndex members of any element of pBufferMemoryBarriers or pImageMemoryBarriers must be equal\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (pBufferMemoryBarriers[i].srcQueueFamilyIndex != pBufferMemoryBarriers[i].dstQueueFamilyIndex) {\n    skip |= LogError(\"VUID-vkCmdWaitEvents-srcQueueFamilyIndex-02803\", commandBuffer,\n                     error_obj.location.dot(Field::pBufferMemoryBarriers, i),\n                     \"has different srcQueueFamilyIndex (%\" PRIu32 \") and dstQueueFamilyIndex (%\" PRIu32 \").\",\n                     pBufferMemoryBarriers[i].srcQueueFamilyIndex, pBufferMemoryBarriers[i].dstQueueFamilyIndex);\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-vkCmdWaitEvents-srcQueueFamilyIndex-02803\", \"The srcQueueFamilyIndex and dstQueueFamilyIndex members of any element of pBufferMemoryBarriers or pImageMemoryBarriers must be equal\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (pImageMemoryBarriers[i].srcQueueFamilyIndex != pImageMemoryBarriers[i].dstQueueFamilyIndex) {\n    skip |= LogError(\"VUID-vkCmdWaitEvents-srcQueueFamilyIndex-02803\", commandBuffer,\n                     error_obj.location.dot(Field::pImageMemoryBarriers, i),\n                     \"has different srcQueueFamilyIndex (%\" PRIu32 \") and dstQueueFamilyIndex (%\" PRIu32 \").\",\n                     pImageMemoryBarriers[i].srcQueueFamilyIndex, pImageMemoryBarriers[i].dstQueueFamilyIndex);\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-vkCmdWaitEvents2-synchronization2-03836\", \"The synchronization2 feature must be enabled\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (!enabled_features.synchronization2) {\n    skip |= LogError(\"VUID-vkCmdWaitEvents2-synchronization2-03836\", commandBuffer, error_obj.location,\n                     \"the synchronization2 feature was not enabled.\");\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-vkCmdWaitEvents2-dependencyFlags-03844\", \"If vkCmdWaitEvents2 is being called inside a render pass instance, the srcStageMask member of any element of the pMemoryBarriers, pBufferMemoryBarriers, or pImageMemoryBarriers members of pDependencyInfos must not include VK_PIPELINE_STAGE_2_HOST_BIT\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (pDependencyInfos[i].dependencyFlags != 0) {\n    skip |= LogError(\"VUID-vkCmdWaitEvents2-dependencyFlags-03844\", objlist, dep_info_loc.dot(Field::dependencyFlags),\n                     \"(%s) must be 0.\", string_VkDependencyFlags(pDependencyInfos[i].dependencyFlags).c_str());\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-vkCmdPipelineBarrier2-synchronization2-03848\", \"The synchronization2 feature must be enabled\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (!enabled_features.synchronization2) {\n    skip |= LogError(\"VUID-vkCmdPipelineBarrier2-synchronization2-03848\", commandBuffer, error_obj.location,\n                     \"the synchronization2 feature was not enabled.\");\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-vkCmdPipelineBarrier2-dependencyFlags-01186\", \"If vkCmdPipelineBarrier2 is called outside of a render pass instance, the dependency flags must not include VK_DEPENDENCY_VIEW_LOCAL_BIT\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (pDependencyInfo->dependencyFlags & VK_DEPENDENCY_VIEW_LOCAL_BIT) {\n    skip |= LogError(\"VUID-vkCmdPipelineBarrier2-dependencyFlags-01186\", objlist, dep_info_loc.dot(Field::dependencyFlags),\n                     \"VK_DEPENDENCY_VIEW_LOCAL_BIT must not be set outside of a render pass instance.\");\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-vkSetEvent-event-03941\", \"event must not have been created with VK_EVENT_CREATE_DEVICE_ONLY_BIT\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (event_state->flags & VK_EVENT_CREATE_DEVICE_ONLY_BIT_KHR) {\n    skip |= LogError(\"VUID-vkSetEvent-event-03941\", event, error_obj.location.dot(Field::event),\n                     \"(%s) was created with VK_EVENT_CREATE_DEVICE_ONLY_BIT_KHR.\", FormatHandle(event).c_str());\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-vkResetEvent-event-03823\", \"event must not have been created with VK_EVENT_CREATE_DEVICE_ONLY_BIT\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (event_state->flags & VK_EVENT_CREATE_DEVICE_ONLY_BIT_KHR) {\n    skip |= LogError(\"VUID-vkResetEvent-event-03823\", event, error_obj.location.dot(Field::event),\n                     \"(%s) was created with VK_EVENT_CREATE_DEVICE_ONLY_BIT_KHR.\", FormatHandle(event).c_str());\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-vkGetEventStatus-event-03940\", \"event must not have been created with VK_EVENT_CREATE_DEVICE_ONLY_BIT\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (event_state->flags & VK_EVENT_CREATE_DEVICE_ONLY_BIT_KHR) {\n    skip |= LogError(\"VUID-vkGetEventStatus-event-03940\", event, error_obj.location.dot(Field::event),\n                     \"(%s) was created with VK_EVENT_CREATE_DEVICE_ONLY_BIT_KHR.\", FormatHandle(event).c_str());\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkSemaphoreSignalInfo-semaphore-03257\", \"semaphore must have been created with a VkSemaphoreType of VK_SEMAPHORE_TYPE_TIMELINE\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (semaphore_state->type != VK_SEMAPHORE_TYPE_TIMELINE) {\n    skip |= LogError(\"VUID-VkSemaphoreSignalInfo-semaphore-03257\", pSignalInfo->semaphore, signal_loc.dot(Field::semaphore),\n                     \"%s was created with %s.\", FormatHandle(pSignalInfo->semaphore).c_str(),\n                     string_VkSemaphoreType(semaphore_state->type));\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkSemaphoreSignalInfo-value-03259\", \"value must be less than the value of any pending semaphore signal operations\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (last_op) {\n    skip |= LogError(\"VUID-VkSemaphoreSignalInfo-value-03259\", pSignalInfo->semaphore, signal_loc.dot(Field::value),\n                     \"(%\" PRIu64 \") must be less than value of any pending signal operation (%\" PRIu64 \") for semaphore %s.\",\n                     pSignalInfo->value, last_op->payload, FormatHandle(pSignalInfo->semaphore).c_str());\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-vkGetSemaphoreCounterValue-semaphore-03255\", \"semaphore must have been created with a VkSemaphoreType of VK_SEMAPHORE_TYPE_TIMELINE\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (semaphore_state->type != VK_SEMAPHORE_TYPE_TIMELINE) {\n    skip |= LogError(\"VUID-vkGetSemaphoreCounterValue-semaphore-03255\", semaphore, error_obj.location.dot(Field::semaphore),\n                     \"%s was created with %s.\", FormatHandle(semaphore).c_str(), string_VkSemaphoreType(semaphore_state->type));\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-vkCmdSetEvent2-srcStageMask-09391\", \"The srcStageMask member of any element of the pMemoryBarriers, pBufferMemoryBarriers, or pImageMemoryBarriers members of pDependencyInfo must not include VK_PIPELINE_STAGE_2_HOST_BIT\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (barrier.srcStageMask == VK_PIPELINE_STAGE_2_HOST_BIT) {\n    skip |= LogError(\"VUID-vkCmdSetEvent2-srcStageMask-09391\", objects, barrier_loc.dot(Field::srcStageMask),\n                     \"is VK_PIPELINE_STAGE_2_HOST_BIT.\");\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-vkCmdSetEvent2-dstStageMask-09392\", \"The dstStageMask member of any element of the pMemoryBarriers, pBufferMemoryBarriers, or pImageMemoryBarriers members of pDependencyInfo must not include VK_PIPELINE_STAGE_2_HOST_BIT\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (barrier.dstStageMask == VK_PIPELINE_STAGE_2_HOST_BIT) {\n    skip |= LogError(\"VUID-vkCmdSetEvent2-dstStageMask-09392\", objects, barrier_loc.dot(Field::dstStageMask),\n                     \"is VK_PIPELINE_STAGE_2_HOST_BIT.\");\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkVideoInlineQueryInfoKHR-queryPool-08373\", \"If queryPool is not VK_NULL_HANDLE, then the sum of firstQuery and queryCount must be less than or equal to the number of queries in queryPool\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (query_info.firstQuery + query_info.queryCount > query_pool_state.create_info.queryCount) {\n    skip |= LogError(\"VUID-VkVideoInlineQueryInfoKHR-queryPool-08373\", query_pool_state.Handle(), loc.dot(Field::firstQuery),\n                     \"(%u) plus queryCount (%u) is greater than the number of queries (%u) in %s.\", query_info.firstQuery,\n                     query_info.queryCount, query_pool_state.create_info.queryCount, FormatHandle(query_pool_state).c_str());\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkVideoEncodeRateControlInfoKHR-layerCount-08245\", \"layerCount member must be less than or equal to VkVideoEncodeCapabilitiesKHR::maxRateControlLayers, as returned by vkGetPhysicalDeviceVideoCapabilitiesKHR for the used video profile\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (rc_info.layerCount > profile_caps.encode.maxRateControlLayers) {\n    const LogObjectList objlist(cmdbuf, vs_state.Handle());\n    skip |= LogError(\"VUID-VkVideoEncodeRateControlInfoKHR-layerCount-08245\", objlist, rc_info_loc.dot(Field::layerCount),\n                     \"(%u) is greater than the maxRateControlLayers (%u) \"\n                     \"supported by the video profile %s was created with.\",\n                     rc_info.layerCount, profile_caps.encode.maxRateControlLayers, FormatHandle(vs_state).c_str());\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkVideoEncodeRateControlInfoKHR-rateControlMode-08275\", \"If rateControlMode is VK_VIDEO_ENCODE_RATE_CONTROL_MODE_CBR_BIT_KHR or VK_VIDEO_ENCODE_RATE_CONTROL_MODE_VBR_BIT_KHR, then layerCount must be greater than 0\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "skip |= ValidateVideoEncodeRateControlLayerInfo(layer_idx, rc_info, pNext, cmdbuf, vs_state, rc_info_loc);\nskip |= LogError(\"VUID-VkVideoEncodeRateControlInfoKHR-rateControlMode-08275\", cmdbuf,\n             rc_info_loc.dot(Field::rateControlMode), \"is %s, but %s is zero.\",\n             string_VkVideoEncodeRateControlModeFlagBitsKHR(rc_info.rateControlMode),\n             rc_info_loc.dot(Field::layerCount).Fields().c_str());\n"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkVideoEncodeRateControlInfoKHR-layerCount-08357\", \"If layerCount is not zero, then virtualBufferSizeInMs must be greater than zero\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (rc_info.virtualBufferSizeInMs == 0) {\n    skip |= LogError(\"VUID-VkVideoEncodeRateControlInfoKHR-layerCount-08357\", cmdbuf,\n                     rc_info_loc.dot(Field::virtualBufferSizeInMs), \"must not be zero if %s (%u) is not zero.\",\n                     rc_info_loc.dot(Field::layerCount).Fields().c_str(), rc_info.layerCount);\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkVideoEncodeH264RateControlInfoKHR-flags-08280\", \"If VkVideoEncodeH264CapabilitiesKHR::flags, as returned by vkGetPhysicalDeviceVideoCapabilitiesKHR for the used video profile, does not include VK_VIDEO_ENCODE_H264_CAPABILITY_HRD_COMPLIANCE_BIT_KHR, then flags must not contain VK_VIDEO_ENCODE_H264_RATE_CONTROL_ATTEMPT_HRD_COMPLIANCE_BIT_KHR\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (rc_info_h264->flags & VK_VIDEO_ENCODE_H264_RATE_CONTROL_ATTEMPT_HRD_COMPLIANCE_BIT_KHR &&\n    (profile_caps.encode_h264.flags & VK_VIDEO_ENCODE_H264_CAPABILITY_HRD_COMPLIANCE_BIT_KHR) == 0) {\n    const LogObjectList objlist(cmdbuf, vs_state.Handle());\n    skip |= LogError(\"VUID-VkVideoEncodeH264RateControlInfoKHR-flags-08280\", objlist, rc_info_h264_loc.dot(Field::flags),\n                     \"includes VK_VIDEO_ENCODE_H264_RATE_CONTROL_ATTEMPT_HRD_COMPLIANCE_BIT_KHR but HRD compliance \"\n                     \"is not supported by the H.264 encode profile %s was created with.\",\n                     FormatHandle(vs_state).c_str());\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkVideoEncodeH264RateControlInfoKHR-flags-08281\", \"If flags contains VK_VIDEO_ENCODE_H264_RATE_CONTROL_REFERENCE_PATTERN_FLAT_BIT_KHR or VK_VIDEO_ENCODE_H264_RATE_CONTROL_REFERENCE_PATTERN_DYADIC_BIT_KHR, then it must also contain VK_VIDEO_ENCODE_H264_RATE_CONTROL_REGULAR_GOP_BIT_KHR\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if ((rc_info_h264->flags & VK_VIDEO_ENCODE_H264_RATE_CONTROL_REFERENCE_PATTERN_FLAT_BIT_KHR ||\n     rc_info_h264->flags & VK_VIDEO_ENCODE_H264_RATE_CONTROL_REFERENCE_PATTERN_DYADIC_BIT_KHR) &&\n    (rc_info_h264->flags & VK_VIDEO_ENCODE_H264_RATE_CONTROL_REGULAR_GOP_BIT_KHR) == 0) {\n    skip |= LogError(\"VUID-VkVideoEncodeH264RateControlInfoKHR-flags-08281\", cmdbuf, rc_info_h264_loc.dot(Field::flags),\n                     \"(%s) specifies a reference pattern but does not indicate the use of a regular GOP structure.\",\n                     string_VkVideoEncodeH264RateControlFlagsKHR(rc_info_h264->flags).c_str());\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkVideoEncodeH264RateControlInfoKHR-flags-08282\", \"If flags contains VK_VIDEO_ENCODE_H264_RATE_CONTROL_REFERENCE_PATTERN_FLAT_BIT_KHR, then it must not also contain VK_VIDEO_ENCODE_H264_RATE_CONTROL_REFERENCE_PATTERN_DYADIC_BIT_KHR\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (rc_info_h264->flags & VK_VIDEO_ENCODE_H264_RATE_CONTROL_REFERENCE_PATTERN_FLAT_BIT_KHR &&\n    rc_info_h264->flags & VK_VIDEO_ENCODE_H264_RATE_CONTROL_REFERENCE_PATTERN_DYADIC_BIT_KHR) {\n    skip |= LogError(\"VUID-VkVideoEncodeH264RateControlInfoKHR-flags-08282\", cmdbuf, rc_info_h264_loc.dot(Field::flags),\n                     \"(%s) indicates conflicting reference patterns.\",\n                     string_VkVideoEncodeH264RateControlFlagsKHR(rc_info_h264->flags).c_str());\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkVideoEncodeH264RateControlInfoKHR-flags-08283\", \"If flags contains VK_VIDEO_ENCODE_H264_RATE_CONTROL_REGULAR_GOP_BIT_KHR, then gopFrameCount must be greater than 0\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (rc_info_h264->flags & VK_VIDEO_ENCODE_H264_RATE_CONTROL_REGULAR_GOP_BIT_KHR && rc_info_h264->gopFrameCount == 0) {\n    skip |= LogError(\"VUID-VkVideoEncodeH264RateControlInfoKHR-flags-08283\", cmdbuf, rc_info_h264_loc.dot(Field::flags),\n                     \"includes VK_VIDEO_ENCODE_H264_RATE_CONTROL_REGULAR_GOP_BIT_KHR but the GOP size \"\n                     \"specified in %s is zero.\",\n                     rc_info_h264_loc.dot(Field::gopFrameCount).Fields().c_str());\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkVideoEncodeH265RateControlInfoKHR-flags-08291\", \"If VkVideoEncodeH265CapabilitiesKHR::flags, as returned by vkGetPhysicalDeviceVideoCapabilitiesKHR for the used video profile, does not include VK_VIDEO_ENCODE_H265_CAPABILITY_HRD_COMPLIANCE_BIT_KHR, then flags must not contain VK_VIDEO_ENCODE_H265_RATE_CONTROL_ATTEMPT_HRD_COMPLIANCE_BIT_KHR\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (rc_info_h265->flags & VK_VIDEO_ENCODE_H265_RATE_CONTROL_ATTEMPT_HRD_COMPLIANCE_BIT_KHR &&\n    (profile_caps.encode_h265.flags & VK_VIDEO_ENCODE_H265_CAPABILITY_HRD_COMPLIANCE_BIT_KHR) == 0) {\n    const LogObjectList objlist(cmdbuf, vs_state.Handle());\n    skip |= LogError(\"VUID-VkVideoEncodeH265RateControlInfoKHR-flags-08291\", objlist, rc_info_h265_loc.dot(Field::flags),\n                     \"includes VK_VIDEO_ENCODE_H265_RATE_CONTROL_ATTEMPT_HRD_COMPLIANCE_BIT_KHR but HRD compliance \"\n                     \"is not supported by the H.265 encode profile %s was created with.\",\n                     FormatHandle(vs_state).c_str());\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkVideoEncodeH265RateControlInfoKHR-flags-08292\", \"If flags contains VK_VIDEO_ENCODE_H265_RATE_CONTROL_REFERENCE_PATTERN_FLAT_BIT_KHR or VK_VIDEO_ENCODE_H265_RATE_CONTROL_REFERENCE_PATTERN_DYADIC_BIT_KHR, then it must also contain VK_VIDEO_ENCODE_H265_RATE_CONTROL_REGULAR_GOP_BIT_KHR\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if ((rc_info_h265->flags & VK_VIDEO_ENCODE_H265_RATE_CONTROL_REFERENCE_PATTERN_FLAT_BIT_KHR ||\n     rc_info_h265->flags & VK_VIDEO_ENCODE_H265_RATE_CONTROL_REFERENCE_PATTERN_DYADIC_BIT_KHR) &&\n    (rc_info_h265->flags & VK_VIDEO_ENCODE_H265_RATE_CONTROL_REGULAR_GOP_BIT_KHR) == 0) {\n    skip |= LogError(\"VUID-VkVideoEncodeH265RateControlInfoKHR-flags-08292\", cmdbuf, rc_info_h265_loc.dot(Field::flags),\n                     \"(%s) specifies a reference pattern but does not indicate the use of a regular GOP structure.\",\n                     string_VkVideoEncodeH265RateControlFlagsKHR(rc_info_h265->flags).c_str());\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkVideoEncodeH265RateControlInfoKHR-flags-08293\", \"If flags contains VK_VIDEO_ENCODE_H265_RATE_CONTROL_REFERENCE_PATTERN_FLAT_BIT_KHR, then it must not also contain VK_VIDEO_ENCODE_H265_RATE_CONTROL_REFERENCE_PATTERN_DYADIC_BIT_KHR\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (rc_info_h265->flags & VK_VIDEO_ENCODE_H265_RATE_CONTROL_REFERENCE_PATTERN_FLAT_BIT_KHR &&\n    rc_info_h265->flags & VK_VIDEO_ENCODE_H265_RATE_CONTROL_REFERENCE_PATTERN_DYADIC_BIT_KHR) {\n    skip |= LogError(\"VUID-VkVideoEncodeH265RateControlInfoKHR-flags-08293\", cmdbuf, rc_info_h265_loc.dot(Field::flags),\n                     \"(%s) indicates conflicting reference patterns.\",\n                     string_VkVideoEncodeH265RateControlFlagsKHR(rc_info_h265->flags).c_str());\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkVideoEncodeH265RateControlInfoKHR-flags-08294\", \"If flags contains VK_VIDEO_ENCODE_H265_RATE_CONTROL_REGULAR_GOP_BIT_KHR, then gopFrameCount must be greater than 0\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (rc_info_h265->flags & VK_VIDEO_ENCODE_H265_RATE_CONTROL_REGULAR_GOP_BIT_KHR && rc_info_h265->gopFrameCount == 0) {\n    skip |= LogError(\"VUID-VkVideoEncodeH265RateControlInfoKHR-flags-08294\", cmdbuf, rc_info_h265_loc.dot(Field::flags),\n                     \"includes VK_VIDEO_ENCODE_H265_RATE_CONTROL_REGULAR_GOP_BIT_KHR but the GOP size \"\n                     \"specified in %s is zero.\",\n                     rc_info_h265_loc.dot(Field::gopFrameCount).Fields().c_str());\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkVideoEncodeRateControlInfoKHR-pLayers-08277\", \"For each element of pLayers, its maxBitrate member must be between 1 and VkVideoEncodeCapabilitiesKHR::maxBitrate, as returned by vkGetPhysicalDeviceVideoCapabilitiesKHR for the used video profile\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (rc_layer_info.maxBitrate < 1 || rc_layer_info.maxBitrate > profile_caps.encode.maxBitrate) {\n    const LogObjectList objlist(cmdbuf, vs_state.Handle());\n    skip |= LogError(\"VUID-VkVideoEncodeRateControlInfoKHR-pLayers-08277\", objlist, rc_layer_info_loc.dot(Field::maxBitrate),\n                     \"(%\" PRIu64 \") must be between 1 and VkVideoEncodeCapabilitiesKHR::maxBitrate (%\" PRIu64\n                     \") limit supported by the video profile %s was created with.\",\n                     rc_layer_info.maxBitrate, profile_caps.encode.maxBitrate, FormatHandle(vs_state).c_str());\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkVideoEncodeRateControlLayerInfoKHR-frameRateNumerator-08350\", \"frameRateNumerator must be greater than zero\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (rc_layer_info.frameRateNumerator == 0) {\n    skip |= LogError(\"VUID-VkVideoEncodeRateControlLayerInfoKHR-frameRateNumerator-08350\", cmdbuf,\n                     rc_layer_info_loc.dot(Field::frameRateNumerator), \"is zero.\");\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkVideoEncodeRateControlLayerInfoKHR-frameRateDenominator-08351\", \"frameRateDenominator must be greater than zero\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (rc_layer_info.frameRateDenominator == 0) {\n    skip |= LogError(\"VUID-VkVideoEncodeRateControlLayerInfoKHR-frameRateDenominator-08351\", cmdbuf,\n                     rc_layer_info_loc.dot(Field::frameRateDenominator), \"is zero.\");\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkVideoProfileInfoKHR-chromaSubsampling-07013\", \"chromaSubsampling must have a single bit set\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (GetBitSetCount(profile->chromaSubsampling) != 1) {\n    skip |= LogError(\"VUID-VkVideoProfileInfoKHR-chromaSubsampling-07013\", object, loc.dot(Field::chromaSubsampling),\n                     \"must have a single bit set.\");\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkVideoProfileInfoKHR-chromaSubsampling-07015\", \"If chromaSubsampling is not VK_VIDEO_CHROMA_SUBSAMPLING_MONOCHROME_BIT_KHR, then chromaBitDepth must have a single bit set\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (GetBitSetCount(profile->chromaBitDepth) != 1) {\n    skip |= LogError(\"VUID-VkVideoProfileInfoKHR-chromaSubsampling-07015\", object, loc.dot(Field::chromaBitDepth),\n                     \"must have a single bit set.\");\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkVideoProfileInfoKHR-videoCodecOperation-07179\", \"If videoCodecOperation is VK_VIDEO_CODEC_OPERATION_DECODE_H264_BIT_KHR, then the pNext chain must include a VkVideoDecodeH264ProfileInfoKHR structure\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (decode_h264 == nullptr) {\n    skip |= LogError(\"VUID-VkVideoProfileInfoKHR-videoCodecOperation-07179\", object, loc.dot(Field::pNext),\n                     profile_pnext_msg, \"VkVideoDecodeH264ProfileInfoKHR\");\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkVideoProfileInfoKHR-videoCodecOperation-07180\", \"If videoCodecOperation is VK_VIDEO_CODEC_OPERATION_DECODE_H265_BIT_KHR, then the pNext chain must include a VkVideoDecodeH265ProfileInfoKHR structure\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (decode_h265 == nullptr) {\n    skip |= LogError(\"VUID-VkVideoProfileInfoKHR-videoCodecOperation-07180\", object, loc.dot(Field::pNext),\n                     profile_pnext_msg, \"VkVideoDecodeH265ProfileInfoKHR\");\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkVideoProfileInfoKHR-videoCodecOperation-09256\", \"If videoCodecOperation is VK_VIDEO_CODEC_OPERATION_DECODE_AV1_BIT_KHR, then the pNext chain must include a VkVideoDecodeAV1ProfileInfoKHR structure\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (decode_av1 == nullptr) {\n    skip |= LogError(\"VUID-VkVideoProfileInfoKHR-videoCodecOperation-09256\", object, loc.dot(Field::pNext),\n                     profile_pnext_msg, \"VkVideoDecodeAV1ProfileInfoKHR\");\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkVideoProfileInfoKHR-videoCodecOperation-07182\", \"If videoCodecOperation is VK_VIDEO_CODEC_OPERATION_ENCODE_H265_BIT_KHR, then the pNext chain must include a VkVideoEncodeH265ProfileInfoKHR structure\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (encode_h265 == nullptr) {\n    skip |= LogError(\"VUID-VkVideoProfileInfoKHR-videoCodecOperation-07182\", object, loc.dot(Field::pNext),\n                     profile_pnext_msg, \"VkVideoEncodeH265ProfileInfoKHR\");\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkVideoProfileListInfoKHR-pProfiles-06813\", \"pProfiles must not contain more than one element whose videoCodecOperation member specifies a decode operation\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (has_decode_profile) {\n    skip |= LogError(\"VUID-VkVideoProfileListInfoKHR-pProfiles-06813\", object, loc,\n                     \"contains more than one profile with decode codec operation.\");\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkVideoDecodeH264SessionParametersAddInfoKHR-None-04825\", \"The seq_parameter_set_id member of each StdVideoH264SequenceParameterSet structure specified in the elements of pStdSPSs must be unique within pStdSPSs\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (!keys.emplace(key).second) {\n    skip |= LogError(\"VUID-VkVideoDecodeH264SessionParametersAddInfoKHR-None-04825\", device, loc.dot(Field::pStdSPSs),\n                     \"keys are not unique.\");\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkVideoSessionParametersCreateInfoKHR-videoSession-07204\", \"If videoSession was created with the video codec operation VK_VIDEO_CODEC_OPERATION_DECODE_H264_BIT_KHR, then the number of elements of spsAddList must be less than or equal to the maxStdSPSCount specified in the VkVideoDecodeH264SessionParametersCreateInfoKHR structure included in the pNext chain\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (keys.size() > create_info->maxStdSPSCount) {\n    skip |= LogError(\"VUID-VkVideoSessionParametersCreateInfoKHR-videoSession-07204\", device, loc.function,\n                     \"number of H.264 SPS entries to add (%zu) is larger than \"\n                     \"VkVideoDecodeH264SessionParametersCreateInfoKHR::maxStdSPSCount (%u).\",\n                     keys.size(), create_info->maxStdSPSCount);\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkVideoSessionParametersCreateInfoKHR-videoSession-07205\", \"If videoSession was created with the video codec operation VK_VIDEO_CODEC_OPERATION_DECODE_H264_BIT_KHR, then the number of elements of ppsAddList must be less than or equal to the maxStdPPSCount specified in the VkVideoDecodeH264SessionParametersCreateInfoKHR structure included in the pNext chain\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (keys.size() > create_info->maxStdPPSCount) {\n    skip |= LogError(\"VUID-VkVideoSessionParametersCreateInfoKHR-videoSession-07205\", device, loc.function,\n                     \"number of H.264 PPS entries to add (%zu) is larger than \"\n                     \"VkVideoDecodeH264SessionParametersCreateInfoKHR::maxStdPPSCount (%u).\",\n                     keys.size(), create_info->maxStdPPSCount);\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkVideoDecodeH265SessionParametersAddInfoKHR-None-04833\", \"The vps_video_parameter_set_id member of each StdVideoH265VideoParameterSet structure specified in the elements of pStdVPSs must be unique within pStdVPSs\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (!keys.emplace(key).second) {\n    skip |= LogError(\"VUID-VkVideoDecodeH265SessionParametersAddInfoKHR-None-04833\", device, loc.dot(Field::pStdVPSs),\n                     \"keys are not unique.\");\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkVideoSessionParametersCreateInfoKHR-videoSession-07207\", \"If videoSession was created with the video codec operation VK_VIDEO_CODEC_OPERATION_DECODE_H265_BIT_KHR, then the number of elements of vpsAddList must be less than or equal to the maxStdVPSCount specified in the VkVideoDecodeH265SessionParametersCreateInfoKHR structure included in the pNext chain\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (keys.size() > create_info->maxStdVPSCount) {\n    skip |= LogError(\"VUID-VkVideoSessionParametersCreateInfoKHR-videoSession-07207\", device, loc.function,\n                     \"number of H.265 VPS entries to add (%zu) is larger than \"\n                     \"VkVideoDecodeH265SessionParametersCreateInfoKHR::maxStdVPSCount (%u).\",\n                     keys.size(), create_info->maxStdVPSCount);\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkVideoDecodeH265SessionParametersAddInfoKHR-None-04834\", \"The pair constructed from the sps_video_parameter_set_id and sps_seq_parameter_set_id members of each StdVideoH265SequenceParameterSet structure specified in the elements of pStdSPSs must be unique within pStdSPSs\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (!keys.emplace(key).second) {\n    skip |= LogError(\"VUID-VkVideoDecodeH265SessionParametersAddInfoKHR-None-04834\", device, loc.dot(Field::pStdSPSs),\n                     \"keys are not unique.\");\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkVideoDecodeH265SessionParametersAddInfoKHR-None-04835\", \"The triplet constructed from the sps_video_parameter_set_id, pps_seq_parameter_set_id, and pps_pic_parameter_set_id members of each StdVideoH265PictureParameterSet structure specified in the elements of pStdPPSs must be unique within pStdPPSs\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (!keys.emplace(key).second) {\n    skip |= LogError(\"VUID-VkVideoDecodeH265SessionParametersAddInfoKHR-None-04835\", device, loc.dot(Field::pStdPPSs),\n                     \"keys are not unique.\");\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkVideoSessionParametersCreateInfoKHR-videoSession-07209\", \"If videoSession was created with the video codec operation VK_VIDEO_CODEC_OPERATION_DECODE_H265_BIT_KHR, then the number of elements of ppsAddList must be less than or equal to the maxStdPPSCount specified in the VkVideoDecodeH265SessionParametersCreateInfoKHR structure included in the pNext chain\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (keys.size() > create_info->maxStdPPSCount) {\n    skip |= LogError(\"VUID-VkVideoSessionParametersCreateInfoKHR-videoSession-07209\", device, loc.function,\n                     \"number of H.265 PPS entries to add (%zu) is larger than \"\n                     \"VkVideoDecodeH265SessionParametersCreateInfoKHR::maxStdPPSCount (%u).\",\n                     keys.size(), create_info->maxStdPPSCount);\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkVideoEncodeH264SessionParametersAddInfoKHR-None-04837\", \"The seq_parameter_set_id member of each StdVideoH264SequenceParameterSet structure specified in the elements of pStdSPSs must be unique within pStdSPSs\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (!keys.emplace(key).second) {\n    skip |= LogError(\"VUID-VkVideoEncodeH264SessionParametersAddInfoKHR-None-04837\", device, loc.dot(Field::pStdSPSs),\n                     \"keys are not unique.\");\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkVideoSessionParametersCreateInfoKHR-videoSession-04839\", \"If videoSession was created with the video codec operation VK_VIDEO_CODEC_OPERATION_ENCODE_H264_BIT_KHR, then the number of elements of spsAddList must be less than or equal to the maxStdSPSCount specified in the VkVideoEncodeH264SessionParametersCreateInfoKHR structure included in the pNext chain\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (keys.size() > create_info->maxStdSPSCount) {\n    skip |= LogError(\"VUID-VkVideoSessionParametersCreateInfoKHR-videoSession-04839\", device, loc.function,\n                     \"number of H.264 SPS entries to add (%zu) is larger than \"\n                     \"VkVideoEncodeH264SessionParametersCreateInfoKHR::maxStdSPSCount (%u).\",\n                     keys.size(), create_info->maxStdSPSCount);\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkVideoSessionParametersCreateInfoKHR-videoSession-04840\", \"If videoSession was created with the video codec operation VK_VIDEO_CODEC_OPERATION_ENCODE_H264_BIT_KHR, then the number of elements of ppsAddList must be less than or equal to the maxStdPPSCount specified in the VkVideoEncodeH264SessionParametersCreateInfoKHR structure included in the pNext chain\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (keys.size() > create_info->maxStdPPSCount) {\n    skip |= LogError(\"VUID-VkVideoSessionParametersCreateInfoKHR-videoSession-04840\", device, loc.function,\n                     \"number of H.264 PPS entries to add (%zu) is larger than \"\n                     \"VkVideoEncodeH264SessionParametersCreateInfoKHR::maxStdPPSCount (%u).\",\n                     keys.size(), create_info->maxStdPPSCount);\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkVideoEncodeH265SessionParametersAddInfoKHR-None-06438\", \"The vps_video_parameter_set_id member of each StdVideoH265VideoParameterSet structure specified in the elements of pStdVPSs must be unique within pStdVPSs\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (!keys.emplace(key).second) {\n    skip |= LogError(\"VUID-VkVideoEncodeH265SessionParametersAddInfoKHR-None-06438\", device, loc.dot(Field::pStdVPSs),\n                     \"keys are not unique.\");\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkVideoSessionParametersCreateInfoKHR-videoSession-04841\", \"If videoSession was created with the video codec operation VK_VIDEO_CODEC_OPERATION_ENCODE_H265_BIT_KHR, then the number of elements of vpsAddList must be less than or equal to the maxStdVPSCount specified in the VkVideoEncodeH265SessionParametersCreateInfoKHR structure included in the pNext chain\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (keys.size() > create_info->maxStdVPSCount) {\n    skip |= LogError(\"VUID-VkVideoSessionParametersCreateInfoKHR-videoSession-04841\", device, loc.function,\n                     \"number of H.265 VPS entries to add (%zu) is larger than \"\n                     \"VkVideoEncodeH265SessionParametersCreateInfoKHR::maxStdVPSCount (%u).\",\n                     keys.size(), create_info->maxStdVPSCount);\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkVideoEncodeH265SessionParametersAddInfoKHR-None-06439\", \"The pair constructed from the sps_video_parameter_set_id and sps_seq_parameter_set_id members of each StdVideoH265SequenceParameterSet structure specified in the elements of pStdSPSs must be unique within pStdSPSs\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (!keys.emplace(key).second) {\n    skip |= LogError(\"VUID-VkVideoEncodeH265SessionParametersAddInfoKHR-None-06439\", device, loc.dot(Field::pStdSPSs),\n                     \"keys are not unique.\");\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkVideoEncodeH265SessionParametersAddInfoKHR-None-06440\", \"The triplet constructed from the sps_video_parameter_set_id, pps_seq_parameter_set_id, and pps_pic_parameter_set_id members of each StdVideoH265PictureParameterSet structure specified in the elements of pStdPPSs must be unique within pStdPPSs\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (!keys.emplace(key).second) {\n    skip |= LogError(\"VUID-VkVideoEncodeH265SessionParametersAddInfoKHR-None-06440\", device, loc.dot(Field::pStdPPSs),\n                     \"keys are not unique.\");\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkVideoSessionParametersCreateInfoKHR-videoSession-04843\", \"If videoSession was created with the video codec operation VK_VIDEO_CODEC_OPERATION_ENCODE_H265_BIT_KHR, then the number of elements of ppsAddList must be less than or equal to the maxStdPPSCount specified in the VkVideoEncodeH265SessionParametersCreateInfoKHR structure included in the pNext chain\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (keys.size() > create_info->maxStdPPSCount) {\n    skip |= LogError(\"VUID-VkVideoSessionParametersCreateInfoKHR-videoSession-04843\", device, loc.function,\n                     \"number of H.265 PPS entries to add (%zu) is larger than \"\n                     \"VkVideoEncodeH265SessionParametersCreateInfoKHR::maxStdPPSCount (%u).\",\n                     keys.size(), create_info->maxStdPPSCount);\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-vkCmdDecodeVideoKHR-pDecodeInfo-07141\", \"If pDecodeInfo->pSetupReferenceSlot is not NULL and none of the following is true: VkVideoDecodeCapabilitiesKHR::flags includes VK_VIDEO_DECODE_CAPABILITY_DPB_AND_OUTPUT_DISTINCT_BIT_KHR, as returned by vkGetPhysicalDeviceVideoCapabilitiesKHR for the video profile the bound video session was created with the bound video session was created with the video codec operation VK_VIDEO_CODEC_OPERATION_DECODE_AV1_BIT_KHR and VkVideoDecodeAV1ProfileInfoKHR::filmGrainSupport set to VK_TRUE, and film grain is enabled for the decoded picture then the video picture resources specified by pDecodeInfo->dstPictureResource and pDecodeInfo->pSetupReferenceSlot->pPictureResource must match\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (!vs_state.profile->HasAV1FilmGrainSupport()) {\n    skip |= LogError(\"VUID-vkCmdDecodeVideoKHR-pDecodeInfo-07141\", objlist, cmd_loc,\n                     \"the AV1 decode profile %s was created with does not support \"\n                     \"VK_VIDEO_DECODE_CAPABILITY_DPB_AND_OUTPUT_DISTINCT_BIT_KHR and does not have \"\n                     \"VkVideoDecodeAV1ProfileInfoKHR::filmGrainSupport set to VK_TRUE but \"\n                     \"pDecodeInfo->dstPictureResource and pSetupReferenceSlot->pPictureResource \"\n                     \"do not match.\",\n                     FormatHandle(vs_state).c_str());\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-vkCmdDecodeVideoKHR-pDecodeInfo-07141\", \"If pDecodeInfo->pSetupReferenceSlot is not NULL and none of the following is true: VkVideoDecodeCapabilitiesKHR::flags includes VK_VIDEO_DECODE_CAPABILITY_DPB_AND_OUTPUT_DISTINCT_BIT_KHR, as returned by vkGetPhysicalDeviceVideoCapabilitiesKHR for the video profile the bound video session was created with the bound video session was created with the video codec operation VK_VIDEO_CODEC_OPERATION_DECODE_AV1_BIT_KHR and VkVideoDecodeAV1ProfileInfoKHR::filmGrainSupport set to VK_TRUE, and film grain is enabled for the decoded picture then the video picture resources specified by pDecodeInfo->dstPictureResource and pDecodeInfo->pSetupReferenceSlot->pPictureResource must match\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "skip |= LogError(\"VUID-vkCmdDecodeVideoKHR-pDecodeInfo-07141\", objlist, cmd_loc,\n                 \"the AV1 decode profile %s was created with does not support \"\n                 \"VK_VIDEO_DECODE_CAPABILITY_DPB_AND_OUTPUT_DISTINCT_BIT_KHR and \"\n                 \"film grain is not enabled for the decoded picture but \"\n                 \"pDecodeInfo->dstPictureResource and pSetupReferenceSlot->pPictureResource \"\n                 \"do not match.\",\n                 FormatHandle(vs_state).c_str());\n"
        },
        {
            "role": "user",
            "content": "{\"VUID-vkCmdDecodeVideoKHR-None-07258\", \"If the bound video session was created with the video codec operation VK_VIDEO_CODEC_OPERATION_DECODE_H264_BIT_KHR but was not created with interlaced frame support, then the decode output picture must represent a frame\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (!interlaced_frame_support && std_picture_info->flags.field_pic_flag) {\n    const LogObjectList objlist(cb_state.Handle(), vs_state.Handle());\n    skip |= LogError(\"VUID-vkCmdDecodeVideoKHR-None-07258\", objlist, loc.function,\n                     \"decode output picture is a field but the bound video session \"\n                     \"%s was not created with interlaced frame support.\",\n                     FormatHandle(vs_state).c_str());\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-vkCmdDecodeVideoKHR-pSliceOffsets-07153\", \"If the bound video session was created with the video codec operation VK_VIDEO_CODEC_OPERATION_DECODE_H264_BIT_KHR, then all elements of the pSliceOffsets member of the VkVideoDecodeH264PictureInfoKHR structure included in the pNext chain of pDecodeInfo must be less than pDecodeInfo->srcBufferRange\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (picture_info->pSliceOffsets[i] >= decode_info.srcBufferRange) {\n    skip |= LogError(\"VUID-vkCmdDecodeVideoKHR-pSliceOffsets-07153\", cb_state.Handle(),\n                     loc.pNext(Struct::VkVideoDecodeH264PictureInfoKHR, Field::pSliceOffsets, i),\n                     \"(%u) is greater than or equal to pDecodeInfo->srcBufferRange (%\" PRIu64 \").\",\n                     picture_info->pSliceOffsets[i], decode_info.srcBufferRange);\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-vkCmdDecodeVideoKHR-StdVideoH264SequenceParameterSet-07154\", \"If the bound video session was created with the video codec operation VK_VIDEO_CODEC_OPERATION_DECODE_H264_BIT_KHR, then the bound video session parameters object must contain a StdVideoH264SequenceParameterSet entry with seq_parameter_set_id matching StdVideoDecodeH264PictureInfo::seq_parameter_set_id that is provided in the pStdPictureInfo member of the VkVideoDecodeH264PictureInfoKHR structure included in the pNext chain of pDecodeInfo\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (session_params.GetH264SPS(std_picture_info->seq_parameter_set_id) == nullptr) {\n    const LogObjectList objlist(cb_state.Handle(), vsp_state.Handle());\n    skip |= LogError(\"VUID-vkCmdDecodeVideoKHR-StdVideoH264SequenceParameterSet-07154\", objlist, loc.function,\n                     \"no H.264 SPS with seq_parameter_set_id = %u \"\n                     \"exists in the bound video session parameters object %s.\",\n                     std_picture_info->seq_parameter_set_id, FormatHandle(vsp_state).c_str());\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-vkCmdDecodeVideoKHR-StdVideoH264PictureParameterSet-07155\", \"If the bound video session was created with the video codec operation VK_VIDEO_CODEC_OPERATION_DECODE_H264_BIT_KHR, then the bound video session parameters object must contain a StdVideoH264PictureParameterSet entry with seq_parameter_set_id and pic_parameter_set_id matching StdVideoDecodeH264PictureInfo::seq_parameter_set_id and StdVideoDecodeH264PictureInfo::pic_parameter_set_id, respectively, that are provided in the pStdPictureInfo member of the VkVideoDecodeH264PictureInfoKHR structure included in the pNext chain of pDecodeInfo\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (session_params.GetH264PPS(std_picture_info->seq_parameter_set_id, std_picture_info->pic_parameter_set_id) == nullptr) {\n    const LogObjectList objlist(cb_state.Handle(), vsp_state.Handle());\n    skip |= LogError(\"VUID-vkCmdDecodeVideoKHR-StdVideoH264PictureParameterSet-07155\", objlist, loc.function,\n                     \"no H.264 PPS with seq_parameter_set_id = %u \"\n                     \"and pic_parameter_set_id = %u exists in the bound video session parameters object %s.\",\n                     std_picture_info->seq_parameter_set_id, std_picture_info->pic_parameter_set_id,\n                     FormatHandle(vsp_state).c_str());\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-vkCmdDecodeVideoKHR-pDecodeInfo-07259\", \"If the bound video session was created with the video codec operation VK_VIDEO_CODEC_OPERATION_DECODE_H264_BIT_KHR but was not created with interlaced frame support, and pDecodeInfo->pSetupReferenceSlot is not NULL, then the reconstructed picture must represent a frame\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (!interlaced_frame_support && !picture_id.IsFrame()) {\n    const LogObjectList objlist(cb_state.Handle(), vs_state.Handle());\n    skip |= LogError(\"VUID-vkCmdDecodeVideoKHR-pDecodeInfo-07259\", objlist, loc.function,\n                     \"reconstructed picture is a field but the bound \"\n                     \"video session %s was not created with interlaced frame support.\",\n                     FormatHandle(vs_state).c_str());\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-vkCmdDecodeVideoKHR-pDecodeInfo-07261\", \"If the bound video session was created with the video codec operation VK_VIDEO_CODEC_OPERATION_DECODE_H264_BIT_KHR, pDecodeInfo->pSetupReferenceSlot is not NULL, and the decode output picture represents a frame, then the reconstructed picture must also represent a frame\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (!dst_is_field && !picture_id.IsFrame()) {\n    skip |= LogError(\"VUID-vkCmdDecodeVideoKHR-pDecodeInfo-07261\", cb_state.Handle(), loc.function,\n                     \"decode output picture is a frame but the \"\n                     \"reconstructed picture is not a frame.\");\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-vkCmdDecodeVideoKHR-pDecodeInfo-07262\", \"If the bound video session was created with the video codec operation VK_VIDEO_CODEC_OPERATION_DECODE_H264_BIT_KHR, pDecodeInfo->pSetupReferenceSlot is not NULL, and the decode output picture represents a top field, then the reconstructed picture must also represent a top field\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (dst_is_field && !dst_is_bottom_field && !picture_id.IsTopField()) {\n    skip |= LogError(\"VUID-vkCmdDecodeVideoKHR-pDecodeInfo-07262\", cb_state.Handle(), loc.function,\n                     \"decode output picture is a top field but the \"\n                     \"reconstructed picture is not a top field.\");\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-vkCmdDecodeVideoKHR-pDecodeInfo-07263\", \"If the bound video session was created with the video codec operation VK_VIDEO_CODEC_OPERATION_DECODE_H264_BIT_KHR, pDecodeInfo->pSetupReferenceSlot is not NULL, and the decode output picture represents a bottom field, then the reconstructed picture must also represent a bottom field\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (dst_is_field && dst_is_bottom_field && !picture_id.IsBottomField()) {\n    skip |= LogError(\"VUID-vkCmdDecodeVideoKHR-pDecodeInfo-07263\", cb_state.Handle(), loc.function,\n                     \"decode output picture is a bottom field but the \"\n                     \"reconstructed picture is not a bottom field.\");\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-vkCmdDecodeVideoKHR-pDecodeInfo-07260\", \"If the bound video session was created with the video codec operation VK_VIDEO_CODEC_OPERATION_DECODE_H264_BIT_KHR but was not created with interlaced frame support, then each active reference picture corresponding to the elements of pDecodeInfo->pReferenceSlots must represent a frame\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (!interlaced_frame_support && !picture_id.IsFrame()) {\n    const LogObjectList objlist(cb_state.Handle(), vs_state.Handle());\n    skip |= LogError(\"VUID-vkCmdDecodeVideoKHR-pDecodeInfo-07260\", objlist, loc.function,\n                     \"reference picture specified in \"\n                     \"pDecodeInfo->pReferenceSlots[%u] is a field but the bound \"\n                     \"video session %s was not created with interlaced frame support.\",\n                     i, FormatHandle(vs_state).c_str());\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-vkCmdDecodeVideoKHR-pNext-07157\", \"If the bound video session was created with the video codec operation VK_VIDEO_CODEC_OPERATION_DECODE_H264_BIT_KHR, then the pNext chain of each element of pDecodeInfo->pReferenceSlots must include a VkVideoDecodeH264DpbSlotInfoKHR structure\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "skip |= LogError(\"VUID-vkCmdDecodeVideoKHR-pNext-07157\", cb_state.Handle(),\n                 loc.dot(Field::pReferenceSlots, i).dot(Field::pNext), pnext_msg, \"VkVideoDecodeH264DpbSlotInfoKHR\");\n"
        },
        {
            "role": "user",
            "content": "{\"VUID-vkCmdDecodeVideoKHR-pSliceSegmentOffsets-07159\", \"If the bound video session was created with the video codec operation VK_VIDEO_CODEC_OPERATION_DECODE_H265_BIT_KHR, then all elements of the pSliceSegmentOffsets member of the VkVideoDecodeH265PictureInfoKHR structure included in the pNext chain of pDecodeInfo must be less than pDecodeInfo->srcBufferRange\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (picture_info->pSliceSegmentOffsets[i] >= decode_info.srcBufferRange) {\n    skip |= LogError(\"VUID-vkCmdDecodeVideoKHR-pSliceSegmentOffsets-07159\", cb_state.Handle(),\n                     loc.pNext(Struct::VkVideoDecodeH265PictureInfoKHR, Field::pSliceSegmentOffsets, i),\n                     \"(%u) is greater than or equal to pDecodeInfo->srcBufferRange (%\" PRIu64 \").\",\n                     picture_info->pSliceSegmentOffsets[i], decode_info.srcBufferRange);\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-vkCmdDecodeVideoKHR-StdVideoH265VideoParameterSet-07160\", \"If the bound video session was created with the video codec operation VK_VIDEO_CODEC_OPERATION_DECODE_H265_BIT_KHR, then the bound video session parameters object must contain a StdVideoH265VideoParameterSet entry with vps_video_parameter_set_id matching StdVideoDecodeH265PictureInfo::sps_video_parameter_set_id that is provided in the pStdPictureInfo member of the VkVideoDecodeH265PictureInfoKHR structure included in the pNext chain of pDecodeInfo\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (session_params.GetH265VPS(std_picture_info->sps_video_parameter_set_id) == nullptr) {\n    const LogObjectList objlist(cb_state.Handle(), vsp_state.Handle());\n    skip |= LogError(\"VUID-vkCmdDecodeVideoKHR-StdVideoH265VideoParameterSet-07160\", objlist, loc.function,\n                     \"no H.265 VPS with sps_video_parameter_set_id = %u \"\n                     \"exists in the bound video session parameters object %s.\",\n                     std_picture_info->sps_video_parameter_set_id, FormatHandle(vsp_state).c_str());\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-vkCmdDecodeVideoKHR-StdVideoH265PictureParameterSet-07162\", \"If the bound video session was created with the video codec operation VK_VIDEO_CODEC_OPERATION_DECODE_H265_BIT_KHR, then the bound video session parameters object must contain a StdVideoH265PictureParameterSet entry with sps_video_parameter_set_id, pps_seq_parameter_set_id, and pps_pic_parameter_set_id matching StdVideoDecodeH265PictureInfo::sps_video_parameter_set_id, StdVideoDecodeH265PictureInfo::pps_seq_parameter_set_id, and StdVideoDecodeH265PictureInfo::pps_pic_parameter_set_id, respectively, that are provided in the pStdPictureInfo member of the VkVideoDecodeH265PictureInfoKHR structure included in the pNext chain of pDecodeInfo\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (session_params.GetH265PPS(std_picture_info->sps_video_parameter_set_id, std_picture_info->pps_seq_parameter_set_id,\n    const LogObjectList objlist(cb_state.Handle(), vsp_state.Handle());\n    skip |= LogError(\"VUID-vkCmdDecodeVideoKHR-StdVideoH265PictureParameterSet-07162\", objlist, loc.function,\n                     \"no H.265 SPS with sps_video_parameter_set_id = %u, \"\n                     \"pps_seq_parameter_set_id = %u, and pps_pic_parameter_set_id = %u exists in \"\n                     \"the bound video session parameters object %s.\",\n                     std_picture_info->sps_video_parameter_set_id, std_picture_info->pps_seq_parameter_set_id,\n                     std_picture_info->pps_pic_parameter_set_id, FormatHandle(vsp_state).c_str());\n"
        },
        {
            "role": "user",
            "content": "{\"VUID-vkCmdDecodeVideoKHR-pNext-07158\", \"If the bound video session was created with the video codec operation VK_VIDEO_CODEC_OPERATION_DECODE_H265_BIT_KHR, then the pNext chain of pDecodeInfo must include a VkVideoDecodeH265PictureInfoKHR structure\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "skip |= LogError(\"VUID-vkCmdDecodeVideoKHR-pNext-07158\", cb_state.Handle(), loc.dot(Field::pNext), pnext_msg,\n                 \"VkVideoDecodeH265PictureInfoKHR\");\n"
        },
        {
            "role": "user",
            "content": "{\"VUID-vkCmdDecodeVideoKHR-pDecodeInfo-07163\", \"If the bound video session was created with the video codec operation VK_VIDEO_CODEC_OPERATION_DECODE_H265_BIT_KHR and pDecodeInfo->pSetupReferenceSlot is not NULL, then the pNext chain of pDecodeInfo->pSetupReferenceSlot must include a VkVideoDecodeH265DpbSlotInfoKHR structure\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (!dpb_slot_info) {\n    skip |= LogError(\"VUID-vkCmdDecodeVideoKHR-pDecodeInfo-07163\", cb_state.Handle(),\n                     loc.dot(Field::pSetupReferenceSlot).dot(Field::pNext), pnext_msg, \"VkVideoDecodeH265DpbSlotInfoKHR\");\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-vkCmdDecodeVideoKHR-pNext-07164\", \"If the bound video session was created with the video codec operation VK_VIDEO_CODEC_OPERATION_DECODE_H265_BIT_KHR, then the pNext chain of each element of pDecodeInfo->pReferenceSlots must include a VkVideoDecodeH265DpbSlotInfoKHR structure\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (!dpb_slot_info) {\n    skip |= LogError(\"VUID-vkCmdDecodeVideoKHR-pNext-07164\", cb_state.Handle(),\n                     loc.dot(Field::pReferenceSlots, i).dot(Field::pNext), pnext_msg, \"VkVideoDecodeH265DpbSlotInfoKHR\");\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-vkCmdDecodeVideoKHR-pNext-09255\", \"If the bound video session was created with the video codec operation VK_VIDEO_CODEC_OPERATION_DECODE_AV1_BIT_KHR, then the pNext chain of each element of pDecodeInfo->pReferenceSlots must include a VkVideoDecodeAV1DpbSlotInfoKHR structure\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (!dpb_slot_info) {\n    skip |= LogError(\"VUID-vkCmdDecodeVideoKHR-pNext-09255\", cb_state.Handle(),\n                     loc.dot(Field::pReferenceSlots, i).dot(Field::pNext), pnext_msg, \"VkVideoDecodeAV1DpbSlotInfoKHR\");\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-vkCmdDecodeVideoKHR-filmGrainSupport-09248\", \"If the bound video session was created with the video codec operation VK_VIDEO_CODEC_OPERATION_DECODE_AV1_BIT_KHR and VkVideoDecodeAV1ProfileInfoKHR::filmGrainSupport set to VK_FALSE, then film grain must not be enabled for the decoded picture\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (!vs_state.profile->HasAV1FilmGrainSupport()) {\n    skip |= LogError(\"VUID-vkCmdDecodeVideoKHR-filmGrainSupport-09248\", cb_state.Handle(),\n                     loc.pNext(Struct::VkVideoDecodeAV1PictureInfoKHR, Field::pStdPictureInfo),\n                     \"has flags.apply_grain set but %s was created with an AV1 decode profile \"\n                     \"with filmGrainSupport disabled.\",\n                     FormatHandle(vs_state).c_str());\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-vkCmdDecodeVideoKHR-pDecodeInfo-09249\", \"If the bound video session was created with the video codec operation VK_VIDEO_CODEC_OPERATION_DECODE_AV1_BIT_KHR, pDecodeInfo->pSetupReferenceSlot is not NULL, and film grain is enabled for the decoded picture, then the video picture resources specified by pDecodeInfo->dstPictureResource and pDecodeInfo->pSetupReferenceSlot->pPictureResource must not match\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (dst_resource == setup_resource) {\n    skip |= LogError(\"VUID-vkCmdDecodeVideoKHR-pDecodeInfo-09249\", cb_state.Handle(),\n                     loc.pNext(Struct::VkVideoDecodeAV1PictureInfoKHR, Field::pStdPictureInfo),\n                     \"has flags.apply_grain set but the decode output picture and the \"\n                     \"reconstructed picture are not distinct.\");\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-vkCmdDecodeVideoKHR-referenceNameSlotIndices-09262\", \"If the bound video session was created with the video codec operation VK_VIDEO_CODEC_OPERATION_DECODE_AV1_BIT_KHR, then each element of the referenceNameSlotIndices array member of the VkVideoDecodeAV1PictureInfoKHR structure included in the pNext chain of pDecodeInfo must either be negative or must equal the slotIndex member of one of the elements of pDecodeInfo->pReferenceSlots\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (reference_slot_indices.find(picture_info->referenceNameSlotIndices[i]) == reference_slot_indices.end()) {\n    skip |= LogError(\"VUID-vkCmdDecodeVideoKHR-referenceNameSlotIndices-09262\", cb_state.Handle(),\n                     loc.pNext(Struct::VkVideoDecodeAV1PictureInfoKHR, Field::referenceNameSlotIndices, i),\n                     \"(%d) does not match the slotIndex of any of the elements of pDecodeInfo->pReferenceSlots.\",\n                     picture_info->referenceNameSlotIndices[i]);\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-vkCmdDecodeVideoKHR-frameHeaderOffset-09251\", \"If the bound video session was created with the video codec operation VK_VIDEO_CODEC_OPERATION_DECODE_AV1_BIT_KHR, then the frameHeaderOffset member of the VkVideoDecodeAV1PictureInfoKHR structure included in the pNext chain of pDecodeInfo must be less than the minimum of pDecodeInfo->srcBufferRange\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (picture_info->frameHeaderOffset >= decode_info.srcBufferRange) {\n    skip |= LogError(\"VUID-vkCmdDecodeVideoKHR-frameHeaderOffset-09251\", cb_state.Handle(),\n                     loc.pNext(Struct::VkVideoDecodeAV1PictureInfoKHR, Field::frameHeaderOffset),\n                     \"(%u) is greater than or equal to pDecodeInfo->srcBufferRange (%\" PRIu64 \").\",\n                     picture_info->frameHeaderOffset, decode_info.srcBufferRange);\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-vkCmdDecodeVideoKHR-pTileOffsets-09253\", \"If the bound video session was created with the video codec operation VK_VIDEO_CODEC_OPERATION_DECODE_AV1_BIT_KHR, then all elements of the pTileOffsets member of the VkVideoDecodeAV1PictureInfoKHR structure included in the pNext chain of pDecodeInfo must be less than pDecodeInfo->srcBufferRange\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (picture_info->pTileOffsets[i] >= decode_info.srcBufferRange) {\n    skip |= LogError(\"VUID-vkCmdDecodeVideoKHR-pTileOffsets-09253\", cb_state.Handle(),\n                     loc.pNext(Struct::VkVideoDecodeAV1PictureInfoKHR, Field::pTileOffsets, i),\n                     \"(%u) is greater than or equal to pDecodeInfo->srcBufferRange (%\" PRIu64 \").\",\n                     picture_info->pTileOffsets[i], decode_info.srcBufferRange);\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-vkCmdDecodeVideoKHR-pTileOffsets-09252\", \"If the bound video session was created with the video codec operation VK_VIDEO_CODEC_OPERATION_DECODE_AV1_BIT_KHR, then for each element i of the pTileOffsets and pTileSizes members of the VkVideoDecodeAV1PictureInfoKHR structure included in the pNext chain of pDecodeInfo the sum of pTileOffsets[i] and pTileSizes[i] must be less than or equal to pDecodeInfo->srcBufferRange\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (picture_info->pTileOffsets[i] + picture_info->pTileSizes[i] > decode_info.srcBufferRange) {\n    skip |= LogError(\"VUID-vkCmdDecodeVideoKHR-pTileOffsets-09252\", cb_state.Handle(),\n                     loc.pNext(Struct::VkVideoDecodeAV1PictureInfoKHR, Field::pTileOffsets, i),\n                     \"(%u) plus pTileSizes[%u] (%u) is greater than pDecodeInfo->srcBufferRange (%\" PRIu64 \").\",\n                     picture_info->pTileOffsets[i], i, picture_info->pTileSizes[i], decode_info.srcBufferRange);\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-vkCmdDecodeVideoKHR-pNext-09250\", \"If the bound video session was created with the video codec operation VK_VIDEO_CODEC_OPERATION_DECODE_AV1_BIT_KHR, then the pNext chain of pDecodeInfo must include a VkVideoDecodeAV1PictureInfoKHR structure\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "skip |= LogError(\"VUID-vkCmdDecodeVideoKHR-pNext-09250\", cb_state.Handle(), loc.dot(Field::pNext), pnext_msg,\n                 \"VkVideoDecodeAV1PictureInfoKHR\");\n"
        },
        {
            "role": "user",
            "content": "{\"VUID-vkCmdEncodeVideoKHR-maxBPictureL0ReferenceCount-08341\", \"If the bound video session was created with the video codec operation VK_VIDEO_CODEC_OPERATION_ENCODE_H264_BIT_KHR and VkVideoEncodeH264CapabilitiesKHR::maxBPictureL0ReferenceCount and VkVideoEncodeH264CapabilitiesKHR::maxL1ReferenceCount are both zero, as returned by vkGetPhysicalDeviceVideoCapabilitiesKHR for the video profile the bound video session was created with, then h264PictureType and each element of h264L0PictureTypes and h264L1PictureTypes must not be STD_VIDEO_H264_PICTURE_TYPE_B\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (profile_caps.encode_h264.maxBPictureL0ReferenceCount == 0 && profile_caps.encode_h264.maxL1ReferenceCount == 0 &&\n    skip |= LogError(\"VUID-vkCmdEncodeVideoKHR-maxBPictureL0ReferenceCount-08341\", vs_state.Handle(), loc,\n                     \"%s is STD_VIDEO_H264_PICTURE_TYPE_B but B pictures \"\n                     \"are not supported by the H.264 encode profile %s was created with.\",\n                     where, FormatHandle(vs_state).c_str());\n"
        },
        {
            "role": "user",
            "content": "{\"VUID-vkCmdEncodeVideoKHR-pEncodeInfo-08228\", \"If the bound video session was created with the video codec operation VK_VIDEO_CODEC_OPERATION_ENCODE_H264_BIT_KHR and pEncodeInfo->pSetupReferenceSlot is not NULL, then the pNext chain of pEncodeInfo->pSetupReferenceSlot must include a VkVideoEncodeH264DpbSlotInfoKHR structure\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (!dpb_slot_info) {\n    skip |= LogError(\"VUID-vkCmdEncodeVideoKHR-pEncodeInfo-08228\", cb_state.Handle(),\n                     loc.dot(Field::pSetupReferenceSlot).dot(Field::pNext), pnext_msg, \"VkVideoEncodeH264DpbSlotInfoKHR\");\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-vkCmdEncodeVideoKHR-pNext-08229\", \"If the bound video session was created with the video codec operation VK_VIDEO_CODEC_OPERATION_ENCODE_H264_BIT_KHR, then the pNext chain of each element of pEncodeInfo->pReferenceSlots must include a VkVideoEncodeH264DpbSlotInfoKHR structure\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (!dpb_slot_info) {\n    skip |= LogError(\"VUID-vkCmdEncodeVideoKHR-pNext-08229\", cb_state.Handle(),\n                     loc.dot(Field::pReferenceSlots, i).dot(Field::pNext), pnext_msg, \"VkVideoEncodeH264DpbSlotInfoKHR\");\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-vkCmdEncodeVideoKHR-StdVideoH264SequenceParameterSet-08226\", \"If the bound video session was created with the video codec operation VK_VIDEO_CODEC_OPERATION_ENCODE_H264_BIT_KHR, then the bound video session parameters object must contain a StdVideoH264SequenceParameterSet entry with seq_parameter_set_id matching StdVideoEncodeH264PictureInfo::seq_parameter_set_id that is provided in the pStdPictureInfo member of the VkVideoEncodeH264PictureInfoKHR structure included in the pNext chain of pEncodeInfo\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (std_sps == nullptr) {\n    const LogObjectList objlist(cb_state.Handle(), vsp_state.Handle());\n    skip |= LogError(\"VUID-vkCmdEncodeVideoKHR-StdVideoH264SequenceParameterSet-08226\", objlist, loc.function,\n                     \"no H.264 SPS with seq_parameter_set_id = %u \"\n                     \"exists in the bound video session parameters object %s.\",\n                     std_picture_info->seq_parameter_set_id, FormatHandle(vsp_state).c_str());\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-vkCmdEncodeVideoKHR-naluSliceEntryCount-08302\", \"If the bound video session was created with the video codec operation VK_VIDEO_CODEC_OPERATION_ENCODE_H264_BIT_KHR, then the naluSliceEntryCount member of the VkVideoEncodeH264PictureInfoKHR structure included in the pNext chain of pEncodeInfo must be less than or equal to minCodingBlockExtent.width multiplied by minCodingBlockExtent.height\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (picture_info->naluSliceEntryCount > min_coding_block_extent.width * min_coding_block_extent.height) {\n    skip |= LogError(\"VUID-vkCmdEncodeVideoKHR-naluSliceEntryCount-08302\", cb_state.Handle(), slice_count_loc,\n                     \"(%u) is greater than the number of MBs (minCodingBlockExtent = {%s}) \"\n                     \"that can be coded for the encode input picture specified in \"\n                     \"pEncodeInfo->srcPictureResource (codedExtent = {%s}).\",\n                     picture_info->naluSliceEntryCount, string_VkExtent2D(min_coding_block_extent).c_str(),\n                     string_VkExtent2D(encode_info.srcPictureResource.codedExtent).c_str());\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-vkCmdEncodeVideoKHR-naluSliceEntryCount-08312\", \"If the bound video session was created with the video codec operation VK_VIDEO_CODEC_OPERATION_ENCODE_H264_BIT_KHR and VkVideoEncodeH264CapabilitiesKHR::flags does not include VK_VIDEO_ENCODE_H264_CAPABILITY_ROW_UNALIGNED_SLICE_BIT_KHR, as returned by vkGetPhysicalDeviceVideoCapabilitiesKHR for the video profile the bound video session was created with, then the naluSliceEntryCount member of the VkVideoEncodeH264PictureInfoKHR structure included in the pNext chain of pEncodeInfo must be less than or equal to minCodingBlockExtent.height\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (picture_info->naluSliceEntryCount > min_coding_block_extent.height) {\n    skip |= LogError(\"VUID-vkCmdEncodeVideoKHR-naluSliceEntryCount-08312\", cb_state.Handle(), slice_count_loc,\n                     \"(%u) is greater than the number of MB rows (minCodingBlockExtent.height = %u) \"\n                     \"that can be coded for the encode input picture specified in \"\n                     \"pEncodeInfo->srcPictureResource (codedExtent = {%s}).\",\n                     picture_info->naluSliceEntryCount, min_coding_block_extent.height,\n                     string_VkExtent2D(encode_info.srcPictureResource.codedExtent).c_str());\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-vkCmdEncodeVideoKHR-constantQp-08270\", \"If the bound video session was created with the video codec operation VK_VIDEO_CODEC_OPERATION_ENCODE_H264_BIT_KHR and the current rate control mode is VK_VIDEO_ENCODE_RATE_CONTROL_MODE_DISABLED_BIT_KHR, then VkVideoEncodeH264NaluSliceInfoKHR::constantQp must be between VkVideoEncodeH264CapabilitiesKHR::minQp and VkVideoEncodeH264CapabilitiesKHR::maxQp, as returned by vkGetPhysicalDeviceVideoCapabilitiesKHR for the video profile the bound video session was created with, for each element of the pNaluSliceEntries member of the VkVideoEncodeH264PictureInfoKHR structure included in the pNext chain of pEncodeInfo\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (slice_info.constantQp < profile_caps.encode_h264.minQp ||\n    slice_info.constantQp > profile_caps.encode_h264.maxQp) {\n    const LogObjectList objlist(cb_state.Handle(), vs_state.Handle());\n    skip |= LogError(\"VUID-vkCmdEncodeVideoKHR-constantQp-08270\", objlist, slice_info_loc.dot(Field::constantQp),\n                     \"(%d) is outside of the range [%d, %d] supported by the video \"\n                     \"profile %s was created with.\",\n                     slice_info.constantQp, profile_caps.encode_h264.minQp, profile_caps.encode_h264.maxQp,\n                     FormatHandle(vs_state).c_str());\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-vkCmdEncodeVideoKHR-constantQp-08269\", \"If the bound video session was created with the video codec operation VK_VIDEO_CODEC_OPERATION_ENCODE_H264_BIT_KHR and the current rate control mode is not VK_VIDEO_ENCODE_RATE_CONTROL_MODE_DISABLED_BIT_KHR, then VkVideoEncodeH264NaluSliceInfoKHR::constantQp must be zero for each element of the pNaluSliceEntries member of the VkVideoEncodeH264PictureInfoKHR structure included in the pNext chain of pEncodeInfo\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (slice_info.constantQp != 0) {\n    const LogObjectList objlist(cb_state.Handle(), vs_state.Handle());\n    skip |= LogError(\"VUID-vkCmdEncodeVideoKHR-constantQp-08269\", objlist, slice_info_loc.dot(Field::constantQp),\n                     \"(%d) is not zero but the currently set video encode rate control mode for %s \"\n                     \"was specified to be %s when beginning the video coding scope.\",\n                     slice_info.constantQp, FormatHandle(vs_state).c_str(),\n                     string_VkVideoEncodeRateControlModeFlagBitsKHR(rc_state.base.rateControlMode));\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkVideoEncodeH264PictureInfoKHR-flags-08315\", \"If VkVideoEncodeH264CapabilitiesKHR::flags, as returned by vkGetPhysicalDeviceVideoCapabilitiesKHR for the used video profile, does not include VK_VIDEO_ENCODE_H264_CAPABILITY_DIFFERENT_SLICE_TYPE_BIT_KHR, then VkVideoEncodeH264NaluSliceInfoKHR::pStdSliceHeader->slice_type must be identical for all elements of pNaluSliceEntries\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if ((profile_caps.encode_h264.flags & VK_VIDEO_ENCODE_H264_CAPABILITY_DIFFERENT_SLICE_TYPE_BIT_KHR) == 0 &&\n    const LogObjectList objlist(cb_state.Handle(), vs_state.Handle());\n    skip |= LogError(\"VUID-VkVideoEncodeH264PictureInfoKHR-flags-08315\", objlist, loc.function,\n                     \"pStdSliceHeader->slice_type does not match across the elements \"\n                     \"of %s but different slice types in a picture are not supported by the H.264 encode \"\n                     \"profile %s was created with.\",\n                     slice_list_loc.Fields().c_str(), FormatHandle(vs_state).c_str());\n"
        },
        {
            "role": "user",
            "content": "{\"VUID-vkCmdEncodeVideoKHR-constantQp-08271\", \"If the bound video session was created with the video codec operation VK_VIDEO_CODEC_OPERATION_ENCODE_H264_BIT_KHR and VkVideoEncodeH264CapabilitiesKHR::flags does not include VK_VIDEO_ENCODE_H264_CAPABILITY_PER_SLICE_CONSTANT_QP_BIT_KHR, as returned by vkGetPhysicalDeviceVideoCapabilitiesKHR for the video profile the bound video session was created with, then VkVideoEncodeH264NaluSliceInfoKHR::constantQp must have the same value for each element of the pNaluSliceEntries member of the VkVideoEncodeH264PictureInfoKHR structure included in the pNext chain of pEncodeInfo\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if ((profile_caps.encode_h264.flags & VK_VIDEO_ENCODE_H264_CAPABILITY_PER_SLICE_CONSTANT_QP_BIT_KHR) == 0 &&\n    const LogObjectList objlist(cb_state.Handle(), vs_state.Handle());\n    skip |= LogError(\"VUID-vkCmdEncodeVideoKHR-constantQp-08271\", objlist, loc.function,\n                     \"constantQp does not match across the elements of %s\"\n                     \"but per-slice constant QP values are not supported by the H.264 encode \"\n                     \"profile %s was created with.\",\n                     slice_list_loc.Fields().c_str(), FormatHandle(vs_state).c_str());\n"
        },
        {
            "role": "user",
            "content": "{\"VUID-vkCmdEncodeVideoKHR-flags-08342\", \"If the bound video session was created with the video codec operation VK_VIDEO_CODEC_OPERATION_ENCODE_H264_BIT_KHR and VkVideoEncodeH264CapabilitiesKHR::flags does not include VK_VIDEO_ENCODE_H264_CAPABILITY_B_FRAME_IN_L0_LIST_BIT_KHR, as returned by vkGetPhysicalDeviceVideoCapabilitiesKHR for the video profile the bound video session was created with, then each element of h264L0PictureTypes must not be STD_VIDEO_H264_PICTURE_TYPE_B\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (std_reference_info->primary_pic_type == STD_VIDEO_H264_PICTURE_TYPE_B &&\n    (profile_caps.encode_h264.flags & VK_VIDEO_ENCODE_H264_CAPABILITY_B_FRAME_IN_L0_LIST_BIT_KHR) == 0) {\n    const LogObjectList objlist(cb_state.Handle(), vs_state.Handle());\n    skip |= LogError(\"VUID-vkCmdEncodeVideoKHR-flags-08342\", objlist, loc.function,\n                     \"primary_pic_type for L0 reference is \"\n                     \"STD_VIDEO_H264_PICTURE_TYPE_B but B pictures are not supported in the \"\n                     \"L0 reference list by the H.264 encode profile %s was created with.\",\n                     FormatHandle(vs_state).c_str());\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-vkCmdEncodeVideoKHR-pNext-08339\", \"If the bound video session was created with the video codec operation VK_VIDEO_CODEC_OPERATION_ENCODE_H264_BIT_KHR, the pNext chain of pEncodeInfo includes a VkVideoEncodeH264PictureInfoKHR structure, and VkVideoEncodeH264PictureInfoKHR::pStdPictureInfo->pRefLists is not NULL, then each element of the RefPicList0 and RefPicList1 array members of the StdVideoEncodeH264ReferenceListsInfo structure pointed to by VkVideoEncodeH264PictureInfoKHR::pStdPictureInfo->pRefLists must either be STD_VIDEO_H264_NO_REFERENCE_PICTURE or must equal the slotIndex member of one of the elements of pEncodeInfo->pReferenceSlots\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "skip |= LogError(\"VUID-vkCmdEncodeVideoKHR-pNext-08339\", cb_state.Handle(), loc.function,\n                 \"%s->pRefLists->RefPicList0[%u] (%u) does not match \"\n                 \"the slotIndex member of any element of pEncodeInfo->pReferenceSlots.\",\n                 loc.pNext(Struct::VkVideoEncodeH264PictureInfoKHR, Field::pStdPictureInfo).Fields().c_str(), i,\n                 ref_list_entry);\n"
        },
        {
            "role": "user",
            "content": "{\"VUID-vkCmdEncodeVideoKHR-flags-08343\", \"If the bound video session was created with the video codec operation VK_VIDEO_CODEC_OPERATION_ENCODE_H264_BIT_KHR and VkVideoEncodeH264CapabilitiesKHR::flags does not include VK_VIDEO_ENCODE_H264_CAPABILITY_B_FRAME_IN_L1_LIST_BIT_KHR, as returned by vkGetPhysicalDeviceVideoCapabilitiesKHR for the video profile the bound video session was created with, then each element of h264L1PictureTypes must not be STD_VIDEO_H264_PICTURE_TYPE_B\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (std_reference_info->primary_pic_type == STD_VIDEO_H264_PICTURE_TYPE_B &&\n    (profile_caps.encode_h264.flags & VK_VIDEO_ENCODE_H264_CAPABILITY_B_FRAME_IN_L1_LIST_BIT_KHR) == 0) {\n    const LogObjectList objlist(cb_state.Handle(), vs_state.Handle());\n    skip |= LogError(\"VUID-vkCmdEncodeVideoKHR-flags-08343\", objlist, loc.function,\n                     \"primary_pic_type for L1 reference is \"\n                     \"STD_VIDEO_H264_PICTURE_TYPE_B but B pictures are not supported in the \"\n                     \"L1 reference list by the H.264 encode profile %s was created with.\",\n                     FormatHandle(vs_state).c_str());\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-vkCmdEncodeVideoKHR-pNext-08353\", \"If the bound video session was created with the video codec operation VK_VIDEO_CODEC_OPERATION_ENCODE_H264_BIT_KHR, the pNext chain of pEncodeInfo includes a VkVideoEncodeH264PictureInfoKHR structure, and pEncodeInfo->referenceSlotCount is greater than zero, then the slotIndex member of each element of pEncodeInfo->pReferenceSlots must equal one of the elements of the RefPicList0 or RefPicList1 array members of the StdVideoEncodeH264ReferenceListsInfo structure pointed to by VkVideoEncodeH264PictureInfoKHR::pStdPictureInfo->pRefLists\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (slot_index >= 0 && (uint32_t)slot_index < vs_state.create_info.maxDpbSlots &&\n    skip |= LogError(\"VUID-vkCmdEncodeVideoKHR-pNext-08353\", cb_state.Handle(),\n                     loc.dot(Field::pReferenceSlots, i).dot(Field::slotIndex),\n                     \"(%d) does not match \"\n                     \"any of the elements of RefPicList0 or RefPicList1 in %s->pRefLists.\",\n                     slot_index,\n                     loc.pNext(Struct::VkVideoEncodeH264PictureInfoKHR, Field::pStdPictureInfo).Fields().c_str());\n"
        },
        {
            "role": "user",
            "content": "{\"VUID-vkCmdEncodeVideoKHR-pNext-08352\", \"If the bound video session was created with the video codec operation VK_VIDEO_CODEC_OPERATION_ENCODE_H264_BIT_KHR, the pNext chain of pEncodeInfo includes a VkVideoEncodeH264PictureInfoKHR structure, and pEncodeInfo->referenceSlotCount is greater than zero, then VkVideoEncodeH264PictureInfoKHR::pStdPictureInfo->pRefLists must not be NULL\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "skip |= LogError(\"VUID-vkCmdEncodeVideoKHR-pNext-08352\", cb_state.Handle(), loc.function,\n                 \"%s->pRefLists is NULL but pEncodeInfo->referenceSlotCount (%u) is not zero.\",\n                 loc.pNext(Struct::VkVideoEncodeH264PictureInfoKHR, Field::pStdPictureInfo).Fields().c_str(),\n                 encode_info.referenceSlotCount);\n"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkVideoEncodeH264PictureInfoKHR-flags-08304\", \"If VkVideoEncodeH264CapabilitiesKHR::flags, as returned by vkGetPhysicalDeviceVideoCapabilitiesKHR for the used video profile, does not include VK_VIDEO_ENCODE_H264_CAPABILITY_GENERATE_PREFIX_NALU_BIT_KHR, then generatePrefixNalu must be VK_FALSE\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (picture_info->generatePrefixNalu &&\n    (profile_caps.encode_h264.flags & VK_VIDEO_ENCODE_H264_CAPABILITY_GENERATE_PREFIX_NALU_BIT_KHR) == 0) {\n    const LogObjectList objlist(cb_state.Handle(), vs_state.Handle());\n    skip |= LogError(\"VUID-VkVideoEncodeH264PictureInfoKHR-flags-08304\", objlist,\n                     loc.pNext(Struct::VkVideoEncodeH264PictureInfoKHR, Field::generatePrefixNalu),\n                     \"is VK_TRUE but VK_VIDEO_ENCODE_H264_CAPABILITY_GENERATE_PREFIX_NALU_BIT_KHR \"\n                     \"is not supported by the H.264 encode profile %s was created with.\",\n                     FormatHandle(vs_state).c_str());\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-vkCmdEncodeVideoKHR-maxPPictureL0ReferenceCount-08345\", \"If the bound video session was created with the video codec operation VK_VIDEO_CODEC_OPERATION_ENCODE_H265_BIT_KHR and VkVideoEncodeH265CapabilitiesKHR::maxPPictureL0ReferenceCount is zero, as returned by vkGetPhysicalDeviceVideoCapabilitiesKHR for the video profile the bound video session was created with, then h265PictureType and each element of h265L0PictureTypes and h265L1PictureTypes must not be STD_VIDEO_H265_PICTURE_TYPE_P\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (profile_caps.encode_h265.maxPPictureL0ReferenceCount == 0 && pic_type == STD_VIDEO_H265_PICTURE_TYPE_P) {\n    skip |= LogError(\"VUID-vkCmdEncodeVideoKHR-maxPPictureL0ReferenceCount-08345\", vs_state.Handle(), loc,\n                     \"%s is STD_VIDEO_H265_PICTURE_TYPE_P but P pictures \"\n                     \"are not supported by the H.265 encode profile %s was created with.\",\n                     where, FormatHandle(vs_state).c_str());\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-vkCmdEncodeVideoKHR-maxBPictureL0ReferenceCount-08346\", \"If the bound video session was created with the video codec operation VK_VIDEO_CODEC_OPERATION_ENCODE_H265_BIT_KHR and VkVideoEncodeH265CapabilitiesKHR::maxBPictureL0ReferenceCount and VkVideoEncodeH265CapabilitiesKHR::maxL1ReferenceCount are both zero, as returned by vkGetPhysicalDeviceVideoCapabilitiesKHR for the video profile the bound video session was created with, then h265PictureType and each element of h265L0PictureTypes and h265L1PictureTypes must not be STD_VIDEO_H265_PICTURE_TYPE_B\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (profile_caps.encode_h265.maxBPictureL0ReferenceCount == 0 && profile_caps.encode_h265.maxL1ReferenceCount == 0 &&\n    skip |= LogError(\"VUID-vkCmdEncodeVideoKHR-maxBPictureL0ReferenceCount-08346\", vs_state.Handle(), loc,\n                     \"%s is STD_VIDEO_H265_PICTURE_TYPE_B but B pictures \"\n                     \"are not supported by the H.265 profile %s was created with.\",\n                     where, FormatHandle(vs_state).c_str());\n"
        },
        {
            "role": "user",
            "content": "{\"VUID-vkCmdEncodeVideoKHR-pEncodeInfo-08234\", \"If the bound video session was created with the video codec operation VK_VIDEO_CODEC_OPERATION_ENCODE_H265_BIT_KHR and pEncodeInfo->pSetupReferenceSlot is not NULL, then the pNext chain of pEncodeInfo->pSetupReferenceSlot must include a VkVideoEncodeH265DpbSlotInfoKHR structure\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (!dpb_slot_info) {\n    skip |= LogError(\"VUID-vkCmdEncodeVideoKHR-pEncodeInfo-08234\", cb_state.Handle(),\n                     loc.dot(Field::pSetupReferenceSlot).dot(Field::pNext), pnext_msg, \"VkVideoEncodeH265DpbSlotInfoKHR\");\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-vkCmdEncodeVideoKHR-pNext-08235\", \"If the bound video session was created with the video codec operation VK_VIDEO_CODEC_OPERATION_ENCODE_H265_BIT_KHR, then the pNext chain of each element of pEncodeInfo->pReferenceSlots must include a VkVideoEncodeH265DpbSlotInfoKHR structure\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (!dpb_slot_info) {\n    skip |= LogError(\"VUID-vkCmdEncodeVideoKHR-pNext-08235\", cb_state.Handle(),\n                     loc.dot(Field::pReferenceSlots, i).dot(Field::pNext), pnext_msg, \"VkVideoEncodeH265DpbSlotInfoKHR\");\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-vkCmdEncodeVideoKHR-StdVideoH265SequenceParameterSet-08232\", \"If the bound video session was created with the video codec operation VK_VIDEO_CODEC_OPERATION_ENCODE_H265_BIT_KHR, then the bound video session parameters object must contain a StdVideoH265SequenceParameterSet entry with sps_video_parameter_set_id and sps_seq_parameter_set_id matching StdVideoEncodeH265PictureInfo::sps_video_parameter_set_id and StdVideoEncodeH265PictureInfo::pps_seq_parameter_set_id, respectively, that are provided in the pStdPictureInfo member of the VkVideoEncodeH265PictureInfoKHR structure included in the pNext chain of pEncodeInfo\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (std_sps == nullptr) {\n    const LogObjectList objlist(cb_state.Handle(), vsp_state.Handle());\n    skip |= LogError(\"VUID-vkCmdEncodeVideoKHR-StdVideoH265SequenceParameterSet-08232\", objlist, loc.function,\n                     \"no H.265 SPS with sps_video_parameter_set_id = %u \"\n                     \"and pps_seq_parameter_set_id = %u exists in the bound video session \"\n                     \"parameters object %s.\",\n                     std_picture_info->sps_video_parameter_set_id, std_picture_info->pps_seq_parameter_set_id,\n                     FormatHandle(vsp_state).c_str());\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-vkCmdEncodeVideoKHR-StdVideoH265PictureParameterSet-08233\", \"If the bound video session was created with the video codec operation VK_VIDEO_CODEC_OPERATION_ENCODE_H265_BIT_KHR, then the bound video session parameters object must contain a StdVideoH265PictureParameterSet entry with sps_video_parameter_set_id, pps_seq_parameter_set_id, and pps_pic_parameter_set_id matching StdVideoEncodeH265PictureInfo::sps_video_parameter_set_id, StdVideoEncodeH265PictureInfo::pps_seq_parameter_set_id, and StdVideoEncodeH265PictureInfo::pps_pic_parameter_set_id, respectively, that are provided in the pStdPictureInfo member of the VkVideoEncodeH265PictureInfoKHR structure included in the pNext chain of pEncodeInfo\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (std_pps == nullptr) {\n    const LogObjectList objlist(cb_state.Handle(), vsp_state.Handle());\n    skip |= LogError(\"VUID-vkCmdEncodeVideoKHR-StdVideoH265PictureParameterSet-08233\", objlist, loc.function,\n                     \"no H.265 SPS with sps_video_parameter_set_id = %u, \"\n                     \"pps_seq_parameter_set_id = %u, and pps_pic_parameter_set_id = %u exists in \"\n                     \"the bound video session parameters object %s.\",\n                     std_picture_info->sps_video_parameter_set_id, std_picture_info->pps_seq_parameter_set_id,\n                     std_picture_info->pps_pic_parameter_set_id, FormatHandle(vsp_state).c_str());\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkVideoEncodeH265PictureInfoKHR-naluSliceSegmentEntryCount-08306\", \"naluSliceSegmentEntryCount must be between 1 and VkVideoEncodeH265CapabilitiesKHR::maxSliceSegmentCount, inclusive, as returned by vkGetPhysicalDeviceVideoCapabilitiesKHR for the used video profile\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (picture_info->naluSliceSegmentEntryCount > profile_caps.encode_h265.maxSliceSegmentCount) {\n    const LogObjectList objlist(cb_state.Handle(), vs_state.Handle());\n    skip |= LogError(\"VUID-VkVideoEncodeH265PictureInfoKHR-naluSliceSegmentEntryCount-08306\", objlist, slice_seg_count_loc,\n                     \"(%u) exceeds the VkVideoEncodeH265CapabilitiesKHR::maxSliceSegmentCount (%u) limit \"\n                     \"supported by the H.265 encode profile %s was created with.\",\n                     picture_info->naluSliceSegmentEntryCount, profile_caps.encode_h265.maxSliceSegmentCount,\n                     FormatHandle(vs_state).c_str());\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-vkCmdEncodeVideoKHR-naluSliceSegmentEntryCount-08307\", \"If the bound video session was created with the video codec operation VK_VIDEO_CODEC_OPERATION_ENCODE_H265_BIT_KHR, then the naluSliceSegmentEntryCount member of the VkVideoEncodeH265PictureInfoKHR structure included in the pNext chain of pEncodeInfo must be less than or equal to minCodingBlockExtent.width multiplied by minCodingBlockExtent.height\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (picture_info->naluSliceSegmentEntryCount > min_coding_block_extent.width * min_coding_block_extent.height) {\n    const LogObjectList objlist(cb_state.Handle(), vs_state.Handle());\n    skip |= LogError(\"VUID-vkCmdEncodeVideoKHR-naluSliceSegmentEntryCount-08307\", objlist, slice_seg_count_loc,\n                     \"(%u) is greater than the number of CTBs (minCodingBlockExtent = {%s}) that can \"\n                     \"be coded for the encode input picture specified in pEncodeInfo->srcPictureResource \"\n                     \"(codedExtent = {%s}) assuming the maximum CTB size (%s) supported by the \"\n                     \"H.265 encode profile %s was created with.\",\n                     picture_info->naluSliceSegmentEntryCount, string_VkExtent2D(min_coding_block_extent).c_str(),\n                     string_VkExtent2D(encode_info.srcPictureResource.codedExtent).c_str(),\n                     string_VkExtent2D(max_coding_block_size).c_str(), FormatHandle(vs_state).c_str());\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkVideoEncodeH265PictureInfoKHR-flags-08323\", \"If VkVideoEncodeH265CapabilitiesKHR::flags, as returned by vkGetPhysicalDeviceVideoCapabilitiesKHR for the used video profile, does not include VK_VIDEO_ENCODE_H265_CAPABILITY_MULTIPLE_TILES_PER_SLICE_SEGMENT_BIT_KHR, then naluSliceSegmentEntryCount must be greater than or equal to the number of H.265 tiles in the picture\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if ((profile_caps.encode_h265.flags & VK_VIDEO_ENCODE_H265_CAPABILITY_MULTIPLE_TILES_PER_SLICE_SEGMENT_BIT_KHR) == 0 &&\n    const LogObjectList objlist(cb_state.Handle(), vs_state.Handle());\n    skip |= LogError(\"VUID-VkVideoEncodeH265PictureInfoKHR-flags-08323\", objlist, slice_seg_count_loc,\n                     \"(%u) is less than the number of H.265 tiles (%u) in the encoded picture \"\n                     \"(num_tile_columns_minus1 = %u and num_tile_rows_minus1 = %u in the active H.265 PPS) \"\n                     \"but multiple tiles per slice segment are not supported by the H.265 encode profile \"\n                     \"%s was created with.\",\n                     picture_info->naluSliceSegmentEntryCount, num_tiles, std_pps->num_tile_columns_minus1,\n                     std_pps->num_tile_rows_minus1, FormatHandle(vs_state).c_str());\n"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkVideoEncodeH265PictureInfoKHR-flags-08324\", \"If VkVideoEncodeH265CapabilitiesKHR::flags, as returned by vkGetPhysicalDeviceVideoCapabilitiesKHR for the used video profile, does not include VK_VIDEO_ENCODE_H265_CAPABILITY_MULTIPLE_SLICE_SEGMENTS_PER_TILE_BIT_KHR, then naluSliceSegmentEntryCount must be less than or equal to the number of H.265 tiles in the picture\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if ((profile_caps.encode_h265.flags & VK_VIDEO_ENCODE_H265_CAPABILITY_MULTIPLE_SLICE_SEGMENTS_PER_TILE_BIT_KHR) == 0 &&\n    const LogObjectList objlist(cb_state.Handle(), vs_state.Handle());\n    skip |= LogError(\"VUID-VkVideoEncodeH265PictureInfoKHR-flags-08324\", objlist, slice_seg_count_loc,\n                     \"(%u) is greater than the number of H.265 tiles (%u) in the encoded picture \"\n                     \"(num_tile_columns_minus1 = %u and num_tile_rows_minus1 = %u in the active H.265 PPS) \"\n                     \"but multiple slice segments per tile are not supported by the H.265 encode profile \"\n                     \"%s was created with.\",\n                     picture_info->naluSliceSegmentEntryCount, num_tiles, std_pps->num_tile_columns_minus1,\n                     std_pps->num_tile_rows_minus1, FormatHandle(vs_state).c_str());\n"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkVideoEncodeH265PictureInfoKHR-flags-08317\", \"If VkVideoEncodeH265CapabilitiesKHR::flags, as returned by vkGetPhysicalDeviceVideoCapabilitiesKHR for the used video profile, does not include VK_VIDEO_ENCODE_H265_CAPABILITY_DIFFERENT_SLICE_SEGMENT_TYPE_BIT_KHR, then VkVideoEncodeH265NaluSliceSegmentInfoKHR::pStdSliceSegmentHeader->slice_type must be identical for all elements of pNaluSliceSegmentEntries\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if ((profile_caps.encode_h265.flags & VK_VIDEO_ENCODE_H265_CAPABILITY_DIFFERENT_SLICE_SEGMENT_TYPE_BIT_KHR) == 0 &&\n    const LogObjectList objlist(cb_state.Handle(), vs_state.Handle());\n    skip |= LogError(\"VUID-VkVideoEncodeH265PictureInfoKHR-flags-08317\", objlist, loc.function,\n                     \"pStdSliceSegmentHeader->slice_type does not match across the elements \"\n                     \"of %s but different slice segment types in a picture are not supported by the H.265 encode \"\n                     \"profile %s was created with.\",\n                     slice_seg_list_loc.Fields().c_str(), FormatHandle(vs_state).c_str());\n"
        },
        {
            "role": "user",
            "content": "{\"VUID-vkCmdEncodeVideoKHR-constantQp-08274\", \"If the bound video session was created with the video codec operation VK_VIDEO_CODEC_OPERATION_ENCODE_H265_BIT_KHR and VkVideoEncodeH265CapabilitiesKHR::flags does not include VK_VIDEO_ENCODE_H265_CAPABILITY_PER_SLICE_SEGMENT_CONSTANT_QP_BIT_KHR, as returned by vkGetPhysicalDeviceVideoCapabilitiesKHR for the video profile the bound video session was created with, then VkVideoEncodeH265NaluSliceSegmentInfoKHR::constantQp must have the same value for each element of the pNaluSliceSegmentEntries member of the VkVideoEncodeH264PictureInfoKHR structure included in the pNext chain of pEncodeInfo\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if ((profile_caps.encode_h265.flags & VK_VIDEO_ENCODE_H265_CAPABILITY_PER_SLICE_SEGMENT_CONSTANT_QP_BIT_KHR) == 0 &&\n    const LogObjectList objlist(cb_state.Handle(), vs_state.Handle());\n    skip |= LogError(\"VUID-vkCmdEncodeVideoKHR-constantQp-08274\", objlist, loc.function,\n                     \"constantQp does not match across the elements of %s \"\n                     \"but per-slice-segment constant QP values are not supported by the H.265 encode \"\n                     \"profile %s was created with.\",\n                     slice_seg_list_loc.Fields().c_str(), FormatHandle(vs_state).c_str());\n"
        },
        {
            "role": "user",
            "content": "{\"VUID-vkCmdEncodeVideoKHR-pNext-08344\", \"If the bound video session was created with the video codec operation VK_VIDEO_CODEC_OPERATION_ENCODE_H265_BIT_KHR, the pNext chain of pEncodeInfo includes a VkVideoEncodeH265PictureInfoKHR structure, and VkVideoEncodeH265PictureInfoKHR::pStdPictureInfo->pRefLists is not NULL, then each element of the RefPicList0 and RefPicList1 array members of the StdVideoEncodeH265ReferenceListsInfo structure pointed to by VkVideoEncodeH265PictureInfoKHR::pStdPictureInfo->pRefLists must either be STD_VIDEO_H265_NO_REFERENCE_PICTURE or must equal the slotIndex member of one of the elements of pEncodeInfo->pReferenceSlots\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "skip |= LogError(\"VUID-vkCmdEncodeVideoKHR-pNext-08344\", cb_state.Handle(), loc.function,\n                 \"%s->pRefLists->RefPicList0[%u] (%u) does not match \"\n                 \"the slotIndex member of any element of pEncodeInfo->pReferenceSlots.\",\n                 loc.pNext(Struct::VkVideoEncodeH265PictureInfoKHR, Field::pStdPictureInfo).Fields().c_str(), i,\n                 ref_list_entry);\n"
        },
        {
            "role": "user",
            "content": "{\"VUID-vkCmdEncodeVideoKHR-pNext-08344\", \"If the bound video session was created with the video codec operation VK_VIDEO_CODEC_OPERATION_ENCODE_H265_BIT_KHR, the pNext chain of pEncodeInfo includes a VkVideoEncodeH265PictureInfoKHR structure, and VkVideoEncodeH265PictureInfoKHR::pStdPictureInfo->pRefLists is not NULL, then each element of the RefPicList0 and RefPicList1 array members of the StdVideoEncodeH265ReferenceListsInfo structure pointed to by VkVideoEncodeH265PictureInfoKHR::pStdPictureInfo->pRefLists must either be STD_VIDEO_H265_NO_REFERENCE_PICTURE or must equal the slotIndex member of one of the elements of pEncodeInfo->pReferenceSlots\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "skip |= LogError(\"VUID-vkCmdEncodeVideoKHR-pNext-08344\", cb_state.Handle(), loc.function,\n                 \"%s->pRefLists->RefPicList1[%u] (%u) does not match \"\n                 \"the slotIndex member of any element of pEncodeInfo->pReferenceSlots.\",\n                 loc.pNext(Struct::VkVideoEncodeH265PictureInfoKHR, Field::pStdPictureInfo).Fields().c_str(), i,\n                 ref_list_entry);\n"
        },
        {
            "role": "user",
            "content": "{\"VUID-vkCmdEncodeVideoKHR-flags-08348\", \"If the bound video session was created with the video codec operation VK_VIDEO_CODEC_OPERATION_ENCODE_H265_BIT_KHR and VkVideoEncodeH265CapabilitiesKHR::flags does not include VK_VIDEO_ENCODE_H265_CAPABILITY_B_FRAME_IN_L1_LIST_BIT_KHR, as returned by vkGetPhysicalDeviceVideoCapabilitiesKHR for the video profile the bound video session was created with, then each element of h265L1PictureTypes must not be STD_VIDEO_H265_PICTURE_TYPE_B\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (std_reference_info->pic_type == STD_VIDEO_H265_PICTURE_TYPE_B &&\n    (profile_caps.encode_h265.flags & VK_VIDEO_ENCODE_H265_CAPABILITY_B_FRAME_IN_L1_LIST_BIT_KHR) == 0) {\n    const LogObjectList objlist(cb_state.Handle(), vs_state.Handle());\n    skip |= LogError(\"VUID-vkCmdEncodeVideoKHR-flags-08348\", objlist, loc.function,\n                     \"pic_type for L1 reference is \"\n                     \"STD_VIDEO_H265_PICTURE_TYPE_B but B pictures are not supported in the \"\n                     \"L1 reference list by the H.265 encode profile %s was created with.\",\n                     FormatHandle(vs_state).c_str());\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-vkCmdEncodeVideoKHR-pNext-08355\", \"If the bound video session was created with the video codec operation VK_VIDEO_CODEC_OPERATION_ENCODE_H265_BIT_KHR, the pNext chain of pEncodeInfo includes a VkVideoEncodeH265PictureInfoKHR structure, and pEncodeInfo->referenceSlotCount is greater than zero, then the slotIndex member of each element of pEncodeInfo->pReferenceSlots must equal one of the elements of the RefPicList0 or RefPicList1 array members of the StdVideoEncodeH265ReferenceListsInfo structure pointed to by VkVideoEncodeH265PictureInfoKHR::pStdPictureInfo->pRefLists\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (slot_index >= 0 && (uint32_t)slot_index < vs_state.create_info.maxDpbSlots &&\n    skip |= LogError(\"VUID-vkCmdEncodeVideoKHR-pNext-08355\", cb_state.Handle(),\n                     loc.dot(Field::pReferenceSlots, i).dot(Field::slotIndex),\n                     \"(%d) does not match \"\n                     \"any of the elements of RefPicList0 or RefPicList1 in %s->pRefLists.\",\n                     slot_index,\n                     loc.pNext(Struct::VkVideoEncodeH265PictureInfoKHR, Field::pStdPictureInfo).Fields().c_str());\n"
        },
        {
            "role": "user",
            "content": "{\"VUID-vkCmdEncodeVideoKHR-pNext-08230\", \"If the bound video session was created with the video codec operation VK_VIDEO_CODEC_OPERATION_ENCODE_H265_BIT_KHR, then the pNext chain of pEncodeInfo must include a VkVideoEncodeH265PictureInfoKHR structure\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "skip |= LogError(\"VUID-vkCmdEncodeVideoKHR-pNext-08230\", cb_state.Handle(), loc.dot(Field::pNext), pnext_msg,\n                 \"VkVideoEncodeH265PictureInfoKHR\");\n"
        },
        {
            "role": "user",
            "content": "{\"VUID-vkCmdDecodeVideoKHR-activeReferencePictureCount-07150\", \"activeReferencePictureCount must be less than or equal to the VkVideoSessionCreateInfoKHR::maxActiveReferencePictures specified when the bound video session was created\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (active_reference_picture_count > vs_state.create_info.maxActiveReferencePictures) {\n    const LogObjectList objlist(cb_state.Handle(), vs_state.Handle());\n    skip |= LogError(\"VUID-vkCmdDecodeVideoKHR-activeReferencePictureCount-07150\", objlist, loc,\n                     \"more active reference pictures (%u) were specified than \"\n                     \"the maxActiveReferencePictures (%u) the bound video session %s was created with.\",\n                     active_reference_picture_count, vs_state.create_info.maxActiveReferencePictures,\n                     FormatHandle(vs_state).c_str());\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-vkCmdEncodeVideoKHR-activeReferencePictureCount-08216\", \"activeReferencePictureCount must be less than or equal to the VkVideoSessionCreateInfoKHR::maxActiveReferencePictures specified when the bound video session was created\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (active_reference_picture_count > vs_state.create_info.maxActiveReferencePictures) {\n    const LogObjectList objlist(cb_state.Handle(), vs_state.Handle());\n    skip |= LogError(\"VUID-vkCmdEncodeVideoKHR-activeReferencePictureCount-08216\", objlist, loc,\n                     \"more active reference pictures (%u) were specified than \"\n                     \"the maxActiveReferencePictures (%u) the bound video session %s was created with.\",\n                     active_reference_picture_count, vs_state.create_info.maxActiveReferencePictures,\n                     FormatHandle(vs_state).c_str());\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-vkCmdDecodeVideoKHR-dpbFrameUseCount-07176\", \"All elements of dpbFrameUseCount must be less than or equal to 1\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (dpb_frame_use_count[i] > 1) {\n    skip |= LogError(\"VUID-vkCmdDecodeVideoKHR-dpbFrameUseCount-07176\", cb_state.Handle(), loc,\n                     \"frame in DPB slot %u is referred to multiple times across \"\n                     \"pDecodeInfo->pSetupReferenceSlot and the elements of pDecodeInfo->pReferenceSlots.\",\n                     i);\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-vkCmdDecodeVideoKHR-dpbBottomFieldUseCount-07178\", \"All elements of dpbBottomFieldUseCount must be less than or equal to 1\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (dpb_bottom_field_use_count[i] > 1) {\n    skip |= LogError(\"VUID-vkCmdDecodeVideoKHR-dpbBottomFieldUseCount-07178\", cb_state.Handle(), loc,\n                     \"bottom field in DPB slot %u is referred to multiple \"\n                     \"times across pDecodeInfo->pSetupReferenceSlot and the elements of \"\n                     \"pDecodeInfo->pReferenceSlots.\",\n                     i);\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-vkCmdEncodeVideoKHR-dpbFrameUseCount-08221\", \"All elements of dpbFrameUseCount must be less than or equal to 1\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (dpb_frame_use_count[i] > 1) {\n    skip |= LogError(\"VUID-vkCmdEncodeVideoKHR-dpbFrameUseCount-08221\", cb_state.Handle(), loc,\n                     \"frame in DPB slot %u is referred to multiple times across \"\n                     \"pEncodeInfo->pSetupReferenceSlot and the elements of pEncodeInfo->pReferenceSlots.\",\n                     i);\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-vkGetPhysicalDeviceVideoCapabilitiesKHR-pVideoProfile-07184\", \"If pVideoProfile->videoCodecOperation is VK_VIDEO_CODEC_OPERATION_DECODE_H264_BIT_KHR, then the pNext chain of pCapabilities must include a VkVideoDecodeH264CapabilitiesKHR structure\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (!vku::FindStructInPNextChain<VkVideoDecodeH264CapabilitiesKHR>(pCapabilities->pNext)) {\n    skip |= LogError(\"VUID-vkGetPhysicalDeviceVideoCapabilitiesKHR-pVideoProfile-07184\", physicalDevice, caps_loc,\n                     caps_pnext_msg, \"VkVideoDecodeH264CapabilitiesKHR\");\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-vkGetPhysicalDeviceVideoCapabilitiesKHR-pVideoProfile-07185\", \"If pVideoProfile->videoCodecOperation is VK_VIDEO_CODEC_OPERATION_DECODE_H265_BIT_KHR, then the pNext chain of pCapabilities must include a VkVideoDecodeH265CapabilitiesKHR structure\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (!vku::FindStructInPNextChain<VkVideoDecodeH265CapabilitiesKHR>(pCapabilities->pNext)) {\n    skip |= LogError(\"VUID-vkGetPhysicalDeviceVideoCapabilitiesKHR-pVideoProfile-07185\", physicalDevice, caps_loc,\n                     caps_pnext_msg, \"VkVideoDecodeH265CapabilitiesKHR\");\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-vkGetPhysicalDeviceVideoCapabilitiesKHR-pVideoProfile-07187\", \"If pVideoProfile->videoCodecOperation is VK_VIDEO_CODEC_OPERATION_ENCODE_H264_BIT_KHR, then the pNext chain of pCapabilities must include a VkVideoEncodeH264CapabilitiesKHR structure\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (!vku::FindStructInPNextChain<VkVideoEncodeH264CapabilitiesKHR>(pCapabilities->pNext)) {\n    skip |= LogError(\"VUID-vkGetPhysicalDeviceVideoCapabilitiesKHR-pVideoProfile-07187\", physicalDevice, caps_loc,\n                     caps_pnext_msg, \"VkVideoEncodeH264CapabilitiesKHR\");\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-vkGetPhysicalDeviceVideoCapabilitiesKHR-pVideoProfile-07188\", \"If pVideoProfile->videoCodecOperation is VK_VIDEO_CODEC_OPERATION_ENCODE_H265_BIT_KHR, then the pNext chain of pCapabilities must include a VkVideoEncodeH265CapabilitiesKHR structure\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (!vku::FindStructInPNextChain<VkVideoEncodeH265CapabilitiesKHR>(pCapabilities->pNext)) {\n    skip |= LogError(\"VUID-vkGetPhysicalDeviceVideoCapabilitiesKHR-pVideoProfile-07188\", physicalDevice, caps_loc,\n                     caps_pnext_msg, \"VkVideoEncodeH265CapabilitiesKHR\");\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-vkGetPhysicalDeviceVideoCapabilitiesKHR-pVideoProfile-07183\", \"If pVideoProfile->videoCodecOperation specifies a decode operation, then the pNext chain of pCapabilities must include a VkVideoDecodeCapabilitiesKHR structure\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (is_decode && !vku::FindStructInPNextChain<VkVideoDecodeCapabilitiesKHR>(pCapabilities->pNext)) {\n    skip |= LogError(\"VUID-vkGetPhysicalDeviceVideoCapabilitiesKHR-pVideoProfile-07183\", physicalDevice, caps_loc,\n                     caps_pnext_msg, \"VkVideoDecodeCapabilitiesKHR\");\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-vkGetPhysicalDeviceVideoCapabilitiesKHR-pVideoProfile-07186\", \"If pVideoProfile->videoCodecOperation specifies an encode operation, then the pNext chain of pCapabilities must include a VkVideoEncodeCapabilitiesKHR structure\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (is_encode && !vku::FindStructInPNextChain<VkVideoEncodeCapabilitiesKHR>(pCapabilities->pNext)) {\n    skip |= LogError(\"VUID-vkGetPhysicalDeviceVideoCapabilitiesKHR-pVideoProfile-07186\", physicalDevice, caps_loc,\n                     caps_pnext_msg, \"VkVideoEncodeCapabilitiesKHR\");\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkPhysicalDeviceVideoEncodeQualityLevelInfoKHR-qualityLevel-08261\", \"qualityLevel must be less than VkVideoEncodeCapabilitiesKHR::maxQualityLevels, as returned by vkGetPhysicalDeviceVideoCapabilitiesKHR for the video profile specified in pVideoProfile\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (profile_desc.IsEncode() && pQualityLevelInfo->qualityLevel >= profile_caps.encode.maxQualityLevels) {\n    skip |= LogError(\"VUID-VkPhysicalDeviceVideoEncodeQualityLevelInfoKHR-qualityLevel-08261\", physicalDevice,\n                     quality_level_info_loc.dot(Field::qualityLevel),\n                     \"(%u) must be smaller than the VkVideoEncodeCapabilitiesKHR::maxQualityLevels (%u) limit \"\n                     \"supported by the specified video profile.\",\n                     pQualityLevelInfo->qualityLevel, profile_caps.encode.maxQualityLevels);\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkPhysicalDeviceVideoEncodeQualityLevelInfoKHR-pVideoProfile-08259\", \"pVideoProfile must be a supported video profile\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "skip |= LogError(\"VUID-VkPhysicalDeviceVideoEncodeQualityLevelInfoKHR-pVideoProfile-08259\", physicalDevice,\n                 quality_level_info_loc.dot(Field::pVideoProfile), \"is not supported.\");\n"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkVideoSessionCreateInfoKHR-flags-08371\", \"If flags includes VK_VIDEO_SESSION_CREATE_INLINE_QUERIES_BIT_KHR, then videoMaintenance1 must be enabled\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (pCreateInfo->flags & VK_VIDEO_SESSION_CREATE_INLINE_QUERIES_BIT_KHR && !enabled_features.videoMaintenance1) {\n    skip |= LogError(\"VUID-VkVideoSessionCreateInfoKHR-flags-08371\", device, create_info_loc.dot(Field::flags),\n                     \"has VK_VIDEO_SESSION_CREATE_INLINE_QUERIES_BIT_KHR set but \"\n                     \"the videoMaintenance1 device feature is not enabled.\");\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkVideoSessionCreateInfoKHR-maxDpbSlots-04847\", \"maxDpbSlots must be less than or equal to VkVideoCapabilitiesKHR::maxDpbSlots, as returned by vkGetPhysicalDeviceVideoCapabilitiesKHR for the video profile specified by pVideoProfile\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (pCreateInfo->maxDpbSlots > profile_caps.base.maxDpbSlots) {\n    skip |= LogError(\"VUID-VkVideoSessionCreateInfoKHR-maxDpbSlots-04847\", device, create_info_loc.dot(Field::maxDpbSlots),\n                     \"(%u) is greater than the \"\n                     \"maxDpbSlots (%u) supported by the video profile.\",\n                     pCreateInfo->maxDpbSlots, profile_caps.base.maxDpbSlots);\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkVideoSessionCreateInfoKHR-maxDpbSlots-04850\", \"If either maxDpbSlots or maxActiveReferencePictures is 0, then both must be 0\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if ((pCreateInfo->maxDpbSlots == 0 && pCreateInfo->maxActiveReferencePictures != 0) ||\n    (pCreateInfo->maxDpbSlots != 0 && pCreateInfo->maxActiveReferencePictures == 0)) {\n    skip |= LogError(\"VUID-VkVideoSessionCreateInfoKHR-maxDpbSlots-04850\", device, error_obj.location,\n                     \"if either pCreateInfo->maxDpbSlots (%u) or \"\n                     \"pCreateInfo->maxActiveReferencePictures (%u) is zero then both must be zero.\",\n                     pCreateInfo->maxDpbSlots, pCreateInfo->maxActiveReferencePictures);\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkVideoSessionCreateInfoKHR-referencePictureFormat-04852\", \"If pVideoProfile->videoCodecOperation specifies a decode operation and maxActiveReferencePictures is greater than 0, then referencePictureFormat must be one of the supported decode DPB formats, as returned by vkGetPhysicalDeviceVideoFormatPropertiesKHR in VkVideoFormatPropertiesKHR::format when called with the imageUsage member of its pVideoFormatInfo parameter containing VK_IMAGE_USAGE_VIDEO_DECODE_DPB_BIT_KHR, and with a VkVideoProfileListInfoKHR structure specified in the pNext chain of its pVideoFormatInfo parameter whose pProfiles member contains an element matching pVideoProfile\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (profile_desc.IsDecode() && pCreateInfo->maxActiveReferencePictures > 0 &&\n    !IsVideoFormatSupported(pCreateInfo->referencePictureFormat, VK_IMAGE_USAGE_VIDEO_DECODE_DPB_BIT_KHR,\n    skip |= LogError(\"VUID-VkVideoSessionCreateInfoKHR-referencePictureFormat-04852\", device,\n                     create_info_loc.dot(Field::referencePictureFormat),\n                     \"(%s) is not a supported \"\n                     \"decode DPB format for the video profile specified in pCreateInfo->pVideoProfile.\",\n                     string_VkFormat(pCreateInfo->referencePictureFormat));\n"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkVideoSessionCreateInfoKHR-referencePictureFormat-06814\", \"If pVideoProfile->videoCodecOperation specifies an encode operation and maxActiveReferencePictures is greater than 0, then referencePictureFormat must be one of the supported decode DPB formats, as returned by then referencePictureFormat must be one of the supported encode DPB formats, as returned by vkGetPhysicalDeviceVideoFormatPropertiesKHR in VkVideoFormatPropertiesKHR::format when called with the imageUsage member of its pVideoFormatInfo parameter containing VK_IMAGE_USAGE_VIDEO_ENCODE_DPB_BIT_KHR, and with a VkVideoProfileListInfoKHR structure specified in the pNext chain of its pVideoFormatInfo parameter whose pProfiles member contains an element matching pVideoProfile\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (profile_desc.IsEncode() && pCreateInfo->maxActiveReferencePictures > 0 &&\n    !IsVideoFormatSupported(pCreateInfo->referencePictureFormat, VK_IMAGE_USAGE_VIDEO_ENCODE_DPB_BIT_KHR,\n    skip |= LogError(\"VUID-VkVideoSessionCreateInfoKHR-referencePictureFormat-06814\", device,\n                     create_info_loc.dot(Field::referencePictureFormat),\n                     \"(%s) is not a supported \"\n                     \"encode DPB format for the video profile specified in pCreateInfo->pVideoProfile.\",\n                     string_VkFormat(pCreateInfo->referencePictureFormat));\n"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkVideoSessionCreateInfoKHR-pStdHeaderVersion-07190\", \"pStdHeaderVersion->extensionName must match VkVideoCapabilitiesKHR::stdHeaderVersion.extensionName, as returned by vkGetPhysicalDeviceVideoCapabilitiesKHR for the video profile specified by pVideoProfile\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (strncmp(pCreateInfo->pStdHeaderVersion->extensionName, profile_caps.base.stdHeaderVersion.extensionName,\n    skip |= LogError(\"VUID-VkVideoSessionCreateInfoKHR-pStdHeaderVersion-07190\", device,\n                     create_info_loc.dot(Field::pStdHeaderVersion).dot(Field::extensionName),\n                     \"'%.*s' is an unsupported Video Std header name, expected '%.*s'.\", VK_MAX_EXTENSION_NAME_SIZE,\n                     pCreateInfo->pStdHeaderVersion->extensionName, VK_MAX_EXTENSION_NAME_SIZE,\n                     profile_caps.base.stdHeaderVersion.extensionName);\n"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkVideoSessionCreateInfoKHR-pVideoProfile-04845\", \"pVideoProfile must be a supported video profile\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "skip |= LogError(\"VUID-VkVideoSessionCreateInfoKHR-pVideoProfile-04845\", device, create_info_loc.dot(Field::pVideoProfile),\n                 \"is not supported.\");\n"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkVideoSessionCreateInfoKHR-pVideoProfile-08251\", \"If pVideoProfile->videoCodecOperation is VK_VIDEO_CODEC_OPERATION_ENCODE_H264_BIT_KHR and the pNext chain of this structure includes a VkVideoEncodeH264SessionCreateInfoKHR structure, then its maxLevelIdc member must be less than or equal to VkVideoEncodeH264CapabilitiesKHR::maxLevelIdc, as returned by vkGetPhysicalDeviceVideoCapabilitiesKHR for the video profile specified in pVideoProfile\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (h264_create_info != nullptr && h264_create_info->maxLevelIdc > profile_caps.encode_h264.maxLevelIdc) {\n    skip |= LogError(\"VUID-VkVideoSessionCreateInfoKHR-pVideoProfile-08251\", device,\n                     create_info_loc.pNext(Struct::VkVideoEncodeH264SessionCreateInfoKHR, Field::maxLevelIdc),\n                     \"(%u) exceeds the maxLevelIdc (%u) supported by the specified H.264 encode profile.\",\n                     h264_create_info->maxLevelIdc, profile_caps.encode_h264.maxLevelIdc);\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkVideoSessionCreateInfoKHR-pVideoProfile-08252\", \"If pVideoProfile->videoCodecOperation is VK_VIDEO_CODEC_OPERATION_ENCODE_H265_BIT_KHR and the pNext chain of this structure includes a VkVideoEncodeH265SessionCreateInfoKHR structure, then its maxLevelIdc member must be less than or equal to VkVideoEncodeH265CapabilitiesKHR::maxLevelIdc, as returned by vkGetPhysicalDeviceVideoCapabilitiesKHR for the video profile specified in pVideoProfile\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (h265_create_info != nullptr && h265_create_info->maxLevelIdc > profile_caps.encode_h265.maxLevelIdc) {\n    skip |= LogError(\"VUID-VkVideoSessionCreateInfoKHR-pVideoProfile-08252\", device,\n                     create_info_loc.pNext(Struct::VkVideoEncodeH265SessionCreateInfoKHR, Field::maxLevelIdc),\n                     \"(%u) exceeds the maxLevelIdc (%u) supported by the specified H.265 encode profile.\",\n                     h265_create_info->maxLevelIdc, profile_caps.encode_h265.maxLevelIdc);\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-vkBindVideoSessionMemoryKHR-memoryBindIndex-07196\", \"The memoryBindIndex member of each element of pBindSessionMemoryInfos must be unique within pBindSessionMemoryInfos\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (memory_bind_indices.find(mem_bind_index) != memory_bind_indices.end()) {\n    skip |= LogError(\"VUID-vkBindVideoSessionMemoryKHR-memoryBindIndex-07196\", videoSession,\n                     error_obj.location.dot(Field::pBindSessionMemoryInfos, i).dot(Field::memoryBindIndex),\n                     \"%u is not unique.\", mem_bind_index);\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkBindVideoSessionMemoryInfoKHR-memorySize-07202\", \"memorySize must be less than or equal to the size of memory minus memoryOffset\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "} else if (bind_info.memoryOffset + bind_info.memorySize > mem_state->allocate_info.allocationSize) {\n    const LogObjectList objlist(videoSession, mem_state->Handle());\n    skip |= LogError(\"VUID-VkBindVideoSessionMemoryInfoKHR-memorySize-07202\", objlist,\n                     error_obj.location.dot(Field::pBindSessionMemoryInfos, i).dot(Field::memoryOffset),\n                     \"(%\" PRIuLEAST64 \") + memory size (%\" PRIuLEAST64\n                     \") must be less than or equal to the size (%\" PRIuLEAST64 \") of %s.\",\n                     bind_info.memoryOffset, bind_info.memorySize, mem_state->allocate_info.allocationSize,\n                     FormatHandle(*mem_state).c_str());\n"
        },
        {
            "role": "user",
            "content": "{\"VUID-vkBindVideoSessionMemoryKHR-pBindSessionMemoryInfos-07199\", \"If an element of pBindSessionMemoryInfos has a corresponding VkMemoryRequirements structure, then the memoryOffset member of that element of pBindSessionMemoryInfos must be an integer multiple of the alignment member of the corresponding VkMemoryRequirements structure\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (SafeModulo(bind_info.memoryOffset, mem_binding_info->requirements.alignment) != 0) {\n    skip |= LogError(\"VUID-vkBindVideoSessionMemoryKHR-pBindSessionMemoryInfos-07199\", videoSession,\n                     error_obj.location.dot(Field::pBindSessionMemoryInfos, i).dot(Field::memoryOffset),\n                     \"(%\" PRIuLEAST64 \") but must be an integer multiple of the alignment value %\" PRIuLEAST64\n                     \" for the memory binding index %u of %s.\",\n                     bind_info.memoryOffset, mem_binding_info->requirements.alignment, bind_info.memoryBindIndex,\n                     FormatHandle(videoSession).c_str());\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-vkBindVideoSessionMemoryKHR-pBindSessionMemoryInfos-07200\", \"If an element of pBindSessionMemoryInfos has a corresponding VkMemoryRequirements structure, then the memorySize member of that element of pBindSessionMemoryInfos must equal the size member of the corresponding VkMemoryRequirements structure\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (bind_info.memorySize != mem_binding_info->requirements.size) {\n    skip |= LogError(\"VUID-vkBindVideoSessionMemoryKHR-pBindSessionMemoryInfos-07200\", videoSession,\n                     error_obj.location.dot(Field::pBindSessionMemoryInfos, i).dot(Field::memorySize),\n                     \"(%\" PRIuLEAST64 \") does not equal the required size (%\" PRIuLEAST64\n                     \") for the memory binding index %u of %s.\",\n                     bind_info.memorySize, mem_binding_info->requirements.size, bind_info.memoryBindIndex,\n                     FormatHandle(videoSession).c_str());\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-vkBindVideoSessionMemoryKHR-videoSession-07195\", \"The memory binding of videoSession identified by the memoryBindIndex member of any element of pBindSessionMemoryInfos must not already be backed by a memory object\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (mem_binding_info->bound) {\n    skip |= LogError(\"VUID-vkBindVideoSessionMemoryKHR-videoSession-07195\", videoSession, error_obj.location,\n                     \"memory binding with index %u of %s is already \"\n                     \"bound but was specified in pBindSessionMemoryInfos[%u].memoryBindIndex.\",\n                     bind_info.memoryBindIndex, FormatHandle(videoSession).c_str(), i);\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkVideoSessionParametersCreateInfoKHR-videoSession-09258\", \"If videoSession was created with the video codec operation VK_VIDEO_CODEC_OPERATION_DECODE_AV1_BIT_KHR, then videoSessionParametersTemplate must be VK_NULL_HANDLE\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (pCreateInfo->videoSessionParametersTemplate != VK_NULL_HANDLE) {\n    skip |= LogError(\"VUID-VkVideoSessionParametersCreateInfoKHR-videoSession-09258\", device,\n                     create_info_loc.dot(Field::videoSessionParametersTemplate),\n                     \"must be VK_NULL_HANDLE when using an AV1 decode profile.\");\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkVideoEncodeQualityLevelInfoKHR-qualityLevel-08311\", \"qualityLevel must be less than VkVideoEncodeCapabilitiesKHR::maxQualityLevels, as returned by vkGetPhysicalDeviceVideoCapabilitiesKHR for the used video profile\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (encode_quality_level >= max_quality_levels) {\n    skip |= LogError(\"VUID-VkVideoEncodeQualityLevelInfoKHR-qualityLevel-08311\", pCreateInfo->videoSession,\n                     create_info_loc.pNext(Struct::VkVideoEncodeQualityLevelInfoKHR, Field::qualityLevel),\n                     \"(%u) must be smaller than the maxQualityLevels (%u) supported by the video \"\n                     \"profile %s was created with.\",\n                     encode_quality_level, max_quality_levels, FormatHandle(pCreateInfo->videoSession).c_str());\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkVideoEncodeQualityLevelInfoKHR-qualityLevel-08311\", \"qualityLevel must be less than VkVideoEncodeCapabilitiesKHR::maxQualityLevels, as returned by vkGetPhysicalDeviceVideoCapabilitiesKHR for the used video profile\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (quality_level_info->qualityLevel >= profile_caps.encode.maxQualityLevels) {\n    const LogObjectList objlist(commandBuffer, vs_state->Handle());\n    skip |= LogError(\"VUID-VkVideoEncodeQualityLevelInfoKHR-qualityLevel-08311\", objlist,\n                     control_info_loc.pNext(Struct::VkVideoEncodeQualityLevelInfoKHR, Field::qualityLevel),\n                     \"(%u) must be smaller than the maxQualityLevels (%u) supported by the video \"\n                     \"profile %s was created with.\",\n                     quality_level_info->qualityLevel, profile_caps.encode.maxQualityLevels,\n                     FormatHandle(*vs_state).c_str());\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkVideoSessionParametersCreateInfoKHR-videoSessionParametersTemplate-08310\", \"If videoSessionParametersTemplate is not VK_NULL_HANDLE and videoSession was created with an encode operation, then qualityLevel must equal the video encode quality level videoSessionParametersTemplate was created with\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (template_state != nullptr && encode_quality_level != template_state->GetEncodeQualityLevel()) {\n    const LogObjectList objlist(device, pCreateInfo->videoSessionParametersTemplate, pCreateInfo->videoSession);\n    skip |= LogError(\"VUID-VkVideoSessionParametersCreateInfoKHR-videoSessionParametersTemplate-08310)\", objlist,\n                     create_info_loc.pNext(Struct::VkVideoEncodeQualityLevelInfoKHR, Field::qualityLevel),\n                     \"(%u) does not match the video encode quality level (%u) template %s was created with.\",\n                     encode_quality_level, template_state->GetEncodeQualityLevel(),\n                     FormatHandle(pCreateInfo->videoSessionParametersTemplate).c_str());\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-vkUpdateVideoSessionParametersKHR-videoSessionParameters-07216\", \"If videoSessionParameters was created with the video codec operation VK_VIDEO_CODEC_OPERATION_DECODE_H264_BIT_KHR and the pNext chain of pUpdateInfo includes a VkVideoDecodeH264SessionParametersAddInfoKHR structure, then videoSessionParameters must not already contain a StdVideoH264SequenceParameterSet entry with seq_parameter_set_id matching any of the elements of VkVideoDecodeH264SessionParametersAddInfoKHR::pStdSPSs\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (vsp_data.GetH264SPS(add_info->pStdSPSs[i].seq_parameter_set_id)) {\n    skip |= LogError(\"VUID-vkUpdateVideoSessionParametersKHR-videoSessionParameters-07216\",\n                     videoSessionParameters, error_obj.location,\n                     \"H.264 SPS with key \"\n                     \"(SPS ID = %u) already exists in %s.\",\n                     add_info->pStdSPSs[i].seq_parameter_set_id, FormatHandle(videoSessionParameters).c_str());\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-vkUpdateVideoSessionParametersKHR-videoSessionParameters-07217\", \"If videoSessionParameters was created with the video codec operation VK_VIDEO_CODEC_OPERATION_DECODE_H264_BIT_KHR, then the number of StdVideoH264SequenceParameterSet entries already stored in it plus the value of the stdSPSCount member of the VkVideoDecodeH264SessionParametersAddInfoKHR structure included in the pUpdateInfo->pNext chain must be less than or equal to the VkVideoDecodeH264SessionParametersCreateInfoKHR::maxStdSPSCount videoSessionParameters was created with\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (add_info->stdSPSCount + vsp_data->h264.sps.size() > vsp_data->h264.sps_capacity) {\n    skip |= LogError(\"VUID-vkUpdateVideoSessionParametersKHR-videoSessionParameters-07217\", videoSessionParameters,\n                     error_obj.location,\n                     \"number of H.264 SPS entries to add \"\n                     \"(%u) plus the already used capacity (%zu) is greater than the maximum H.264 \"\n                     \"SPS capacity (%u) the %s was created with.\",\n                     add_info->stdSPSCount, vsp_data->h264.sps.size(), vsp_data->h264.sps_capacity,\n                     FormatHandle(videoSessionParameters).c_str());\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-vkUpdateVideoSessionParametersKHR-videoSessionParameters-07218\", \"If videoSessionParameters was created with the video codec operation VK_VIDEO_CODEC_OPERATION_DECODE_H264_BIT_KHR and the pNext chain of pUpdateInfo includes a VkVideoDecodeH264SessionParametersAddInfoKHR structure, then videoSessionParameters must not already contain a StdVideoH264PictureParameterSet entry with both seq_parameter_set_id and pic_parameter_set_id matching any of the elements of VkVideoDecodeH264SessionParametersAddInfoKHR::pStdPPSs\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (vsp_data.GetH264PPS(add_info->pStdPPSs[i].seq_parameter_set_id,\n    skip |= LogError(\"VUID-vkUpdateVideoSessionParametersKHR-videoSessionParameters-07218\",\n                     videoSessionParameters, error_obj.location,\n                     \"H.264 PPS with key \"\n                     \"(SPS ID = %u, PPS ID = %u) already exists in %s.\",\n                     add_info->pStdPPSs[i].seq_parameter_set_id, add_info->pStdPPSs[i].pic_parameter_set_id,\n                     FormatHandle(videoSessionParameters).c_str());\n"
        },
        {
            "role": "user",
            "content": "{\"VUID-vkUpdateVideoSessionParametersKHR-videoSessionParameters-07219\", \"If videoSessionParameters was created with the video codec operation VK_VIDEO_CODEC_OPERATION_DECODE_H264_BIT_KHR, then the number of StdVideoH264PictureParameterSet entries already stored in it plus the value of the stdPPSCount member of the VkVideoDecodeH264SessionParametersAddInfoKHR structure included in the pUpdateInfo->pNext chain must be less than or equal to the VkVideoDecodeH264SessionParametersCreateInfoKHR::maxStdPPSCount videoSessionParameters was created with\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (add_info->stdPPSCount + vsp_data->h264.pps.size() > vsp_data->h264.pps_capacity) {\n    skip |= LogError(\"VUID-vkUpdateVideoSessionParametersKHR-videoSessionParameters-07219\", videoSessionParameters,\n                     error_obj.location,\n                     \"number of H.264 PPS entries to add \"\n                     \"(%u) plus the already used capacity (%zu) is greater than the maximum H.264 \"\n                     \"PPS capacity (%u) the %s was created with.\",\n                     add_info->stdPPSCount, vsp_data->h264.pps.size(), vsp_data->h264.pps_capacity,\n                     FormatHandle(videoSessionParameters).c_str());\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-vkUpdateVideoSessionParametersKHR-videoSessionParameters-07221\", \"If videoSessionParameters was created with the video codec operation VK_VIDEO_CODEC_OPERATION_DECODE_H265_BIT_KHR, then the number of StdVideoH265VideoParameterSet entries already stored in it plus the value of the stdVPSCount member of the VkVideoDecodeH265SessionParametersAddInfoKHR structure included in the pUpdateInfo->pNext chain must be less than or equal to the VkVideoDecodeH265SessionParametersCreateInfoKHR::maxStdVPSCount videoSessionParameters was created with\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (add_info->stdVPSCount + vsp_data->h265.vps.size() > vsp_data->h265.vps_capacity) {\n    skip |= LogError(\"VUID-vkUpdateVideoSessionParametersKHR-videoSessionParameters-07221\", videoSessionParameters,\n                     error_obj.location,\n                     \"number of H.265 VPS entries to add \"\n                     \"(%u) plus the already used capacity (%zu) is greater than the maximum H.265 \"\n                     \"VPS capacity (%u) the %s was created with.\",\n                     add_info->stdVPSCount, vsp_data->h265.vps.size(), vsp_data->h265.vps_capacity,\n                     FormatHandle(videoSessionParameters).c_str());\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-vkUpdateVideoSessionParametersKHR-videoSessionParameters-07223\", \"If videoSessionParameters was created with the video codec operation VK_VIDEO_CODEC_OPERATION_DECODE_H265_BIT_KHR, then the number of StdVideoH265SequenceParameterSet entries already stored in it plus the value of the stdSPSCount member of the VkVideoDecodeH265SessionParametersAddInfoKHR structure included in the pUpdateInfo->pNext chain must be less than or equal to the VkVideoDecodeH265SessionParametersCreateInfoKHR::maxStdSPSCount videoSessionParameters was created with\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (add_info->stdSPSCount + vsp_data->h265.sps.size() > vsp_data->h265.sps_capacity) {\n    skip |= LogError(\"VUID-vkUpdateVideoSessionParametersKHR-videoSessionParameters-07223\", videoSessionParameters,\n                     error_obj.location,\n                     \"number of H.265 SPS entries to add \"\n                     \"(%u) plus the already used capacity (%zu) is greater than the maximum H.265 \"\n                     \"SPS capacity (%u) the %s was created with.\",\n                     add_info->stdSPSCount, vsp_data->h265.sps.size(), vsp_data->h265.sps_capacity,\n                     FormatHandle(videoSessionParameters).c_str());\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-vkUpdateVideoSessionParametersKHR-videoSessionParameters-07225\", \"If videoSessionParameters was created with the video codec operation VK_VIDEO_CODEC_OPERATION_DECODE_H265_BIT_KHR, then the number of StdVideoH265PictureParameterSet entries already stored in it plus the value of the stdPPSCount member of the VkVideoDecodeH265SessionParametersAddInfoKHR structure included in the pUpdateInfo->pNext chain must be less than or equal to the VkVideoDecodeH265SessionParametersCreateInfoKHR::maxStdPPSCount videoSessionParameters was created with\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (add_info->stdPPSCount + vsp_data->h265.pps.size() > vsp_data->h265.pps_capacity) {\n    skip |= LogError(\"VUID-vkUpdateVideoSessionParametersKHR-videoSessionParameters-07225\", videoSessionParameters,\n                     error_obj.location,\n                     \"number of H.265 PPS entries to add \"\n                     \"(%u) plus the already used capacity (%zu) is greater than the maximum H.265 \"\n                     \"PPS capacity (%u) the %s was created with.\",\n                     add_info->stdPPSCount, vsp_data->h265.pps.size(), vsp_data->h265.pps_capacity,\n                     FormatHandle(videoSessionParameters).c_str());\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-vkUpdateVideoSessionParametersKHR-videoSessionParameters-09260\", \"videoSessionParameters must not have been created with the video codec operation VK_VIDEO_CODEC_OPERATION_DECODE_AV1_BIT_KHR\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "skip |= LogError(\"VUID-vkUpdateVideoSessionParametersKHR-videoSessionParameters-09260\", videoSessionParameters,\n                 error_obj.location, \"AV1 decode session parameters cannot be updated.\");\n"
        },
        {
            "role": "user",
            "content": "{\"VUID-vkUpdateVideoSessionParametersKHR-videoSessionParameters-06441\", \"If videoSessionParameters was created with the video codec operation VK_VIDEO_CODEC_OPERATION_ENCODE_H264_BIT_KHR, then the number of StdVideoH264SequenceParameterSet entries already stored in it plus the value of the stdSPSCount member of the VkVideoEncodeH264SessionParametersAddInfoKHR structure included in the pUpdateInfo->pNext chain must be less than or equal to the VkVideoEncodeH264SessionParametersCreateInfoKHR::maxStdSPSCount videoSessionParameters was created with\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (add_info->stdSPSCount + vsp_data->h264.sps.size() > vsp_data->h264.sps_capacity) {\n    skip |= LogError(\"VUID-vkUpdateVideoSessionParametersKHR-videoSessionParameters-06441\", videoSessionParameters,\n                     error_obj.location,\n                     \"number of H.264 SPS entries to add \"\n                     \"(%u) plus the already used capacity (%zu) is greater than the maximum H.264 \"\n                     \"SPS capacity (%u) the %s was created with.\",\n                     add_info->stdSPSCount, vsp_data->h264.sps.size(), vsp_data->h264.sps_capacity,\n                     FormatHandle(videoSessionParameters).c_str());\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-vkUpdateVideoSessionParametersKHR-videoSessionParameters-07227\", \"If videoSessionParameters was created with the video codec operation VK_VIDEO_CODEC_OPERATION_ENCODE_H264_BIT_KHR and the pNext chain of pUpdateInfo includes a VkVideoEncodeH264SessionParametersAddInfoKHR structure, then videoSessionParameters must not already contain a StdVideoH264PictureParameterSet entry with both seq_parameter_set_id and pic_parameter_set_id matching any of the elements of VkVideoEncodeH264SessionParametersAddInfoKHR::pStdPPSs\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (vsp_data.GetH264PPS(add_info->pStdPPSs[i].seq_parameter_set_id,\n    skip |= LogError(\"VUID-vkUpdateVideoSessionParametersKHR-videoSessionParameters-07227\",\n                     videoSessionParameters, error_obj.location,\n                     \"H.264 PPS with key \"\n                     \"(SPS ID = %u, PPS ID = %u) already exists in %s.\",\n                     add_info->pStdPPSs[i].seq_parameter_set_id, add_info->pStdPPSs[i].pic_parameter_set_id,\n                     FormatHandle(videoSessionParameters).c_str());\n"
        },
        {
            "role": "user",
            "content": "{\"VUID-vkUpdateVideoSessionParametersKHR-videoSessionParameters-06442\", \"If videoSessionParameters was created with the video codec operation VK_VIDEO_CODEC_OPERATION_ENCODE_H264_BIT_KHR, then the number of StdVideoH264PictureParameterSet entries already stored in it plus the value of the stdPPSCount member of the VkVideoEncodeH264SessionParametersAddInfoKHR structure included in the pUpdateInfo->pNext chain must be less than or equal to the VkVideoEncodeH264SessionParametersCreateInfoKHR::maxStdPPSCount videoSessionParameters was created with\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (add_info->stdPPSCount + vsp_data->h264.pps.size() > vsp_data->h264.pps_capacity) {\n    skip |= LogError(\"VUID-vkUpdateVideoSessionParametersKHR-videoSessionParameters-06442\", videoSessionParameters,\n                     error_obj.location,\n                     \"number of H.264 PPS entries to add \"\n                     \"(%u) plus the already used capacity (%zu) is greater than the maximum H.264 \"\n                     \"PPS capacity (%u) the %s was created with.\",\n                     add_info->stdPPSCount, vsp_data->h264.pps.size(), vsp_data->h264.pps_capacity,\n                     FormatHandle(videoSessionParameters).c_str());\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-vkUpdateVideoSessionParametersKHR-videoSessionParameters-07228\", \"If videoSessionParameters was created with the video codec operation VK_VIDEO_CODEC_OPERATION_ENCODE_H265_BIT_KHR and the pNext chain of pUpdateInfo includes a VkVideoEncodeH265SessionParametersAddInfoKHR structure, then videoSessionParameters must not already contain a StdVideoH265VideoParameterSet entry with vps_video_parameter_set_id matching any of the elements of VkVideoEncodeH265SessionParametersAddInfoKHR::pStdVPSs\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (vsp_data.GetH265VPS(add_info->pStdVPSs[i].vps_video_parameter_set_id)) {\n    skip |= LogError(\"VUID-vkUpdateVideoSessionParametersKHR-videoSessionParameters-07228\",\n                     videoSessionParameters, error_obj.location,\n                     \"H.265 VPS with key \"\n                     \"(VPS ID = %u) already exists in %s.\",\n                     add_info->pStdVPSs[i].vps_video_parameter_set_id,\n                     FormatHandle(videoSessionParameters).c_str());\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-vkUpdateVideoSessionParametersKHR-videoSessionParameters-06444\", \"If videoSessionParameters was created with the video codec operation VK_VIDEO_CODEC_OPERATION_ENCODE_H265_BIT_KHR, then the number of StdVideoH265SequenceParameterSet entries already stored in it plus the value of the stdSPSCount member of the VkVideoEncodeH265SessionParametersAddInfoKHR structure included in the pUpdateInfo->pNext chain must be less than or equal to the VkVideoEncodeH265SessionParametersCreateInfoKHR::maxStdSPSCount videoSessionParameters was created with\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (add_info->stdSPSCount + vsp_data->h265.sps.size() > vsp_data->h265.sps_capacity) {\n    skip |= LogError(\"VUID-vkUpdateVideoSessionParametersKHR-videoSessionParameters-06444\", videoSessionParameters,\n                     error_obj.location,\n                     \"number of H.265 SPS entries to add \"\n                     \"(%u) plus the already used capacity (%zu) is greater than the maximum H.265 \"\n                     \"SPS capacity (%u) the %s was created with.\",\n                     add_info->stdSPSCount, vsp_data->h265.sps.size(), vsp_data->h265.sps_capacity,\n                     FormatHandle(videoSessionParameters).c_str());\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-vkUpdateVideoSessionParametersKHR-videoSessionParameters-06445\", \"If videoSessionParameters was created with the video codec operation VK_VIDEO_CODEC_OPERATION_ENCODE_H265_BIT_KHR, then the number of StdVideoH265PictureParameterSet entries already stored in it plus the value of the stdPPSCount member of the VkVideoEncodeH265SessionParametersAddInfoKHR structure included in the pUpdateInfo->pNext chain must be less than or equal to the VkVideoEncodeH265SessionParametersCreateInfoKHR::maxStdPPSCount videoSessionParameters was created with\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (add_info->stdPPSCount + vsp_data->h265.pps.size() > vsp_data->h265.pps_capacity) {\n    skip |= LogError(\"VUID-vkUpdateVideoSessionParametersKHR-videoSessionParameters-06445\", videoSessionParameters,\n                     error_obj.location,\n                     \"number of H.265 PPS entries to add \"\n                     \"(%u) plus the already used capacity (%zu) is greater than the maximum H.265 \"\n                     \"PPS capacity (%u) the %s was created with.\",\n                     add_info->stdPPSCount, vsp_data->h265.pps.size(), vsp_data->h265.pps_capacity,\n                     FormatHandle(videoSessionParameters).c_str());\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkVideoEncodeH264SessionParametersGetInfoKHR-writeStdSPS-08279\", \"At least one of writeStdSPS and writeStdPPS must be VK_TRUE\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (!h264_info->writeStdSPS && !h264_info->writeStdPPS) {\n    skip |= LogError(\"VUID-VkVideoEncodeH264SessionParametersGetInfoKHR-writeStdSPS-08279\",\n                     pVideoSessionParametersInfo->videoSessionParameters, h264_info_loc,\n                     \"must have at least one of writeStdSPS and writeStdPPS set to VK_TRUE.\");\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-vkGetEncodedVideoSessionParametersKHR-pVideoSessionParametersInfo-08263\", \"If pVideoSessionParametersInfo->videoSessionParameters was created with the video codec operation VK_VIDEO_CODEC_OPERATION_ENCODE_H264_BIT_KHR, then for the VkVideoEncodeH264SessionParametersGetInfoKHR structure included in the pNext chain of pVideoSessionParametersInfo, if its writeStdSPS member is VK_TRUE, then pVideoSessionParametersInfo->videoSessionParameters must contain a StdVideoH264SequenceParameterSet entry with seq_parameter_set_id matching VkVideoEncodeH264SessionParametersGetInfoKHR::stdSPSId\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (h264_info->writeStdSPS && vsp_data.GetH264SPS(h264_info->stdSPSId) == nullptr) {\n    skip |= LogError(\"VUID-vkGetEncodedVideoSessionParametersKHR-pVideoSessionParametersInfo-08263\",\n                     pVideoSessionParametersInfo->videoSessionParameters, error_obj.location,\n                     \"%s does not contain an H.264 SPS \"\n                     \"matching the stdSPSId (%u) specified in %s.\",\n                     FormatHandle(*vsp_state).c_str(), h264_info->stdSPSId, h264_info_loc.Fields().c_str());\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-vkGetEncodedVideoSessionParametersKHR-pVideoSessionParametersInfo-08262\", \"If pVideoSessionParametersInfo->videoSessionParameters was created with the video codec operation VK_VIDEO_CODEC_OPERATION_ENCODE_H264_BIT_KHR, then the pNext chain of pVideoSessionParametersInfo must include a VkVideoEncodeH264SessionParametersGetInfoKHR structure\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "skip |= LogError(\"VUID-vkGetEncodedVideoSessionParametersKHR-pVideoSessionParametersInfo-08262\",\n                 pVideoSessionParametersInfo->videoSessionParameters, params_info_loc.dot(Field::pNext),\n                 pnext_msg, \"VkVideoEncodeH264SessionParametersGetInfoKHR\");\n"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkVideoEncodeH265SessionParametersGetInfoKHR-writeStdVPS-08290\", \"At least one of writeStdVPS, writeStdSPS, and writeStdPPS must be VK_TRUE\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (!h265_info->writeStdVPS && !h265_info->writeStdSPS && !h265_info->writeStdPPS) {\n    skip |= LogError(\"VUID-VkVideoEncodeH265SessionParametersGetInfoKHR-writeStdVPS-08290\",\n                     pVideoSessionParametersInfo->videoSessionParameters, h265_info_loc,\n                     \"must have at least one of writeStdVPS, writeStdSPS, and writeStdPPS set to VK_TRUE.\");\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-vkGetEncodedVideoSessionParametersKHR-pVideoSessionParametersInfo-08266\", \"If pVideoSessionParametersInfo->videoSessionParameters was created with the video codec operation VK_VIDEO_CODEC_OPERATION_ENCODE_H265_BIT_KHR, then for the VkVideoEncodeH265SessionParametersGetInfoKHR structure included in the pNext chain of pVideoSessionParametersInfo, if its writeStdVPS member is VK_TRUE, then pVideoSessionParametersInfo->videoSessionParameters must contain a StdVideoH265VideoParameterSet entry with vps_video_parameter_set_id matching VkVideoEncodeH265SessionParametersGetInfoKHR::stdVPSId\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (h265_info->writeStdVPS && vsp_data.GetH265VPS(h265_info->stdVPSId) == nullptr) {\n    skip |= LogError(\"VUID-vkGetEncodedVideoSessionParametersKHR-pVideoSessionParametersInfo-08266\",\n                     pVideoSessionParametersInfo->videoSessionParameters, error_obj.location,\n                     \"%s does not contain an H.265 VPS \"\n                     \"matching the stdVPSId (%u) specified in %s.\",\n                     FormatHandle(*vsp_state).c_str(), h265_info->stdVPSId, h265_info_loc.Fields().c_str());\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-vkGetEncodedVideoSessionParametersKHR-pVideoSessionParametersInfo-08267\", \"If pVideoSessionParametersInfo->videoSessionParameters was created with the video codec operation VK_VIDEO_CODEC_OPERATION_ENCODE_H265_BIT_KHR, then for the VkVideoEncodeH265SessionParametersGetInfoKHR structure included in the pNext chain of pVideoSessionParametersInfo, if its writeStdSPS member is VK_TRUE, then pVideoSessionParametersInfo->videoSessionParameters must contain a StdVideoH265SequenceParameterSet entry with sps_video_parameter_set_id and sps_seq_parameter_set_id matching VkVideoEncodeH265SessionParametersGetInfoKHR::stdVPSId and VkVideoEncodeH265SessionParametersGetInfoKHR::stdSPSId, respectively\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (h265_info->writeStdSPS && vsp_data.GetH265SPS(h265_info->stdVPSId, h265_info->stdSPSId) == nullptr) {\n    skip |= LogError(\"VUID-vkGetEncodedVideoSessionParametersKHR-pVideoSessionParametersInfo-08267\",\n                     pVideoSessionParametersInfo->videoSessionParameters, error_obj.location,\n                     \"%s does not contain an H.265 SPS \"\n                     \"matching the stdVPSId (%u) and stdSPSId (%u) specified in %s.\",\n                     FormatHandle(*vsp_state).c_str(), h265_info->stdVPSId, h265_info->stdSPSId,\n                     h265_info_loc.Fields().c_str());\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-vkGetEncodedVideoSessionParametersKHR-pVideoSessionParametersInfo-08265\", \"If pVideoSessionParametersInfo->videoSessionParameters was created with the video codec operation VK_VIDEO_CODEC_OPERATION_ENCODE_H265_BIT_KHR, then the pNext chain of pVideoSessionParametersInfo must include a VkVideoEncodeH265SessionParametersGetInfoKHR structure\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "skip |= LogError(\"VUID-vkGetEncodedVideoSessionParametersKHR-pVideoSessionParametersInfo-08265\",\n                 pVideoSessionParametersInfo->videoSessionParameters, params_info_loc.dot(Field::pNext),\n                 pnext_msg, \"VkVideoEncodeH265SessionParametersGetInfoKHR\");\n"
        },
        {
            "role": "user",
            "content": "{\"VUID-vkGetEncodedVideoSessionParametersKHR-pVideoSessionParametersInfo-08359\", \"pVideoSessionParametersInfo->videoSessionParameters must have been created with an encode operation\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "skip |= LogError(\"VUID-vkGetEncodedVideoSessionParametersKHR-pVideoSessionParametersInfo-08359\",\n                 pVideoSessionParametersInfo->videoSessionParameters, params_info_loc.dot(Field::videoSessionParameters),\n                 \"(%s) was not created with an encode operation.\",\n                 FormatHandle(pVideoSessionParametersInfo->videoSessionParameters).c_str());\n"
        },
        {
            "role": "user",
            "content": "{\"VUID-vkCmdBeginVideoCodingKHR-None-07232\", \"There must be no active queries\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (cb_state->activeQueries.size() > 0) {\n    skip |= LogError(\"VUID-vkCmdBeginVideoCodingKHR-None-07232\", commandBuffer, error_obj.location.dot(Field::commandBuffer),\n                     \"%s has active queries.\", FormatHandle(commandBuffer).c_str());\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-vkCmdBeginVideoCodingKHR-commandBuffer-07231\", \"The VkCommandPool that commandBuffer was allocated from must support the video codec operation pBeginInfo->videoSession was created with, as returned by vkGetPhysicalDeviceQueueFamilyProperties2 in VkQueueFamilyVideoPropertiesKHR::videoCodecOperations\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if ((qf_ext_props.video_props.videoCodecOperations & vs_state->GetCodecOp()) == 0) {\n    const LogObjectList objlist(commandBuffer, pBeginInfo->videoSession, cb_state->command_pool->Handle());\n    skip |= LogError(\"VUID-vkCmdBeginVideoCodingKHR-commandBuffer-07231\", objlist, begin_info_loc.dot(Field::videoSession),\n                     \"%s does not support video codec operation %s \"\n                     \"that %s specified in pBeginInfo->videoSession was created with.\",\n                     FormatHandle(cb_state->command_pool->Handle()).c_str(),\n                     string_VkVideoCodecOperationFlagBitsKHR(vs_state->GetCodecOp()),\n                     FormatHandle(pBeginInfo->videoSession).c_str());\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-vkCmdBeginVideoCodingKHR-commandBuffer-07233\", \"If commandBuffer is an unprotected command buffer and protectedNoFault is not supported, then pBeginInfo->videoSession must not have been created with VK_VIDEO_SESSION_CREATE_PROTECTED_CONTENT_BIT_KHR\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if ((!phys_dev_props_core11.protectedNoFault) && (cb_state->unprotected == true) &&\n    const LogObjectList objlist(commandBuffer, pBeginInfo->videoSession);\n    skip |= LogError(\"VUID-vkCmdBeginVideoCodingKHR-commandBuffer-07233\", objlist, error_obj.location.dot(Field::commandBuffer),\n                     \"%s is unprotected while %s was created with \"\n                     \"VK_VIDEO_SESSION_CREATE_PROTECTED_CONTENT_BIT_KHR.\",\n                     FormatHandle(commandBuffer).c_str(), FormatHandle(pBeginInfo->videoSession).c_str());\n"
        },
        {
            "role": "user",
            "content": "{\"VUID-vkCmdBeginVideoCodingKHR-commandBuffer-07234\", \"If commandBuffer is a protected command buffer and protectedNoFault is not supported, then pBeginInfo->videoSession must have been created with VK_VIDEO_SESSION_CREATE_PROTECTED_CONTENT_BIT_KHR\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if ((!phys_dev_props_core11.protectedNoFault) && (cb_state->unprotected == false) &&\n    const LogObjectList objlist(commandBuffer, pBeginInfo->videoSession);\n    skip |= LogError(\"VUID-vkCmdBeginVideoCodingKHR-commandBuffer-07234\", objlist, error_obj.location.dot(Field::commandBuffer),\n                     \"%s is protected while %s was created without \"\n                     \"VK_VIDEO_SESSION_CREATE_PROTECTED_CONTENT_BIT_KHR.\",\n                     FormatHandle(commandBuffer).c_str(), FormatHandle(pBeginInfo->videoSession).c_str());\n"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkVideoBeginCodingInfoKHR-slotIndex-04856\", \"Each non-negative VkVideoReferenceSlotInfoKHR::slotIndex specified in the elements of pReferenceSlots must be less than the VkVideoSessionCreateInfoKHR::maxDpbSlots specified when videoSession was created\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (slot.slotIndex >= 0 && (uint32_t)slot.slotIndex >= vs_state->create_info.maxDpbSlots) {\n    const LogObjectList objlist(commandBuffer, pBeginInfo->videoSession);\n    skip |= LogError(\"VUID-VkVideoBeginCodingInfoKHR-slotIndex-04856\", objlist,\n                     begin_info_loc.dot(Field::pReferenceSlots, i).dot(Field::slotIndex),\n                     \"(%d) \"\n                     \"is greater than the maxDpbSlots %s was created with.\",\n                     slot.slotIndex, FormatHandle(pBeginInfo->videoSession).c_str());\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkVideoBeginCodingInfoKHR-pPictureResource-07238\", \"Each video picture resource corresponding to any non-NULL pPictureResource member specified in the elements of pReferenceSlots must be unique within pReferenceSlots\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (!resources_unique) {\n    const LogObjectList objlist(commandBuffer, pBeginInfo->videoSession);\n    skip |= LogError(\"VUID-VkVideoBeginCodingInfoKHR-pPictureResource-07238\", objlist, error_obj.location,\n                     \"more than one element of pBeginInfo->pReferenceSlots \"\n                     \"refers to the same video picture resource.\");\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkVideoBeginCodingInfoKHR-videoSessionParameters-04857\", \"If videoSessionParameters is not VK_NULL_HANDLE, it must have been created with videoSession specified in VkVideoSessionParametersCreateInfoKHR::videoSession\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (vsp_state && vsp_state->vs_state->VkHandle() != vs_state->VkHandle()) {\n    const LogObjectList objlist(commandBuffer, pBeginInfo->videoSessionParameters, pBeginInfo->videoSession);\n    skip |= LogError(\"VUID-VkVideoBeginCodingInfoKHR-videoSessionParameters-04857\", objlist,\n                     begin_info_loc.dot(Field::videoSessionParameters), \"%s was not created for %s.\",\n                     FormatHandle(pBeginInfo->videoSessionParameters).c_str(), FormatHandle(pBeginInfo->videoSession).c_str());\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-vkCmdBeginVideoCodingKHR-pBeginInfo-08255\", \"If pBeginInfo->videoSession was created with the video codec operation VK_VIDEO_CODEC_OPERATION_ENCODE_H264_BIT_KHR, the current rate control mode is not VK_VIDEO_ENCODE_RATE_CONTROL_MODE_DEFAULT_KHR or VK_VIDEO_ENCODE_RATE_CONTROL_MODE_DISABLED_BIT_KHR, and VkVideoEncodeH264CapabilitiesKHR::requiresGopRemainingFrames is VK_TRUE, as returned by vkGetPhysicalDeviceVideoCapabilitiesKHR for the video profile the pBeginInfo->videoSession was created with, then the pNext chain of pBeginInfo must include an instance of the VkVideoEncodeH264GopRemainingFrameInfoKHR with its useGopRemainingFrames member set to VK_TRUE\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "const LogObjectList objlist(commandBuffer, pBeginInfo->videoSession);\nskip |= LogError(\"VUID-vkCmdBeginVideoCodingKHR-pBeginInfo-08255\", objlist, error_obj.location,\n                 \"requiresGopRemainingFrames is VK_TRUE for \"\n                 \"the H.264 encode profile %s was created with, but %s in the pNext \"\n                 \"chain of pBeginInfo.\",\n                 FormatHandle(pBeginInfo->videoSession).c_str(), why);\n"
        },
        {
            "role": "user",
            "content": "{\"VUID-vkCmdBeginVideoCodingKHR-pBeginInfo-08256\", \"If pBeginInfo->videoSession was created with the video codec operation VK_VIDEO_CODEC_OPERATION_ENCODE_H265_BIT_KHR, the current rate control mode is not VK_VIDEO_ENCODE_RATE_CONTROL_MODE_DEFAULT_KHR or VK_VIDEO_ENCODE_RATE_CONTROL_MODE_DISABLED_BIT_KHR, and VkVideoEncodeH265CapabilitiesKHR::requiresGopRemainingFrames is VK_TRUE, as returned by vkGetPhysicalDeviceVideoCapabilitiesKHR for the video profile the pBeginInfo->videoSession was created with, then the pNext chain of pBeginInfo must include an instance of the VkVideoEncodeH265GopRemainingFrameInfoKHR with its useGopRemainingFrames member set to VK_TRUE\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "const LogObjectList objlist(commandBuffer, pBeginInfo->videoSession);\nskip |= LogError(\"VUID-vkCmdBeginVideoCodingKHR-pBeginInfo-08256\", objlist, error_obj.location,\n                 \"requiresGopRemainingFrames is VK_TRUE for \"\n                 \"the H.265 encode profile %s was created with, but %s in the pNext \"\n                 \"chain of pBeginInfo.\",\n                 FormatHandle(pBeginInfo->videoSession).c_str(), why);\n"
        },
        {
            "role": "user",
            "content": "{\"VUID-vkCmdBeginVideoCodingKHR-slotIndex-07239\", \"If the slotIndex member of any element of pBeginInfo->pReferenceSlots is not negative, then it must specify the index of a DPB slot that is in the active state in pBeginInfo->videoSession at the time the command is executed on the device\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (!dev_state.IsSlotActive(slot.index)) {\n    skip |= dev_data.LogError(\"VUID-vkCmdBeginVideoCodingKHR-slotIndex-07239\", vs_state->Handle(), loc,\n                              \"DPB slot index %d is not active in %s.\", slot.index,\n                              dev_data.FormatHandle(*vs_state).c_str());\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-vkCmdEndVideoCodingKHR-None-07251\", \"There must be no active queries\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (cb_state->activeQueries.size() > 0) {\n    skip |= LogError(\"VUID-vkCmdEndVideoCodingKHR-None-07251\", commandBuffer, error_obj.location.dot(Field::commandBuffer),\n                     \"%s has active queries.\", FormatHandle(commandBuffer).c_str());\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkVideoCodingControlInfoKHR-flags-07018\", \"If flags includes VK_VIDEO_CODING_CONTROL_ENCODE_RATE_CONTROL_BIT_KHR, then the pNext chain must include a VkVideoEncodeRateControlInfoKHR structure\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "skip |= ValidateVideoEncodeRateControlInfo(*rc_info, pCodingControlInfo->pNext, commandBuffer, *vs_state,\n                                           control_info_loc);\nskip |= LogError(\"VUID-VkVideoCodingControlInfoKHR-flags-07018\", commandBuffer, control_info_loc.dot(Field::flags),\n                 flags_pnext_msg, \"VK_VIDEO_CODING_CONTROL_ENCODE_RATE_CONTROL_BIT_KHR\",\n                 \"VkVideoEncodeRateControlInfoKHR\");\n"
        },
        {
            "role": "user",
            "content": "{\"VUID-vkCmdControlVideoCodingKHR-pCodingControlInfo-08243\", \"If the bound video session was not created with an encode operation, then pCodingControlInfo->flags must not include VK_VIDEO_CODING_CONTROL_ENCODE_RATE_CONTROL_BIT_KHR or VK_VIDEO_CODING_CONTROL_ENCODE_QUALITY_LEVEL_BIT_KHR\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "const LogObjectList objlist(commandBuffer, vs_state->Handle());\nskip |= LogError(\"VUID-vkCmdControlVideoCodingKHR-pCodingControlInfo-08243\", objlist,\n                 control_info_loc.dot(Field::flags), flags_require_encode_msg,\n                 \"VK_VIDEO_CODING_CONTROL_ENCODE_RATE_CONTROL_BIT_KHR\", FormatHandle(*vs_state).c_str());\n"
        },
        {
            "role": "user",
            "content": "{\"VUID-vkCmdControlVideoCodingKHR-pCodingControlInfo-08243\", \"If the bound video session was not created with an encode operation, then pCodingControlInfo->flags must not include VK_VIDEO_CODING_CONTROL_ENCODE_RATE_CONTROL_BIT_KHR or VK_VIDEO_CODING_CONTROL_ENCODE_QUALITY_LEVEL_BIT_KHR\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "const LogObjectList objlist(commandBuffer, vs_state->Handle());\nskip |= LogError(\"VUID-vkCmdControlVideoCodingKHR-pCodingControlInfo-08243\", objlist,\n                 control_info_loc.dot(Field::flags), flags_require_encode_msg,\n                 \"VK_VIDEO_CODING_CONTROL_ENCODE_QUALITY_LEVEL_BIT_KHR\", FormatHandle(*vs_state).c_str());\n"
        },
        {
            "role": "user",
            "content": "{\"VUID-vkCmdDecodeVideoKHR-None-08249\", \"The bound video session must have been created with a decode operation\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (!vs_state->IsDecode()) {\n    const LogObjectList objlist(commandBuffer, vs_state->Handle());\n    skip |= LogError(\"VUID-vkCmdDecodeVideoKHR-None-08249\", objlist, error_obj.location,\n                     \"the video codec operation (%s) the bound video session %s \"\n                     \"was created with is not a decode operation.\",\n                     string_VkVideoCodecOperationFlagBitsKHR(vs_state->GetCodecOp()), FormatHandle(*vs_state).c_str());\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkVideoDecodeInfoKHR-srcBuffer-07165\", \"srcBuffer must have been created with VK_BUFFER_USAGE_VIDEO_DECODE_SRC_BIT_KHR set\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if ((buffer_state->usage & VK_BUFFER_USAGE_VIDEO_DECODE_SRC_BIT_KHR) == 0) {\n    const LogObjectList objlist(commandBuffer, vs_state->Handle(), pDecodeInfo->srcBuffer);\n    skip |= LogError(\"VUID-VkVideoDecodeInfoKHR-srcBuffer-07165\", objlist, decode_info_loc.dot(Field::srcBuffer),\n                     \"(%s) was not created with \"\n                     \"VK_BUFFER_USAGE_VIDEO_DECODE_SRC_BIT_KHR.\",\n                     FormatHandle(pDecodeInfo->srcBuffer).c_str());\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-vkCmdDecodeVideoKHR-pDecodeInfo-07135\", \"pDecodeInfo->srcBuffer must be compatible with the video profile the bound video session was created with\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (!IsBufferCompatibleWithVideoProfile(*buffer_state, vs_state->profile)) {\n    const LogObjectList objlist(commandBuffer, vs_state->Handle(), pDecodeInfo->srcBuffer);\n    skip |= LogError(\"VUID-vkCmdDecodeVideoKHR-pDecodeInfo-07135\", objlist, decode_info_loc.dot(Field::srcBuffer),\n                     \"(%s) is not compatible \"\n                     \"with the video profile %s was created with.\",\n                     FormatHandle(pDecodeInfo->srcBuffer).c_str(), FormatHandle(*vs_state).c_str());\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-vkCmdDecodeVideoKHR-pDecodeInfo-07138\", \"pDecodeInfo->srcBufferOffset must be an integer multiple of VkVideoCapabilitiesKHR::minBitstreamBufferOffsetAlignment, as returned by vkGetPhysicalDeviceVideoCapabilitiesKHR for the video profile the bound video session was created with\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (!IsIntegerMultipleOf(pDecodeInfo->srcBufferOffset, profile_caps.base.minBitstreamBufferOffsetAlignment)) {\n    const LogObjectList objlist(commandBuffer, vs_state->Handle());\n    skip |= LogError(\"VUID-vkCmdDecodeVideoKHR-pDecodeInfo-07138\", objlist, decode_info_loc.dot(Field::srcBufferOffset),\n                     \"(%\" PRIu64 \") is not an integer multiple of the minBitstreamBufferOffsetAlignment (%\" PRIu64\n                     \") required by the video profile %s was created with.\",\n                     pDecodeInfo->srcBufferOffset, profile_caps.base.minBitstreamBufferOffsetAlignment,\n                     FormatHandle(*vs_state).c_str());\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-vkCmdDecodeVideoKHR-pDecodeInfo-07139\", \"pDecodeInfo->srcBufferRange must be an integer multiple of VkVideoCapabilitiesKHR::minBitstreamBufferSizeAlignment, as returned by vkGetPhysicalDeviceVideoCapabilitiesKHR for the video profile the bound video session was created with\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (!IsIntegerMultipleOf(pDecodeInfo->srcBufferRange, profile_caps.base.minBitstreamBufferSizeAlignment)) {\n    const LogObjectList objlist(commandBuffer, vs_state->Handle());\n    skip |= LogError(\"VUID-vkCmdDecodeVideoKHR-pDecodeInfo-07139\", objlist, decode_info_loc.dot(Field::srcBufferRange),\n                     \"(%\" PRIu64 \") is not an integer multiple of the minBitstreamBufferSizeAlignment (%\" PRIu64\n                     \") required by the video profile %s was created with.\",\n                     pDecodeInfo->srcBufferRange, profile_caps.base.minBitstreamBufferSizeAlignment,\n                     FormatHandle(*vs_state).c_str());\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-vkCmdDecodeVideoKHR-pDecodeInfo-08376\", \"pDecodeInfo->pSetupReferenceSlot must not be NULL unless the bound video session was created with VkVideoSessionCreateInfoKHR::maxDpbSlots equal to zero\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (vs_state->create_info.maxDpbSlots > 0 && pDecodeInfo->pSetupReferenceSlot == nullptr) {\n    const LogObjectList objlist(commandBuffer, vs_state->Handle());\n    skip |= LogError(\"VUID-vkCmdDecodeVideoKHR-pDecodeInfo-08376\", objlist, decode_info_loc.dot(Field::pSetupReferenceSlot),\n                     \"is NULL but the bound video session %s was created with maxDpbSlot %u.\", FormatHandle(*vs_state).c_str(),\n                     vs_state->create_info.maxDpbSlots);\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkVideoDecodeInfoKHR-pSetupReferenceSlot-07168\", \"If pSetupReferenceSlot is not NULL, then its slotIndex member must not be negative\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (pDecodeInfo->pSetupReferenceSlot->slotIndex < 0) {\n    skip |= LogError(\"VUID-VkVideoDecodeInfoKHR-pSetupReferenceSlot-07168\", commandBuffer,\n                     decode_info_loc.dot(Field::pSetupReferenceSlot).dot(Field::slotIndex), \"(%d) must not be negative.\",\n                     pDecodeInfo->pSetupReferenceSlot->slotIndex);\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-vkCmdDecodeVideoKHR-pDecodeInfo-07170\", \"If pDecodeInfo->pSetupReferenceSlot is not NULL, then pDecodeInfo->pSetupReferenceSlot->slotIndex must be less than the VkVideoSessionCreateInfoKHR::maxDpbSlots specified when the bound video session was created\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "pDecodeInfo->pSetupReferenceSlot->slotIndex);\n} else if ((uint32_t)pDecodeInfo->pSetupReferenceSlot->slotIndex >= vs_state->create_info.maxDpbSlots) {\nskip |= LogError(\"VUID-vkCmdDecodeVideoKHR-pDecodeInfo-07170\", commandBuffer,\ndecode_info_loc.dot(Field::pSetupReferenceSlot).dot(Field::slotIndex),\n\"(%d) must be smaller than the maxDpbSlots (%u) the bound video session %s \"\n\"was created with.\",\npDecodeInfo->pSetupReferenceSlot->slotIndex, vs_state->create_info.maxDpbSlots,\nFormatHandle(*vs_state).c_str());\n"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkVideoDecodeInfoKHR-pSetupReferenceSlot-07169\", \"If pSetupReferenceSlot is not NULL, then its pPictureResource must not be NULL\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "\"VUID-vkCmdDecodeVideoKHR-pDecodeInfo-07254\", &hit_error);\nskip |= LogError(\"VUID-VkVideoDecodeInfoKHR-pSetupReferenceSlot-07169\", commandBuffer,\ndecode_info_loc.dot(Field::pSetupReferenceSlot).dot(Field::pPictureResource), \"is NULL\");\n"
        },
        {
            "role": "user",
            "content": "{\"VUID-vkCmdDecodeVideoKHR-pDecodeInfo-07142\", \"pDecodeInfo->dstPictureResource.imageViewBinding must be compatible with the video profile the bound video session was created with\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (!IsImageCompatibleWithVideoProfile(*dst_resource.image_state, vs_state->profile)) {\n    const LogObjectList objlist(commandBuffer, vs_state->Handle(), dst_resource.image_view_state->Handle(),\n    skip |= LogError(\"VUID-vkCmdDecodeVideoKHR-pDecodeInfo-07142\", objlist,\n                     decode_info_loc.dot(Field::dstPictureResource).dot(Field::imageViewBinding),\n                     \"(%s created from %s) is not compatible with the video profile the bound \"\n                     \"video session %s was created with.\",\n                     FormatHandle(pDecodeInfo->dstPictureResource.imageViewBinding).c_str(),\n                     FormatHandle(dst_resource.image_state->Handle()).c_str(), FormatHandle(*vs_state).c_str());\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-vkCmdDecodeVideoKHR-pDecodeInfo-07143\", \"The format of pDecodeInfo->dstPictureResource.imageViewBinding must match the VkVideoSessionCreateInfoKHR::pictureFormat the bound video session was created with\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (dst_resource.image_view_state->create_info.format != vs_state->create_info.pictureFormat) {\n    const LogObjectList objlist(commandBuffer, vs_state->Handle(), dst_resource.image_view_state->Handle(),\n    skip |= LogError(\"VUID-vkCmdDecodeVideoKHR-pDecodeInfo-07143\", objlist,\n                     decode_info_loc.dot(Field::dstPictureResource).dot(Field::imageViewBinding),\n                     \"(%s created from %s) format (%s) does not match the pictureFormat (%s) \"\n                     \"the bound video session %s was created with.\",\n                     FormatHandle(dst_resource.image_view_state->Handle()).c_str(),\n                     FormatHandle(dst_resource.image_state->Handle()).c_str(),\n                     string_VkFormat(dst_resource.image_view_state->create_info.format),\n                     string_VkFormat(vs_state->create_info.pictureFormat), FormatHandle(vs_state->Handle()).c_str());\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-vkCmdDecodeVideoKHR-pDecodeInfo-07146\", \"pDecodeInfo->dstPictureResource.imageViewBinding must have been created with VK_IMAGE_USAGE_VIDEO_DECODE_DST_BIT_KHR\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if ((supported_usage & VK_IMAGE_USAGE_VIDEO_DECODE_DST_BIT_KHR) == 0) {\n    const LogObjectList objlist(commandBuffer, vs_state->Handle(), dst_resource.image_view_state->Handle(),\n    skip |= LogError(\"VUID-vkCmdDecodeVideoKHR-pDecodeInfo-07146\", objlist,\n                     decode_info_loc.dot(Field::dstPictureResource).dot(Field::imageViewBinding),\n                     \"(%s created from %s) was not created with VK_IMAGE_USAGE_VIDEO_DECODE_DST_BIT_KHR \"\n                     \"thus it cannot be used as a decode output picture with the bound video session %s \"\n                     \"that was created with a decode operation.\",\n                     FormatHandle(dst_resource.image_view_state->Handle()).c_str(),\n                     FormatHandle(dst_resource.image_state->Handle()).c_str(), FormatHandle(*vs_state).c_str());\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkVideoDecodeInfoKHR-slotIndex-07171\", \"The slotIndex member of each element of pReferenceSlots must not be negative\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (pDecodeInfo->pReferenceSlots[i].slotIndex < 0) {\n    skip |= LogError(\"VUID-VkVideoDecodeInfoKHR-slotIndex-07171\", commandBuffer,\n                     decode_info_loc.dot(Field::pReferenceSlots, i).dot(Field::slotIndex), \"(%d) must not be negative.\",\n                     pDecodeInfo->pReferenceSlots[i].slotIndex);\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-vkCmdDecodeVideoKHR-slotIndex-07256\", \"The slotIndex member of each element of pDecodeInfo->pReferenceSlots must be less than the VkVideoSessionCreateInfoKHR::maxDpbSlots specified when the bound video session was created\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "pDecodeInfo->pReferenceSlots[i].slotIndex);\n} else if ((uint32_t)pDecodeInfo->pReferenceSlots[i].slotIndex >= vs_state->create_info.maxDpbSlots) {\nconst LogObjectList objlist(commandBuffer, vs_state->Handle());\nskip |= LogError(\"VUID-vkCmdDecodeVideoKHR-slotIndex-07256\", objlist,\ndecode_info_loc.dot(Field::pReferenceSlots, i).dot(Field::slotIndex),\n\"(%d) must be smaller than the maxDpbSlots (%u) the bound video session %s \"\n\"was created with.\",\npDecodeInfo->pReferenceSlots[i].slotIndex, vs_state->create_info.maxDpbSlots,\nFormatHandle(*vs_state).c_str());\n"
        },
        {
            "role": "user",
            "content": "{\"VUID-vkCmdDecodeVideoKHR-pDecodeInfo-07151\", \"The pPictureResource member of each element of pDecodeInfo->pReferenceSlots must match one of the bound reference picture resource associated with the DPB slot index specified in the slotIndex member of that element\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (it == bound_resources.end()) {\n    skip |= LogError(\"VUID-vkCmdDecodeVideoKHR-pDecodeInfo-07151\", commandBuffer, error_obj.location,\n                     \"the video picture resource specified in \"\n                     \"pDecodeInfo->pReferenceSlots[%u].pPictureResource is not one of the \"\n                     \"bound video picture resources.\",\n                     i);\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-vkCmdDecodeVideoKHR-pDecodeInfo-07151\", \"The pPictureResource member of each element of pDecodeInfo->pReferenceSlots must match one of the bound reference picture resource associated with the DPB slot index specified in the slotIndex member of that element\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "} else if (pDecodeInfo->pReferenceSlots[i].slotIndex >= 0 &&\n           pDecodeInfo->pReferenceSlots[i].slotIndex != it->second) {\n    skip |= LogError(\"VUID-vkCmdDecodeVideoKHR-pDecodeInfo-07151\", commandBuffer, error_obj.location,\n                     \"the bound video picture resource specified  in \"\n                     \"pDecodeInfo->pReferenceSlots[%u].pPictureResource is not currently \"\n                     \"associated with the DPB slot index specifed in \"\n                     \"pDecodeInfo->pReferenceSlots[%u].slotIndex (%d).\",\n                     i, i, pDecodeInfo->pReferenceSlots[i].slotIndex);\n"
        },
        {
            "role": "user",
            "content": "{\"VUID-vkCmdDecodeVideoKHR-pDecodeInfo-07264\", \"Each video picture resource corresponding to the pPictureResource member specified in the elements of pDecodeInfo->pReferenceSlots must be unique within pDecodeInfo->pReferenceSlots\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (!resources_unique) {\n    skip |= LogError(\"VUID-vkCmdDecodeVideoKHR-pDecodeInfo-07264\", commandBuffer, error_obj.location,\n                     \"more than one element of pDecodeInfo->pReferenceSlots \"\n                     \"refers to the same video picture resource.\");\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-vkCmdDecodeVideoKHR-opCount-07134\", \"For each active query, the active query index corresponding to the query type of that query plus opCount must be less than or equal to the last activatable query index corresponding to the query type of that query plus one\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (query.active_query_index + op_count > query.last_activatable_query_index + 1) {\n    skip |= LogError(\"VUID-vkCmdDecodeVideoKHR-opCount-07134\", commandBuffer, error_obj.location,\n                     \"not enough activatable queries for query type %s \"\n                     \"with opCount %u, active query index %u, and last activatable query index %u.\",\n                     string_VkQueryType(query_pool_state->create_info.queryType), op_count, query.active_query_index,\n                     query.last_activatable_query_index);\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-vkCmdDecodeVideoKHR-pNext-08365\", \"If the bound video session was created with VK_VIDEO_SESSION_CREATE_INLINE_QUERIES_BIT_KHR, and the pNext chain of pDecodeInfo includes a VkVideoInlineQueryInfoKHR structure with its queryPool member specifying a valid VkQueryPool handle, then VkVideoInlineQueryInfoKHR::queryCount must equal opCount\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (inline_query_info->queryCount != op_count) {\n    const LogObjectList objlist(commandBuffer, vs_state->Handle());\n    skip |= LogError(\"VUID-vkCmdDecodeVideoKHR-pNext-08365\", objlist,\n                     decode_info_loc.pNext(Struct::VkVideoInlineQueryInfoKHR, Field::queryCount),\n                     \"(%u) is not equal to opCount (%u).\", inline_query_info->queryCount, op_count);\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-vkCmdDecodeVideoKHR-queryType-08367\", \"If the bound video session was created with VK_VIDEO_SESSION_CREATE_INLINE_QUERIES_BIT_KHR, then the queryType used to create the queryPool specified in the VkVideoInlineQueryInfoKHR structure included in the pNext chain of pDecodeInfo must be VK_QUERY_TYPE_RESULT_STATUS_ONLY_KHR\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (query_pool_state->create_info.queryType != VK_QUERY_TYPE_RESULT_STATUS_ONLY_KHR) {\n    const LogObjectList objlist(commandBuffer, inline_query_info->queryPool);\n    skip |= LogError(\"VUID-vkCmdDecodeVideoKHR-queryType-08367\", objlist,\n                     decode_info_loc.pNext(Struct::VkVideoInlineQueryInfoKHR, Field::queryPool),\n                     \"(%s) has query type (%s) but must be VK_QUERY_TYPE_RESULT_STATUS_ONLY_KHR.\",\n                     FormatHandle(*query_pool_state).c_str(),\n                     string_VkQueryType(query_pool_state->create_info.queryType));\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-vkCmdDecodeVideoKHR-queryType-08369\", \"If the bound video session was created with VK_VIDEO_SESSION_CREATE_INLINE_QUERIES_BIT_KHR, and the queryType used to create the queryPool specified in the VkVideoInlineQueryInfoKHR structure included in the pNext chain of pDecodeInfo is VK_QUERY_TYPE_RESULT_STATUS_ONLY_KHR, then the VkCommandPool that commandBuffer was allocated from must have been created with a queue family index that supports result status queries, as indicated by VkQueueFamilyQueryResultStatusPropertiesKHR::queryResultStatusSupport\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (!qf_ext_props.query_result_status_props.queryResultStatusSupport) {\n    const LogObjectList objlist(commandBuffer, inline_query_info->queryPool);\n    skip |= LogError(\"VUID-vkCmdDecodeVideoKHR-queryType-08369\", objlist, error_obj.location,\n                     \"the command pool's queue family (index %u) the command \"\n                     \"buffer %s was allocated from does not support result status queries.\",\n                     cb_state->command_pool->queueFamilyIndex, FormatHandle(*cb_state).c_str());\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-vkCmdDecodeVideoKHR-pDecodeInfo-07266\", \"If the bound video session was created with the video codec operation VK_VIDEO_CODEC_OPERATION_DECODE_H264_BIT_KHR and an active reference picture corresponding to any element of pDecodeInfo->pReferenceSlots represents a frame, then the DPB slot index of the bound video session specified by the slotIndex member of that element must be currently associated with a frame picture matching the video picture resource specified by the pPictureResource member of the same element at the time the command is executed on the device\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (slot.picture_id.IsFrame() &&\n    !dev_state.IsSlotPicture(slot.index, vvl::VideoPictureID::Frame(), slot.resource)) {\n    skip |= log_picture_kind_error(slot, \"VUID-vkCmdDecodeVideoKHR-pDecodeInfo-07266\", \"frame\");\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-vkCmdDecodeVideoKHR-pDecodeInfo-07267\", \"If the bound video session was created with the video codec operation VK_VIDEO_CODEC_OPERATION_DECODE_H264_BIT_KHR and an active reference picture corresponding to any element of pDecodeInfo->pReferenceSlots represents a top field, then the DPB slot index of the bound video session specified by the slotIndex member of that element must be currently associated with a top field picture matching the video picture resource specified by the pPictureResource member of the same element at the time the command is executed on the device\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (slot.picture_id.ContainsTopField() &&\n    !dev_state.IsSlotPicture(slot.index, vvl::VideoPictureID::TopField(), slot.resource)) {\n    skip |= log_picture_kind_error(slot, \"VUID-vkCmdDecodeVideoKHR-pDecodeInfo-07267\", \"top field\");\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-vkCmdDecodeVideoKHR-pDecodeInfo-07268\", \"If the bound video session was created with the video codec operation VK_VIDEO_CODEC_OPERATION_DECODE_H264_BIT_KHR and an active reference picture corresponding to any element of pDecodeInfo->pReferenceSlots represents a bottom field, then the DPB slot index of the bound video session specified by the slotIndex member of that element must be currently associated with a bottom field picture matching the video picture resource specified by the pPictureResource member of the same element at the time the command is executed on the device\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (slot.picture_id.ContainsBottomField() &&\n    !dev_state.IsSlotPicture(slot.index, vvl::VideoPictureID::BottomField(), slot.resource)) {\n    skip |= log_picture_kind_error(slot, \"VUID-vkCmdDecodeVideoKHR-pDecodeInfo-07268\", \"bottom field\");\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-vkCmdEncodeVideoKHR-None-08318\", \"The bound video session parameters object must have been created with the currently set video encode quality level for the bound video session at the time the command is executed on the device\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (vsp_state->GetEncodeQualityLevel() != cb_state->video_encode_quality_level.value()) {\n    const LogObjectList objlist(vs_state->Handle(), vsp_state->Handle());\n    skip |= LogError(\"VUID-vkCmdEncodeVideoKHR-None-08318\", objlist, error_obj.location,\n                     \"the currently configured encode quality level (%u) for %s \"\n                     \"does not match the encode quality level (%u) %s was created with.\",\n                     cb_state->video_encode_quality_level.value(), FormatHandle(*vs_state).c_str(),\n                     vsp_state->GetEncodeQualityLevel(), FormatHandle(*vsp_state).c_str());\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-vkCmdEncodeVideoKHR-None-08318\", \"The bound video session parameters object must have been created with the currently set video encode quality level for the bound video session at the time the command is executed on the device\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (vsp_state->GetEncodeQualityLevel() != dev_state.GetEncodeQualityLevel()) {\n    const LogObjectList objlist(vs_state->Handle(), vsp_state->Handle());\n    skip |= dev_data.LogError(\"VUID-vkCmdEncodeVideoKHR-None-08318\", objlist, loc,\n                              \"The currently configured encode quality level (%u) for %s \"\n                              \"does not match the encode quality level (%u) %s was created with.\",\n                              dev_state.GetEncodeQualityLevel(), dev_data.FormatHandle(*vs_state).c_str(),\n                              vsp_state->GetEncodeQualityLevel(), dev_data.FormatHandle(*vsp_state).c_str());\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkVideoEncodeInfoKHR-dstBuffer-08236\", \"dstBuffer must have been created with VK_BUFFER_USAGE_VIDEO_ENCODE_DST_BIT_KHR set\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if ((buffer_state->usage & VK_BUFFER_USAGE_VIDEO_ENCODE_DST_BIT_KHR) == 0) {\n    const LogObjectList objlist(commandBuffer, vs_state->Handle(), pEncodeInfo->dstBuffer);\n    skip |= LogError(\"VUID-VkVideoEncodeInfoKHR-dstBuffer-08236\", objlist, encode_info_loc.dot(Field::dstBuffer),\n                     \"(%s) was not created with \"\n                     \"VK_BUFFER_USAGE_VIDEO_ENCODE_DST_BIT_KHR.\",\n                     FormatHandle(pEncodeInfo->dstBuffer).c_str());\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-vkCmdEncodeVideoKHR-pEncodeInfo-08201\", \"pEncodeInfo->dstBuffer must be compatible with the video profile the bound video session was created with\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (!IsBufferCompatibleWithVideoProfile(*buffer_state, vs_state->profile)) {\n    const LogObjectList objlist(commandBuffer, vs_state->Handle(), pEncodeInfo->dstBuffer);\n    skip |= LogError(\"VUID-vkCmdEncodeVideoKHR-pEncodeInfo-08201\", objlist, encode_info_loc.dot(Field::dstBuffer),\n                     \" (%s) is not compatible \"\n                     \"with the video profile %s was created with.\",\n                     FormatHandle(pEncodeInfo->dstBuffer).c_str(), FormatHandle(*vs_state).c_str());\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkVideoEncodeInfoKHR-dstBufferRange-08238\", \"dstBufferRange must be less than or equal to the size of dstBuffer minus dstBufferOffset\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (pEncodeInfo->dstBufferOffset + pEncodeInfo->dstBufferRange > buffer_state->create_info.size) {\n    const LogObjectList objlist(commandBuffer, vs_state->Handle(), pEncodeInfo->dstBuffer);\n    skip |= LogError(\"VUID-VkVideoEncodeInfoKHR-dstBufferRange-08238\", objlist, encode_info_loc.dot(Field::dstBufferOffset),\n                     \"(%\" PRIu64 \") plus pEncodeInfo->dstBufferRange (%\" PRIu64\n                     \") must be less than or equal to the size (%\" PRIu64 \") of pEncodeInfo->dstBuffer (%s).\",\n                     pEncodeInfo->dstBufferOffset, pEncodeInfo->dstBufferRange, buffer_state->create_info.size,\n                     FormatHandle(pEncodeInfo->dstBuffer).c_str());\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-vkCmdEncodeVideoKHR-pEncodeInfo-08205\", \"pEncodeInfo->dstBufferRange must be an integer multiple of VkVideoCapabilitiesKHR::minBitstreamBufferSizeAlignment, as returned by vkGetPhysicalDeviceVideoCapabilitiesKHR for the video profile the bound video session was created with\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (!IsIntegerMultipleOf(pEncodeInfo->dstBufferRange, profile_caps.base.minBitstreamBufferSizeAlignment)) {\n    const LogObjectList objlist(commandBuffer, vs_state->Handle());\n    skip |= LogError(\"VUID-vkCmdEncodeVideoKHR-pEncodeInfo-08205\", objlist, encode_info_loc.dot(Field::dstBufferRange),\n                     \"(%\" PRIu64 \") is not an integer multiple of the minBitstreamBufferSizeAlignment (%\" PRIu64\n                     \") required by the video profile %s was created with.\",\n                     pEncodeInfo->dstBufferRange, profile_caps.base.minBitstreamBufferSizeAlignment,\n                     FormatHandle(*vs_state).c_str());\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-vkCmdEncodeVideoKHR-pEncodeInfo-08377\", \"pEncodeInfo->pSetupReferenceSlot must not be NULL unless the bound video session was created with VkVideoSessionCreateInfoKHR::maxDpbSlots equal to zero\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (vs_state->create_info.maxDpbSlots > 0 && pEncodeInfo->pSetupReferenceSlot == nullptr) {\n    const LogObjectList objlist(commandBuffer, vs_state->Handle());\n    skip |= LogError(\"VUID-vkCmdEncodeVideoKHR-pEncodeInfo-08377\", objlist, encode_info_loc.dot(Field::pSetupReferenceSlot),\n                     \"is NULL but the bound video session %s was created with maxDpbSlot %u.\", FormatHandle(*vs_state).c_str(),\n                     vs_state->create_info.maxDpbSlots);\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkVideoEncodeInfoKHR-pSetupReferenceSlot-08239\", \"If pSetupReferenceSlot is not NULL, then its slotIndex member must not be negative\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (pEncodeInfo->pSetupReferenceSlot->slotIndex < 0) {\n    skip |= LogError(\"VUID-VkVideoEncodeInfoKHR-pSetupReferenceSlot-08239\", commandBuffer,\n                     encode_info_loc.dot(Field::pSetupReferenceSlot).dot(Field::slotIndex), \"(%d) must not be negative.\",\n                     pEncodeInfo->pSetupReferenceSlot->slotIndex);\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-vkCmdEncodeVideoKHR-pEncodeInfo-08215\", \"If pEncodeInfo->pSetupReferenceSlot is not NULL, then pEncodeInfo->pSetupReferenceSlot->pPictureResource must match one of the bound reference picture resource\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (bound_resources.find(setup_resource) == bound_resources.end()) {\n    skip |= LogError(\"VUID-vkCmdEncodeVideoKHR-pEncodeInfo-08215\", commandBuffer, error_obj.location,\n                     \"the video picture resource specified in \"\n                     \"pEncodeInfo->pSetupReferenceSlot->pPictureResource is not one of the \"\n                     \"bound video picture resources.\");\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkVideoEncodeInfoKHR-pSetupReferenceSlot-08240\", \"If pSetupReferenceSlot is not NULL, then its pPictureResource must not be NULL\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "\"VUID-vkCmdEncodeVideoKHR-pEncodeInfo-08223\", &hit_error);\nskip |= LogError(\"VUID-VkVideoEncodeInfoKHR-pSetupReferenceSlot-08240\", commandBuffer,\nencode_info_loc.dot(Field::pSetupReferenceSlot).dot(Field::pPictureResource), \"is NULL.\");\n"
        },
        {
            "role": "user",
            "content": "{\"VUID-vkCmdEncodeVideoKHR-pEncodeInfo-08206\", \"pEncodeInfo->srcPictureResource.imageViewBinding must be compatible with the video profile the bound video session was created with\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (!IsImageCompatibleWithVideoProfile(*src_resource.image_state, vs_state->profile)) {\n    const LogObjectList objlist(commandBuffer, vs_state->Handle(), src_resource.image_view_state->Handle(),\n    skip |= LogError(\"VUID-vkCmdEncodeVideoKHR-pEncodeInfo-08206\", objlist,\n                     encode_info_loc.dot(Field::srcPictureResource).dot(Field::imageViewBinding),\n                     \"(%s created from %s) is not compatible with the video profile the bound \"\n                     \"video session %s was created with.\",\n                     FormatHandle(pEncodeInfo->srcPictureResource.imageViewBinding).c_str(),\n                     FormatHandle(src_resource.image_state->Handle()).c_str(), FormatHandle(*vs_state).c_str());\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-vkCmdEncodeVideoKHR-pEncodeInfo-08207\", \"The format of pEncodeInfo->srcPictureResource.imageViewBinding must match the VkVideoSessionCreateInfoKHR::pictureFormat the bound video session was created with\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (src_resource.image_view_state->create_info.format != vs_state->create_info.pictureFormat) {\n    const LogObjectList objlist(commandBuffer, vs_state->Handle(), src_resource.image_view_state->Handle(),\n    skip |= LogError(\"VUID-vkCmdEncodeVideoKHR-pEncodeInfo-08207\", objlist,\n                     encode_info_loc.dot(Field::srcPictureResource).dot(Field::imageViewBinding),\n                     \"(%s created from %s) format (%s) does not match the pictureFormat (%s) \"\n                     \"the bound video session %s was created with.\",\n                     FormatHandle(src_resource.image_view_state->Handle()).c_str(),\n                     FormatHandle(src_resource.image_state->Handle()).c_str(),\n                     string_VkFormat(src_resource.image_view_state->create_info.format),\n                     string_VkFormat(vs_state->create_info.pictureFormat), FormatHandle(*vs_state).c_str());\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkVideoEncodeInfoKHR-slotIndex-08241\", \"The slotIndex member of each element of pReferenceSlots must not be negative\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (pEncodeInfo->pReferenceSlots[i].slotIndex < 0) {\n    skip |= LogError(\"VUID-VkVideoEncodeInfoKHR-slotIndex-08241\", commandBuffer,\n                     encode_info_loc.dot(Field::pReferenceSlots, i).dot(Field::slotIndex),\n                     \"(%d) \"\n                     \"must not be negative.\",\n                     pEncodeInfo->pReferenceSlots[i].slotIndex);\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-vkCmdEncodeVideoKHR-slotIndex-08217\", \"The slotIndex member of each element of pEncodeInfo->pReferenceSlots must be less than the VkVideoSessionCreateInfoKHR::maxDpbSlots specified when the bound video session was created\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "pEncodeInfo->pReferenceSlots[i].slotIndex);\n} else if ((uint32_t)pEncodeInfo->pReferenceSlots[i].slotIndex >= vs_state->create_info.maxDpbSlots) {\nconst LogObjectList objlist(commandBuffer, vs_state->Handle());\nskip |= LogError(\"VUID-vkCmdEncodeVideoKHR-slotIndex-08217\", objlist,\nencode_info_loc.dot(Field::pReferenceSlots, i).dot(Field::slotIndex),\n\"(%d) \"\n\"must be smaller than the maxDpbSlots (%u) the bound video session %s \"\n\"was created with.\",\npEncodeInfo->pReferenceSlots[i].slotIndex, vs_state->create_info.maxDpbSlots,\nFormatHandle(*vs_state).c_str());\n"
        },
        {
            "role": "user",
            "content": "{\"VUID-vkCmdEncodeVideoKHR-pPictureResource-08219\", \"The pPictureResource member of each element of pEncodeInfo->pReferenceSlots must match one of the bound reference picture resource associated with the DPB slot index specified in the slotIndex member of that element\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (it == bound_resources.end()) {\n    skip |= LogError(\"VUID-vkCmdEncodeVideoKHR-pPictureResource-08219\", commandBuffer, error_obj.location,\n                     \"the video picture resource specified in \"\n                     \"pEncodeInfo->pReferenceSlots[%u].pPictureResource is not one of the \"\n                     \"bound video picture resources.\",\n                     i);\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-vkCmdEncodeVideoKHR-pPictureResource-08219\", \"The pPictureResource member of each element of pEncodeInfo->pReferenceSlots must match one of the bound reference picture resource associated with the DPB slot index specified in the slotIndex member of that element\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "skip |= LogError(\"VUID-vkCmdEncodeVideoKHR-pPictureResource-08219\", commandBuffer, error_obj.location,\n                 \"the bound video picture resource specified in \"\n                 \"pEncodeInfo->pReferenceSlots[%u].pPictureResource is not currently \"\n                 \"associated with the DPB slot index specifed in \"\n                 \"pEncodeInfo->pReferenceSlots[%u].slotIndex (%d).\",\n                 i, i, pEncodeInfo->pReferenceSlots[i].slotIndex);\n"
        },
        {
            "role": "user",
            "content": "{\"VUID-vkCmdEncodeVideoKHR-pPictureResource-08220\", \"Each video picture resource corresponding to the pPictureResource member specified in the elements of pEncodeInfo->pReferenceSlots must be unique within pEncodeInfo->pReferenceSlots\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (!resources_unique) {\n    skip |= LogError(\"VUID-vkCmdEncodeVideoKHR-pPictureResource-08220\", commandBuffer, error_obj.location,\n                     \"more than one element of pEncodeInfo->pReferenceSlots \"\n                     \"refers to the same video picture resource.\");\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-vkCmdEncodeVideoKHR-opCount-07174\", \"For each active query, the active query index corresponding to the query type of that query plus opCount must be less than or equal to the last activatable query index corresponding to the query type of that query plus one\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (query.active_query_index + op_count > query.last_activatable_query_index + 1) {\n    skip |= LogError(\"VUID-vkCmdEncodeVideoKHR-opCount-07174\", commandBuffer, error_obj.location,\n                     \"not enough activatable queries for query type %s \"\n                     \"with opCount %u, active query index %u, and last activatable query index %u.\",\n                     string_VkQueryType(query_pool_state->create_info.queryType), op_count, query.active_query_index,\n                     query.last_activatable_query_index);\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-vkCmdEncodeVideoKHR-pNext-08360\", \"If the bound video session was created with VK_VIDEO_SESSION_CREATE_INLINE_QUERIES_BIT_KHR, and the pNext chain of pEncodeInfo includes a VkVideoInlineQueryInfoKHR structure with its queryPool member specifying a valid VkQueryPool handle, then VkVideoInlineQueryInfoKHR::queryCount must equal opCount\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (inline_query_info->queryCount != op_count) {\n    const LogObjectList objlist(commandBuffer, vs_state->Handle());\n    skip |= LogError(\"VUID-vkCmdEncodeVideoKHR-pNext-08360\", objlist,\n                     encode_info_loc.pNext(Struct::VkVideoInlineQueryInfoKHR, Field::queryCount),\n                     \"(%u) is not equal to opCount (%u).\", inline_query_info->queryCount, op_count);\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-vkCmdEncodeVideoKHR-queryType-08362\", \"If the bound video session was created with VK_VIDEO_SESSION_CREATE_INLINE_QUERIES_BIT_KHR, then the queryType used to create the queryPool specified in the VkVideoInlineQueryInfoKHR structure included in the pNext chain of pEncodeInfo must be VK_QUERY_TYPE_RESULT_STATUS_ONLY_KHR or VK_QUERY_TYPE_VIDEO_ENCODE_FEEDBACK_KHR\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (query_pool_state->create_info.queryType != VK_QUERY_TYPE_RESULT_STATUS_ONLY_KHR &&\n    query_pool_state->create_info.queryType != VK_QUERY_TYPE_VIDEO_ENCODE_FEEDBACK_KHR) {\n    const LogObjectList objlist(commandBuffer, inline_query_info->queryPool);\n    skip |= LogError(\"VUID-vkCmdEncodeVideoKHR-queryType-08362\", objlist,\n                     encode_info_loc.pNext(Struct::VkVideoInlineQueryInfoKHR, Field::queryPool),\n                     \"(%s) has query type (%s) but must be VK_QUERY_TYPE_RESULT_STATUS_ONLY_KHR or \"\n                     \"VK_QUERY_TYPE_VIDEO_ENCODE_FEEDBACK_KHR.\",\n                     FormatHandle(*query_pool_state).c_str(),\n                     string_VkQueryType(query_pool_state->create_info.queryType));\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-vkCmdEncodeVideoKHR-queryType-08364\", \"If the bound video session was created with VK_VIDEO_SESSION_CREATE_INLINE_QUERIES_BIT_KHR, and the queryType used to create the queryPool specified in the VkVideoInlineQueryInfoKHR structure included in the pNext chain of pEncodeInfo is VK_QUERY_TYPE_RESULT_STATUS_ONLY_KHR, then the VkCommandPool that commandBuffer was allocated from must have been created with a queue family index that supports result status queries, as indicated by VkQueueFamilyQueryResultStatusPropertiesKHR::queryResultStatusSupport\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (query_pool_state->create_info.queryType == VK_QUERY_TYPE_RESULT_STATUS_ONLY_KHR &&\n    const LogObjectList objlist(commandBuffer, inline_query_info->queryPool);\n    skip |= LogError(\"VUID-vkCmdEncodeVideoKHR-queryType-08364\", objlist, error_obj.location,\n                     \"the command pool's queue family (index %u) the command \"\n                     \"buffer %s was allocated from does not support result status queries.\",\n                     cb_state->command_pool->queueFamilyIndex, FormatHandle(*cb_state).c_str());\n"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkSwapchainCreateInfoKHR-presentMode-01281\", \"presentMode must be one of the VkPresentModeKHR values returned by vkGetPhysicalDeviceSurfacePresentModesKHR for the surface\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "skip |= LogError(\"VUID-VkSwapchainCreateInfoKHR-presentMode-01281\", device, create_info_loc.dot(Field::presentMode),\n                 \"(%s) is not supported (the following are supported %s).\", string_VkPresentModeKHR(present_mode),\n                 ss.str().c_str());\n"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkSwapchainCreateInfoKHR-pNext-06752\", \"If the imageCompressionControlSwapchain feature is not enabled, the pNext chain must not include an VkImageCompressionControlEXT structure\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (image_compression_control && !enabled_features.imageCompressionControlSwapchain) {\n    skip |= LogError(\"VUID-VkSwapchainCreateInfoKHR-pNext-06752\", device, create_info_loc.dot(Field::pNext),\n                     \"contains VkImageCompressionControlEXT, but imageCompressionControlSwapchain is not enabled\");\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-vkQueuePresentKHR-pWaitSemaphores-03267\", \"All elements of the pWaitSemaphores member of pPresentInfo must be created with a VkSemaphoreType of VK_SEMAPHORE_TYPE_BINARY\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (semaphore_state->type != VK_SEMAPHORE_TYPE_BINARY) {\n    skip |= LogError(\"VUID-vkQueuePresentKHR-pWaitSemaphores-03267\", pPresentInfo->pWaitSemaphores[i],\n                     present_info_loc.dot(Field::pWaitSemaphores, i), \"(%s) is not a VK_SEMAPHORE_TYPE_BINARY\",\n                     FormatHandle(pPresentInfo->pWaitSemaphores[i]).c_str());\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkPresentInfoKHR-pImageIndices-01430\", \"Each element of pImageIndices must be the index of a presentable image acquired from the swapchain specified by the corresponding element of the pSwapchains array, and the presented image subresource must be in the VK_IMAGE_LAYOUT_PRESENT_SRC_KHR or VK_IMAGE_LAYOUT_SHARED_PRESENT_KHR layout at the time the operation is executed on a VkDevice\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "pPresentInfo->pImageIndices[i], static_cast<uint32_t>(swapchain_data->images.size()));\n} else if (!swapchain_data->images[pPresentInfo->pImageIndices[i]].acquired) {\nassert(swapchain_data->images[pPresentInfo->pImageIndices[i]].image_state);\nskip |= LogError(\"VUID-VkPresentInfoKHR-pImageIndices-01430\", pPresentInfo->pSwapchains[i], swapchain_loc,\n\"image at index %\" PRIu32 \" was not acquired from the swapchain.\", pPresentInfo->pImageIndices[i]);\n"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkPresentInfoKHR-pImageIndices-01430\", \"Each element of pImageIndices must be the index of a presentable image acquired from the swapchain specified by the corresponding element of the pSwapchains array, and the presented image subresource must be in the VK_IMAGE_LAYOUT_PRESENT_SRC_KHR or VK_IMAGE_LAYOUT_SHARED_PRESENT_KHR layout at the time the operation is executed on a VkDevice\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if ((layout != VK_IMAGE_LAYOUT_PRESENT_SRC_KHR) &&\n    skip |= LogError(\"VUID-VkPresentInfoKHR-pImageIndices-01430\", queue, swapchain_loc,\n                     \"images passed to present must be in layout \"\n                     \"VK_IMAGE_LAYOUT_PRESENT_SRC_KHR or \"\n                     \"VK_IMAGE_LAYOUT_SHARED_PRESENT_KHR but is in %s.\",\n                     string_VkImageLayout(layout));\n"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkDisplayPresentInfoKHR-srcRect-01257\", \"srcRect must specify a rectangular region that is a subset of the image being presented\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "display_present_info->srcRect.offset.y + display_present_info->srcRect.extent.height >\nskip |= LogError(\"VUID-VkDisplayPresentInfoKHR-srcRect-01257\", queue,\n                 present_info_loc.pNext(Struct::VkDisplayPresentInfoKHR, Field::srcRect),\n                 \"(%s) is not a subset of the image begin presented extent (%s).\",\n                 string_VkRect2D(display_present_info->srcRect).c_str(),\n                 string_VkExtent3D(image_state->create_info.extent).c_str());\n"
        },
        {
            "role": "user",
            "content": "{\"VUID-vkQueuePresentKHR-pSwapchains-01292\", \"Each element of pSwapchains member of pPresentInfo must be a swapchain that is created for a surface for which presentation is supported from queue as determined using a call to vkGetPhysicalDeviceSurfaceSupportKHR\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (surface_state && !surface_state->GetQueueSupport(physical_device, queue_state->queue_family_index)) {\n    skip |= LogError(\"VUID-vkQueuePresentKHR-pSwapchains-01292\", pPresentInfo->pSwapchains[i], swapchain_loc,\n                     \"image on queue that cannot present to this surface.\");\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkRectLayerKHR-offset-04864\", \"The sum of offset and extent, after being transformed according to the preTransform member of the VkSwapchainCreateInfoKHR structure, must be no greater than the imageExtent member of the VkSwapchainCreateInfoKHR structure passed to vkCreateSwapchainKHR\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if ((rect.offset.y + rect.extent.height) > swapchain_data->create_info.imageExtent.height) {\n    skip |= LogError(\"VUID-VkRectLayerKHR-offset-04864\", pPresentInfo->pSwapchains[i], rect_loc,\n                     \"sum of offset.y (%\" PRId32 \") and extent.height (%\" PRIu32\n                     \") after applying preTransform (%s) is greater \"\n                     \"than the corresponding swapchain's imageExtent.height (%\" PRIu32 \").\",\n                     rect.offset.y, rect.extent.height,\n                     string_VkSurfaceTransformFlagBitsKHR(swapchain_data->create_info.preTransform),\n                     swapchain_data->create_info.imageExtent.height);\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkPresentTimesInfoGOOGLE-swapchainCount-01247\", \"swapchainCount must be the same value as VkPresentInfoKHR::swapchainCount, where VkPresentInfoKHR is included in the pNext chain of this VkPresentTimesInfoGOOGLE structure\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (pPresentInfo->swapchainCount != present_times_info->swapchainCount) {\n    skip |= LogError(\"VUID-VkPresentTimesInfoGOOGLE-swapchainCount-01247\", pPresentInfo->pSwapchains[0],\n                     present_info_loc.pNext(Struct::VkPresentTimesInfoGOOGLE, Field::swapchainCount),\n                     \"(%\" PRIu32 \") is not equal to pPresentInfo->swapchainCount (%\" PRIu32 \").\",\n                     present_times_info->swapchainCount, pPresentInfo->swapchainCount);\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkPresentInfoKHR-pNext-06235\", \"If a VkPresentIdKHR structure is included in the pNext chain, and the presentId feature is not enabled, each presentIds entry in that structure must be NULL\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (present_id_info->pPresentIds[i] != 0) {\n    skip |= LogError(\"VUID-VkPresentInfoKHR-pNext-06235\", pPresentInfo->pSwapchains[0],\n                     present_info_loc.pNext(Struct::VkPresentIdKHR, Field::pPresentIds, i),\n                     \"%\" PRIu64 \" is not NULL but presentId feature is not enabled.\",\n                     present_id_info->pPresentIds[i]);\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkPresentIdKHR-swapchainCount-04998\", \"swapchainCount must be the same value as VkPresentInfoKHR::swapchainCount, where this VkPresentIdKHR is in the pNext chain of the VkPresentInfoKHR structure\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (pPresentInfo->swapchainCount != present_id_info->swapchainCount) {\n    skip |= LogError(\"VUID-VkPresentIdKHR-swapchainCount-04998\", pPresentInfo->pSwapchains[0],\n                     present_info_loc.pNext(Struct::VkPresentIdKHR, Field::swapchainCount),\n                     \"(%\" PRIu32 \") is not equal to pPresentInfo->swapchainCount (%\" PRIu32 \").\",\n                     present_id_info->swapchainCount, pPresentInfo->swapchainCount);\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkSwapchainPresentFenceInfoEXT-swapchainCount-07757\", \"swapchainCount must be equal to VkPresentInfoKHR::swapchainCount\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (pPresentInfo->swapchainCount != swapchain_present_fence_info->swapchainCount) {\n    skip |= LogError(\"VUID-VkSwapchainPresentFenceInfoEXT-swapchainCount-07757\", pPresentInfo->pSwapchains[0],\n                     present_info_loc.pNext(Struct::VkSwapchainPresentFenceInfoEXT, Field::swapchainCount),\n                     \"(%\" PRIu32 \") is not equal to pPresentInfo->swapchainCount (%\" PRIu32 \").\",\n                     swapchain_present_fence_info->swapchainCount, pPresentInfo->swapchainCount);\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkSwapchainPresentModeInfoEXT-swapchainCount-07760\", \"swapchainCount must be equal to VkPresentInfoKHR::swapchainCount\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (pPresentInfo->swapchainCount != swapchain_present_mode_info->swapchainCount) {\n    skip |= LogError(\"VUID-VkSwapchainPresentModeInfoEXT-swapchainCount-07760\", pPresentInfo->pSwapchains[0],\n                     present_info_loc.pNext(Struct::VkSwapchainPresentModeInfoEXT, Field::swapchainCount),\n                     \"(%\" PRIu32 \") is not equal to pPresentInfo->swapchainCount (%\" PRIu32 \").\",\n                     swapchain_present_mode_info->swapchainCount, pPresentInfo->swapchainCount);\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkSwapchainPresentModeInfoEXT-pPresentModes-07761\", \"Each entry in pPresentModes must be a presentation mode specified in VkSwapchainPresentModesCreateInfoEXT::pPresentModes when creating the entry's corresponding swapchain\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (!found_match) {\n    skip |= LogError(\"VUID-VkSwapchainPresentModeInfoEXT-pPresentModes-07761\", pPresentInfo->pSwapchains[i],\n                     present_info_loc.pNext(Struct::VkSwapchainPresentModeInfoEXT, Field::presentMode),\n                     \"(%s) that was not specified in a VkSwapchainPresentModesCreateInfoEXT \"\n                     \"structure extending VkCreateSwapchainsKHR.\",\n                     string_VkPresentModeKHR(present_mode));\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkSwapchainPresentModeInfoEXT-pPresentModes-07761\", \"Each entry in pPresentModes must be a presentation mode specified in VkSwapchainPresentModesCreateInfoEXT::pPresentModes when creating the entry's corresponding swapchain\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "skip |= LogError(\"VUID-VkSwapchainPresentModeInfoEXT-pPresentModes-07761\", pPresentInfo->pSwapchains[i],\n                 present_info_loc.pNext(Struct::VkSwapchainPresentModeInfoEXT, Field::presentMode),\n                 \"(%s), but a VkSwapchainPresentModesCreateInfoEXT structure was not included in the \"\n                 \"pNext chain of VkCreateSwapchainsKHR.\",\n                 string_VkPresentModeKHR(present_mode));\n"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkReleaseSwapchainImagesInfoEXT-pImageIndices-07785\", \"Each element of pImageIndices must be the index of a presentable image acquired from the swapchain specified by swapchain\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "pReleaseInfo->pImageIndices[i], static_cast<uint32_t>(swapchain_state->images.size()));\n} else if (!swapchain_state->images[pReleaseInfo->pImageIndices[i]].acquired) {\nassert(swapchain_state->images[pReleaseInfo->pImageIndices[i]].image_state);\nskip |= LogError(\"VUID-VkReleaseSwapchainImagesInfoEXT-pImageIndices-07785\", pReleaseInfo->swapchain,\nrelease_info_loc.dot(Field::pImageIndices, i), \"%\" PRIu32 \" was not acquired from the swapchain.\",\npReleaseInfo->pImageIndices[i]);\n"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkReleaseSwapchainImagesInfoEXT-pImageIndices-07786\", \"All uses of presentable images identified by elements of pImageIndices must have completed execution\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (image_in_use) {\n    skip |= LogError(\"VUID-VkReleaseSwapchainImagesInfoEXT-pImageIndices-07786\", pReleaseInfo->swapchain, release_info_loc,\n                     \"One or more of the images in this swapchain is still in use.\");\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-vkAcquireNextImageKHR-fence-01287\", \"If fence is not VK_NULL_HANDLE, fence must be unsignaled\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (auto fence_state = Get<vvl::Fence>(fence)) {\n    const LogObjectList objlist(device, fence);\n    skip |= ValidateFenceForSubmit(*fence_state, \"VUID-vkAcquireNextImageKHR-fence-01287\",\n                                   \"VUID-vkAcquireNextImageKHR-fence-01287\", objlist, loc);\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-vkWaitForPresentKHR-presentWait-06234\", \"The presentWait feature must be enabled\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (!enabled_features.presentWait) {\n    skip |= LogError(\"VUID-vkWaitForPresentKHR-presentWait-06234\", swapchain, error_obj.location,\n                     \"presentWait feature is not enabled.\");\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-vkDestroySurfaceKHR-surface-01266\", \"All VkSwapchainKHR objects created for surface must have been destroyed prior to destroying surface\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (surface_state && surface_state->swapchain) {\n    skip |= LogError(\"VUID-vkDestroySurfaceKHR-surface-01266\", instance, error_obj.location,\n                     \"called before its associated VkSwapchainKHR was destroyed.\");\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkDisplaySurfaceCreateInfoKHR-alphaMode-01254\", \"If alphaMode is VK_DISPLAY_PLANE_ALPHA_GLOBAL_BIT_KHR then globalAlpha must be between 0 and 1, inclusive\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if ((global_alpha > 1.0f) || (global_alpha < 0.0f)) {\n    skip |= LogError(\"VUID-VkDisplaySurfaceCreateInfoKHR-alphaMode-01254\", display_mode,\n                     create_info_loc.dot(Field::globalAlpha),\n                     \"is %f, but alphaMode is VK_DISPLAY_PLANE_ALPHA_GLOBAL_BIT_KHR.\", global_alpha);\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkDisplaySurfaceCreateInfoKHR-width-01256\", \"The width and height members of imageExtent must be less than or equal to VkPhysicalDeviceLimits::maxImageDimension2D\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (width >= device_properties.limits.maxImageDimension2D) {\n    skip |= LogError(\"VUID-VkDisplaySurfaceCreateInfoKHR-width-01256\", display_mode,\n                     create_info_loc.dot(Field::imageExtent).dot(Field::width),\n                     \"(%\" PRIu32 \") exceeds device limit maxImageDimension2D (%\" PRIu32 \").\", width,\n                     device_properties.limits.maxImageDimension2D);\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkDisplaySurfaceCreateInfoKHR-width-01256\", \"The width and height members of imageExtent must be less than or equal to VkPhysicalDeviceLimits::maxImageDimension2D\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (height >= device_properties.limits.maxImageDimension2D) {\n    skip |= LogError(\"VUID-VkDisplaySurfaceCreateInfoKHR-width-01256\", display_mode,\n                     create_info_loc.dot(Field::imageExtent).dot(Field::height),\n                     \"(%\" PRIu32 \") exceeds device limit maxImageDimension2D (%\" PRIu32 \").\", height,\n                     device_properties.limits.maxImageDimension2D);\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkDisplaySurfaceCreateInfoKHR-alphaMode-01255\", \"alphaMode must be one of the bits present in the supportedAlpha member of VkDisplayPlaneCapabilitiesKHR for the display plane corresponding to displayMode\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if ((pCreateInfo->alphaMode & plane_capabilities.supportedAlpha) == 0) {\n    skip |= LogError(\"VUID-VkDisplaySurfaceCreateInfoKHR-alphaMode-01255\", display_mode, create_info_loc,\n                     \"alphaMode is %s but planeIndex %\" PRIu32\n                     \" supportedAlpha (%s) \"\n                     \"does not support the mode.\",\n                     string_VkDisplayPlaneAlphaFlagBitsKHR(pCreateInfo->alphaMode), plane_index,\n                     string_VkDisplayPlaneAlphaFlagsKHR(plane_capabilities.supportedAlpha).c_str());\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-vkAcquireFullScreenExclusiveModeEXT-swapchain-02674\", \"swapchain must not be in the retired state\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (swapchain_state->retired) {\n    skip |= LogError(\"VUID-vkAcquireFullScreenExclusiveModeEXT-swapchain-02674\", device, error_obj.location,\n                     \"swapchain %s is retired.\", FormatHandle(swapchain).c_str());\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-vkAcquireFullScreenExclusiveModeEXT-swapchain-02675\", \"swapchain must be a swapchain created with a VkSurfaceFullScreenExclusiveInfoEXT structure, with fullScreenExclusive set to VK_FULL_SCREEN_EXCLUSIVE_APPLICATION_CONTROLLED_EXT\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (!surface_full_screen_exclusive_info ||\n    skip |= LogError(\"VUID-vkAcquireFullScreenExclusiveModeEXT-swapchain-02675\", device, error_obj.location,\n                     \"swapchain %s was not created with VkSurfaceFullScreenExclusiveInfoEXT in \"\n                     \"the pNext chain with fullScreenExclusive equal to VK_FULL_SCREEN_EXCLUSIVE_APPLICATION_CONTROLLED_EXT.\",\n                     FormatHandle(swapchain).c_str());\n"
        },
        {
            "role": "user",
            "content": "{\"VUID-vkAcquireFullScreenExclusiveModeEXT-swapchain-02676\", \"swapchain must not currently have exclusive full-screen access\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (swapchain_state->exclusive_full_screen_access) {\n    skip |= LogError(\"VUID-vkAcquireFullScreenExclusiveModeEXT-swapchain-02676\", device, error_obj.location,\n                     \"swapchain %s already has exclusive full-screen access.\", FormatHandle(swapchain).c_str());\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-vkReleaseFullScreenExclusiveModeEXT-swapchain-02678\", \"swapchain must be a swapchain created with a VkSurfaceFullScreenExclusiveInfoEXT structure, with fullScreenExclusive set to VK_FULL_SCREEN_EXCLUSIVE_APPLICATION_CONTROLLED_EXT\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (!surface_full_screen_exclusive_info ||\n    skip |= LogError(\"VUID-vkReleaseFullScreenExclusiveModeEXT-swapchain-02678\", device, error_obj.location,\n                     \"swapchain %s was not created with VkSurfaceFullScreenExclusiveInfoEXT in \"\n                     \"the pNext chain with fullScreenExclusive equal to VK_FULL_SCREEN_EXCLUSIVE_APPLICATION_CONTROLLED_EXT.\",\n                     FormatHandle(swapchain).c_str());\n"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkPhysicalDeviceSurfaceInfo2KHR-pNext-02672\", \"If the pNext chain includes a VkSurfaceFullScreenExclusiveInfoEXT structure with its fullScreenExclusive member set to VK_FULL_SCREEN_EXCLUSIVE_APPLICATION_CONTROLLED_EXT, and surface was created using vkCreateWin32SurfaceKHR, a VkSurfaceFullScreenExclusiveWin32InfoEXT structure must be included in the pNext chain\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "vku::FindStructInPNextChain<VkSurfaceFullScreenExclusiveWin32InfoEXT>(pSurfaceInfo->pNext);\nconst LogObjectList objlist(device, pSurfaceInfo->surface);\nskip |= LogError(\"VUID-VkPhysicalDeviceSurfaceInfo2KHR-pNext-02672\", objlist,\n             error_obj.location.dot(Field::pSurfaceInfo)\n                 .pNext(Struct::VkSurfaceFullScreenExclusiveInfoEXT, Field::fullScreenExclusive),\n             \"is VK_FULL_SCREEN_EXCLUSIVE_APPLICATION_CONTROLLED_EXT, but does not contain \"\n             \"a VkSurfaceFullScreenExclusiveWin32InfoEXT structure.\");\n"
        },
        {
            "role": "user",
            "content": "{\"VUID-vkGetPhysicalDeviceSurfaceFormatsKHR-surface-06525\", \"If surface is not VK_NULL_HANDLE, surface must be supported by physicalDevice, as reported by vkGetPhysicalDeviceSurfaceSupportKHR or an equivalent platform-specific mechanism\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "bool skip = false;\nskip |= ValidatePhysicalDeviceSurfaceSupport(physicalDevice, surface, \"VUID-vkGetPhysicalDeviceSurfaceFormatsKHR-surface-06525\",\n                                             error_obj.location);\n"
        },
        {
            "role": "user",
            "content": "{\"VUID-vkGetDisplayPlaneSupportedDisplaysKHR-planeIndex-01249\", \"planeIndex must be less than the number of display planes supported by the device as determined by calling vkGetPhysicalDeviceDisplayPlanePropertiesKHR\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (planeIndex >= pd_state->display_plane_property_count) {\n    skip |= LogError(\"VUID-vkGetDisplayPlaneSupportedDisplaysKHR-planeIndex-01249\", physicalDevice, loc,\n                     \"is %\" PRIu32 \", but vkGetPhysicalDeviceDisplayPlaneProperties(2)KHR returned %\" PRIu32\n                     \". (Do you have the plane index hardcoded?).\",\n                     planeIndex, pd_state->display_plane_property_count);\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkSamplerYcbcrConversionCreateInfo-format-01650\", \"The potential format features of the sampler Y'CBCR conversion must support VK_FORMAT_FEATURE_MIDPOINT_CHROMA_SAMPLES_BIT or VK_FORMAT_FEATURE_COSITED_CHROMA_SAMPLES_BIT\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (((format_features & VK_FORMAT_FEATURE_2_MIDPOINT_CHROMA_SAMPLES_BIT_KHR) == 0) &&\n    skip |= LogError(\"VUID-VkSamplerYcbcrConversionCreateInfo-format-01650\", device, create_info_loc.dot(Field::format),\n                     \"(%s) does not support either VK_FORMAT_FEATURE_MIDPOINT_CHROMA_SAMPLES_BIT or \"\n                     \"VK_FORMAT_FEATURE_COSITED_CHROMA_SAMPLES_BIT\",\n                     string_VkFormat(conversion_format));\n"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkSamplerYcbcrConversionCreateInfo-forceExplicitReconstruction-01656\", \"If the potential format features of the sampler Y'CBCR conversion do not support VK_FORMAT_FEATURE_SAMPLED_IMAGE_YCBCR_CONVERSION_CHROMA_RECONSTRUCTION_EXPLICIT_FORCEABLE_BIT forceExplicitReconstruction must be VK_FALSE\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (((format_features & VK_FORMAT_FEATURE_2_SAMPLED_IMAGE_YCBCR_CONVERSION_CHROMA_RECONSTRUCTION_EXPLICIT_FORCEABLE_BIT_KHR) ==\n    (pCreateInfo->forceExplicitReconstruction == VK_TRUE)) {\n    skip |= LogError(\"VUID-VkSamplerYcbcrConversionCreateInfo-forceExplicitReconstruction-01656\", device,\n                     create_info_loc.dot(Field::format),\n                     \"(%s) does not support \"\n                     \"VK_FORMAT_FEATURE_SAMPLED_IMAGE_YCBCR_CONVERSION_CHROMA_RECONSTRUCTION_EXPLICIT_FORCEABLE_BIT so \"\n                     \"forceExplicitReconstruction must be VK_FALSE\",\n                     string_VkFormat(conversion_format));\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkSamplerYcbcrConversionCreateInfo-chromaFilter-01657\", \"If the potential format features of the sampler Y'CBCR conversion do not support VK_FORMAT_FEATURE_SAMPLED_IMAGE_YCBCR_CONVERSION_LINEAR_FILTER_BIT, chromaFilter must not be VK_FILTER_LINEAR\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (((format_features & VK_FORMAT_FEATURE_2_SAMPLED_IMAGE_YCBCR_CONVERSION_LINEAR_FILTER_BIT_KHR) == 0) &&\n    (pCreateInfo->chromaFilter == VK_FILTER_LINEAR)) {\n    skip |= LogError(\"VUID-VkSamplerYcbcrConversionCreateInfo-chromaFilter-01657\", device, create_info_loc.dot(Field::format),\n                     \"(%s) does not support VK_FORMAT_FEATURE_SAMPLED_IMAGE_YCBCR_CONVERSION_LINEAR_FILTER_BIT so \"\n                     \"chromaFilter must not be VK_FILTER_LINEAR\",\n                     string_VkFormat(conversion_format));\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkDispatchIndirectCommand-x-00417\", \"x must be less than or equal to VkPhysicalDeviceLimits::maxComputeWorkGroupCount[0]\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "skip |= gpuav.LogError(\"VUID-VkDispatchIndirectCommand-x-00417\", objlist, loc,\n                       \"Indirect dispatch VkDispatchIndirectCommand::x of %\" PRIu32\n                       \" would exceed maxComputeWorkGroupCount[0] limit of %\" PRIu32 \".\",\n                       count, gpuav.phys_dev_props.limits.maxComputeWorkGroupCount[0]);\n"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkDispatchIndirectCommand-z-00419\", \"z must be less than or equal to VkPhysicalDeviceLimits::maxComputeWorkGroupCount[2]\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "skip |= gpuav.LogError(\"VUID-VkDispatchIndirectCommand-z-00419\", objlist, loc,\n                       \"Indirect dispatch VkDispatchIndirectCommand::z of %\" PRIu32\n                       \" would exceed maxComputeWorkGroupCount[2] limit of %\" PRIu32 \".\",\n                       count, gpuav.phys_dev_props.limits.maxComputeWorkGroupCount[0]);\n"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkTraceRaysIndirectCommandKHR-width-03638\", \"width must be less than or equal to VkPhysicalDeviceLimits::maxComputeWorkGroupCount[0] \u00d7 VkPhysicalDeviceLimits::maxComputeWorkGroupSize[0]\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "const uint32_t width = error_record[kPreActionParamOffset_0];\nskip |= gpuav.LogError(\"VUID-VkTraceRaysIndirectCommandKHR-width-03638\", objlist, loc,\n                       \"Indirect trace rays of VkTraceRaysIndirectCommandKHR::width of %\" PRIu32\n                       \" would exceed VkPhysicalDeviceLimits::maxComputeWorkGroupCount[0] * \"\n                       \"VkPhysicalDeviceLimits::maxComputeWorkGroupSize[0] limit of %\" PRIu64 \".\",\n                       width,\n                       static_cast<uint64_t>(gpuav.phys_dev_props.limits.maxComputeWorkGroupCount[0]) *\n                           static_cast<uint64_t>(gpuav.phys_dev_props.limits.maxComputeWorkGroupSize[0]));\n"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkTraceRaysIndirectCommandKHR-height-03639\", \"height must be less than or equal to VkPhysicalDeviceLimits::maxComputeWorkGroupCount[1] \u00d7 VkPhysicalDeviceLimits::maxComputeWorkGroupSize[1]\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "uint32_t height = error_record[kPreActionParamOffset_0];\nskip |= gpuav.LogError(\"VUID-VkTraceRaysIndirectCommandKHR-height-03639\", objlist, loc,\n                       \"Indirect trace rays of VkTraceRaysIndirectCommandKHR::height of %\" PRIu32\n                       \" would exceed VkPhysicalDeviceLimits::maxComputeWorkGroupCount[1] * \"\n                       \"VkPhysicalDeviceLimits::maxComputeWorkGroupSize[1] limit of %\" PRIu64 \".\",\n                       height,\n                       static_cast<uint64_t>(gpuav.phys_dev_props.limits.maxComputeWorkGroupCount[1]) *\n                           static_cast<uint64_t>(gpuav.phys_dev_props.limits.maxComputeWorkGroupSize[1]));\n"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkTraceRaysIndirectCommandKHR-depth-03640\", \"depth must be less than or equal to VkPhysicalDeviceLimits::maxComputeWorkGroupCount[2] \u00d7 VkPhysicalDeviceLimits::maxComputeWorkGroupSize[2]\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "uint32_t depth = error_record[kPreActionParamOffset_0];\nskip |= gpuav.LogError(\"VUID-VkTraceRaysIndirectCommandKHR-depth-03640\", objlist, loc,\n                       \"Indirect trace rays of VkTraceRaysIndirectCommandKHR::height of %\" PRIu32\n                       \" would exceed VkPhysicalDeviceLimits::maxComputeWorkGroupCount[2] * \"\n                       \"VkPhysicalDeviceLimits::maxComputeWorkGroupSize[2] limit of %\" PRIu64 \".\",\n                       depth,\n                       static_cast<uint64_t>(gpuav.phys_dev_props.limits.maxComputeWorkGroupCount[2]) *\n                           static_cast<uint64_t>(gpuav.phys_dev_props.limits.maxComputeWorkGroupSize[2]));\n"
        },
        {
            "role": "user",
            "content": "{\"VUID-vkFreeCommandBuffers-pCommandBuffers-00048\", \"pCommandBuffers must be a valid pointer to an array of commandBufferCount VkCommandBuffer handles, each element of which must either be a valid handle or NULL\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "skip |= LogError(\"VUID-vkFreeCommandBuffers-pCommandBuffers-00048\", command_buffer, loc, \"Invalid %s.\",\n                 FormatHandle(command_buffer).c_str());\n"
        },
        {
            "role": "user",
            "content": "{\"VUID-vkFreeDescriptorSets-pDescriptorSets-parent\", \"Each element of pDescriptorSets that is a valid handle must have been created, allocated, or retrieved from descriptorPool\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "// We know that the parent *must* be a descriptor pool\nconst LogObjectList objlist(descriptor_set, parent_pool, descriptor_pool);\nskip |= LogError(\"VUID-vkFreeDescriptorSets-pDescriptorSets-parent\", objlist, loc,\n                 \"attempting to free %s\"\n                 \" belonging to %s from %s.\",\n                 FormatHandle(descriptor_set).c_str(), FormatHandle(parent_pool).c_str(),\n                 FormatHandle(descriptor_pool).c_str());\n"
        },
        {
            "role": "user",
            "content": "{\"VUID-vkFreeDescriptorSets-pDescriptorSets-00310\", \"pDescriptorSets must be a valid pointer to an array of descriptorSetCount VkDescriptorSet handles, each element of which must either be a valid handle or VK_NULL_HANDLE\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "skip |= LogError(\"VUID-vkFreeDescriptorSets-pDescriptorSets-00310\", descriptor_set, loc, \"Invalid %s.\",\n                 FormatHandle(descriptor_set).c_str());\n"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkWriteDescriptorSet-dstSet-00320\", \"dstSet must be a valid VkDescriptorSet handle\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (!isPush && desc->dstSet) {\n    skip |= ValidateObject(desc->dstSet, kVulkanObjectTypeDescriptorSet, false, \"VUID-VkWriteDescriptorSet-dstSet-00320\",\n                           \"VUID-VkWriteDescriptorSet-commonparent\", loc);\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkWriteDescriptorSet-descriptorType-02997\", \"If descriptorType is VK_DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER, VK_DESCRIPTOR_TYPE_SAMPLED_IMAGE, or VK_DESCRIPTOR_TYPE_STORAGE_IMAGE, and the nullDescriptor feature is not enabled, the imageView member of each element of pImageInfo must not be VK_NULL_HANDLE\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (!null_descriptor_enabled && desc->pImageInfo[i].imageView == VK_NULL_HANDLE) {\n    skip |= LogError(\"VUID-VkWriteDescriptorSet-descriptorType-02997\", desc->dstSet,\n                     loc.dot(Field::pImageInfo, i).dot(Field::imageView), \"is VK_NULL_HANDLE.\");\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkDescriptorBufferInfo-buffer-02998\", \"If the nullDescriptor feature is not enabled, buffer must not be VK_NULL_HANDLE\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (!null_descriptor_enabled && desc->pBufferInfo[i].buffer == VK_NULL_HANDLE) {\n    skip |= LogError(\"VUID-VkDescriptorBufferInfo-buffer-02998\", desc->dstSet,\n                     loc.dot(Field::pBufferInfo, i).dot(Field::buffer), \"is VK_NULL_HANDLE.\");\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-vkCmdPushDescriptorSetKHR-layout-parameter\", \"layout must be a valid VkPipelineLayout handle\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "bool skip = false;\n// Checked by chassis: commandBuffer: \"VUID-vkCmdPushDescriptorSetKHR-commandBuffer-parameter\"\nskip |= ValidateObject(layout, kVulkanObjectTypePipelineLayout, false, \"VUID-vkCmdPushDescriptorSetKHR-layout-parameter\",\n                       \"VUID-vkCmdPushDescriptorSetKHR-commonparent\", error_obj.location.dot(Field::layout));\n"
        },
        {
            "role": "user",
            "content": "{\"VUID-vkDestroyInstance-instance-00630\", \"If VkAllocationCallbacks were provided when instance was created, a compatible set of callbacks must be provided here\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "skip |= obj_lifetimes_data->ReportUndestroyedDeviceObjects(device, error_obj.location);\nskip |= ValidateDestroyObject(device, kVulkanObjectTypeDevice, pAllocator, \"VUID-vkDestroyInstance-instance-00630\",\n                              \"VUID-vkDestroyInstance-instance-00631\", error_obj.location);\n"
        },
        {
            "role": "user",
            "content": "{\"VUID-vkDestroyDevice-device-00379\", \"If VkAllocationCallbacks were provided when device was created, a compatible set of callbacks must be provided here\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "bool skip = false;\n// Checked by chassis: device: \"VUID-vkDestroyDevice-device-parameter\"\nskip |= ValidateDestroyObject(device, kVulkanObjectTypeDevice, pAllocator, \"VUID-vkDestroyDevice-device-00379\",\n                              \"VUID-vkDestroyDevice-device-00380\", error_obj.location);\n"
        },
        {
            "role": "user",
            "content": "{\"VUID-vkFreeCommandBuffers-commandPool-parameter\", \"commandPool must be a valid VkCommandPool handle\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "bool skip = false;\n// Checked by chassis: device: \"VUID-vkFreeCommandBuffers-device-parameter\"\nskip |= ValidateObject(commandPool, kVulkanObjectTypeCommandPool, false, \"VUID-vkFreeCommandBuffers-commandPool-parameter\",\n                       \"VUID-vkFreeCommandBuffers-commandPool-parent\", error_obj.location.dot(Field::commandPool));\n"
        },
        {
            "role": "user",
            "content": "{\"VUID-vkDestroyCommandPool-commandPool-parameter\", \"If commandPool is not VK_NULL_HANDLE, commandPool must be a valid VkCommandPool handle\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "// Checked by chassis: device: \"VUID-vkDestroyCommandPool-device-parameter\"\nconst Location command_pool_loc = error_obj.location.dot(Field::commandPool);\nskip |= ValidateObject(commandPool, kVulkanObjectTypeCommandPool, true, \"VUID-vkDestroyCommandPool-commandPool-parameter\",\n                       \"VUID-vkDestroyCommandPool-commandPool-parent\", command_pool_loc);\n"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkDebugMarkerObjectTagInfoEXT-object-01494\", \"object must not be VK_NULL_HANDLE\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (pTagInfo->object == (uint64_t)VK_NULL_HANDLE) {\n    skip |= LogError(\"VUID-VkDebugMarkerObjectTagInfoEXT-object-01494\", device,\n                     error_obj.location.dot(Field::pTagInfo).dot(Field::object), \"is VK_NULL_HANDLE.\");\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkDebugMarkerObjectNameInfoEXT-objectType-01490\", \"objectType must not be VK_DEBUG_REPORT_OBJECT_TYPE_UNKNOWN_EXT\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (pNameInfo->objectType == VK_DEBUG_REPORT_OBJECT_TYPE_UNKNOWN_EXT) {\n    skip |= LogError(\"VUID-VkDebugMarkerObjectNameInfoEXT-objectType-01490\", device,\n                     error_obj.location.dot(Field::pNameInfo).dot(Field::objectType),\n                     \"is VK_DEBUG_REPORT_OBJECT_TYPE_UNKNOWN_EXT.\");\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkDebugMarkerObjectNameInfoEXT-object-01491\", \"object must not be VK_NULL_HANDLE\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (pNameInfo->object == (uint64_t)VK_NULL_HANDLE) {\n    skip |= LogError(\"VUID-VkDebugMarkerObjectNameInfoEXT-object-01491\", device,\n                     error_obj.location.dot(Field::pNameInfo).dot(Field::object), \"is VK_NULL_HANDLE.\");\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkDebugMarkerObjectNameInfoEXT-object-01492\", \"object must be a Vulkan object of the type associated with objectType as defined in VkDebugReportObjectTypeEXT and Vulkan Handle Relationship\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (object_type != kVulkanObjectTypeImage || !swapchain_image_map.contains(pNameInfo->object)) {\n    skip |= LogError(\"VUID-VkDebugMarkerObjectNameInfoEXT-object-01492\", device,\n                     error_obj.location.dot(Field::pNameInfo).dot(Field::objectType),\n                     \"(%s) doesn't match the object (0x%\" PRIx64 \").\",\n                     string_VkDebugReportObjectTypeEXT(pNameInfo->objectType), pNameInfo->object);\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-vkSetDebugUtilsObjectNameEXT-pNameInfo-07874\", \"If pNameInfo->objectHandle is the valid handle of a device-level object, that object must be a descendent of the VkDevice identified by device\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (HandleToUint64(device) != object_handle) {\n    skip |= LogError(\"VUID-vkSetDebugUtilsObjectNameEXT-pNameInfo-07874\", device, error_obj.location.dot(Field::objectType),\n                     \"is VK_OBJECT_TYPE_DEVICE but objectHandle (0x%\" PRIx64 \") != device (%s).\", object_handle,\n                     FormatHandle(device).c_str());\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-vkSetDebugUtilsObjectTagEXT-pNameInfo-07877\", \"If pNameInfo->objectHandle is the valid handle of a device-level object, that object must be a descendent of the VkDevice identified by device\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (HandleToUint64(device) != object_handle) {\n    skip |= LogError(\"VUID-vkSetDebugUtilsObjectTagEXT-pNameInfo-07877\", device,\n                     error_obj.location.dot(Field::pTagInfo).dot(Field::objectType),\n                     \"is VK_OBJECT_TYPE_DEVICE but objectHandle (0x%\" PRIx64 \") != device (%s).\", object_handle,\n                     FormatHandle(device).c_str());\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkDebugUtilsObjectTagInfoEXT-objectHandle-01910\", \"objectHandle must be a valid Vulkan handle of the type associated with objectType as defined in the VkObjectType and Vulkan Handle Relationship table\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "skip |= ValidateAnonymousObject(object_handle, object_type, \"VUID-VkDebugUtilsObjectTagInfoEXT-objectHandle-01910\",\n                                \"VUID-vkSetDebugUtilsObjectTagEXT-pNameInfo-07877\",\n                                error_obj.location.dot(Field::pTagInfo).dot(Field::objectHandle));\n"
        },
        {
            "role": "user",
            "content": "{\"VUID-vkCmdBuildAccelerationStructuresKHR-srcAccelerationStructure-04629\", \"If the srcAccelerationStructure member of any element of pInfos is not VK_NULL_HANDLE, the srcAccelerationStructure member must be a valid VkAccelerationStructureKHR handle\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "bool skip = false;\n// Checked by chassis: commandBuffer: \"VUID-vkCmdBuildAccelerationStructuresKHR-commandBuffer-parameter\"\nskip |= ValidateAccelerationStructures(\"VUID-vkCmdBuildAccelerationStructuresKHR-srcAccelerationStructure-04629\",\n                                       \"VUID-vkCmdBuildAccelerationStructuresKHR-dstAccelerationStructure-03800\", infoCount,\n                                       pInfos, error_obj.location);\n"
        },
        {
            "role": "user",
            "content": "{\"VUID-vkCmdBuildAccelerationStructuresIndirectKHR-srcAccelerationStructure-04629\", \"If the srcAccelerationStructure member of any element of pInfos is not VK_NULL_HANDLE, the srcAccelerationStructure member must be a valid VkAccelerationStructureKHR handle\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "bool skip = false;\n// Checked by chassis: commandBuffer: \"VUID-vkCmdBuildAccelerationStructuresIndirectKHR-commandBuffer-parameter\"\nskip |= ValidateAccelerationStructures(\"VUID-vkCmdBuildAccelerationStructuresIndirectKHR-srcAccelerationStructure-04629\",\n                                       \"VUID-vkCmdBuildAccelerationStructuresIndirectKHR-dstAccelerationStructure-03800\",\n                                       infoCount, pInfos, error_obj.location);\n"
        },
        {
            "role": "user",
            "content": "{\"VUID-vkSetPrivateData-objectHandle-04016\", \"objectHandle must be device or a child of device\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (IsInstanceVkObjectType(objectType) || objectType == VK_OBJECT_TYPE_UNKNOWN) {\n    skip |= LogError(\"VUID-vkSetPrivateData-objectHandle-04016\", device, error_obj.location.dot(Field::objectType), \"is %s.\",\n                     string_VkObjectType(objectType));\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-vkSetPrivateData-objectHandle-04016\", \"objectHandle must be device or a child of device\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (HandleToUint64(device) != objectHandle) {\n    skip |= LogError(\"VUID-vkSetPrivateData-objectHandle-04016\", device, error_obj.location.dot(Field::objectType),\n                     \"is VK_OBJECT_TYPE_DEVICE but objectHandle (0x%\" PRIx64 \") != device (%s).\", objectHandle,\n                     FormatHandle(device).c_str());\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-vkSetPrivateData-objectHandle-04017\", \"objectHandle must be a valid handle to an object of type objectType\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "skip |= ValidateAnonymousObject(objectHandle, objectType, \"VUID-vkSetPrivateData-objectHandle-04017\",\n                                \"VUID-vkSetPrivateData-objectHandle-04016\", error_obj.location.dot(Field::objectHandle));\n"
        },
        {
            "role": "user",
            "content": "{\"VUID-vkGetPrivateData-objectType-04018\", \"objectHandle must be device or a child of device\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (IsInstanceVkObjectType(objectType) || objectType == VK_OBJECT_TYPE_UNKNOWN) {\n    skip |= LogError(\"VUID-vkGetPrivateData-objectType-04018\", device, error_obj.location.dot(Field::objectType), \"is %s.\",\n                     string_VkObjectType(objectType));\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-vkGetPrivateData-objectHandle-09498\", \"objectHandle must be a valid handle to an object of type objectType\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "skip |= ValidateAnonymousObject(objectHandle, objectType, \"VUID-vkGetPrivateData-objectHandle-09498\",\n                                \"VUID-vkGetPrivateData-objectType-04018\", error_obj.location.dot(Field::objectHandle));\n"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkBufferCreateInfo-size-00912\", \"size must be greater than 0\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "return skip;\nconst Location create_info_loc = error_obj.location.dot(Field::pCreateInfo);\nskip |= ValidateNotZero(pCreateInfo->size == 0, \"VUID-VkBufferCreateInfo-size-00912\", create_info_loc.dot(Field::size));\n"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkBufferCreateInfo-sharingMode-00914\", \"If sharingMode is VK_SHARING_MODE_CONCURRENT, queueFamilyIndexCount must be greater than 1\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (pCreateInfo->queueFamilyIndexCount <= 1) {\n    skip |= LogError(\"VUID-VkBufferCreateInfo-sharingMode-00914\", device, create_info_loc.dot(Field::sharingMode),\n                     \"VK_SHARING_MODE_CONCURRENT, but queueFamilyIndexCount is %\" PRIu32 \".\",\n                     pCreateInfo->queueFamilyIndexCount);\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkBufferCreateInfo-sharingMode-00913\", \"If sharingMode is VK_SHARING_MODE_CONCURRENT, pQueueFamilyIndices must be a valid pointer to an array of queueFamilyIndexCount uint32_t values\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (pCreateInfo->pQueueFamilyIndices == nullptr) {\n    skip |= LogError(\"VUID-VkBufferCreateInfo-sharingMode-00913\", device, create_info_loc.dot(Field::sharingMode),\n                     \"is VK_SHARING_MODE_CONCURRENT, but pQueueFamilyIndices is NULL.\");\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkBufferCreateInfo-flags-00916\", \"If the sparseResidencyBuffer feature is not enabled, flags must not contain VK_BUFFER_CREATE_SPARSE_RESIDENCY_BIT\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if ((pCreateInfo->flags & VK_BUFFER_CREATE_SPARSE_RESIDENCY_BIT) && (!enabled_features.sparseResidencyBuffer)) {\n    skip |= LogError(\"VUID-VkBufferCreateInfo-flags-00916\", device, create_info_loc.dot(Field::flags),\n                     \"includes VK_BUFFER_CREATE_SPARSE_RESIDENCY_BIT, but the sparseResidencyBuffer feature is not enabled.\");\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkBufferCreateInfo-flags-00917\", \"If the sparseResidencyAliased feature is not enabled, flags must not contain VK_BUFFER_CREATE_SPARSE_ALIASED_BIT\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if ((pCreateInfo->flags & VK_BUFFER_CREATE_SPARSE_ALIASED_BIT) && (!enabled_features.sparseResidencyAliased)) {\n    skip |= LogError(\"VUID-VkBufferCreateInfo-flags-00917\", device, create_info_loc.dot(Field::flags),\n                     \"includes VK_BUFFER_CREATE_SPARSE_ALIASED_BIT, but the sparseResidencyAliased feature is not enabled.\");\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkBufferCreateInfo-flags-00918\", \"If flags contains VK_BUFFER_CREATE_SPARSE_RESIDENCY_BIT or VK_BUFFER_CREATE_SPARSE_ALIASED_BIT, it must also contain VK_BUFFER_CREATE_SPARSE_BINDING_BIT\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (((pCreateInfo->flags & (VK_BUFFER_CREATE_SPARSE_RESIDENCY_BIT | VK_BUFFER_CREATE_SPARSE_ALIASED_BIT)) != 0) &&\n    ((pCreateInfo->flags & VK_BUFFER_CREATE_SPARSE_BINDING_BIT) != VK_BUFFER_CREATE_SPARSE_BINDING_BIT)) {\n    skip |= LogError(\"VUID-VkBufferCreateInfo-flags-00918\", device, create_info_loc.dot(Field::flags), \"is %s.\",\n                     string_VkBufferCreateFlags(pCreateInfo->flags).c_str());\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkBufferCreateInfo-size-06409\", \"size must be less than or equal to VkPhysicalDeviceMaintenance4Properties::maxBufferSize\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (pCreateInfo->size > phys_dev_ext_props.maintenance4_props.maxBufferSize) {\n    skip |= LogError(\"VUID-VkBufferCreateInfo-size-06409\", device, create_info_loc.dot(Field::size),\n                     \"(%\" PRIu64\n                     \") is larger than the maximum allowed buffer size \"\n                     \"VkPhysicalDeviceMaintenance4Properties.maxBufferSize (%\" PRIu64 \").\",\n                     pCreateInfo->size, phys_dev_ext_props.maintenance4_props.maxBufferSize);\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-vkCmdBindVertexBuffers-firstBinding-00624\", \"firstBinding must be less than VkPhysicalDeviceLimits::maxVertexInputBindings\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (firstBinding > device_limits.maxVertexInputBindings) {\n    skip |= LogError(\"VUID-vkCmdBindVertexBuffers-firstBinding-00624\", commandBuffer, error_obj.location,\n                     \"firstBinding (%\" PRIu32 \") must be less than maxVertexInputBindings (%\" PRIu32 \").\", firstBinding,\n                     device_limits.maxVertexInputBindings);\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-vkCmdBindVertexBuffers-firstBinding-00625\", \"The sum of firstBinding and bindingCount must be less than or equal to VkPhysicalDeviceLimits::maxVertexInputBindings\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "\"firstBinding (%\" PRIu32 \") must be less than maxVertexInputBindings (%\" PRIu32 \").\", firstBinding,\n} else if ((firstBinding + bindingCount) > device_limits.maxVertexInputBindings) {\nskip |= LogError(\"VUID-vkCmdBindVertexBuffers-firstBinding-00625\", commandBuffer, error_obj.location,\n\"sum of firstBinding (%\" PRIu32 \") and bindingCount (%\" PRIu32\n\") must be less than \"\n\"maxVertexInputBindings (%\" PRIu32 \").\",\nfirstBinding, bindingCount, device_limits.maxVertexInputBindings);\n"
        },
        {
            "role": "user",
            "content": "{\"VUID-vkCmdBindVertexBuffers-pBuffers-parameter\", \"pBuffers must be a valid pointer to an array of bindingCount valid or VK_NULL_HANDLE VkBuffer handles\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (pBuffers == nullptr) {\n    skip |= LogError(\"VUID-vkCmdBindVertexBuffers-pBuffers-parameter\", commandBuffer,\n                     error_obj.location.dot(Field::pBuffers), \"is NULL.\");\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-vkCmdBindVertexBuffers-pBuffers-04001\", \"If the nullDescriptor feature is not enabled, all elements of pBuffers must not be VK_NULL_HANDLE\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (!enabled_features.nullDescriptor) {\n    skip |= LogError(\"VUID-vkCmdBindVertexBuffers-pBuffers-04001\", commandBuffer, buffer_loc, \"is VK_NULL_HANDLE.\");\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-vkCmdBindTransformFeedbackBuffersEXT-transformFeedback-02355\", \"VkPhysicalDeviceTransformFeedbackFeaturesEXT::transformFeedback must be enabled\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (!enabled_features.transformFeedback) {\n    skip |= LogError(\"VUID-vkCmdBindTransformFeedbackBuffersEXT-transformFeedback-02355\", commandBuffer, error_obj.location,\n                     \"transformFeedback feature was not enabled.\");\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-vkCmdBindTransformFeedbackBuffersEXT-pOffsets-02359\", \"All elements of pOffsets must be a multiple of 4\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (pOffsets[i] & 3) {\n    skip |= LogError(\"VUID-vkCmdBindTransformFeedbackBuffersEXT-pOffsets-02359\", commandBuffer,\n                     error_obj.location.dot(Field::pOffsets, i), \"(%\" PRIu64 \") is not a multiple of 4.\", pOffsets[i]);\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-vkCmdBindTransformFeedbackBuffersEXT-firstBinding-02356\", \"firstBinding must be less than VkPhysicalDeviceTransformFeedbackPropertiesEXT::maxTransformFeedbackBuffers\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (firstBinding >= phys_dev_ext_props.transform_feedback_props.maxTransformFeedbackBuffers) {\n    skip |= LogError(\"VUID-vkCmdBindTransformFeedbackBuffersEXT-firstBinding-02356\", commandBuffer, error_obj.location,\n                     \"The firstBinding(%\" PRIu32\n                     \") index is greater than or equal to \"\n                     \"maxTransformFeedbackBuffers(%\" PRIu32 \").\",\n                     firstBinding, phys_dev_ext_props.transform_feedback_props.maxTransformFeedbackBuffers);\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-vkCmdBindTransformFeedbackBuffersEXT-firstBinding-02357\", \"The sum of firstBinding and bindingCount must be less than or equal to VkPhysicalDeviceTransformFeedbackPropertiesEXT::maxTransformFeedbackBuffers\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (firstBinding + bindingCount > phys_dev_ext_props.transform_feedback_props.maxTransformFeedbackBuffers) {\n    skip |= LogError(\"VUID-vkCmdBindTransformFeedbackBuffersEXT-firstBinding-02357\", commandBuffer, error_obj.location,\n                     \"The sum of firstBinding(%\" PRIu32 \") and bindCount(%\" PRIu32\n                     \") is greater than maxTransformFeedbackBuffers(%\" PRIu32 \").\",\n                     firstBinding, bindingCount, phys_dev_ext_props.transform_feedback_props.maxTransformFeedbackBuffers);\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-vkCmdBeginTransformFeedbackEXT-transformFeedback-02366\", \"VkPhysicalDeviceTransformFeedbackFeaturesEXT::transformFeedback must be enabled\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (!enabled_features.transformFeedback) {\n    skip |= LogError(\"VUID-vkCmdBeginTransformFeedbackEXT-transformFeedback-02366\", commandBuffer, error_obj.location,\n                     \"transformFeedback feature was not enabled.\");\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-vkCmdBeginTransformFeedbackEXT-firstCounterBuffer-02368\", \"firstCounterBuffer must be less than VkPhysicalDeviceTransformFeedbackPropertiesEXT::maxTransformFeedbackBuffers\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (firstCounterBuffer >= phys_dev_ext_props.transform_feedback_props.maxTransformFeedbackBuffers) {\n    skip |= LogError(\"VUID-vkCmdBeginTransformFeedbackEXT-firstCounterBuffer-02368\", commandBuffer, error_obj.location,\n                     \"The firstCounterBuffer(%\" PRIu32\n                     \") index is greater than or equal to \"\n                     \"maxTransformFeedbackBuffers(%\" PRIu32 \").\",\n                     firstCounterBuffer, phys_dev_ext_props.transform_feedback_props.maxTransformFeedbackBuffers);\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-vkCmdBeginTransformFeedbackEXT-firstCounterBuffer-02369\", \"The sum of firstCounterBuffer and counterBufferCount must be less than or equal to VkPhysicalDeviceTransformFeedbackPropertiesEXT::maxTransformFeedbackBuffers\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (firstCounterBuffer + counterBufferCount > phys_dev_ext_props.transform_feedback_props.maxTransformFeedbackBuffers) {\n    skip |= LogError(\"VUID-vkCmdBeginTransformFeedbackEXT-firstCounterBuffer-02369\", commandBuffer, error_obj.location,\n                     \"The sum of firstCounterBuffer(%\" PRIu32 \") and counterBufferCount(%\" PRIu32\n                     \") is greater than maxTransformFeedbackBuffers(%\" PRIu32 \").\",\n                     firstCounterBuffer, counterBufferCount,\n                     phys_dev_ext_props.transform_feedback_props.maxTransformFeedbackBuffers);\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-vkCmdEndTransformFeedbackEXT-transformFeedback-02374\", \"VkPhysicalDeviceTransformFeedbackFeaturesEXT::transformFeedback must be enabled\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (!enabled_features.transformFeedback) {\n    skip |= LogError(\"VUID-vkCmdEndTransformFeedbackEXT-transformFeedback-02374\", commandBuffer, error_obj.location,\n                     \"transformFeedback feature was not enabled.\");\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-vkCmdEndTransformFeedbackEXT-firstCounterBuffer-02376\", \"firstCounterBuffer must be less than VkPhysicalDeviceTransformFeedbackPropertiesEXT::maxTransformFeedbackBuffers\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (firstCounterBuffer >= phys_dev_ext_props.transform_feedback_props.maxTransformFeedbackBuffers) {\n    skip |= LogError(\"VUID-vkCmdEndTransformFeedbackEXT-firstCounterBuffer-02376\", commandBuffer, error_obj.location,\n                     \"The firstCounterBuffer(%\" PRIu32\n                     \") index is greater than or equal to \"\n                     \"maxTransformFeedbackBuffers(%\" PRIu32 \").\",\n                     firstCounterBuffer, phys_dev_ext_props.transform_feedback_props.maxTransformFeedbackBuffers);\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-vkCmdEndTransformFeedbackEXT-firstCounterBuffer-02377\", \"The sum of firstCounterBuffer and counterBufferCount must be less than or equal to VkPhysicalDeviceTransformFeedbackPropertiesEXT::maxTransformFeedbackBuffers\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (firstCounterBuffer + counterBufferCount > phys_dev_ext_props.transform_feedback_props.maxTransformFeedbackBuffers) {\n    skip |= LogError(\"VUID-vkCmdEndTransformFeedbackEXT-firstCounterBuffer-02377\", commandBuffer, error_obj.location,\n                     \"The sum of firstCounterBuffer(%\" PRIu32 \") and counterBufferCount(%\" PRIu32\n                     \") is greater than maxTransformFeedbackBuffers(%\" PRIu32 \").\",\n                     firstCounterBuffer, counterBufferCount,\n                     phys_dev_ext_props.transform_feedback_props.maxTransformFeedbackBuffers);\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-vkCmdBindVertexBuffers2-bindingCount-arraylength\", \"If any of pSizes, or pStrides are not NULL, bindingCount must be greater than 0\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "skip |= LogError(\"VUID-vkCmdBindVertexBuffers2-bindingCount-arraylength\", commandBuffer, error_obj.location,\n                 \"%s, so bindingCount must be greater than 0.\", not_null_msg);\n"
        },
        {
            "role": "user",
            "content": "{\"VUID-vkCmdBindVertexBuffers2-pOffsets-parameter\", \"pOffsets must be a valid pointer to an array of bindingCount VkDeviceSize values\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (!pOffsets && bindingCount > 0) {\n    skip |= LogError(\"VUID-vkCmdBindVertexBuffers2-pOffsets-parameter\", commandBuffer,\n                     error_obj.location.dot(Field::pOffsets), \"is NULL.\");\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-vkCmdBindVertexBuffers2-pBuffers-04111\", \"If the nullDescriptor feature is not enabled, all elements of pBuffers must not be VK_NULL_HANDLE\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (!enabled_features.nullDescriptor) {\n    skip |= LogError(\"VUID-vkCmdBindVertexBuffers2-pBuffers-04111\", commandBuffer, buffer_loc, \"is VK_NULL_HANDLE.\");\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-vkCmdBindVertexBuffers2-pBuffers-04112\", \"If an element of pBuffers is VK_NULL_HANDLE, then the corresponding element of pOffsets must be zero\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (!enabled_features.nullDescriptor) {\n    skip |= LogError(\"VUID-vkCmdBindVertexBuffers2-pBuffers-04111\", commandBuffer, buffer_loc, \"is VK_NULL_HANDLE.\");\n    skip |= LogError(\"VUID-vkCmdBindVertexBuffers2-pBuffers-04112\", commandBuffer, buffer_loc,\n                     \"is VK_NULL_HANDLE, but pOffsets[%\" PRIu32 \"] is not 0.\", i);\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-vkCmdBindVertexBuffers2-pStrides-03362\", \"If pStrides is not NULL each element of pStrides must be less than or equal to VkPhysicalDeviceLimits::maxVertexInputBindingStride\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (pStrides[i] > device_limits.maxVertexInputBindingStride) {\n    skip |= LogError(\"VUID-vkCmdBindVertexBuffers2-pStrides-03362\", commandBuffer,\n                     error_obj.location.dot(Field::pStrides, i),\n                     \"(%\" PRIu64 \") must be less than maxVertexInputBindingStride (%\" PRIu32 \").\", pStrides[i],\n                     device_limits.maxVertexInputBindingStride);\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkPushConstantsInfoKHR-None-09495\", \"If the dynamicPipelineLayout feature is not enabled, layout must be a valid VkPipelineLayout handle\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (!enabled_features.dynamicPipelineLayout) {\n    skip |= LogError(\"VUID-VkPushConstantsInfoKHR-None-09495\", commandBuffer,\n                     error_obj.location.dot(Field::pPushConstantsInfo).dot(Field::layout), \"is VK_NULL_HANDLE.\");\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-vkCmdClearColorImage-pColor-04961\", \"pColor must be a valid pointer to a VkClearColorValue union\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (!pColor) {\n    skip |= LogError(\"VUID-vkCmdClearColorImage-pColor-04961\", commandBuffer, error_obj.location, \"pColor must not be null\");\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-vkGetQueryPoolResults-flags-09443\", \"If flags includes VK_QUERY_RESULT_WITH_STATUS_BIT_KHR, then it must not include VK_QUERY_RESULT_WITH_AVAILABILITY_BIT\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if ((flags & VK_QUERY_RESULT_WITH_STATUS_BIT_KHR) && (flags & VK_QUERY_RESULT_WITH_AVAILABILITY_BIT)) {\n    skip |= LogError(\"VUID-vkGetQueryPoolResults-flags-09443\", device, error_obj.location.dot(Field::flags),\n                     \"(%s) include both STATUS_BIT and AVAILABILITY_BIT.\", string_VkQueryResultFlags(flags).c_str());\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkConditionalRenderingBeginInfoEXT-offset-01984\", \"offset must be a multiple of 4\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if ((pConditionalRenderingBegin->offset & 3) != 0) {\n    skip |= LogError(\"VUID-VkConditionalRenderingBeginInfoEXT-offset-01984\", commandBuffer, error_obj.location,\n                     \" pConditionalRenderingBegin->offset (%\" PRIu64 \") is not a multiple of 4.\",\n                     pConditionalRenderingBegin->offset);\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-vkCmdClearAttachments-rect-02682\", \"The rect member of each element of pRects must have an extent.width greater than 0\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (pRects[rect].rect.extent.width == 0) {\n    skip |= LogError(\"VUID-vkCmdClearAttachments-rect-02682\", commandBuffer,\n                     rect_loc.dot(Field::rect).dot(Field::extent).dot(Field::width), \"is zero.\");\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkBufferCopy-size-01988\", \"The size must be greater than 0\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (pRegions[i].size == 0) {\n    skip |= LogError(\"VUID-VkBufferCopy-size-01988\", commandBuffer,\n                     error_obj.location.dot(Field::pRegions, i).dot(Field::size), \"is zero\");\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-vkCmdUpdateBuffer-dstOffset-00036\", \"dstOffset must be a multiple of 4\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (dstOffset & 3) {\n    const LogObjectList objlist(commandBuffer, dstBuffer);\n    skip |= LogError(\"VUID-vkCmdUpdateBuffer-dstOffset-00036\", objlist, error_obj.location.dot(Field::dstOffset),\n                     \"(%\" PRIu64 \"), is not a multiple of 4.\", dstOffset);\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-vkCmdUpdateBuffer-dataSize-00037\", \"dataSize must be less than or equal to 65536\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if ((dataSize <= 0) || (dataSize > 65536)) {\n    const LogObjectList objlist(commandBuffer, dstBuffer);\n    skip |= LogError(\"VUID-vkCmdUpdateBuffer-dataSize-00037\", objlist, error_obj.location.dot(Field::dataSize),\n                     \"(%\" PRIu64 \"), must be greater than zero and less than or equal to 65536.\", dataSize);\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-vkCmdUpdateBuffer-dataSize-00038\", \"dataSize must be a multiple of 4\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "\"(%\" PRIu64 \"), must be greater than zero and less than or equal to 65536.\", dataSize);\n} else if (dataSize & 3) {\nconst LogObjectList objlist(commandBuffer, dstBuffer);\nskip |= LogError(\"VUID-vkCmdUpdateBuffer-dataSize-00038\", objlist, error_obj.location.dot(Field::dataSize),\n\"(%\" PRIu64 \"), is not a multiple of 4.\", dataSize);\n"
        },
        {
            "role": "user",
            "content": "{\"VUID-vkCmdFillBuffer-size-00026\", \"If size is not equal to VK_WHOLE_SIZE, size must be greater than 0\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (size <= 0) {\n    const LogObjectList objlist(commandBuffer, dstBuffer);\n    skip |= LogError(\"VUID-vkCmdFillBuffer-size-00026\", objlist, error_obj.location.dot(Field::size),\n                     \"(%\" PRIu64 \") must be greater than zero.\", size);\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-vkCmdFillBuffer-size-00028\", \"If size is not equal to VK_WHOLE_SIZE, size must be a multiple of 4\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "\"(%\" PRIu64 \") must be greater than zero.\", size);\n} else if (size & 3) {\nconst LogObjectList objlist(commandBuffer, dstBuffer);\nskip |= LogError(\"VUID-vkCmdFillBuffer-size-00028\", objlist, error_obj.location.dot(Field::size),\n\"(%\" PRIu64 \") is not a multiple of 4.\", size);\n"
        },
        {
            "role": "user",
            "content": "{\"VUID-vkCmdBindDescriptorBuffersEXT-None-08047\", \"The descriptorBuffer feature must be enabled\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (!enabled_features.descriptorBuffer) {\n    skip |= LogError(\"VUID-vkCmdBindDescriptorBuffersEXT-None-08047\", commandBuffer, error_obj.location,\n                     \"descriptorBuffer feature was not enabled.\");\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkPushDescriptorSetInfoKHR-None-09495\", \"If the dynamicPipelineLayout feature is not enabled, layout must be a valid VkPipelineLayout handle\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (!enabled_features.dynamicPipelineLayout) {\n    skip |= LogError(\"VUID-VkPushDescriptorSetInfoKHR-None-09495\", commandBuffer,\n                     error_obj.location.dot(Field::pPushDescriptorSetInfo).dot(Field::layout), \"is VK_NULL_HANDLE.\");\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkViewport-width-01771\", \"width must be less than or equal to VkPhysicalDeviceLimits::maxViewportDimensions[0]\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "LogError(\"VUID-VkViewport-width-01770\", object, loc.dot(Field::width), \"(%f) is not greater than 0.0.\", viewport.width);\n} else if (!(f_lte_u32_exact(viewport.width, max_w) || f_lte_u32_direct(viewport.width, max_w))) {\nskip |= LogError(\"VUID-VkViewport-width-01771\", object, loc.dot(Field::width),\n             \"(%f) exceeds VkPhysicalDeviceLimits::maxViewportDimensions[0] (%\" PRIu32 \").\", viewport.width, max_w);\n"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkViewport-apiVersion-07917\", \"If the VK_KHR_maintenance1 extension is not enabled, the VK_AMD_negative_viewport_height extension is not enabled, and VkPhysicalDeviceProperties::apiVersion is less than Vulkan 1.1, height must be greater than 0.0\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (!negative_height_enabled && !(viewport.height > 0.0f)) {\n    skip |= LogError(\"VUID-VkViewport-apiVersion-07917\", object, loc.dot(Field::height), \"(%f) is not greater 0.0.\",\n                     viewport.height);\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkViewport-height-01773\", \"The absolute value of height must be less than or equal to VkPhysicalDeviceLimits::maxViewportDimensions[1]\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "} else if (!(f_lte_u32_exact(fabsf(viewport.height), max_h) || f_lte_u32_direct(fabsf(viewport.height), max_h))) {\n    skip |= LogError(\"VUID-VkViewport-height-01773\", object, loc.dot(Field::height),\n                     \"absolute value (%f) exceeds VkPhysicalDeviceLimits::maxViewportDimensions[1] (%\" PRIu32 \").\",\n                     viewport.height, max_h);\n"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkViewport-x-01774\", \"x must be greater than or equal to viewportBoundsRange[0]\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (!(viewport.x >= device_limits.viewportBoundsRange[0])) {\n    skip |= LogError(\"VUID-VkViewport-x-01774\", object, loc.dot(Field::x),\n                     \"(%f) is less than VkPhysicalDeviceLimits::viewportBoundsRange[0] (%f).\", viewport.x,\n                     device_limits.viewportBoundsRange[0]);\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkViewport-y-01775\", \"y must be greater than or equal to viewportBoundsRange[0]\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (!(viewport.y >= device_limits.viewportBoundsRange[0])) {\n    skip |= LogError(\"VUID-VkViewport-y-01775\", object, loc.dot(Field::y),\n                     \"(%f) is less than VkPhysicalDeviceLimits::viewportBoundsRange[0] (%f).\", viewport.y,\n                     device_limits.viewportBoundsRange[0]);\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkViewport-y-01776\", \"y must be less than or equal to viewportBoundsRange[1]\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "} else if (negative_height_enabled && viewport.y > device_limits.viewportBoundsRange[1]) {\n    skip |= LogError(\"VUID-VkViewport-y-01776\", object, loc.dot(Field::y),\n                     \"(%f) exceeds VkPhysicalDeviceLimits::viewportBoundsRange[1] (%f).\", viewport.y,\n                     device_limits.viewportBoundsRange[1]);\n"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkViewport-y-01233\", \"(y + height) must be less than or equal to viewportBoundsRange[1]\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (boundary > device_limits.viewportBoundsRange[1]) {\n    skip |= LogError(\"VUID-VkViewport-y-01233\", object, loc,\n                     \"y (%f) + height (%f) is %f which exceeds VkPhysicalDeviceLimits::viewportBoundsRange[1] (%f).\",\n                     viewport.y, viewport.height, boundary, device_limits.viewportBoundsRange[1]);\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkViewport-y-01777\", \"(y + height) must be greater than or equal to viewportBoundsRange[0]\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "\"y (%f) + height (%f) is %f which exceeds VkPhysicalDeviceLimits::viewportBoundsRange[1] (%f).\",\nviewport.y, viewport.height, boundary, device_limits.viewportBoundsRange[1]);\nskip |= LogError(\"VUID-VkViewport-y-01777\", object, loc,\n\"y (%f) + height (%f) is %f which is less than VkPhysicalDeviceLimits::viewportBoundsRange[0] (%f).\",\nviewport.y, viewport.height, boundary, device_limits.viewportBoundsRange[0]);\n"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkViewport-maxDepth-01235\", \"If the VK_EXT_depth_range_unrestricted extension is not enabled, maxDepth must be between 0.0 and 1.0, inclusive\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (!(viewport.maxDepth >= 0.0) || !(viewport.maxDepth <= 1.0)) {\n    skip |= LogError(\"VUID-VkViewport-maxDepth-01235\", object, loc.dot(Field::maxDepth), \"is %f.\", viewport.maxDepth);\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkCommandBufferInheritanceViewportScissorInfoNV-viewportScissor2D-04783\", \"If the multiViewport feature is not enabled and viewportScissor2D is VK_TRUE, then viewportDepthCount must be 1\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (p_inherited_viewport_scissor_info != nullptr && !enabled_features.multiViewport &&\n    p_inherited_viewport_scissor_info->viewportScissor2D == VK_TRUE &&\n    skip |= LogError(\"VUID-VkCommandBufferInheritanceViewportScissorInfoNV-viewportScissor2D-04783\", commandBuffer,\n                     error_obj.location,\n                     \"multiViewport feature was not enabled, but \"\n                     \"VkCommandBufferInheritanceViewportScissorInfoNV::viewportScissor2D in \"\n                     \"pBeginInfo->pInheritanceInfo->pNext is VK_TRUE and viewportDepthCount is not 1.\");\n"
        },
        {
            "role": "user",
            "content": "{\"VUID-vkCmdSetViewportWithCount-viewportCount-03395\", \"If the multiViewport feature is not enabled, viewportCount must be 1\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (viewportCount != 1) {\n    skip |= LogError(\"VUID-vkCmdSetViewportWithCount-viewportCount-03395\", commandBuffer,\n                     error_obj.location.dot(Field::viewportCount),\n                     \"(%\" PRIu32 \") is not 1, but the multiViewport feature is not enabled.\", viewportCount);\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-vkCmdSetViewportWithCount-viewportCount-03394\", \"viewportCount must be between 1 and VkPhysicalDeviceLimits::maxViewports, inclusive\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (viewportCount < 1 || viewportCount > device_limits.maxViewports) {\n    skip |= LogError(\"VUID-vkCmdSetViewportWithCount-viewportCount-03394\", commandBuffer,\n                     error_obj.location.dot(Field::viewportCount),\n                     \"(%\" PRIu32\n                     \") must \"\n                     \"not be greater than VkPhysicalDeviceLimits::maxViewports (=%\" PRIu32 \").\",\n                     viewportCount, device_limits.maxViewports);\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-vkCmdSetScissorWithCount-scissorCount-03397\", \"scissorCount must be between 1 and VkPhysicalDeviceLimits::maxViewports, inclusive\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (scissorCount == 0) {\n    skip |= LogError(\"VUID-vkCmdSetScissorWithCount-scissorCount-03397\", commandBuffer,\n                     error_obj.location.dot(Field::scissorCount),\n                     \"(%\" PRIu32\n                     \") must \"\n                     \"be great than zero.\",\n                     scissorCount);\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-vkCmdSetScissorWithCount-scissorCount-03397\", \"scissorCount must be between 1 and VkPhysicalDeviceLimits::maxViewports, inclusive\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "scissorCount);\n} else if (scissorCount > device_limits.maxViewports) {\nskip |= LogError(\"VUID-vkCmdSetScissorWithCount-scissorCount-03397\", commandBuffer,\nerror_obj.location.dot(Field::scissorCount),\n\"(%\" PRIu32\n\") must \"\n\"not be greater than maxViewports (%\" PRIu32 \").\",\nscissorCount, device_limits.maxViewports);\n"
        },
        {
            "role": "user",
            "content": "{\"VUID-vkCmdSetScissorWithCount-x-03399\", \"The x and y members of offset member of any element of pScissors must be greater than or equal to 0\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (scissor.offset.x < 0) {\n    skip |= LogError(\"VUID-vkCmdSetScissorWithCount-x-03399\", commandBuffer,\n                     scissor_loc.dot(Field::offset).dot(Field::x), \"(%\" PRId32 \") is negative.\", scissor.offset.x);\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-vkCmdSetScissorWithCount-x-03399\", \"The x and y members of offset member of any element of pScissors must be greater than or equal to 0\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (scissor.offset.y < 0) {\n    skip |= LogError(\"VUID-vkCmdSetScissorWithCount-x-03399\", commandBuffer,\n                     scissor_loc.dot(Field::offset).dot(Field::y), \"(%\" PRId32 \") is negative.\", scissor.offset.y);\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-vkCmdSetScissorWithCount-offset-03401\", \"Evaluation of (offset.y + extent.height) must not cause a signed integer addition overflow for any element of pScissors\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (y_sum > vvl::kI32Max) {\n    skip |= LogError(\"VUID-vkCmdSetScissorWithCount-offset-03401\", commandBuffer, scissor_loc,\n                     \"offset.y (%\" PRId32 \") + extent.height (%\" PRIu32 \") is %\" PRIi64 \" which will overflow int32_t.\",\n                     scissor.offset.y, scissor.extent.height, y_sum);\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-vkCmdSetVertexInputEXT-vertexBindingDescriptionCount-04791\", \"vertexBindingDescriptionCount must be less than or equal to VkPhysicalDeviceLimits::maxVertexInputBindings\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (vertexBindingDescriptionCount > device_limits.maxVertexInputBindings) {\n    skip |= LogError(\"VUID-vkCmdSetVertexInputEXT-vertexBindingDescriptionCount-04791\", commandBuffer,\n                     error_obj.location.dot(Field::vertexBindingDescriptionCount),\n                     \"(%\" PRIu32 \") is greater than the maxVertexInputBindings limit (%\" PRIu32 \").\",\n                     vertexBindingDescriptionCount, device_limits.maxVertexInputBindings);\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-vkCmdSetVertexInputEXT-vertexAttributeDescriptionCount-04792\", \"vertexAttributeDescriptionCount must be less than or equal to VkPhysicalDeviceLimits::maxVertexInputAttributes\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (vertexAttributeDescriptionCount > device_limits.maxVertexInputAttributes) {\n    skip |= LogError(\"VUID-vkCmdSetVertexInputEXT-vertexAttributeDescriptionCount-04792\", commandBuffer,\n                     error_obj.location.dot(Field::vertexAttributeDescriptionCount),\n                     \"(%\" PRIu32 \") is greater than the maxVertexInputAttributes limit (%\" PRIu32 \").\",\n                     vertexAttributeDescriptionCount, device_limits.maxVertexInputAttributes);\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-vkCmdSetVertexInputEXT-binding-04793\", \"For every binding specified by each element of pVertexAttributeDescriptions, a VkVertexInputBindingDescription2EXT must exist in pVertexBindingDescriptions with the same value of binding\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (!binding_found) {\n    skip |= LogError(\"VUID-vkCmdSetVertexInputEXT-binding-04793\", commandBuffer,\n                     error_obj.location.dot(Field::pVertexAttributeDescriptions, attribute),\n                     \"references an unspecified binding.\");\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-vkCmdSetVertexInputEXT-pVertexAttributeDescriptions-04795\", \"All elements of pVertexAttributeDescriptions must describe distinct attribute locations\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (location_it != vertex_locations.cend()) {\n    skip |= LogError(\"VUID-vkCmdSetVertexInputEXT-pVertexAttributeDescriptions-04795\", commandBuffer,\n                     error_obj.location.dot(Field::pVertexAttributeDescriptions, location),\n                     \"is already in pVertexAttributeDescriptions[%\" PRIu32 \"].\", *location_it);\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkVertexInputBindingDescription2EXT-binding-04796\", \"binding must be less than VkPhysicalDeviceLimits::maxVertexInputBindings\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (pVertexBindingDescriptions[binding].binding > device_limits.maxVertexInputBindings) {\n    skip |= LogError(\"VUID-VkVertexInputBindingDescription2EXT-binding-04796\", commandBuffer,\n                     binding_loc.dot(Field::binding), \"(%\" PRIu32 \") is greater than maxVertexInputBindings (%\" PRIu32 \").\",\n                     pVertexBindingDescriptions[binding].binding, device_limits.maxVertexInputBindings);\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkVertexInputBindingDescription2EXT-stride-04797\", \"stride must be less than or equal to VkPhysicalDeviceLimits::maxVertexInputBindingStride\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (pVertexBindingDescriptions[binding].stride > device_limits.maxVertexInputBindingStride) {\n    skip |= LogError(\"VUID-VkVertexInputBindingDescription2EXT-stride-04797\", commandBuffer, binding_loc.dot(Field::stride),\n                     \"(%\" PRIu32 \") is greater than maxVertexInputBindingStride (%\" PRIu32 \").\",\n                     pVertexBindingDescriptions[binding].stride, device_limits.maxVertexInputBindingStride);\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkVertexInputBindingDescription2EXT-divisor-04799\", \"If the vertexAttributeInstanceRateDivisor feature is not enabled, divisor must be 1\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (!enabled_features.vertexAttributeInstanceRateDivisor) {\n    skip |= LogError(\"VUID-VkVertexInputBindingDescription2EXT-divisor-04799\", commandBuffer,\n                     binding_loc.dot(Field::divisor),\n                     \"is %\" PRIu32\n                     \" (greater than 1) but \"\n                     \"vertexAttributeInstanceRateDivisor feature was not enabled\",\n                     pVertexBindingDescriptions[binding].divisor);\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkVertexInputBindingDescription2EXT-divisor-06227\", \"If divisor is not 1 then inputRate must be of type VK_VERTEX_INPUT_RATE_INSTANCE\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (pVertexBindingDescriptions[binding].inputRate != VK_VERTEX_INPUT_RATE_INSTANCE) {\n    skip |= LogError(\"VUID-VkVertexInputBindingDescription2EXT-divisor-06227\", commandBuffer,\n                     binding_loc.dot(Field::divisor), \"is %\" PRIu32 \" (greater than 1) but inputRate is %s.\",\n                     pVertexBindingDescriptions[binding].divisor,\n                     string_VkVertexInputRate(pVertexBindingDescriptions[binding].inputRate));\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkVertexInputAttributeDescription2EXT-location-06228\", \"location must be less than VkPhysicalDeviceLimits::maxVertexInputAttributes\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (pVertexAttributeDescriptions[attribute].location > device_limits.maxVertexInputAttributes) {\n    skip |= LogError(\"VUID-VkVertexInputAttributeDescription2EXT-location-06228\", commandBuffer,\n                     attribute_loc.dot(Field::location),\n                     \"(%\" PRIu32 \") is greater than maxVertexInputAttributes (%\" PRIu32 \").\",\n                     pVertexAttributeDescriptions[attribute].location, device_limits.maxVertexInputAttributes);\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-vkCmdSetDiscardRectangleEXT-offset-00588\", \"Evaluation of (offset.x + extent.width) in each VkRect2D element of pDiscardRectangles must not cause a signed integer addition overflow\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (x_sum > std::numeric_limits<int32_t>::max()) {\n    skip |= LogError(\"VUID-vkCmdSetDiscardRectangleEXT-offset-00588\", commandBuffer, loc,\n                     \"offset.x (%\" PRId32 \") + extent.width (%\" PRIu32 \") is %\" PRIi64 \") which will overflow int32_t.\",\n                     pDiscardRectangles[i].offset.x, pDiscardRectangles[i].extent.width, x_sum);\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-vkCmdSetDiscardRectangleEXT-offset-00589\", \"Evaluation of (offset.y + extent.height) in each VkRect2D element of pDiscardRectangles must not cause a signed integer addition overflow\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (y_sum > std::numeric_limits<int32_t>::max()) {\n    skip |= LogError(\"VUID-vkCmdSetDiscardRectangleEXT-offset-00589\", commandBuffer, loc,\n                     \"offset.y (%\" PRId32 \") + extent.height (%\" PRIu32 \") is %\" PRIi64 \") which will overflow int32_t.\",\n                     pDiscardRectangles[i].offset.y, pDiscardRectangles[i].extent.height, y_sum);\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-vkCmdSetDiscardRectangleModeEXT-specVersion-07852\", \"The VK_EXT_discard_rectangles extension must be enabled, and the implementation must support at least specVersion 2 of this extension\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (discard_rectangles_extension_version < 2) {\n    skip |= LogError(\"VUID-vkCmdSetDiscardRectangleModeEXT-specVersion-07852\", commandBuffer, error_obj.location,\n                     \"Requires support for version 2 of VK_EXT_discard_rectangles.\");\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-vkCmdSetExclusiveScissorEnableNV-exclusiveScissor-07853\", \"The exclusiveScissor feature must be enabled, and the implementation must support at least specVersion 2 of the VK_NV_scissor_exclusive extension\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (scissor_exclusive_extension_version < 2) {\n    skip |= LogError(\"VUID-vkCmdSetExclusiveScissorEnableNV-exclusiveScissor-07853\", commandBuffer, error_obj.location,\n                     \"Requires support for version 2 of VK_NV_scissor_exclusive.\");\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-vkCmdSetExclusiveScissorNV-firstExclusiveScissor-02035\", \"If the multiViewport feature is not enabled, firstExclusiveScissor must be 0\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (firstExclusiveScissor != 0) {\n    skip |= LogError(\"VUID-vkCmdSetExclusiveScissorNV-firstExclusiveScissor-02035\", commandBuffer,\n                     error_obj.location.dot(Field::firstExclusiveScissor),\n                     \"is %\" PRIu32 \" but the multiViewport feature is not enabled.\", firstExclusiveScissor);\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-vkCmdSetExclusiveScissorNV-exclusiveScissorCount-02036\", \"If the multiViewport feature is not enabled, exclusiveScissorCount must be 1\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (exclusiveScissorCount > 1) {\n    skip |= LogError(\"VUID-vkCmdSetExclusiveScissorNV-exclusiveScissorCount-02036\", commandBuffer,\n                     error_obj.location.dot(Field::exclusiveScissorCount),\n                     \"is %\" PRIu32 \" but the multiViewport feature is not enabled.\", exclusiveScissorCount);\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-vkCmdSetExclusiveScissorNV-x-02037\", \"The x and y members of offset in each member of pExclusiveScissors must be greater than or equal to 0\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (scissor.offset.x < 0) {\n    skip |= LogError(\"VUID-vkCmdSetExclusiveScissorNV-x-02037\", commandBuffer,\n                     scissor_loc.dot(Field::offset).dot(Field::x), \"(%\" PRId32 \") is negative.\", scissor.offset.x);\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-vkCmdSetExclusiveScissorNV-x-02037\", \"The x and y members of offset in each member of pExclusiveScissors must be greater than or equal to 0\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (scissor.offset.y < 0) {\n    skip |= LogError(\"VUID-vkCmdSetExclusiveScissorNV-x-02037\", commandBuffer,\n                     scissor_loc.dot(Field::offset).dot(Field::y), \"(%\" PRId32 \") is negative.\", scissor.offset.y);\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-vkCmdSetExclusiveScissorNV-offset-02038\", \"Evaluation of (offset.x + extent.width) for each member of pExclusiveScissors must not cause a signed integer addition overflow\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (x_sum > vvl::kI32Max) {\n    skip |= LogError(\"VUID-vkCmdSetExclusiveScissorNV-offset-02038\", commandBuffer, scissor_loc,\n                     \"offset.x (%\" PRId32 \") + extent.width (%\" PRIu32 \") is %\" PRIi64 \" which will overflow int32_t.\",\n                     scissor.offset.x, scissor.extent.width, x_sum);\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-vkCmdSetExclusiveScissorNV-offset-02039\", \"Evaluation of (offset.y + extent.height) for each member of pExclusiveScissors must not cause a signed integer addition overflow\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (y_sum > vvl::kI32Max) {\n    skip |= LogError(\"VUID-vkCmdSetExclusiveScissorNV-offset-02039\", commandBuffer, scissor_loc,\n                     \"offset.y (%\" PRId32 \") + extent.height (%\" PRIu32 \") is %\" PRIi64 \" which will overflow int32_t.\",\n                     scissor.offset.y, scissor.extent.height, y_sum);\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-vkCmdSetViewportShadingRatePaletteNV-firstViewport-02068\", \"If the multiViewport feature is not enabled, firstViewport must be 0\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (firstViewport != 0) {\n    skip |= LogError(\"VUID-vkCmdSetViewportShadingRatePaletteNV-firstViewport-02068\", commandBuffer,\n                     error_obj.location.dot(Field::firstViewport),\n                     \"is %\" PRIu32 \" but the multiViewport feature was not enabled.\", firstViewport);\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-vkCmdSetViewportShadingRatePaletteNV-viewportCount-02069\", \"If the multiViewport feature is not enabled, viewportCount must be 1\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (viewportCount > 1) {\n    skip |= LogError(\"VUID-vkCmdSetViewportShadingRatePaletteNV-viewportCount-02069\", commandBuffer,\n                     error_obj.location.dot(Field::viewportCount),\n                     \"is %\" PRIu32 \" but the multiViewport feature was not enabled.\", viewportCount);\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-vkCmdSetViewportShadingRatePaletteNV-firstViewport-02067\", \"The sum of firstViewport and viewportCount must be between 1 and VkPhysicalDeviceLimits::maxViewports, inclusive\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (sum > device_limits.maxViewports) {\n    skip |= LogError(\"VUID-vkCmdSetViewportShadingRatePaletteNV-firstViewport-02067\", commandBuffer, error_obj.location,\n                     \"firstViewport + viewportCount (=%\" PRIu32 \" + %\" PRIu32 \" = %\" PRIu64\n                     \") is greater than VkPhysicalDeviceLimits::maxViewports (=%\" PRIu32 \").\",\n                     firstViewport, viewportCount, sum, device_limits.maxViewports);\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-vkCmdSetCoarseSampleOrderNV-sampleOrderType-02081\", \"If sampleOrderType is not VK_COARSE_SAMPLE_ORDER_TYPE_CUSTOM_NV, customSamplerOrderCount must be 0\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (sampleOrderType != VK_COARSE_SAMPLE_ORDER_TYPE_CUSTOM_NV && customSampleOrderCount != 0) {\n    skip |= LogError(\"VUID-vkCmdSetCoarseSampleOrderNV-sampleOrderType-02081\", commandBuffer, error_obj.location,\n                     \"If sampleOrderType is not VK_COARSE_SAMPLE_ORDER_TYPE_CUSTOM_NV, \"\n                     \"customSampleOrderCount must be 0.\");\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-vkCmdSetScissor-firstScissor-00593\", \"If the multiViewport feature is not enabled, firstScissor must be 0\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (firstScissor != 0) {\n    skip |= LogError(\"VUID-vkCmdSetScissor-firstScissor-00593\", commandBuffer, error_obj.location.dot(Field::firstScissor),\n                     \"is %\" PRIu32 \" but the multiViewport feature was not enabled.\", firstScissor);\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-vkCmdSetScissor-scissorCount-00594\", \"If the multiViewport feature is not enabled, scissorCount must be 1\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (scissorCount > 1) {\n    skip |= LogError(\"VUID-vkCmdSetScissor-scissorCount-00594\", commandBuffer, error_obj.location.dot(Field::scissorCount),\n                     \"is %\" PRIu32 \" but the multiViewport feature was not enabled.\", scissorCount);\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-vkCmdSetScissor-firstScissor-00592\", \"The sum of firstScissor and scissorCount must be between 1 and VkPhysicalDeviceLimits::maxViewports, inclusive\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (sum > device_limits.maxViewports) {\n    skip |= LogError(\"VUID-vkCmdSetScissor-firstScissor-00592\", commandBuffer, error_obj.location,\n                     \"firstScissor (%\" PRIu32 \") + scissorCount (%\" PRIu32 \") is %\" PRIu64\n                     \" which is greater than maxViewports (%\" PRIu32 \").\",\n                     firstScissor, scissorCount, sum, device_limits.maxViewports);\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-vkCmdSetScissor-x-00595\", \"The x and y members of offset member of any element of pScissors must be greater than or equal to 0\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (scissor.offset.x < 0) {\n    skip |= LogError(\"VUID-vkCmdSetScissor-x-00595\", commandBuffer, scissor_loc.dot(Field::offset).dot(Field::x),\n                     \"(%\" PRId32 \") is negative.\", scissor.offset.x);\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-vkCmdSetScissor-offset-00596\", \"Evaluation of (offset.x + extent.width) must not cause a signed integer addition overflow for any element of pScissors\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (x_sum > vvl::kI32Max) {\n    skip |= LogError(\"VUID-vkCmdSetScissor-offset-00596\", commandBuffer, scissor_loc,\n                     \"offset.x (%\" PRId32 \") + extent.width (%\" PRIu32 \") is %\" PRIi64 \" which will overflow int32_t.\",\n                     scissor.offset.x, scissor.extent.width, x_sum);\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-vkCmdSetScissor-offset-00597\", \"Evaluation of (offset.y + extent.height) must not cause a signed integer addition overflow for any element of pScissors\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (y_sum > vvl::kI32Max) {\n    skip |= LogError(\"VUID-vkCmdSetScissor-offset-00597\", commandBuffer, scissor_loc,\n                     \"offset.y (%\" PRId32 \") + extent.height (%\" PRIu32 \") is %\" PRIi64 \" which will overflow int32_t.\",\n                     scissor.offset.y, scissor.extent.height, y_sum);\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-vkCmdSetLineWidth-lineWidth-00788\", \"If the wideLines feature is not enabled, lineWidth must be 1.0\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (!enabled_features.wideLines && (lineWidth != 1.0f)) {\n    skip |= LogError(\"VUID-vkCmdSetLineWidth-lineWidth-00788\", commandBuffer, error_obj.location.dot(Field::lineWidth),\n                     \"is %f (not 1.0), but wideLines was not enabled.\", lineWidth);\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-vkCmdSetLineStippleKHR-lineStippleFactor-02776\", \"lineStippleFactor must be in the range [1,256]\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (lineStippleFactor < 1 || lineStippleFactor > 256) {\n    skip |= LogError(\"VUID-vkCmdSetLineStippleKHR-lineStippleFactor-02776\", commandBuffer,\n                     error_obj.location.dot(Field::lineStippleFactor), \"%\" PRIu32 \" is not in [1,256].\", lineStippleFactor);\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkCoarseSampleOrderCustomNV-sampleCount-02074\", \"sampleCount must correspond to a sample count enumerated in VkSampleCountFlags whose corresponding bit is set in VkPhysicalDeviceLimits::framebufferNoAttachmentsSampleCounts\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (order.sampleCount == 0 || (order.sampleCount & (order.sampleCount - 1)) ||\n    !(order.sampleCount & device_limits.framebufferNoAttachmentsSampleCounts)) {\n    skip |= LogError(\"VUID-VkCoarseSampleOrderCustomNV-sampleCount-02074\", device, order_loc,\n                     \"sampleCount (=%\" PRIu32\n                     \") must \"\n                     \"correspond to a sample count enumerated in VkSampleCountFlags whose corresponding bit \"\n                     \"is set in framebufferNoAttachmentsSampleCounts.\",\n                     order.sampleCount);\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkCoarseSampleOrderCustomNV-sampleLocationCount-02075\", \"sampleLocationCount must be equal to the product of sampleCount, the fragment width for shadingRate, and the fragment height for shadingRate\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (order.sampleLocationCount != order.sampleCount * sample_order_info->width * sample_order_info->height) {\n    skip |= LogError(\"VUID-VkCoarseSampleOrderCustomNV-sampleLocationCount-02075\", device, order_loc,\n                     \"sampleLocationCount (=%\" PRIu32\n                     \") must \"\n                     \"be equal to the product of sampleCount (=%\" PRIu32\n                     \"), the fragment width for shadingRate \"\n                     \"(=%\" PRIu32 \"), and the fragment height for shadingRate (=%\" PRIu32 \").\",\n                     order.sampleLocationCount, order.sampleCount, sample_order_info->width, sample_order_info->height);\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkCoarseSampleLocationNV-pixelX-02078\", \"pixelX must be less than the width (in pixels) of the fragment\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (sample_loc->pixelX >= sample_order_info->width) {\n    skip |= LogError(\"VUID-VkCoarseSampleLocationNV-pixelX-02078\", device, order_loc,\n                     \"pixelX must be less than the width (in pixels) of the fragment.\");\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkCoarseSampleLocationNV-pixelY-02079\", \"pixelY must be less than the height (in pixels) of the fragment\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (sample_loc->pixelY >= sample_order_info->height) {\n    skip |= LogError(\"VUID-VkCoarseSampleLocationNV-pixelY-02079\", device, order_loc,\n                     \"pixelY must be less than the height (in pixels) of the fragment.\");\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkSamplerCreateInfo-pNext-06726\", \"If samplerFilterMinmax is not enabled and the pNext chain includes a VkSamplerReductionModeCreateInfo structure, then the sampler reduction mode must be set to VK_SAMPLER_REDUCTION_MODE_WEIGHTED_AVERAGE\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if ((api_version >= VK_API_VERSION_1_2) && !enabled_features.samplerFilterMinmax) {\n    skip |= LogError(\"VUID-VkSamplerCreateInfo-pNext-06726\", device,\n                     create_info_loc.pNext(Struct::VkSamplerReductionModeCreateInfo, Field::reductionMode),\n                     \"is %s but samplerFilterMinmax feature was not enabled.\",\n                     string_VkSamplerReductionMode(sampler_reduction->reductionMode));\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkSamplerCreateInfo-None-01647\", \"If sampler Y'CBCR conversion is enabled and the pNext chain includes a VkSamplerReductionModeCreateInfo structure, then the sampler reduction mode must be set to VK_SAMPLER_REDUCTION_MODE_WEIGHTED_AVERAGE\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (vku::FindStructInPNextChain<VkSamplerYcbcrConversionInfo>(create_info.pNext)) {\n    skip |= LogError(\"VUID-VkSamplerCreateInfo-None-01647\", device,\n                     create_info_loc.pNext(Struct::VkSamplerReductionModeCreateInfo, Field::reductionMode),\n                     \"is %s but a VkSamplerYcbcrConversionInfo structure is also linked in the pNext chain of the \"\n                     \"VkSamplerCreateInfo structure.\",\n                     string_VkSamplerReductionMode(sampler_reduction->reductionMode));\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkSamplerCreateInfo-magFilter-07911\", \"If the VK_EXT_filter_cubic extension is not enabled and either magFilter or minFilter is VK_FILTER_CUBIC_IMG, the reductionMode member of VkSamplerReductionModeCreateInfo must be VK_SAMPLER_REDUCTION_MODE_WEIGHTED_AVERAGE\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (!IsExtEnabled(device_extensions.vk_ext_filter_cubic)) {\n    skip |= LogError(\"VUID-VkSamplerCreateInfo-magFilter-07911\", device,\n                     create_info_loc.pNext(Struct::VkSamplerReductionModeCreateInfo, Field::reductionMode),\n                     \"is %s, magFilter is %s and minFilter is %s, but \"\n                     \"extension %s is not enabled.\",\n                     string_VkSamplerReductionMode(sampler_reduction->reductionMode),\n                     string_VkFilter(create_info.magFilter), string_VkFilter(create_info.minFilter),\n                     VK_EXT_FILTER_CUBIC_EXTENSION_NAME);\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkSamplerCreateInfo-borderColor-04011\", \"If borderColor is one of VK_BORDER_COLOR_FLOAT_CUSTOM_EXT or VK_BORDER_COLOR_INT_CUSTOM_EXT, then a VkSamplerCustomBorderColorCreateInfoEXT must be included in the pNext chain\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (!custom_create_info) {\n    skip |= LogError(\"VUID-VkSamplerCreateInfo-borderColor-04011\", device, create_info_loc.dot(Field::borderColor),\n                     \"is %s but there is no VkSamplerCustomBorderColorCreateInfoEXT \"\n                     \"struct in pNext chain.\",\n                     string_VkBorderColor(create_info.borderColor));\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkSamplerCustomBorderColorCreateInfoEXT-format-04014\", \"If the customBorderColorWithoutFormat feature is not enabled then format must not be VK_FORMAT_UNDEFINED\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (custom_create_info->format == VK_FORMAT_UNDEFINED && !enabled_features.customBorderColorWithoutFormat) {\n    skip |= LogError(\"VUID-VkSamplerCustomBorderColorCreateInfoEXT-format-04014\", device,\n                     create_info_loc.pNext(Struct::VkSamplerCustomBorderColorCreateInfoEXT, Field::format),\n                     \"is VK_FORMAT_UNDEFINED but the \"\n                     \"customBorderColorWithoutFormat feature was not enabled.\");\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkSamplerCreateInfo-flags-02574\", \"If flags includes VK_SAMPLER_CREATE_SUBSAMPLED_BIT_EXT, then minFilter and magFilter must be equal\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (create_info.minFilter != create_info.magFilter) {\n    skip |= LogError(\"VUID-VkSamplerCreateInfo-flags-02574\", device, create_info_loc.dot(Field::flags),\n                     \"includes VK_SAMPLER_CREATE_SUBSAMPLED_BIT_EXT, but \"\n                     \"minFilter (%s) and magFilter (%s) are not equal.\",\n                     string_VkFilter(create_info.minFilter), string_VkFilter(create_info.magFilter));\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkSamplerCreateInfo-flags-02575\", \"If flags includes VK_SAMPLER_CREATE_SUBSAMPLED_BIT_EXT, then mipmapMode must be VK_SAMPLER_MIPMAP_MODE_NEAREST\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (create_info.mipmapMode != VK_SAMPLER_MIPMAP_MODE_NEAREST) {\n    skip |= LogError(\"VUID-VkSamplerCreateInfo-flags-02575\", device, create_info_loc.dot(Field::flags),\n                     \"includes VK_SAMPLER_CREATE_SUBSAMPLED_BIT_EXT, but \"\n                     \"mipmapMode (%s) is not VK_SAMPLER_MIPMAP_MODE_NEAREST.\",\n                     string_VkSamplerMipmapMode(create_info.mipmapMode));\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkSamplerCreateInfo-flags-02576\", \"If flags includes VK_SAMPLER_CREATE_SUBSAMPLED_BIT_EXT, then minLod and maxLod must be zero\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (create_info.minLod != 0.0 || create_info.maxLod != 0.0) {\n    skip |= LogError(\"VUID-VkSamplerCreateInfo-flags-02576\", device, create_info_loc.dot(Field::flags),\n                     \"includes VK_SAMPLER_CREATE_SUBSAMPLED_BIT_EXT, but \"\n                     \"minLod (%f) and maxLod (%f) are not zero.\",\n                     create_info.minLod, create_info.maxLod);\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkSamplerCreateInfo-flags-02579\", \"If flags includes VK_SAMPLER_CREATE_SUBSAMPLED_BIT_EXT, then compareEnable must be VK_FALSE\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (create_info.compareEnable) {\n    skip |= LogError(\"VUID-VkSamplerCreateInfo-flags-02579\", device, create_info_loc.dot(Field::flags),\n                     \"includes VK_SAMPLER_CREATE_SUBSAMPLED_BIT_EXT, \"\n                     \"but compareEnable is VK_TRUE.\");\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkSamplerCreateInfo-flags-02580\", \"If flags includes VK_SAMPLER_CREATE_SUBSAMPLED_BIT_EXT, then unnormalizedCoordinates must be VK_FALSE\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (create_info.unnormalizedCoordinates) {\n    skip |= LogError(\"VUID-VkSamplerCreateInfo-flags-02580\", device, create_info_loc.dot(Field::flags),\n                     \"includes VK_SAMPLER_CREATE_SUBSAMPLED_BIT_EXT, \"\n                     \"but unnormalizedCoordinates is VK_TRUE.\");\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkSamplerCreateInfo-flags-06964\", \"If flags includes VK_SAMPLER_CREATE_IMAGE_PROCESSING_BIT_QCOM, then minFilter and magFilter must be VK_FILTER_NEAREST\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if ((create_info.minFilter != VK_FILTER_NEAREST) || (create_info.magFilter != VK_FILTER_NEAREST)) {\n    skip |= LogError(\"VUID-VkSamplerCreateInfo-flags-06964\", device, create_info_loc.dot(Field::flags),\n                     \"includes VK_SAMPLER_CREATE_IMAGE_PROCESSING_BIT_QCOM, so \"\n                     \"minFilter (%s) must be VK_FILTER_NEAREST and \"\n                     \"magFilter (%s) must be VK_FILTER_NEAREST.\",\n                     string_VkFilter(create_info.minFilter), string_VkFilter(create_info.magFilter));\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkSamplerCreateInfo-flags-06965\", \"If flags includes VK_SAMPLER_CREATE_IMAGE_PROCESSING_BIT_QCOM, then mipmapMode must be VK_SAMPLER_MIPMAP_MODE_NEAREST\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (create_info.mipmapMode != VK_SAMPLER_MIPMAP_MODE_NEAREST) {\n    skip |= LogError(\"VUID-VkSamplerCreateInfo-flags-06965\", device, create_info_loc.dot(Field::flags),\n                     \"includes VK_SAMPLER_CREATE_IMAGE_PROCESSING_BIT_QCOM, so \"\n                     \"mipmapMode (%s) must be VK_SAMPLER_MIPMAP_MODE_NEAREST.\",\n                     string_VkSamplerMipmapMode(create_info.mipmapMode));\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkSamplerCreateInfo-flags-06968\", \"If flags includes VK_SAMPLER_CREATE_IMAGE_PROCESSING_BIT_QCOM, and if addressModeU or addressModeV is VK_SAMPLER_ADDRESS_MODE_CLAMP_TO_BORDER, then borderColor must be VK_BORDER_COLOR_FLOAT_TRANSPARENT_BLACK\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (((create_info.addressModeU == VK_SAMPLER_ADDRESS_MODE_CLAMP_TO_BORDER) ||\n    skip |= LogError(\"VUID-VkSamplerCreateInfo-flags-06968\", device, create_info_loc.dot(Field::flags),\n                     \"includes VK_SAMPLER_CREATE_IMAGE_PROCESSING_BIT_QCOM, \"\n                     \"so if either addressModeU (%s) or addressModeV (%s) is \"\n                     \"VK_SAMPLER_ADDRESS_MODE_CLAMP_TO_BORDER, then\"\n                     \"borderColor (%s) must be VK_BORDER_COLOR_FLOAT_TRANSPARENT_BLACK.\",\n                     string_VkSamplerAddressMode(create_info.addressModeU),\n                     string_VkSamplerAddressMode(create_info.addressModeV), string_VkBorderColor(create_info.borderColor));\n"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkSamplerCreateInfo-flags-06969\", \"If flags includes VK_SAMPLER_CREATE_IMAGE_PROCESSING_BIT_QCOM, then anisotropyEnable must be VK_FALSE\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (create_info.anisotropyEnable) {\n    skip |= LogError(\"VUID-VkSamplerCreateInfo-flags-06969\", device, create_info_loc.dot(Field::flags),\n                     \"includes VK_SAMPLER_CREATE_IMAGE_PROCESSING_BIT_QCOM, \"\n                     \"but anisotropyEnable is VK_TRUE.\");\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkSamplerCreateInfo-flags-06970\", \"If flags includes VK_SAMPLER_CREATE_IMAGE_PROCESSING_BIT_QCOM, then compareEnable must be VK_FALSE\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (create_info.compareEnable) {\n    skip |= LogError(\"VUID-VkSamplerCreateInfo-flags-06970\", device, create_info_loc.dot(Field::flags),\n                     \"includes VK_SAMPLER_CREATE_IMAGE_PROCESSING_BIT_QCOM, \"\n                     \"but compareEnable is VK_TRUE.\");\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkSamplerCreateInfo-anisotropyEnable-01071\", \"If anisotropyEnable is VK_TRUE, maxAnisotropy must be between 1.0 and VkPhysicalDeviceLimits::maxSamplerAnisotropy, inclusive\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (!IsBetweenInclusive(pCreateInfo->maxAnisotropy, 1.0F, limits.maxSamplerAnisotropy)) {\n    skip |= LogError(\"VUID-VkSamplerCreateInfo-anisotropyEnable-01071\", device, create_info_loc.dot(Field::maxAnisotropy),\n                     \"is %f but must be in the range of [1.0, %f] (maxSamplerAnistropy).\", pCreateInfo->maxAnisotropy,\n                     limits.maxSamplerAnisotropy);\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkSamplerCreateInfo-unnormalizedCoordinates-01073\", \"If unnormalizedCoordinates is VK_TRUE, mipmapMode must be VK_SAMPLER_MIPMAP_MODE_NEAREST\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (pCreateInfo->mipmapMode != VK_SAMPLER_MIPMAP_MODE_NEAREST) {\n    skip |= LogError(\"VUID-VkSamplerCreateInfo-unnormalizedCoordinates-01073\", device,\n                     create_info_loc.dot(Field::unnormalizedCoordinates),\n                     \"is VK_TRUE, but mipmapMode (%s) must be VK_SAMPLER_MIPMAP_MODE_NEAREST.\",\n                     string_VkSamplerMipmapMode(pCreateInfo->mipmapMode));\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkSamplerCreateInfo-unnormalizedCoordinates-01074\", \"If unnormalizedCoordinates is VK_TRUE, minLod and maxLod must be zero\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (pCreateInfo->minLod != 0.0f || pCreateInfo->maxLod != 0.0f) {\n    skip |= LogError(\"VUID-VkSamplerCreateInfo-unnormalizedCoordinates-01074\", device,\n                     create_info_loc.dot(Field::unnormalizedCoordinates),\n                     \"is VK_TRUE, but minLod (%f) and maxLod (%f) must both be zero.\", pCreateInfo->minLod,\n                     pCreateInfo->maxLod);\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkSamplerCreateInfo-unnormalizedCoordinates-01075\", \"If unnormalizedCoordinates is VK_TRUE, addressModeU and addressModeV must each be either VK_SAMPLER_ADDRESS_MODE_CLAMP_TO_EDGE or VK_SAMPLER_ADDRESS_MODE_CLAMP_TO_BORDER\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "skip |= LogError(\"VUID-VkSamplerCreateInfo-unnormalizedCoordinates-01075\", device,\n                 create_info_loc.dot(Field::unnormalizedCoordinates),\n                 \"is VK_TRUE, but addressModeU (%s) and addressModeV (%s) must both be \"\n                 \"CLAMP_TO_EDGE or CLAMP_TO_BORDER.\",\n                 string_VkSamplerAddressMode(pCreateInfo->addressModeU),\n                 string_VkSamplerAddressMode(pCreateInfo->addressModeV));\n"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkSamplerCreateInfo-unnormalizedCoordinates-01076\", \"If unnormalizedCoordinates is VK_TRUE, anisotropyEnable must be VK_FALSE\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (pCreateInfo->anisotropyEnable == VK_TRUE) {\n    skip |= LogError(\"VUID-VkSamplerCreateInfo-unnormalizedCoordinates-01076\", device, create_info_loc,\n                     \"anisotropyEnable and unnormalizedCoordinates are both VK_TRUE.\");\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkSamplerCreateInfo-addressModeU-01079\", \"If samplerMirrorClampToEdge is not enabled, and if the VK_KHR_sampler_mirror_clamp_to_edge extension is not enabled, addressModeU, addressModeV and addressModeW must not be VK_SAMPLER_ADDRESS_MODE_MIRROR_CLAMP_TO_EDGE\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (pCreateInfo->addressModeU == VK_SAMPLER_ADDRESS_MODE_MIRROR_CLAMP_TO_EDGE) {\n    skip |= LogError(\"VUID-VkSamplerCreateInfo-addressModeU-01079\", device, create_info_loc.dot(Field::addressModeU),\n                     \"is VK_SAMPLER_ADDRESS_MODE_MIRROR_CLAMP_TO_EDGE but the \"\n                     \"VK_KHR_sampler_mirror_clamp_to_edge extension or samplerMirrorClampToEdge feature was not enabled.\");\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkSamplerCreateInfo-addressModeU-01079\", \"If samplerMirrorClampToEdge is not enabled, and if the VK_KHR_sampler_mirror_clamp_to_edge extension is not enabled, addressModeU, addressModeV and addressModeW must not be VK_SAMPLER_ADDRESS_MODE_MIRROR_CLAMP_TO_EDGE\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "} else if (pCreateInfo->addressModeV == VK_SAMPLER_ADDRESS_MODE_MIRROR_CLAMP_TO_EDGE) {\n    skip |= LogError(\"VUID-VkSamplerCreateInfo-addressModeU-01079\", device, create_info_loc.dot(Field::addressModeV),\n                     \"is VK_SAMPLER_ADDRESS_MODE_MIRROR_CLAMP_TO_EDGE but the \"\n                     \"VK_KHR_sampler_mirror_clamp_to_edge extension or samplerMirrorClampToEdge feature was not enabled.\");\n"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkSamplerCreateInfo-addressModeU-01079\", \"If samplerMirrorClampToEdge is not enabled, and if the VK_KHR_sampler_mirror_clamp_to_edge extension is not enabled, addressModeU, addressModeV and addressModeW must not be VK_SAMPLER_ADDRESS_MODE_MIRROR_CLAMP_TO_EDGE\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "} else if (pCreateInfo->addressModeW == VK_SAMPLER_ADDRESS_MODE_MIRROR_CLAMP_TO_EDGE) {\n    skip |= LogError(\"VUID-VkSamplerCreateInfo-addressModeU-01079\", device, create_info_loc.dot(Field::addressModeW),\n                     \"is VK_SAMPLER_ADDRESS_MODE_MIRROR_CLAMP_TO_EDGE but the \"\n                     \"VK_KHR_sampler_mirror_clamp_to_edge extension or samplerMirrorClampToEdge feature was not enabled.\");\n"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkSamplerCreateInfo-magFilter-01081\", \"If either magFilter or minFilter is VK_FILTER_CUBIC_EXT, anisotropyEnable must be VK_FALSE\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if ((pCreateInfo->anisotropyEnable == VK_TRUE) &&\n    ((pCreateInfo->minFilter == VK_FILTER_CUBIC_IMG) || (pCreateInfo->magFilter == VK_FILTER_CUBIC_IMG))) {\n    skip |= LogError(\"VUID-VkSamplerCreateInfo-magFilter-01081\", device, create_info_loc,\n                     \"anisotropyEnable is VK_TRUE, but minFilter = %s and magFilter = %s\",\n                     string_VkFilter(pCreateInfo->minFilter), string_VkFilter(pCreateInfo->magFilter));\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkSamplerCreateInfo-mipLodBias-01069\", \"The absolute value of mipLodBias must be less than or equal to VkPhysicalDeviceLimits::maxSamplerLodBias\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (pCreateInfo->mipLodBias > limits.maxSamplerLodBias) {\n    skip |= LogError(\"VUID-VkSamplerCreateInfo-mipLodBias-01069\", device, create_info_loc.dot(Field::mipLodBias),\n                     \"(%f) is greater than maxSamplerLodBias (%f)\", pCreateInfo->mipLodBias, limits.maxSamplerLodBias);\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkSamplerCreateInfo-nonSeamlessCubeMap-06788\", \"If the nonSeamlessCubeMap feature is not enabled, flags must not include VK_SAMPLER_CREATE_NON_SEAMLESS_CUBE_MAP_BIT_EXT\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if ((pCreateInfo->flags & VK_SAMPLER_CREATE_NON_SEAMLESS_CUBE_MAP_BIT_EXT) && (!enabled_features.nonSeamlessCubeMap)) {\n    skip |= LogError(\"VUID-VkSamplerCreateInfo-nonSeamlessCubeMap-06788\", device, create_info_loc.dot(Field::flags),\n                     \"includes VK_SAMPLER_CREATE_NON_SEAMLESS_CUBE_MAP_BIT_EXT but the \"\n                     \"nonSeamlessCubeMap feature was not enabled.\");\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkSamplerCreateInfo-flags-08110\", \"If flags includes VK_SAMPLER_CREATE_DESCRIPTOR_BUFFER_CAPTURE_REPLAY_BIT_EXT, the descriptorBufferCaptureReplay feature must be enabled\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if ((pCreateInfo->flags & VK_SAMPLER_CREATE_DESCRIPTOR_BUFFER_CAPTURE_REPLAY_BIT_EXT) &&\n    skip |= LogError(\"VUID-VkSamplerCreateInfo-flags-08110\", device, create_info_loc.dot(Field::flags),\n                     \"includes VK_SAMPLER_CREATE_DESCRIPTOR_BUFFER_CAPTURE_REPLAY_BIT_EXT but descriptorBufferCaptureReplay \"\n                     \"feature was not enabled.\");\n"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkSamplerCreateInfo-pNext-08111\", \"If the pNext chain includes a VkOpaqueCaptureDescriptorDataCreateInfoEXT structure, flags must contain VK_SAMPLER_CREATE_DESCRIPTOR_BUFFER_CAPTURE_REPLAY_BIT_EXT\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (!(pCreateInfo->flags & VK_SAMPLER_CREATE_DESCRIPTOR_BUFFER_CAPTURE_REPLAY_BIT_EXT)) {\n    skip |= LogError(\"VUID-VkSamplerCreateInfo-pNext-08111\", device, create_info_loc.dot(Field::flags),\n                     \"is %s but VkOpaqueCaptureDescriptorDataCreateInfoEXT is in pNext chain.\",\n                     string_VkSamplerCreateFlags(pCreateInfo->flags).c_str());\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkMutableDescriptorTypeListEXT-pDescriptorTypes-04601\", \"pDescriptorTypes must not contain VK_DESCRIPTOR_TYPE_STORAGE_BUFFER_DYNAMIC\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "skip |= LogError(\"VUID-VkMutableDescriptorTypeListEXT-pDescriptorTypes-04601\", device, type_loc,\n                 \"is VK_DESCRIPTOR_TYPE_STORAGE_BUFFER_DYNAMIC.\");\n"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkMutableDescriptorTypeListEXT-pDescriptorTypes-04602\", \"pDescriptorTypes must not contain VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER_DYNAMIC\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "skip |= LogError(\"VUID-VkMutableDescriptorTypeListEXT-pDescriptorTypes-04602\", device, type_loc,\n                 \"is VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER_DYNAMIC.\");\n"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkMutableDescriptorTypeListEXT-pDescriptorTypes-04603\", \"pDescriptorTypes must not contain VK_DESCRIPTOR_TYPE_INLINE_UNIFORM_BLOCK\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "skip |= LogError(\"VUID-VkMutableDescriptorTypeListEXT-pDescriptorTypes-04603\", device, type_loc,\n                 \"is VK_DESCRIPTOR_TYPE_INLINE_UNIFORM_BLOCK_EXT.\");\n"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkDescriptorSetLayoutBinding-descriptorCount-09465\", \"If descriptorCount is not 0, stageFlags must be VK_SHADER_STAGE_ALL or a valid combination of other VkShaderStageFlagBits values\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (stage_flags != VK_SHADER_STAGE_ALL && ((stage_flags & (~AllVkShaderStageFlagBitsExcludingStageAll)) != 0)) {\n    skip |= LogError(\"VUID-VkDescriptorSetLayoutBinding-descriptorCount-09465\", device,\n                     binding_loc.dot(Field::descriptorCount),\n                     \"is %\" PRIu32 \" but stageFlags is invalid (0x%\" PRIx32 \").\",\n                     create_info.pBindings[i].descriptorCount, stage_flags);\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkDescriptorSetLayoutCreateInfo-pBindings-07303\", \"If any element pBindings[i] has a descriptorType of VK_DESCRIPTOR_TYPE_MUTABLE_EXT, then the pNext chain must include a VkMutableDescriptorTypeCreateInfoEXT structure, and mutableDescriptorTypeListCount must be greater than i\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "skip |= LogError(\"VUID-VkDescriptorSetLayoutCreateInfo-pBindings-07303\", device,\n                 binding_loc.dot(Field::descriptorType),\n                 \"is VK_DESCRIPTOR_TYPE_MUTABLE_EXT but VkMutableDescriptorTypeCreateInfoEXT is not \"\n                 \"included in the pNext chain.\");\n"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkDescriptorSetLayoutCreateInfo-descriptorType-04594\", \"If a binding has a descriptorType value of VK_DESCRIPTOR_TYPE_MUTABLE_EXT, then pImmutableSamplers must be NULL\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (create_info.pBindings[i].pImmutableSamplers) {\n    skip |= LogError(\"VUID-VkDescriptorSetLayoutCreateInfo-descriptorType-04594\", device,\n                     binding_loc.dot(Field::descriptorType),\n                     \"is VK_DESCRIPTOR_TYPE_MUTABLE_EXT but pImmutableSamplers is not NULL.\");\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkDescriptorSetLayoutCreateInfo-mutableDescriptorType-04595\", \"If VkPhysicalDeviceMutableDescriptorTypeFeaturesEXT::mutableDescriptorType is not enabled, pBindings must not contain a descriptorType of VK_DESCRIPTOR_TYPE_MUTABLE_EXT\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (!enabled_features.mutableDescriptorType) {\n    skip |= LogError(\"VUID-VkDescriptorSetLayoutCreateInfo-mutableDescriptorType-04595\", device,\n                     binding_loc.dot(Field::descriptorType),\n                     \"is VK_DESCRIPTOR_TYPE_MUTABLE_EXT but \"\n                     \"mutableDescriptorType feature was not enabled.\");\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkDescriptorSetLayoutCreateInfo-flags-04591\", \"If flags contains VK_DESCRIPTOR_SET_LAYOUT_CREATE_PUSH_DESCRIPTOR_BIT_KHR, pBindings must not have a descriptorType of VK_DESCRIPTOR_TYPE_MUTABLE_EXT\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (create_info.flags & VK_DESCRIPTOR_SET_LAYOUT_CREATE_PUSH_DESCRIPTOR_BIT_KHR &&\n    create_info.pBindings[i].descriptorType == VK_DESCRIPTOR_TYPE_MUTABLE_EXT) {\n    skip |= LogError(\"VUID-VkDescriptorSetLayoutCreateInfo-flags-04591\", device, binding_loc.dot(Field::descriptorType),\n                     \"is VK_DESCRIPTOR_TYPE_MUTABLE_EXT, but flags includes \"\n                     \"VK_DESCRIPTOR_SET_LAYOUT_CREATE_PUSH_DESCRIPTOR_BIT_KHR.\");\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkDescriptorSetLayoutCreateInfo-flags-04590\", \"If flags contains VK_DESCRIPTOR_SET_LAYOUT_CREATE_PUSH_DESCRIPTOR_BIT_KHR, flags must not contain VK_DESCRIPTOR_SET_LAYOUT_CREATE_HOST_ONLY_POOL_BIT_EXT\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if ((create_info.flags & VK_DESCRIPTOR_SET_LAYOUT_CREATE_PUSH_DESCRIPTOR_BIT_KHR) &&\n    (create_info.flags & VK_DESCRIPTOR_SET_LAYOUT_CREATE_HOST_ONLY_POOL_BIT_EXT)) {\n    skip |= LogError(\"VUID-VkDescriptorSetLayoutCreateInfo-flags-04590\", device, create_info_loc.dot(Field::flags), \"is %s.\",\n                     string_VkDescriptorSetLayoutCreateFlags(create_info.flags).c_str());\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkDescriptorSetLayoutCreateInfo-flags-04592\", \"If flags contains VK_DESCRIPTOR_SET_LAYOUT_CREATE_UPDATE_AFTER_BIND_POOL_BIT, flags must not contain VK_DESCRIPTOR_SET_LAYOUT_CREATE_HOST_ONLY_POOL_BIT_EXT\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if ((create_info.flags & VK_DESCRIPTOR_SET_LAYOUT_CREATE_UPDATE_AFTER_BIND_POOL_BIT) &&\n    (create_info.flags & VK_DESCRIPTOR_SET_LAYOUT_CREATE_HOST_ONLY_POOL_BIT_EXT)) {\n    skip |= LogError(\"VUID-VkDescriptorSetLayoutCreateInfo-flags-04592\", device, create_info_loc.dot(Field::flags), \"is %s.\",\n                     string_VkDescriptorSetLayoutCreateFlags(create_info.flags).c_str());\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkDescriptorSetLayoutCreateInfo-flags-04596\", \"If flags contains VK_DESCRIPTOR_SET_LAYOUT_CREATE_HOST_ONLY_POOL_BIT_EXT, VkPhysicalDeviceMutableDescriptorTypeFeaturesEXT::mutableDescriptorType must be enabled\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (create_info.flags & VK_DESCRIPTOR_SET_LAYOUT_CREATE_HOST_ONLY_POOL_BIT_EXT && !enabled_features.mutableDescriptorType) {\n    skip |= LogError(\"VUID-VkDescriptorSetLayoutCreateInfo-flags-04596\", device, create_info_loc.dot(Field::flags),\n                     \"is %s, but mutableDescriptorType feature was not enabled.\",\n                     string_VkDescriptorSetLayoutCreateFlags(create_info.flags).c_str());\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkDescriptorSetLayoutCreateInfo-flags-08001\", \"If flags contains VK_DESCRIPTOR_SET_LAYOUT_CREATE_EMBEDDED_IMMUTABLE_SAMPLERS_BIT_EXT, flags must also contain VK_DESCRIPTOR_SET_LAYOUT_CREATE_DESCRIPTOR_BUFFER_BIT_EXT\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if ((create_info.flags & VK_DESCRIPTOR_SET_LAYOUT_CREATE_EMBEDDED_IMMUTABLE_SAMPLERS_BIT_EXT) &&\n    !(create_info.flags & VK_DESCRIPTOR_SET_LAYOUT_CREATE_DESCRIPTOR_BUFFER_BIT_EXT)) {\n    skip |= LogError(\"VUID-VkDescriptorSetLayoutCreateInfo-flags-08001\", device, create_info_loc.dot(Field::flags), \"is %s.\",\n                     string_VkDescriptorSetLayoutCreateFlags(create_info.flags).c_str());\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkDescriptorSetLayoutCreateInfo-flags-08003\", \"If flags contains VK_DESCRIPTOR_SET_LAYOUT_CREATE_DESCRIPTOR_BUFFER_BIT_EXT, then flags must not contain VK_DESCRIPTOR_SET_LAYOUT_CREATE_HOST_ONLY_POOL_BIT_VALVE\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if ((create_info.flags & VK_DESCRIPTOR_SET_LAYOUT_CREATE_DESCRIPTOR_BUFFER_BIT_EXT) &&\n    (create_info.flags & VK_DESCRIPTOR_SET_LAYOUT_CREATE_HOST_ONLY_POOL_BIT_VALVE)) {\n    skip |= LogError(\"VUID-VkDescriptorSetLayoutCreateInfo-flags-08003\", device, create_info_loc.dot(Field::flags), \"is %s.\",\n                     string_VkDescriptorSetLayoutCreateFlags(create_info.flags).c_str());\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkWriteDescriptorSet-descriptorCount-arraylength\", \"descriptorCount must be greater than 0\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (descriptor_writes.descriptorCount == 0) {\n    skip |= LogError(\"VUID-VkWriteDescriptorSet-descriptorCount-arraylength\", device,\n                     writes_loc.dot(Field::descriptorCount), \"is zero.\");\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkWriteDescriptorSet-descriptorType-00324\", \"If descriptorType is VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER, VK_DESCRIPTOR_TYPE_STORAGE_BUFFER, VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER_DYNAMIC, or VK_DESCRIPTOR_TYPE_STORAGE_BUFFER_DYNAMIC, pBufferInfo must be a valid pointer to an array of descriptorCount valid VkDescriptorBufferInfo structures\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (descriptor_writes.pBufferInfo == nullptr) {\n    skip |= LogError(\"VUID-VkWriteDescriptorSet-descriptorType-00324\", device, writes_loc.dot(Field::descriptorType),\n                     \"is %s but pBufferInfo is NULL.\", string_VkDescriptorType(descriptor_type));\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkDescriptorBufferInfo-buffer-02999\", \"If buffer is VK_NULL_HANDLE, offset must be zero and range must be VK_WHOLE_SIZE\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (descriptor_writes.pBufferInfo[descriptor_index].buffer == VK_NULL_HANDLE &&\n    skip |= LogError(\"VUID-VkDescriptorBufferInfo-buffer-02999\", device,\n                     writes_loc.dot(Field::pBufferInfo, descriptor_index).dot(Field::buffer),\n                     \"is VK_NULL_HANDLE, but offset (%\" PRIu64 \") is not zero and range (%\" PRIu64\n                     \") is not VK_WHOLE_SIZE when descriptor type is %s.\",\n                     descriptor_writes.pBufferInfo[descriptor_index].offset,\n                     descriptor_writes.pBufferInfo[descriptor_index].range,\n                     string_VkDescriptorType(descriptor_type));\n"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkWriteDescriptorSet-descriptorType-00328\", \"If descriptorType is VK_DESCRIPTOR_TYPE_STORAGE_BUFFER or VK_DESCRIPTOR_TYPE_STORAGE_BUFFER_DYNAMIC, the offset member of each element of pBufferInfo must be a multiple of VkPhysicalDeviceLimits::minStorageBufferOffsetAlignment\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (SafeModulo(descriptor_writes.pBufferInfo[j].offset, storage_alignment) != 0) {\n    skip |= LogError(\"VUID-VkWriteDescriptorSet-descriptorType-00328\", device,\n                     writes_loc.dot(Field::pBufferInfo, j).dot(Field::offset),\n                     \"(%\" PRIu64 \") must be a multiple of device limit minStorageBufferOffsetAlignment %\" PRIu64\n                     \" when descriptor type is %s.\",\n                     descriptor_writes.pBufferInfo[j].offset, storage_alignment,\n                     string_VkDescriptorType(descriptor_type));\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkWriteDescriptorSet-descriptorType-02382\", \"If descriptorType is VK_DESCRIPTOR_TYPE_ACCELERATION_STRUCTURE_KHR, the pNext chain must include a VkWriteDescriptorSetAccelerationStructureKHR structure whose accelerationStructureCount member equals descriptorCount\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (!pnext_struct) {\n    skip |= LogError(\"VUID-VkWriteDescriptorSet-descriptorType-02382\", device, writes_loc,\n                     \"doesn't include a pNext chain to VkWriteDescriptorSetAccelerationStructureKHR.\");\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkWriteDescriptorSet-descriptorType-03817\", \"If descriptorType is VK_DESCRIPTOR_TYPE_ACCELERATION_STRUCTURE_NV, the pNext chain must include a VkWriteDescriptorSetAccelerationStructureNV structure whose accelerationStructureCount member equals descriptorCount\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (!pnext_struct || (pnext_struct->accelerationStructureCount != descriptor_writes.descriptorCount)) {\n    skip |= LogError(\"VUID-VkWriteDescriptorSet-descriptorType-03817\", device, loc,\n                     \"If descriptorType is VK_DESCRIPTOR_TYPE_ACCELERATION_STRUCTURE_NV, the pNext\"\n                     \"chain must include a VkWriteDescriptorSetAccelerationStructureNV structure whose \"\n                     \"accelerationStructureCount %\" PRIu32 \" member equals descriptorCount %\" PRIu32 \".\",\n                     pnext_struct ? pnext_struct->accelerationStructureCount : -1, descriptor_writes.descriptorCount);\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkWriteDescriptorSetAccelerationStructureNV-accelerationStructureCount-arraylength\", \"accelerationStructureCount must be greater than 0\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (pnext_struct->accelerationStructureCount == 0) {\n    skip |= LogError(\"VUID-VkWriteDescriptorSetAccelerationStructureNV-accelerationStructureCount-arraylength\",\n                     device, loc, \"accelerationStructureCount must be greater than 0 .\");\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkDescriptorPoolCreateInfo-descriptorPoolOverallocation-09227\", \"If the descriptorPoolOverallocation feature is not enabled, or flags does not have VK_DESCRIPTOR_POOL_CREATE_ALLOW_OVERALLOCATION_SETS_BIT_NV set, maxSets must be greater than 0\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (pCreateInfo->maxSets == 0 && ((pCreateInfo->flags & VK_DESCRIPTOR_POOL_CREATE_ALLOW_OVERALLOCATION_SETS_BIT_NV) == 0)) {\n    skip |= LogError(\"VUID-VkDescriptorPoolCreateInfo-descriptorPoolOverallocation-09227\", device,\n                     create_info_loc.dot(Field::maxSets), \"is zero.\");\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkDescriptorPoolSize-descriptorCount-00302\", \"descriptorCount must be greater than 0\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (pCreateInfo->pPoolSizes[i].descriptorCount <= 0) {\n    skip |= LogError(\"VUID-VkDescriptorPoolSize-descriptorCount-00302\", device, pool_loc.dot(Field::descriptorCount),\n                     \"is zero.\");\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkDescriptorPoolCreateInfo-mutableDescriptorType-04608\", \"If VkPhysicalDeviceMutableDescriptorTypeFeaturesEXT::mutableDescriptorType is not enabled, pPoolSizes must not contain a descriptorType of VK_DESCRIPTOR_TYPE_MUTABLE_EXT\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (pCreateInfo->pPoolSizes[i].type == VK_DESCRIPTOR_TYPE_MUTABLE_EXT && !enabled_features.mutableDescriptorType) {\n    skip |= LogError(\"VUID-VkDescriptorPoolCreateInfo-mutableDescriptorType-04608\", device, pool_loc.dot(Field::type),\n                     \"is VK_DESCRIPTOR_TYPE_MUTABLE_EXT \"\n                     \", but mutableDescriptorType feature was not enabled.\");\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkDescriptorPoolCreateInfo-pPoolSizes-04787\", \"If pPoolSizes contains a descriptorType of VK_DESCRIPTOR_TYPE_MUTABLE_EXT, any other VK_DESCRIPTOR_TYPE_MUTABLE_EXT element in pPoolSizes must not have sets of supported descriptor types which partially overlap\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (MutableDescriptorTypePartialOverlap(pCreateInfo, i, j)) {\n    skip |= LogError(\"VUID-VkDescriptorPoolCreateInfo-pPoolSizes-04787\", device, pool_loc.dot(Field::type),\n                     \"and pCreateInfo->pPoolSizes[%\" PRIu32\n                     \"].type are both VK_DESCRIPTOR_TYPE_MUTABLE_EXT \"\n                     \" and have sets which partially overlap.\",\n                     j);\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkDescriptorPoolCreateInfo-flags-04607\", \"If flags has the VK_DESCRIPTOR_POOL_CREATE_HOST_ONLY_BIT_EXT bit set, then the VK_DESCRIPTOR_POOL_CREATE_UPDATE_AFTER_BIND_BIT bit must not be set\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if ((pCreateInfo->flags & VK_DESCRIPTOR_POOL_CREATE_HOST_ONLY_BIT_EXT) &&\n    (pCreateInfo->flags & VK_DESCRIPTOR_POOL_CREATE_UPDATE_AFTER_BIND_BIT)) {\n    skip |= LogError(\"VUID-VkDescriptorPoolCreateInfo-flags-04607\", device, create_info_loc.dot(Field::flags),\n                     \"includes both \"\n                     \"VK_DESCRIPTOR_POOL_CREATE_HOST_ONLY_BIT_EXT and VK_DESCRIPTOR_POOL_CREATE_UPDATE_AFTER_BIND_BIT\");\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkQueryPoolCreateInfo-queryType-00791\", \"If the pipelineStatisticsQuery feature is not enabled, queryType must not be VK_QUERY_TYPE_PIPELINE_STATISTICS\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (!enabled_features.pipelineStatisticsQuery) {\n    skip |= LogError(\"VUID-VkQueryPoolCreateInfo-queryType-00791\", device, create_info_loc.dot(Field::queryType),\n                     \"is VK_QUERY_TYPE_PIPELINE_STATISTICS but pipelineStatisticsQuery feature was not enabled.\");\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkQueryPoolCreateInfo-meshShaderQueries-07069\", \"If the meshShaderQueries feature is not enabled, and queryType is VK_QUERY_TYPE_PIPELINE_STATISTICS, pipelineStatistics must not contain VK_QUERY_PIPELINE_STATISTIC_TASK_SHADER_INVOCATIONS_BIT_EXT or VK_QUERY_PIPELINE_STATISTIC_MESH_SHADER_INVOCATIONS_BIT_EXT\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "!enabled_features.meshShaderQueries) {\nskip |= LogError(\"VUID-VkQueryPoolCreateInfo-meshShaderQueries-07069\", device,\n          create_info_loc.dot(Field::pipelineStatistics),\n          \"(%s) contains mesh/task shader bit, but \"\n          \"meshShaderQueries feature was not enabled.\",\n          string_VkQueryPipelineStatisticFlags(pCreateInfo->pipelineStatistics).c_str());\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkQueryPoolCreateInfo-queryType-09534\", \"If queryType is VK_QUERY_TYPE_PIPELINE_STATISTICS, pipelineStatistics must not be zero\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (pCreateInfo->pipelineStatistics == 0) {\n    skip |= LogError(\"VUID-VkQueryPoolCreateInfo-queryType-09534\", device, create_info_loc.dot(Field::queryType),\n                     \"is VK_QUERY_TYPE_PIPELINE_STATISTICS, but pCreateInfo->pipelineStatistics is zero\");\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkQueryPoolCreateInfo-queryType-03222\", \"If queryType is VK_QUERY_TYPE_PERFORMANCE_QUERY_KHR, the pNext chain must include a VkQueryPoolPerformanceCreateInfoKHR structure\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (!vku::FindStructInPNextChain<VkQueryPoolPerformanceCreateInfoKHR>(pCreateInfo->pNext)) {\n    skip |= LogError(\"VUID-VkQueryPoolCreateInfo-queryType-03222\", device, create_info_loc.dot(Field::queryType),\n                     \"is VK_QUERY_TYPE_PERFORMANCE_QUERY_KHR, but the pNext does not contain in instance of \"\n                     \"VkQueryPoolPerformanceCreateInfoKHR.\");\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkQueryPoolCreateInfo-queryCount-02763\", \"queryCount must be greater than 0\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (pCreateInfo->queryCount == 0) {\n    skip |= LogError(\"VUID-VkQueryPoolCreateInfo-queryCount-02763\", device, create_info_loc.dot(Field::queryCount), \"is zero.\");\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-vkCreateSamplerYcbcrConversion-None-01648\", \"The samplerYcbcrConversion feature must be enabled\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (!enabled_features.samplerYcbcrConversion) {\n    skip |= LogError(\"VUID-vkCreateSamplerYcbcrConversion-None-01648\", device, error_obj.location,\n                     \"samplerYcbcrConversion feature must be enabled.\");\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkSamplerYcbcrConversionCreateInfo-components-02581\", \"If the format has a _422 or _420 suffix, then components.g must be the identity swizzle\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if ((components.g != VK_COMPONENT_SWIZZLE_G) && (components.g != VK_COMPONENT_SWIZZLE_IDENTITY)) {\n    skip |= LogError(\"VUID-VkSamplerYcbcrConversionCreateInfo-components-02581\", device, create_info_loc,\n                     \"When using a XChroma subsampled format (%s) the components.g needs to be VK_COMPONENT_SWIZZLE_G \"\n                     \"or VK_COMPONENT_SWIZZLE_IDENTITY, but is %s.\",\n                     string_VkFormat(format), string_VkComponentSwizzle(components.g));\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkSamplerYcbcrConversionCreateInfo-components-02583\", \"If the format has a _422 or _420 suffix, then components.r must be the identity swizzle or VK_COMPONENT_SWIZZLE_B\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if ((components.r != VK_COMPONENT_SWIZZLE_R) && (components.r != VK_COMPONENT_SWIZZLE_IDENTITY) &&\n    (components.r != VK_COMPONENT_SWIZZLE_B)) {\n    skip |= LogError(\"VUID-VkSamplerYcbcrConversionCreateInfo-components-02583\", device, create_info_loc,\n                     \"When using a XChroma subsampled format (%s) the components.r needs to be VK_COMPONENT_SWIZZLE_R \"\n                     \"or VK_COMPONENT_SWIZZLE_IDENTITY or VK_COMPONENT_SWIZZLE_B, but is %s.\",\n                     string_VkFormat(format), string_VkComponentSwizzle(components.r));\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkSamplerYcbcrConversionCreateInfo-components-02584\", \"If the format has a _422 or _420 suffix, then components.b must be the identity swizzle or VK_COMPONENT_SWIZZLE_R\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if ((components.b != VK_COMPONENT_SWIZZLE_B) && (components.b != VK_COMPONENT_SWIZZLE_IDENTITY) &&\n    (components.b != VK_COMPONENT_SWIZZLE_R)) {\n    skip |= LogError(\"VUID-VkSamplerYcbcrConversionCreateInfo-components-02584\", device, create_info_loc,\n                     \"When using a XChroma subsampled format (%s) the components.b needs to be VK_COMPONENT_SWIZZLE_B \"\n                     \"or VK_COMPONENT_SWIZZLE_IDENTITY or VK_COMPONENT_SWIZZLE_R, but is %s.\",\n                     string_VkFormat(format), string_VkComponentSwizzle(components.b));\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkDescriptorGetInfoEXT-type-08018\", \"type must not be VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER_DYNAMIC, VK_DESCRIPTOR_TYPE_STORAGE_BUFFER_DYNAMIC or VK_DESCRIPTOR_TYPE_INLINE_UNIFORM_BLOCK\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "skip |= LogError(\"VUID-VkDescriptorGetInfoEXT-type-08018\", device, descriptor_info_loc.dot(Field::type), \"is %s.\",\n                 string_VkDescriptorType(pDescriptorInfo->type));\n"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkDescriptorGetInfoEXT-pCombinedImageSampler-parameter\", \"If type is VK_DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER, the pCombinedImageSampler member of data must be a valid pointer to a valid VkDescriptorImageInfo structure\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (!pDescriptorInfo->data.pCombinedImageSampler) {\n    skip |= LogError(\"VUID-VkDescriptorGetInfoEXT-pCombinedImageSampler-parameter\", device,\n                     descriptor_info_loc.dot(Field::type),\n                     \"is VK_DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER, but pCombinedImageSampler is null.\");\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkDescriptorAddressInfoEXT-None-09508\", \"If address is not zero, and the descriptor is of type VK_DESCRIPTOR_TYPE_UNIFORM_TEXEL_BUFFER or VK_DESCRIPTOR_TYPE_STORAGE_TEXEL_BUFFER, then format must not be VK_FORMAT_UNDEFINED\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if ((pDescriptorInfo->type == VK_DESCRIPTOR_TYPE_UNIFORM_TEXEL_BUFFER ||\n    address_info->format == VK_FORMAT_UNDEFINED) {\n    skip |= LogError(\"VUID-VkDescriptorAddressInfoEXT-None-09508\", device, address_loc.dot(Field::format),\n                     \"is VK_FORMAT_UNDEFINED.\");\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkSetDescriptorBufferOffsetsInfoEXT-layout-09496\", \"If layout is VK_NULL_HANDLE, the pNext chain must include a valid VkPipelineLayoutCreateInfo structure\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "LogError(\"VUID-VkSetDescriptorBufferOffsetsInfoEXT-None-09495\", commandBuffer,\n         error_obj.location.dot(Field::pSetDescriptorBufferOffsetsInfo).dot(Field::layout), \"is VK_NULL_HANDLE.\");\nskip |= LogError(\"VUID-VkSetDescriptorBufferOffsetsInfoEXT-layout-09496\", commandBuffer,\n             error_obj.location.dot(Field::pSetDescriptorBufferOffsetsInfo).dot(Field::layout),\n             \"is VK_NULL_HANDLE and pNext is missing VkPipelineLayoutCreateInfo.\");\n"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkBindDescriptorBufferEmbeddedSamplersInfoEXT-None-09495\", \"If the dynamicPipelineLayout feature is not enabled, layout must be a valid VkPipelineLayout handle\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (!enabled_features.dynamicPipelineLayout) {\n    skip |= LogError(\"VUID-VkBindDescriptorBufferEmbeddedSamplersInfoEXT-None-09495\", commandBuffer,\n                     error_obj.location.dot(Field::pBindDescriptorBufferEmbeddedSamplersInfo).dot(Field::layout),\n                     \"is VK_NULL_HANDLE.\");\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkBindDescriptorBufferEmbeddedSamplersInfoEXT-layout-09496\", \"If layout is VK_NULL_HANDLE, the pNext chain must include a valid VkPipelineLayoutCreateInfo structure\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "error_obj.location.dot(Field::pBindDescriptorBufferEmbeddedSamplersInfo).dot(Field::layout),\nskip |= LogError(\"VUID-VkBindDescriptorBufferEmbeddedSamplersInfoEXT-layout-09496\", commandBuffer,\nerror_obj.location.dot(Field::pBindDescriptorBufferEmbeddedSamplersInfo).dot(Field::layout),\n\"is VK_NULL_HANDLE and pNext is missing VkPipelineLayoutCreateInfo.\");\n"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkPushDescriptorSetWithTemplateInfoKHR-layout-09496\", \"If layout is VK_NULL_HANDLE, the pNext chain must include a valid VkPipelineLayoutCreateInfo structure\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "error_obj.location.dot(Field::pPushDescriptorSetWithTemplateInfo).dot(Field::layout),\nskip |= LogError(\"VUID-VkPushDescriptorSetWithTemplateInfoKHR-layout-09496\", commandBuffer,\nerror_obj.location.dot(Field::pPushDescriptorSetWithTemplateInfo).dot(Field::layout),\n\"is VK_NULL_HANDLE and pNext is missing VkPipelineLayoutCreateInfo.\");\n"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkBindDescriptorSetsInfoKHR-None-09495\", \"If the dynamicPipelineLayout feature is not enabled, layout must be a valid VkPipelineLayout handle\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (!enabled_features.dynamicPipelineLayout) {\n    skip |= LogError(\"VUID-VkBindDescriptorSetsInfoKHR-None-09495\", commandBuffer,\n                     error_obj.location.dot(Field::pBindDescriptorSetsInfo).dot(Field::layout), \"is VK_NULL_HANDLE.\");\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkBindDescriptorSetsInfoKHR-layout-09496\", \"If layout is VK_NULL_HANDLE, the pNext chain must include a valid VkPipelineLayoutCreateInfo structure\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "skip |= LogError(\"VUID-VkBindDescriptorSetsInfoKHR-None-09495\", commandBuffer,\n                 error_obj.location.dot(Field::pBindDescriptorSetsInfo).dot(Field::layout), \"is VK_NULL_HANDLE.\");\nskip |= LogError(\"VUID-VkBindDescriptorSetsInfoKHR-layout-09496\", commandBuffer,\n                 error_obj.location.dot(Field::pBindDescriptorSetsInfo).dot(Field::layout),\n                 \"is VK_NULL_HANDLE and pNext is missing VkPipelineLayoutCreateInfo.\");\n"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkMemoryPriorityAllocateInfoEXT-priority-02602\", \"priority must be between 0 and 1, inclusive\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (chained_prio_struct && (chained_prio_struct->priority < 0.0f || chained_prio_struct->priority > 1.0f)) {\n    skip |= LogError(\"VUID-VkMemoryPriorityAllocateInfoEXT-priority-02602\", device,\n                     allocate_info_loc.pNext(Struct::VkMemoryPriorityAllocateInfoEXT, Field::priority), \"is %f\",\n                     chained_prio_struct->priority);\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkMemoryAllocateInfo-flags-03331\", \"If VkMemoryAllocateFlagsInfo::flags includes VK_MEMORY_ALLOCATE_DEVICE_ADDRESS_BIT, the bufferDeviceAddress feature must be enabled\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if ((flags & VK_MEMORY_ALLOCATE_DEVICE_ADDRESS_BIT) && !enabled_features.bufferDeviceAddress) {\n    skip |= LogError(\"VUID-VkMemoryAllocateInfo-flags-03331\", device, flags_loc,\n                     \"has VK_MEMORY_ALLOCATE_DEVICE_ADDRESS_BIT set, but bufferDeviceAddress feature is not enabled.\");\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkDeviceImageMemoryRequirements-pCreateInfo-06416\", \"The pCreateInfo->pNext chain must not contain a VkImageSwapchainCreateInfoKHR structure\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (vku::FindStructInPNextChain<VkImageSwapchainCreateInfoKHR>(create_info.pNext)) {\n    skip |= LogError(\"VUID-VkDeviceImageMemoryRequirements-pCreateInfo-06416\", device, loc,\n                     \"pNext chain contains VkImageSwapchainCreateInfoKHR.\");\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkDeviceImageMemoryRequirements-pCreateInfo-06776\", \"The pCreateInfo->pNext chain must not contain a VkImageDrmFormatModifierExplicitCreateInfoEXT structure\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (vku::FindStructInPNextChain<VkImageDrmFormatModifierExplicitCreateInfoEXT>(create_info.pNext)) {\n    skip |= LogError(\"VUID-VkDeviceImageMemoryRequirements-pCreateInfo-06776\", device, loc,\n                     \"pNext chain contains VkImageDrmFormatModifierExplicitCreateInfoEXT.\");\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkDeviceImageMemoryRequirements-pCreateInfo-06417\", \"If pCreateInfo->format specifies a multi-planar format and pCreateInfo->flags has VK_IMAGE_CREATE_DISJOINT_BIT set then planeAspect must not be VK_IMAGE_ASPECT_NONE_KHR\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (memory_requirements.planeAspect == VK_IMAGE_ASPECT_NONE_KHR) {\n    skip |= LogError(\"VUID-VkDeviceImageMemoryRequirements-pCreateInfo-06417\", device, loc.dot(Field::planeAspect),\n                     \"is VK_IMAGE_ASPECT_NONE_KHR with a multi-planar format and disjoint flag.\");\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkDeviceImageMemoryRequirements-pNext-06996\", \"Applications also must not call vkGetDeviceImageMemoryRequirements with a VkImageCreateInfo whose pNext chain includes a VkExternalFormatANDROID structure with non-zero externalFormat\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (external_format != 0) {\n    skip |= LogError(\"VUID-VkDeviceImageMemoryRequirements-pNext-06996\", device, loc.dot(Field::pCreateInfo),\n                     \"pNext chain contains VkExternalFormatANDROID with externalFormat %\" PRIu64 \".\", external_format);\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkSparseImageMemoryBind-extent-09388\", \"extent.width must be greater than 0\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (bind.extent.width == 0) {\n    const LogObjectList objlist(queue, image_bind.image);\n    skip |= LogError(\"VUID-VkSparseImageMemoryBind-extent-09388\", objlist,\n                     error_obj.location.dot(Field::pBindInfo, bind_info_i)\n                         .dot(Field::pImageBinds, image_bind_i)\n                         .dot(Field::pBinds, bind_i)\n                         .dot(Field::extent)\n                         .dot(Field::width),\n                     \"is zero.\");\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkSparseImageMemoryBind-extent-09389\", \"extent.height must be greater than 0\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (bind.extent.height == 0) {\n    const LogObjectList objlist(queue, image_bind.image);\n    skip |= LogError(\"VUID-VkSparseImageMemoryBind-extent-09389\", objlist,\n                     error_obj.location.dot(Field::pBindInfo, bind_info_i)\n                         .dot(Field::pImageBinds, image_bind_i)\n                         .dot(Field::pBinds, bind_i)\n                         .dot(Field::extent)\n                         .dot(Field::height),\n                     \"is zero.\");\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkSparseImageMemoryBind-extent-09390\", \"extent.depth must be greater than 0\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (bind.extent.depth == 0) {\n    const LogObjectList objlist(queue, image_bind.image);\n    skip |= LogError(\"VUID-VkSparseImageMemoryBind-extent-09390\", objlist,\n                     error_obj.location.dot(Field::pBindInfo, bind_info_i)\n                         .dot(Field::pImageBinds, image_bind_i)\n                         .dot(Field::pBinds, bind_i)\n                         .dot(Field::extent)\n                         .dot(Field::depth),\n                     \"is zero.\");\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkMemoryGetFdInfoKHR-handleType-00672\", \"handleType must be VK_EXTERNAL_MEMORY_HANDLE_TYPE_OPAQUE_FD_BIT or VK_EXTERNAL_MEMORY_HANDLE_TYPE_DMA_BUF_BIT_EXT\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (0 == (pGetFdInfo->handleType & allowed_types)) {\n    skip |= LogError(\"VUID-VkMemoryGetFdInfoKHR-handleType-00672\", pGetFdInfo->memory, error_obj.location,\n                     \"handle type %s is not one of the supported handle types.\",\n                     string_VkExternalMemoryHandleTypeFlagBits(pGetFdInfo->handleType));\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-vkGetMemoryFdPropertiesKHR-fd-00673\", \"fd must point to a valid POSIX file descriptor memory handle\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (fd < 0) {\n    skip |= LogError(\"VUID-vkGetMemoryFdPropertiesKHR-fd-00673\", device, error_obj.location,\n                     \"fd handle (%d) is not a valid POSIX file descriptor.\", fd);\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-vkGetMemoryFdPropertiesKHR-handleType-00674\", \"handleType must not be VK_EXTERNAL_MEMORY_HANDLE_TYPE_OPAQUE_FD_BIT\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (handleType == VK_EXTERNAL_MEMORY_HANDLE_TYPE_OPAQUE_FD_BIT) {\n    skip |= LogError(\"VUID-vkGetMemoryFdPropertiesKHR-handleType-00674\", device, error_obj.location,\n                     \"opaque handle type %s is not allowed.\", string_VkExternalMemoryHandleTypeFlagBits(handleType));\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkImportFenceFdInfoKHR-handleType-01464\", \"handleType must be a value included in the Handle Types Supported by VkImportFenceFdInfoKHR table\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "bool skip = false;\nconst Location info_loc = error_obj.location.dot(Field::pImportFenceFdInfo);\nskip |= ValidateExternalFenceHandleType(pImportFenceFdInfo->fence, \"VUID-VkImportFenceFdInfoKHR-handleType-01464\",\n                                        info_loc.dot(Field::handleType), pImportFenceFdInfo->handleType, kFenceFdHandleTypes);\n"
        },
        {
            "role": "user",
            "content": "{\"VUID-vkGetMemoryHostPointerPropertiesEXT-pHostPointer-01753\", \"pHostPointer must be a pointer aligned to an integer multiple of VkPhysicalDeviceExternalMemoryHostPropertiesEXT::minImportedHostPointerAlignment\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (SafeModulo(host_pointer, phys_dev_ext_props.external_memory_host_props.minImportedHostPointerAlignment) != 0) {\n    skip |= LogError(\"VUID-vkGetMemoryHostPointerPropertiesEXT-pHostPointer-01753\", device,\n                     error_obj.location.dot(Field::pHostPointer),\n                     \"(0x%\" PRIxLEAST64\n                     \") is not aligned \"\n                     \"to minImportedHostPointerAlignment (%\" PRIuLEAST64 \")\",\n                     host_pointer, phys_dev_ext_props.external_memory_host_props.minImportedHostPointerAlignment);\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkMemoryGetWin32HandleInfoKHR-handleType-00664\", \"handleType must be defined as an NT handle or a global share handle\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if ((pGetWin32HandleInfo->handleType & (nt_handles | global_share_handles)) == 0) {\n    skip |= LogError(\"VUID-VkMemoryGetWin32HandleInfoKHR-handleType-00664\", pGetWin32HandleInfo->memory, error_obj.location,\n                     \"handle type %s is not one of the supported handle types.\",\n                     string_VkExternalMemoryHandleTypeFlagBits(pGetWin32HandleInfo->handleType));\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-vkGetMemoryWin32HandlePropertiesKHR-handle-00665\", \"handle must point to a valid Windows memory handle\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (handle == NULL || handle == INVALID_HANDLE_VALUE) {\n    skip |= LogError(\"VUID-vkGetMemoryWin32HandlePropertiesKHR-handle-00665\", device, error_obj.location.dot(Field::handle),\n                     \"(0x%\" PRIxPTR \") is not a valid Windows handle.\", reinterpret_cast<std::uintptr_t>(handle));\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkImportSemaphoreWin32HandleInfoKHR-handleType-01466\", \"If handleType is not VK_EXTERNAL_SEMAPHORE_HANDLE_TYPE_OPAQUE_WIN32_BIT or VK_EXTERNAL_SEMAPHORE_HANDLE_TYPE_D3D12_FENCE_BIT, name must be NULL\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if ((info->handleType & kNameAllowedTypes) == 0 && info->name) {\n    skip |= LogError(\"VUID-VkImportSemaphoreWin32HandleInfoKHR-handleType-01466\", info->semaphore,\n                     error_obj.location.dot(Field::pImportSemaphoreWin32HandleInfo).dot(Field::name),\n                     \"(%p) must be NULL if handleType is %s\", reinterpret_cast<const void *>(info->name),\n                     string_VkExternalSemaphoreHandleTypeFlagBits(info->handleType));\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkImportFenceWin32HandleInfoKHR-handleType-01457\", \"handleType must be a value included in the Handle Types Supported by VkImportFenceWin32HandleInfoKHR table\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "const VkImportFenceWin32HandleInfoKHR *info,\nbool skip = false;\nskip |= ValidateExternalFenceHandleType(info->fence, \"VUID-VkImportFenceWin32HandleInfoKHR-handleType-01457\",\nerror_obj.location.dot(Field::pImportFenceWin32HandleInfo).dot(Field::handleType),\ninfo->handleType, kFenceWin32HandleTypes);\n"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkImportFenceWin32HandleInfoKHR-handleType-01459\", \"If handleType is not VK_EXTERNAL_FENCE_HANDLE_TYPE_OPAQUE_WIN32_BIT, name must be NULL\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if ((info->handleType & kNameAllowedTypes) == 0 && info->name) {\n    skip |= LogError(\"VUID-VkImportFenceWin32HandleInfoKHR-handleType-01459\", info->fence,\n                     error_obj.location.dot(Field::pImportFenceWin32HandleInfo).dot(Field::name),\n                     \"(%p) must be NULL if handleType is %s\", reinterpret_cast<const void *>(info->name),\n                     string_VkExternalFenceHandleTypeFlagBits(info->handleType));\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkImportFenceWin32HandleInfoKHR-handle-01462\", \"If handle is not NULL, name must be NULL\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (info->handle && info->name) {\n    skip |= LogError(\"VUID-VkImportFenceWin32HandleInfoKHR-handle-01462\", info->fence,\n                     error_obj.location.dot(Field::pImportFenceWin32HandleInfo), \"both handle (%p) and name (%p) are non-NULL\",\n                     info->handle, reinterpret_cast<const void *>(info->name));\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkMemoryAllocateInfo-allocationSize-07897\", \"If the parameters do not define an import or export operation, allocationSize must be greater than 0\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (!ext.has_export && ext.total_import_ops == 0 && allocate_info.allocationSize == 0) {\n    skip |= LogError(\"VUID-VkMemoryAllocateInfo-allocationSize-07897\", device, allocate_info_loc.dot(Field::allocationSize),\n                     \"is 0.\");\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkMemoryAllocateInfo-pNext-03332\", \"If the pNext chain includes a VkImportMemoryHostPointerInfoEXT structure, VkMemoryOpaqueCaptureAddressAllocateInfo::opaqueCaptureAddress must be zero\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (ext.import_info_host_pointer) {\n    skip |= LogError(\"VUID-VkMemoryAllocateInfo-pNext-03332\", device, address_loc,\n                     \"is non-zero (%\" PRIu64 \") but the pNext chain includes a VkImportMemoryHostPointerInfoEXT structure.\",\n                     opaque_alloc_info->opaqueCaptureAddress);\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkMemoryAllocateInfo-None-06657\", \"The parameters must not define more than one import operation\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (ext.total_import_ops > 1) {\n    skip |= LogError(\"VUID-VkMemoryAllocateInfo-None-06657\", device, allocate_info_loc,\n                     \"%\" PRIu32 \" import operations are defined\", ext.total_import_ops);\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkMemoryAllocateInfo-pNext-00640\", \"If the pNext chain includes a VkExportMemoryAllocateInfo structure, it must not include a VkExportMemoryAllocateInfoNV or VkExportMemoryWin32HandleInfoNV structure\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (ext.export_info_nv) {\n    skip |= LogError(\"VUID-VkMemoryAllocateInfo-pNext-00640\", device, allocate_info_loc,\n                     \"pNext chain includes both VkExportMemoryAllocateInfo and \"\n                     \"VkExportMemoryAllocateInfoNV\");\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkMemoryAllocateInfo-pNext-00640\", \"If the pNext chain includes a VkExportMemoryAllocateInfo structure, it must not include a VkExportMemoryAllocateInfoNV or VkExportMemoryWin32HandleInfoNV structure\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (ext.export_info_win32_nv) {\n    skip |= LogError(\"VUID-VkMemoryAllocateInfo-pNext-00640\", device, allocate_info_loc,\n                     \"pNext chain includes both VkExportMemoryAllocateInfo and \"\n                     \"VkExportMemoryWin32HandleInfoNV\");\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkImportMemoryFdInfoKHR-handleType-00670\", \"If handleType is not 0, fd must be a valid handle of the type specified by handleType\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (ext.import_info_fd->fd < 0) {\n    skip |= LogError(\"VUID-VkImportMemoryFdInfoKHR-handleType-00670\", device,\n                     allocate_info_loc.pNext(Struct::VkImportMemoryFdInfoKHR, Field::fd),\n                     \"(%d) is not a valid POSIX file descriptor.\", ext.import_info_fd->fd);\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkImportMemoryFdInfoKHR-handleType-00669\", \"If handleType is not 0, it must be VK_EXTERNAL_MEMORY_HANDLE_TYPE_OPAQUE_FD_BIT or VK_EXTERNAL_MEMORY_HANDLE_TYPE_DMA_BUF_BIT_EXT\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (ext.import_info_fd->handleType != VK_EXTERNAL_MEMORY_HANDLE_TYPE_OPAQUE_FD_BIT &&\n    ext.import_info_fd->handleType != VK_EXTERNAL_MEMORY_HANDLE_TYPE_DMA_BUF_BIT_EXT) {\n    skip |= LogError(\"VUID-VkImportMemoryFdInfoKHR-handleType-00669\", device,\n                     allocate_info_loc.pNext(Struct::VkImportMemoryFdInfoKHR, Field::handleType), \"%s is not allowed.\",\n                     string_VkExternalMemoryHandleTypeFlagBits(ext.import_info_fd->handleType));\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkImportMemoryHostPointerInfoEXT-handleType-01748\", \"If handleType is not 0, it must be VK_EXTERNAL_MEMORY_HANDLE_TYPE_HOST_ALLOCATION_BIT_EXT or VK_EXTERNAL_MEMORY_HANDLE_TYPE_HOST_MAPPED_FOREIGN_MEMORY_BIT_EXT\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (ext.import_info_host_pointer->handleType != VK_EXTERNAL_MEMORY_HANDLE_TYPE_HOST_ALLOCATION_BIT_EXT &&\n    ext.import_info_host_pointer->handleType != VK_EXTERNAL_MEMORY_HANDLE_TYPE_HOST_MAPPED_FOREIGN_MEMORY_BIT_EXT) {\n    skip |= LogError(\"VUID-VkImportMemoryHostPointerInfoEXT-handleType-01748\", device,\n                     allocate_info_loc.pNext(Struct::VkImportMemoryHostPointerInfoEXT, Field::handleType), \"is %s.\",\n                     string_VkExternalMemoryHandleTypeFlagBits(ext.import_info_host_pointer->handleType));\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkImportMemoryHostPointerInfoEXT-pHostPointer-01749\", \"pHostPointer must be a pointer aligned to an integer multiple of VkPhysicalDeviceExternalMemoryHostPropertiesEXT::minImportedHostPointerAlignment\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (SafeModulo(host_pointer, phys_dev_ext_props.external_memory_host_props.minImportedHostPointerAlignment) != 0) {\n    skip |= LogError(\"VUID-VkImportMemoryHostPointerInfoEXT-pHostPointer-01749\", device,\n                     allocate_info_loc.pNext(Struct::VkImportMemoryHostPointerInfoEXT, Field::pHostPointer),\n                     \"(0x%\" PRIxLEAST64\n                     \") is not aligned \"\n                     \"to minImportedHostPointerAlignment (%\" PRIuLEAST64 \")\",\n                     host_pointer, phys_dev_ext_props.external_memory_host_props.minImportedHostPointerAlignment);\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkMemoryAllocateInfo-pNext-02806\", \"If the parameters define an import operation and the external handle is a host pointer, the pNext chain must not include a VkMemoryDedicatedAllocateInfo structure with either its image or buffer field set to a value other than VK_NULL_HANDLE\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (dedicated_allocate_info->buffer != VK_NULL_HANDLE) {\n    skip |= LogError(\"VUID-VkMemoryAllocateInfo-pNext-02806\", device,\n                     allocate_info_loc.pNext(Struct::VkMemoryDedicatedAllocateInfo, Field::buffer),\n                     \"is %s but also using a host import with VkImportMemoryHostPointerInfoEXT.\",\n                     FormatHandle(dedicated_allocate_info->buffer).c_str());\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkMemoryAllocateInfo-pNext-02806\", \"If the parameters define an import operation and the external handle is a host pointer, the pNext chain must not include a VkMemoryDedicatedAllocateInfo structure with either its image or buffer field set to a value other than VK_NULL_HANDLE\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "skip |= LogError(\"VUID-VkMemoryAllocateInfo-pNext-02806\", device,\n                 allocate_info_loc.pNext(Struct::VkMemoryDedicatedAllocateInfo, Field::image),\n                 \"is %s but also using a host import with VkImportMemoryHostPointerInfoEXT.\",\n                 FormatHandle(dedicated_allocate_info->image).c_str());\n"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkMemoryAllocateInfo-pNext-06780\", \"If the pNext chain includes a VkExportMetalObjectCreateInfoEXT structure, its exportObjectType member must be VK_EXPORT_METAL_OBJECT_TYPE_METAL_BUFFER_BIT_EXT\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "skip |= ExportMetalObjectsPNextUtil(VK_EXPORT_METAL_OBJECT_TYPE_METAL_BUFFER_BIT_EXT, \"VUID-VkMemoryAllocateInfo-pNext-06780\",\n                                    allocate_info_loc, \"VK_EXPORT_METAL_OBJECT_TYPE_METAL_BUFFER_BIT_EXT\", allocate_info.pNext);\n"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkFramebufferCreateInfo-flags-03189\", \"If the imagelessFramebuffer feature is not enabled, flags must not include VK_FRAMEBUFFER_CREATE_IMAGELESS_BIT\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (!enabled_features.imagelessFramebuffer) {\n    skip |= LogError(\"VUID-VkFramebufferCreateInfo-flags-03189\", device, create_info_loc.dot(Field::flags),\n                     \"includes VK_FRAMEBUFFER_CREATE_IMAGELESS_BIT, but the imagelessFramebuffer feature is not enabled.\");\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkFramebufferCreateInfo-flags-03191\", \"If flags includes VK_FRAMEBUFFER_CREATE_IMAGELESS_BIT, the attachmentImageInfoCount member of a VkFramebufferAttachmentsCreateInfo structure in the pNext chain must be equal to either zero or attachmentCount\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (framebuffer_attachments_create_info->attachmentImageInfoCount != 0 &&\n    skip |= LogError(\"VUID-VkFramebufferCreateInfo-flags-03191\", device,\n                     create_info_loc.pNext(Struct::VkFramebufferAttachmentsCreateInfo, Field::attachmentImageInfoCount),\n                     \"is %\" PRIu32 \" which is not equal to pCreateInfo->attachmentCount (%\" PRIu32 \").\",\n                     framebuffer_attachments_create_info->attachmentImageInfoCount, pCreateInfo->attachmentCount);\n"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkFramebufferCreateInfo-width-00885\", \"width must be greater than 0\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (pCreateInfo->width == 0) {\n    skip |= LogError(\"VUID-VkFramebufferCreateInfo-width-00885\", device, create_info_loc.dot(Field::width), \"is zero.\");\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkFramebufferCreateInfo-height-00887\", \"height must be greater than 0\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (pCreateInfo->height == 0) {\n    skip |= LogError(\"VUID-VkFramebufferCreateInfo-height-00887\", device, create_info_loc.dot(Field::height), \"is zero.\");\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkFramebufferCreateInfo-layers-00889\", \"layers must be greater than 0\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (pCreateInfo->layers == 0) {\n    skip |= LogError(\"VUID-VkFramebufferCreateInfo-layers-00889\", device, create_info_loc.dot(Field::layers), \"is zero.\");\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkFramebufferCreateInfo-height-00888\", \"height must be less than or equal to maxFramebufferHeight\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (pCreateInfo->height > device_limits.maxFramebufferHeight) {\n    skip |= LogError(\"VUID-VkFramebufferCreateInfo-height-00888\", device, create_info_loc.dot(Field::height),\n                     \"(%\" PRIu32 \") exceeds physical device limits (%\" PRIu32 \").\", pCreateInfo->height,\n                     device_limits.maxFramebufferHeight);\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkFramebufferCreateInfo-layers-00890\", \"layers must be less than or equal to maxFramebufferLayers\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (pCreateInfo->layers > device_limits.maxFramebufferLayers) {\n    skip |= LogError(\"VUID-VkFramebufferCreateInfo-layers-00890\", device, create_info_loc.dot(Field::layers),\n                     \"(%\" PRIu32 \") exceeds physical device limits (%\" PRIu32 \").\", pCreateInfo->layers,\n                     device_limits.maxFramebufferLayers);\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkImageCreateInfo-sharingMode-00942\", \"If sharingMode is VK_SHARING_MODE_CONCURRENT, queueFamilyIndexCount must be greater than 1\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (queue_family_index_count <= 1) {\n    skip |= LogError(\"VUID-VkImageCreateInfo-sharingMode-00942\", device, create_info_loc.dot(Field::queueFamilyIndexCount),\n                     \"is %\" PRIu32 \".\", queue_family_index_count);\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkImageCreateInfo-sharingMode-00941\", \"If sharingMode is VK_SHARING_MODE_CONCURRENT, pQueueFamilyIndices must be a valid pointer to an array of queueFamilyIndexCount uint32_t values\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (pCreateInfo->pQueueFamilyIndices == nullptr) {\n    skip |= LogError(\"VUID-VkImageCreateInfo-sharingMode-00941\", device, create_info_loc.dot(Field::pQueueFamilyIndices),\n                     \"is NULL.\");\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkImageCreateInfo-extent-00945\", \"extent.height must be greater than 0\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "skip |= ValidateNotZero(pCreateInfo->extent.width == 0, \"VUID-VkImageCreateInfo-extent-00944\",\n                        create_info_loc.dot(Field::extent).dot(Field::width));\nskip |= ValidateNotZero(pCreateInfo->extent.height == 0, \"VUID-VkImageCreateInfo-extent-00945\",\n                        create_info_loc.dot(Field::extent).dot(Field::height));\n"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkImageCreateInfo-extent-00946\", \"extent.depth must be greater than 0\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "create_info_loc.dot(Field::extent).dot(Field::width));\nskip |= ValidateNotZero(pCreateInfo->extent.height == 0, \"VUID-VkImageCreateInfo-extent-00945\",\ncreate_info_loc.dot(Field::extent).dot(Field::height));\nskip |= ValidateNotZero(pCreateInfo->extent.depth == 0, \"VUID-VkImageCreateInfo-extent-00946\",\ncreate_info_loc.dot(Field::extent).dot(Field::depth));\n"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkImageCreateInfo-mipLevels-00947\", \"mipLevels must be greater than 0\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "skip |= ValidateNotZero(pCreateInfo->extent.depth == 0, \"VUID-VkImageCreateInfo-extent-00946\",\nskip |= ValidateNotZero(pCreateInfo->mipLevels == 0, \"VUID-VkImageCreateInfo-mipLevels-00947\",\n                        create_info_loc.dot(Field::mipLevels));\n"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkImageCreateInfo-arrayLayers-00948\", \"arrayLayers must be greater than 0\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "skip |= ValidateNotZero(pCreateInfo->mipLevels == 0, \"VUID-VkImageCreateInfo-mipLevels-00947\",\nskip |= ValidateNotZero(pCreateInfo->arrayLayers == 0, \"VUID-VkImageCreateInfo-arrayLayers-00948\",\n                        create_info_loc.dot(Field::arrayLayers));\n"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkImageCreateInfo-imageType-00956\", \"If imageType is VK_IMAGE_TYPE_1D, both extent.height and extent.depth must be 1\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if ((pCreateInfo->imageType == VK_IMAGE_TYPE_1D) && ((pCreateInfo->extent.height != 1) || (pCreateInfo->extent.depth != 1))) {\n    skip |= LogError(\"VUID-VkImageCreateInfo-imageType-00956\", device, create_info_loc,\n                     \"if pCreateInfo->imageType is VK_IMAGE_TYPE_1D, both pCreateInfo->extent.height and \"\n                     \"pCreateInfo->extent.depth must be 1.\");\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkImageCreateInfo-flags-00949\", \"If flags contains VK_IMAGE_CREATE_CUBE_COMPATIBLE_BIT, imageType must be VK_IMAGE_TYPE_2D\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (type != VK_IMAGE_TYPE_2D) {\n    skip |= LogError(\"VUID-VkImageCreateInfo-flags-00949\", device, create_info_loc,\n                     \"Image type %s is incompatible with VK_IMAGE_CREATE_CUBE_COMPATIBLE_BIT.\", string_VkImageType(type));\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkImageCreateInfo-flags-08865\", \"If flags contains VK_IMAGE_CREATE_CUBE_COMPATIBLE_BIT, extent.width and extent.height must be equal\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (width != height) {\n    skip |= LogError(\"VUID-VkImageCreateInfo-flags-08865\", device, create_info_loc,\n                     \"extent.width (=%\" PRIu32 \") not equal to extent.height (=%\" PRIu32 \").\", pCreateInfo->extent.width,\n                     pCreateInfo->extent.height);\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkImageCreateInfo-flags-08866\", \"If flags contains VK_IMAGE_CREATE_CUBE_COMPATIBLE_BIT, arrayLayers must be greater than or equal to 6\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (pCreateInfo->arrayLayers < 6) {\n    skip |= LogError(\"VUID-VkImageCreateInfo-flags-08866\", device, create_info_loc,\n                     \"arrayLayers (=%\" PRIu32 \") is less than 6.\", pCreateInfo->arrayLayers);\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkImageCreateInfo-imageType-00961\", \"If imageType is VK_IMAGE_TYPE_3D, arrayLayers must be 1\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if ((pCreateInfo->imageType == VK_IMAGE_TYPE_3D) && (pCreateInfo->arrayLayers != 1)) {\n    skip |= LogError(\"VUID-VkImageCreateInfo-imageType-00961\", device, create_info_loc,\n                     \"if pCreateInfo->imageType is VK_IMAGE_TYPE_3D, pCreateInfo->arrayLayers must be 1.\");\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkImageCreateInfo-usage-00966\", \"If usage includes VK_IMAGE_USAGE_TRANSIENT_ATTACHMENT_BIT, usage must also contain at least one of VK_IMAGE_USAGE_COLOR_ATTACHMENT_BIT, VK_IMAGE_USAGE_DEPTH_STENCIL_ATTACHMENT_BIT, or VK_IMAGE_USAGE_INPUT_ATTACHMENT_BIT\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (0 == (pCreateInfo->usage & legal_flags)) {\n    skip |= LogError(\"VUID-VkImageCreateInfo-usage-00966\", device, create_info_loc,\n                     \"Transient attachment image without a compatible attachment flag set.\");\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkImageCreateInfo-usage-00963\", \"If usage includes VK_IMAGE_USAGE_TRANSIENT_ATTACHMENT_BIT, then bits other than VK_IMAGE_USAGE_COLOR_ATTACHMENT_BIT, VK_IMAGE_USAGE_DEPTH_STENCIL_ATTACHMENT_BIT, and VK_IMAGE_USAGE_INPUT_ATTACHMENT_BIT must not be set\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (0 != (pCreateInfo->usage & ~legal_flags)) {\n    skip |= LogError(\"VUID-VkImageCreateInfo-usage-00963\", device, create_info_loc,\n                     \"Transient attachment image with incompatible usage flags set.\");\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkImageCreateInfo-mipLevels-00958\", \"mipLevels must be less than or equal to the number of levels in the complete mipmap chain based on extent.width, extent.height, and extent.depth\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (max_dim > 0 && pCreateInfo->mipLevels > max_mip_levels) {\n    skip |= LogError(\"VUID-VkImageCreateInfo-mipLevels-00958\", device, create_info_loc,\n                     \"pCreateInfo->mipLevels must be less than or equal to \"\n                     \"floor(log2(max(pCreateInfo->extent.width, pCreateInfo->extent.height, pCreateInfo->extent.depth)))+1.\");\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkImageCreateInfo-flags-07755\", \"If flags contains VK_IMAGE_CREATE_2D_VIEW_COMPATIBLE_BIT_EXT, imageType must be VK_IMAGE_TYPE_3D\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if ((image_flags & VK_IMAGE_CREATE_2D_VIEW_COMPATIBLE_BIT_EXT) && (pCreateInfo->imageType != VK_IMAGE_TYPE_3D)) {\n    skip |= LogError(\"VUID-VkImageCreateInfo-flags-07755\", device, create_info_loc.dot(Field::flags),\n                     \"includes VK_IMAGE_CREATE_2D_VIEW_COMPATIBLE_BIT_EXT but \"\n                     \"imageType is %s.\",\n                     string_VkImageType(pCreateInfo->imageType));\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkImageCreateInfo-flags-01533\", \"If flags contains VK_IMAGE_CREATE_SAMPLE_LOCATIONS_COMPATIBLE_DEPTH_BIT_EXT format must be a depth or depth/stencil format\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (((image_flags & VK_IMAGE_CREATE_SAMPLE_LOCATIONS_COMPATIBLE_DEPTH_BIT_EXT) != 0) &&\n    skip |= LogError(\"VUID-VkImageCreateInfo-flags-01533\", device, create_info_loc.dot(Field::flags),\n                     \"includes VK_IMAGE_CREATE_SAMPLE_LOCATIONS_COMPATIBLE_DEPTH_BIT_EXT the \"\n                     \"format (%s) must be a depth or depth/stencil format.\",\n                     string_VkFormat(image_format));\n"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkImageCreateInfo-usage-00968\", \"If the shaderStorageImageMultisample feature is not enabled, and usage contains VK_IMAGE_USAGE_STORAGE_BIT, samples must be VK_SAMPLE_COUNT_1_BIT\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if ((!enabled_features.shaderStorageImageMultisample) && ((pCreateInfo->usage & VK_IMAGE_USAGE_STORAGE_BIT) != 0) &&\n    skip |= LogError(\"VUID-VkImageCreateInfo-usage-00968\", device, create_info_loc.dot(Field::usage),\n                     \"includes VK_IMAGE_USAGE_STORAGE_BIT and imageType is %s, but shaderStorageImageMultisample feature \"\n                     \"was not enabled.\",\n                     string_VkSampleCountFlagBits(pCreateInfo->samples));\n"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkImageCreateInfo-tiling-02261\", \"If tiling is VK_IMAGE_TILING_DRM_FORMAT_MODIFIER_EXT, then the pNext chain must include exactly one of VkImageDrmFormatModifierListCreateInfoEXT or VkImageDrmFormatModifierExplicitCreateInfoEXT structures\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if ((!drm_format_mod_list) && (!drm_format_mod_explict)) {\n    skip |= LogError(\"VUID-VkImageCreateInfo-tiling-02261\", device, create_info_loc.dot(Field::tiling),\n                     \"is VK_IMAGE_TILING_DRM_FORMAT_MODIFIER_EXT but pNext is missing \"\n                     \"VkImageDrmFormatModifierListCreateInfoEXT or \"\n                     \"VkImageDrmFormatModifierExplicitCreateInfoEXT.\");\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkImageCreateInfo-tiling-02353\", \"If tiling is VK_IMAGE_TILING_DRM_FORMAT_MODIFIER_EXT and flags contains VK_IMAGE_CREATE_MUTABLE_FORMAT_BIT, then the pNext chain must include a VkImageFormatListCreateInfo structure with non-zero viewFormatCount\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (!format_list_info) {\n    skip |= LogError(\"VUID-VkImageCreateInfo-tiling-02353\", device, create_info_loc.dot(Field::tiling),\n                     \"is VK_IMAGE_TILING_DRM_FORMAT_MODIFIER_EXT, flags includes \"\n                     \"VK_IMAGE_CREATE_MUTABLE_FORMAT_BIT, but pNext is missing VkImageFormatListCreateInfo.\");\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkImageCreateInfo-pNext-02262\", \"If the pNext chain includes a VkImageDrmFormatModifierListCreateInfoEXT or VkImageDrmFormatModifierExplicitCreateInfoEXT structure, then tiling must be VK_IMAGE_TILING_DRM_FORMAT_MODIFIER_EXT\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "skip |= LogError(\"VUID-VkImageCreateInfo-pNext-02262\", device, create_info_loc.dot(Field::tiling),\n                 \"is %s, but there is a \"\n                 \"VkImageDrmFormatModifierListCreateInfoEXT in the pNext chain\",\n                 string_VkImageTiling(pCreateInfo->tiling));\n"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkImageCreateInfo-pNext-02262\", \"If the pNext chain includes a VkImageDrmFormatModifierListCreateInfoEXT or VkImageDrmFormatModifierExplicitCreateInfoEXT structure, then tiling must be VK_IMAGE_TILING_DRM_FORMAT_MODIFIER_EXT\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "\"VkImageDrmFormatModifierListCreateInfoEXT in the pNext chain\",\nstring_VkImageTiling(pCreateInfo->tiling));\nskip |= LogError(\"VUID-VkImageCreateInfo-pNext-02262\", device, create_info_loc.dot(Field::tiling),\n\"is %s, but there is a VkImageDrmFormatModifierExplicitCreateInfoEXT \"\n\"in the pNext chain\",\nstring_VkImageTiling(pCreateInfo->tiling));\n"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkImageDrmFormatModifierExplicitCreateInfoEXT-size-02267\", \"For each element of pPlaneLayouts, size must be 0\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (drm_format_mod_explict->pPlaneLayouts[i].size != 0) {\n    skip |= LogError(\"VUID-VkImageDrmFormatModifierExplicitCreateInfoEXT-size-02267\", device,\n                     drm_loc.dot(Field::size), \"is %\" PRIu64 \".\", drm_format_mod_explict->pPlaneLayouts[i].size);\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkImageDrmFormatModifierExplicitCreateInfoEXT-depthPitch-02269\", \"For each element of pPlaneLayouts, depthPitch must be 0 if VkImageCreateInfo::extent.depth is 1\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (pCreateInfo->extent.depth == 1 && drm_format_mod_explict->pPlaneLayouts[i].depthPitch != 0) {\n    skip |= LogError(\"VUID-VkImageDrmFormatModifierExplicitCreateInfoEXT-depthPitch-02269\", device,\n                     drm_loc.dot(Field::depthPitch), \"is %\" PRIu64 \" and extext.depth is 1.\",\n                     drm_format_mod_explict->pPlaneLayouts[i].depthPitch);\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkImageCreateInfo-pNext-06746\", \"If the pNext chain includes a VkImageCompressionControlEXT structure, it must not contain a VkImageDrmFormatModifierExplicitCreateInfoEXT structure\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (drm_format_mod_explict && compression_control) {\n    skip |= LogError(\"VUID-VkImageCreateInfo-pNext-06746\", device, create_info_loc.dot(Field::pNext),\n                     \"has both VkImageCompressionControlEXT and VkImageDrmFormatModifierExplicitCreateInfoEXT.\");\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkImageCreateInfo-samples-02257\", \"If samples is not VK_SAMPLE_COUNT_1_BIT, then imageType must be VK_IMAGE_TYPE_2D, flags must not contain VK_IMAGE_CREATE_CUBE_COMPATIBLE_BIT, mipLevels must be equal to 1, and imageCreateMaybeLinear (as defined in Image Creation Limits) must be VK_FALSE,\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if ((pCreateInfo->samples != VK_SAMPLE_COUNT_1_BIT) &&\n    skip |= LogError(\"VUID-VkImageCreateInfo-samples-02257\", device, create_info_loc,\n                     \"image created with\\n\"\n                     \"samples = %s\\n\"\n                     \"imageType = %s\\n\"\n                     \"flags = %s (contains VK_IMAGE_CREATE_CUBE_COMPATIBLE_BIT)\\n\"\n                     \"mipLevels = %\" PRIu32\n                     \"\\n\"\n                     \"which is not valid.\",\n                     string_VkSampleCountFlagBits(pCreateInfo->samples), string_VkImageType(pCreateInfo->imageType),\n                     string_VkImageCreateFlags(image_flags).c_str(), pCreateInfo->mipLevels);\n"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkImageCreateInfo-flags-02259\", \"If flags contains VK_IMAGE_CREATE_SPLIT_INSTANCE_BIND_REGIONS_BIT, then mipLevels must be one, arrayLayers must be one, imageType must be VK_IMAGE_TYPE_2D. and imageCreateMaybeLinear (as defined in Image Creation Limits) must be VK_FALSE\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if ((image_flags & VK_IMAGE_CREATE_SPLIT_INSTANCE_BIND_REGIONS_BIT) &&\n    skip |= LogError(\"VUID-VkImageCreateInfo-flags-02259\", device, create_info_loc,\n                     \"image created with\\n\"\n                     \"imageType = %s\\n\"\n                     \"flags = %s (contains VK_IMAGE_CREATE_SPLIT_INSTANCE_BIND_REGIONS_BIT)\\n\"\n                     \"arrayLayers = %\" PRIu32\n                     \"\\n\"\n                     \"mipLevels = %\" PRIu32\n                     \"\\n\"\n                     \"which is not valid.\",\n                     string_VkImageType(pCreateInfo->imageType), string_VkImageCreateFlags(image_flags).c_str(),\n                     pCreateInfo->arrayLayers, pCreateInfo->mipLevels);\n"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkImageCreateInfo-samples-02558\", \"If samples is not VK_SAMPLE_COUNT_1_BIT, usage must not contain VK_IMAGE_USAGE_FRAGMENT_DENSITY_MAP_BIT_EXT\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (pCreateInfo->samples != VK_SAMPLE_COUNT_1_BIT) {\n    skip |= LogError(\"VUID-VkImageCreateInfo-samples-02558\", device, create_info_loc.dot(Field::usage),\n                     \"includes VK_IMAGE_USAGE_FRAGMENT_DENSITY_MAP_BIT_EXT, but samples is %s.\",\n                     string_VkSampleCountFlagBits(pCreateInfo->samples));\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkImageCreateInfo-flags-02565\", \"If flags contains VK_IMAGE_CREATE_SUBSAMPLED_BIT_EXT, tiling must be VK_IMAGE_TILING_OPTIMAL\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (pCreateInfo->tiling != VK_IMAGE_TILING_OPTIMAL) {\n    skip |= LogError(\"VUID-VkImageCreateInfo-flags-02565\", device, create_info_loc.dot(Field::flags),\n                     \"includes VK_IMAGE_CREATE_SUBSAMPLED_BIT_EXT, but tiling is %s.\",\n                     string_VkImageTiling(pCreateInfo->tiling));\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkImageCreateInfo-flags-02566\", \"If flags contains VK_IMAGE_CREATE_SUBSAMPLED_BIT_EXT, imageType must be VK_IMAGE_TYPE_2D\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (pCreateInfo->imageType != VK_IMAGE_TYPE_2D) {\n    skip |= LogError(\"VUID-VkImageCreateInfo-flags-02566\", device, create_info_loc.dot(Field::flags),\n                     \"includes VK_IMAGE_CREATE_SUBSAMPLED_BIT_EXT, but imageType is %s.\",\n                     string_VkImageType(pCreateInfo->imageType));\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkImageCreateInfo-flags-02567\", \"If flags contains VK_IMAGE_CREATE_SUBSAMPLED_BIT_EXT, flags must not contain VK_IMAGE_CREATE_CUBE_COMPATIBLE_BIT\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (image_flags & VK_IMAGE_CREATE_CUBE_COMPATIBLE_BIT) {\n    skip |= LogError(\"VUID-VkImageCreateInfo-flags-02567\", device, create_info_loc.dot(Field::flags),\n                     \"is %s, which contains SUBSAMPLED_BIT and CUBE_COMPATIBLE.\",\n                     string_VkImageCreateFlags(image_flags).c_str());\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkImageCreateInfo-format-04713\", \"If format has a _420 suffix, extent.height must be a multiple of 2\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (vkuFormatIsYChromaSubsampled(image_format) && (SafeModulo(pCreateInfo->extent.height, 2) != 0)) {\n    skip |= LogError(\"VUID-VkImageCreateInfo-format-04713\", device, create_info_loc.dot(Field::format),\n                     \"(%s) is Y Chroma Subsampled (has _420 suffix) so the height (%\" PRIu32 \") must be a multiple of 2.\",\n                     string_VkFormat(image_format), pCreateInfo->extent.height);\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkImageCreateInfo-flags-04738\", \"If flags does not contain VK_IMAGE_CREATE_MUTABLE_FORMAT_BIT and the pNext chain includes a VkImageFormatListCreateInfo structure, then VkImageFormatListCreateInfo::viewFormatCount must be 0 or 1\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (!mutable_image && view_format_count > 1) {\n    skip |= LogError(\"VUID-VkImageCreateInfo-flags-04738\", device,\n                     create_info_loc.pNext(Struct::VkImageFormatListCreateInfo, Field::viewFormatCount),\n                     \"is %\" PRIu32 \" but flag (%s) does not include VK_IMAGE_CREATE_MUTABLE_FORMAT_BIT.\", view_format_count,\n                     string_VkImageCreateFlags(image_flags).c_str());\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkImageFormatListCreateInfo-viewFormatCount-09540\", \"If viewFormatCount is not 0, each element of pViewFormats must not be VK_FORMAT_UNDEFINED\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (view_format == VK_FORMAT_UNDEFINED) {\n    skip |= LogError(\"VUID-VkImageFormatListCreateInfo-viewFormatCount-09540\", device, format_loc,\n                     \"is VK_FORMAT_UNDEFINED.\");\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkImageCreateInfo-pNext-06722\", \"If a VkImageFormatListCreateInfo structure was included in the pNext chain and format is not a multi-planar format and VkImageFormatListCreateInfo::viewFormatCount is not zero, then each format in VkImageFormatListCreateInfo::pViewFormats must either be compatible with the format as described in the compatibility table or, if flags contains VK_IMAGE_CREATE_BLOCK_TEXEL_VIEW_COMPATIBLE_BIT, be an uncompressed format that is size-compatible with format\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (!size_compatible) {\n    skip |= LogError(\"VUID-VkImageCreateInfo-pNext-06722\", device, format_loc,\n                     \"(%s) and VkImageCreateInfo::format (%s) are not compatible or size-compatible.\",\n                     string_VkFormat(view_format), string_VkFormat(image_format));\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkImageCompressionControlEXT-flags-06748\", \"If flags includes VK_IMAGE_COMPRESSION_FIXED_RATE_EXPLICIT_EXT, pFixedRateFlags must not be NULL\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (image_compression_control->flags == VK_IMAGE_COMPRESSION_FIXED_RATE_EXPLICIT_EXT &&\n    skip |= LogError(\"VUID-VkImageCompressionControlEXT-flags-06748\", device,\n                     create_info_loc.pNext(Struct::VkImageCompressionControlEXT, Field::flags),\n                     \"is %s, but pFixedRateFlags is NULL.\",\n                     string_VkImageCompressionFlagsEXT(image_compression_control->flags).c_str());\n"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkImageCreateInfo-flags-09403\", \"If flags contains VK_IMAGE_CREATE_2D_ARRAY_COMPATIBLE_BIT, flags must not include VK_IMAGE_CREATE_SPARSE_ALIASED_BIT, VK_IMAGE_CREATE_SPARSE_BINDING_BIT, or VK_IMAGE_CREATE_SPARSE_RESIDENCY_BIT\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if ((image_flags & VK_IMAGE_CREATE_2D_ARRAY_COMPATIBLE_BIT) &&\n    skip |= LogError(\"VUID-VkImageCreateInfo-flags-09403\", device, create_info_loc.dot(Field::flags), \"is %s.\",\n                     string_VkImageCreateFlags(image_flags).c_str());\n"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkImageCreateInfo-flags-00969\", \"If the sparseBinding feature is not enabled, flags must not contain VK_IMAGE_CREATE_SPARSE_BINDING_BIT\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if ((image_flags & VK_IMAGE_CREATE_SPARSE_BINDING_BIT) && (!enabled_features.sparseBinding)) {\n    skip |= LogError(\"VUID-VkImageCreateInfo-flags-00969\", device, create_info_loc.dot(Field::flags),\n                     \"includes VK_IMAGE_CREATE_SPARSE_BINDING_BIT, but the \"\n                     \"sparseBinding feature was not enabled.\");\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkImageCreateInfo-flags-01924\", \"If the sparseResidencyAliased feature is not enabled, flags must not contain VK_IMAGE_CREATE_SPARSE_ALIASED_BIT\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if ((image_flags & VK_IMAGE_CREATE_SPARSE_ALIASED_BIT) && (!enabled_features.sparseResidencyAliased)) {\n    skip |= LogError(\"VUID-VkImageCreateInfo-flags-01924\", device, create_info_loc.dot(Field::flags),\n                     \"includes VK_IMAGE_CREATE_SPARSE_ALIASED_BIT but the sparseResidencyAliased feature was not enabled.\");\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkImageCreateInfo-tiling-04121\", \"If tiling is VK_IMAGE_TILING_LINEAR, flags must not contain VK_IMAGE_CREATE_SPARSE_RESIDENCY_BIT\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (VK_IMAGE_TILING_LINEAR == create_info.tiling) {\n    skip |= LogError(\"VUID-VkImageCreateInfo-tiling-04121\", device, create_info_loc.dot(Field::flags),\n                     \"includes VK_IMAGE_CREATE_SPARSE_RESIDENCY_BIT but tiling is VK_IMAGE_TILING_LINEAR.\");\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkImageCreateInfo-imageType-00970\", \"If imageType is VK_IMAGE_TYPE_1D, flags must not contain VK_IMAGE_CREATE_SPARSE_RESIDENCY_BIT\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (VK_IMAGE_TYPE_1D == create_info.imageType) {\n    skip |= LogError(\"VUID-VkImageCreateInfo-imageType-00970\", device, create_info_loc.dot(Field::flags),\n                     \"includes VK_IMAGE_CREATE_SPARSE_BINDING_BIT but imageType is VK_IMAGE_TYPE_1D.\");\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkImageCreateInfo-imageType-00971\", \"If the sparseResidencyImage2D feature is not enabled, and imageType is VK_IMAGE_TYPE_2D, flags must not contain VK_IMAGE_CREATE_SPARSE_RESIDENCY_BIT\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if ((!enabled_features.sparseResidencyImage2D) && (VK_IMAGE_TYPE_2D == create_info.imageType)) {\n    skip |= LogError(\"VUID-VkImageCreateInfo-imageType-00971\", device, create_info_loc.dot(Field::flags),\n                     \"includes VK_IMAGE_CREATE_SPARSE_BINDING_BIT and imageType is VK_IMAGE_TYPE_2D, but \"\n                     \"sparseResidencyImage2D feature was not enabled.\");\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkImageCreateInfo-imageType-00972\", \"If the sparseResidencyImage3D feature is not enabled, and imageType is VK_IMAGE_TYPE_3D, flags must not contain VK_IMAGE_CREATE_SPARSE_RESIDENCY_BIT\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if ((!enabled_features.sparseResidencyImage3D) && (VK_IMAGE_TYPE_3D == create_info.imageType)) {\n    skip |= LogError(\"VUID-VkImageCreateInfo-imageType-00972\", device, create_info_loc.dot(Field::flags),\n                     \"includes VK_IMAGE_CREATE_SPARSE_BINDING_BIT and imageType is VK_IMAGE_TYPE_3D, but \"\n                     \"sparseResidencyImage3D feature was not enabled.\");\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkImageCreateInfo-imageType-00974\", \"If the sparseResidency4Samples feature is not enabled, imageType is VK_IMAGE_TYPE_2D, and samples is VK_SAMPLE_COUNT_4_BIT, flags must not contain VK_IMAGE_CREATE_SPARSE_RESIDENCY_BIT\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "\"includes VK_IMAGE_CREATE_SPARSE_BINDING_BIT and imageType is VK_IMAGE_TYPE_2D and samples is \"\nskip |= LogError(\"VUID-VkImageCreateInfo-imageType-00974\", device, create_info_loc.dot(Field::flags),\n\"includes VK_IMAGE_CREATE_SPARSE_BINDING_BIT and imageType is VK_IMAGE_TYPE_2D and samples is \"\n\"VK_SAMPLE_COUNT_4_BIT, but sparseResidency4Samples feature was not enabled.\");\n"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkImageCreateInfo-imageType-00975\", \"If the sparseResidency8Samples feature is not enabled, imageType is VK_IMAGE_TYPE_2D, and samples is VK_SAMPLE_COUNT_8_BIT, flags must not contain VK_IMAGE_CREATE_SPARSE_RESIDENCY_BIT\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "\"includes VK_IMAGE_CREATE_SPARSE_BINDING_BIT and imageType is VK_IMAGE_TYPE_2D and samples is \"\nskip |= LogError(\"VUID-VkImageCreateInfo-imageType-00975\", device, create_info_loc.dot(Field::flags),\n\"includes VK_IMAGE_CREATE_SPARSE_BINDING_BIT and imageType is VK_IMAGE_TYPE_2D and samples is \"\n\"VK_SAMPLE_COUNT_8_BIT, but sparseResidency8Samples feature was not enabled.\");\n"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkImageCreateInfo-imageType-00976\", \"If the sparseResidency16Samples feature is not enabled, imageType is VK_IMAGE_TYPE_2D, and samples is VK_SAMPLE_COUNT_16_BIT, flags must not contain VK_IMAGE_CREATE_SPARSE_RESIDENCY_BIT\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "\"includes VK_IMAGE_CREATE_SPARSE_BINDING_BIT and imageType is VK_IMAGE_TYPE_2D and samples is \"\nskip |= LogError(\"VUID-VkImageCreateInfo-imageType-00976\", device, create_info_loc.dot(Field::flags),\n\"includes VK_IMAGE_CREATE_SPARSE_BINDING_BIT and imageType is VK_IMAGE_TYPE_2D and samples is \"\n\"VK_SAMPLE_COUNT_16_BIT, but sparseResidency16Samples feature was not enabled.\");\n"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkImageCreateInfo-imageType-02082\", \"If usage includes VK_IMAGE_USAGE_FRAGMENT_SHADING_RATE_ATTACHMENT_BIT_KHR, imageType must be VK_IMAGE_TYPE_2D\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (create_info.imageType != VK_IMAGE_TYPE_2D) {\n    skip |= LogError(\"VUID-VkImageCreateInfo-imageType-02082\", device, create_info_loc.dot(Field::usage),\n                     \"includes VK_IMAGE_USAGE_FRAGMENT_SHADING_RATE_ATTACHMENT_BIT_KHR (or the \"\n                     \"alias VK_IMAGE_USAGE_SHADING_RATE_IMAGE_BIT_NV), but imageType is %s.\",\n                     string_VkImageType(create_info.imageType));\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkImageCreateInfo-shadingRateImage-07727\", \"If the shadingRateImage feature is enabled and usage includes VK_IMAGE_USAGE_SHADING_RATE_IMAGE_BIT_NV, tiling must be VK_IMAGE_TILING_OPTIMAL\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (enabled_features.shadingRateImage && create_info.tiling != VK_IMAGE_TILING_OPTIMAL) {\n    skip |= LogError(\"VUID-VkImageCreateInfo-shadingRateImage-07727\", device, create_info_loc.dot(Field::usage),\n                     \"includes VK_IMAGE_USAGE_SHADING_RATE_IMAGE_BIT_NV, tiling must be \"\n                     \"VK_IMAGE_TILING_OPTIMAL.\");\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkImageCreateInfo-flags-02050\", \"If flags contains VK_IMAGE_CREATE_CORNER_SAMPLED_BIT_NV, imageType must be VK_IMAGE_TYPE_2D or VK_IMAGE_TYPE_3D\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (create_info.imageType != VK_IMAGE_TYPE_2D && create_info.imageType != VK_IMAGE_TYPE_3D) {\n    skip |= LogError(\"VUID-VkImageCreateInfo-flags-02050\", device, create_info_loc.dot(Field::flags),\n                     \"includes VK_IMAGE_CREATE_CORNER_SAMPLED_BIT_NV, \"\n                     \"but imageType is %s.\",\n                     string_VkImageType(create_info.imageType));\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkImageCreateInfo-flags-02051\", \"If flags contains VK_IMAGE_CREATE_CORNER_SAMPLED_BIT_NV, it must not contain VK_IMAGE_CREATE_CUBE_COMPATIBLE_BIT and the format must not be a depth/stencil format\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if ((create_info.flags & VK_IMAGE_CREATE_CUBE_COMPATIBLE_BIT) || vkuFormatIsDepthOrStencil(create_info.format)) {\n    skip |= LogError(\"VUID-VkImageCreateInfo-flags-02051\", device, create_info_loc.dot(Field::flags),\n                     \"includes VK_IMAGE_CREATE_CORNER_SAMPLED_BIT_NV, \"\n                     \"it must not also contain VK_IMAGE_CREATE_CUBE_COMPATIBLE_BIT and format (%s) must not be a \"\n                     \"depth/stencil format.\",\n                     string_VkFormat(create_info.format));\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkImageCreateInfo-flags-02052\", \"If flags contains VK_IMAGE_CREATE_CORNER_SAMPLED_BIT_NV and imageType is VK_IMAGE_TYPE_2D, extent.width and extent.height must be greater than 1\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (create_info.imageType == VK_IMAGE_TYPE_2D && (create_info.extent.width == 1 || create_info.extent.height == 1)) {\n    skip |= LogError(\"VUID-VkImageCreateInfo-flags-02052\", device, create_info_loc.dot(Field::flags),\n                     \"includes VK_IMAGE_CREATE_CORNER_SAMPLED_BIT_NV and \"\n                     \"imageType is VK_IMAGE_TYPE_2D, extent.width and extent.height must be \"\n                     \"greater than 1.\");\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkImageStencilUsageCreateInfo-stencilUsage-02539\", \"If stencilUsage includes VK_IMAGE_USAGE_TRANSIENT_ATTACHMENT_BIT, it must not include bits other than VK_IMAGE_USAGE_DEPTH_STENCIL_ATTACHMENT_BIT or VK_IMAGE_USAGE_INPUT_ATTACHMENT_BIT\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if ((image_stencil_struct->stencilUsage & ~legal_flags) != 0) {\n    skip |= LogError(\"VUID-VkImageStencilUsageCreateInfo-stencilUsage-02539\", device,\n                     create_info_loc.pNext(Struct::VkImageStencilUsageCreateInfo, Field::stencilUsage), \"is %s.\",\n                     string_VkImageUsageFlags(image_stencil_struct->stencilUsage).c_str());\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkImageStencilUsageCreateInfo-stencilUsage-02539\", \"If stencilUsage includes VK_IMAGE_USAGE_TRANSIENT_ATTACHMENT_BIT, it must not include bits other than VK_IMAGE_USAGE_DEPTH_STENCIL_ATTACHMENT_BIT or VK_IMAGE_USAGE_INPUT_ATTACHMENT_BIT\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if ((image_stencil_struct->stencilUsage & ~legal_flags) != 0) {\n    skip |= LogError(\"VUID-VkImageStencilUsageCreateInfo-stencilUsage-02539\", physicalDevice,\n                     format_info_loc.pNext(Struct::VkImageStencilUsageCreateInfo, Field::stencilUsage), \"is %s.\",\n                     string_VkImageUsageFlags(image_stencil_struct->stencilUsage).c_str());\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkImageCreateInfo-Format-02536\", \"If Format is a depth-stencil format and the pNext chain includes a VkImageStencilUsageCreateInfo structure with its stencilUsage member including VK_IMAGE_USAGE_INPUT_ATTACHMENT_BIT, extent.width must be less than or equal to VkPhysicalDeviceLimits::maxFramebufferWidth\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (create_info.extent.width > device_limits.maxFramebufferWidth) {\n    skip |= LogError(\"VUID-VkImageCreateInfo-Format-02536\", device,\n                     create_info_loc.pNext(Struct::VkImageStencilUsageCreateInfo, Field::stencilUsage),\n                     \"includes VK_IMAGE_USAGE_INPUT_ATTACHMENT_BIT and image width (%\" PRIu32\n                     \") exceeds device \"\n                     \"maxFramebufferWidth (%\" PRIu32 \")\",\n                     create_info.extent.width, device_limits.maxFramebufferWidth);\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkImageCreateInfo-format-02537\", \"If format is a depth-stencil format and the pNext chain includes a VkImageStencilUsageCreateInfo structure with its stencilUsage member including VK_IMAGE_USAGE_INPUT_ATTACHMENT_BIT, extent.height must be less than or equal to VkPhysicalDeviceLimits::maxFramebufferHeight\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (create_info.extent.height > device_limits.maxFramebufferHeight) {\n    skip |= LogError(\"VUID-VkImageCreateInfo-format-02537\", device,\n                     create_info_loc.pNext(Struct::VkImageStencilUsageCreateInfo, Field::stencilUsage),\n                     \"includes VK_IMAGE_USAGE_INPUT_ATTACHMENT_BIT and image height (%\" PRIu32\n                     \") exceeds device \"\n                     \"maxFramebufferHeight (%\" PRIu32 \")\",\n                     create_info.extent.height, device_limits.maxFramebufferHeight);\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkImageCreateInfo-format-02795\", \"If format is a depth-stencil format, usage includes VK_IMAGE_USAGE_DEPTH_STENCIL_ATTACHMENT_BIT, and the pNext chain includes a VkImageStencilUsageCreateInfo structure, then its VkImageStencilUsageCreateInfo::stencilUsage member must also include VK_IMAGE_USAGE_DEPTH_STENCIL_ATTACHMENT_BIT\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (((create_info.usage & VK_IMAGE_USAGE_DEPTH_STENCIL_ATTACHMENT_BIT) != 0) &&\n    skip |= LogError(\"VUID-VkImageCreateInfo-format-02795\", device, create_info_loc.dot(Field::usage),\n                     \"is (%s), format is %s, and %s is %s\", string_VkImageUsageFlags(create_info.usage).c_str(),\n                     string_VkFormat(create_info.format),\n                     create_info_loc.pNext(Struct::VkImageStencilUsageCreateInfo, Field::stencilUsage).Fields().c_str(),\n                     string_VkImageUsageFlags(image_stencil_struct->stencilUsage).c_str());\n"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkImageCreateInfo-format-02796\", \"If format is a depth-stencil format, usage does not include VK_IMAGE_USAGE_DEPTH_STENCIL_ATTACHMENT_BIT, and the pNext chain includes a VkImageStencilUsageCreateInfo structure, then its VkImageStencilUsageCreateInfo::stencilUsage member must also not include VK_IMAGE_USAGE_DEPTH_STENCIL_ATTACHMENT_BIT\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "} else if (((create_info.usage & VK_IMAGE_USAGE_DEPTH_STENCIL_ATTACHMENT_BIT) == 0) &&\n    skip |= LogError(\"VUID-VkImageCreateInfo-format-02796\", device, create_info_loc.dot(Field::usage),\n                     \"is (%s), format is %s, and %s is %s\", string_VkImageUsageFlags(create_info.usage).c_str(),\n                     string_VkFormat(create_info.format),\n                     create_info_loc.pNext(Struct::VkImageStencilUsageCreateInfo, Field::stencilUsage).Fields().c_str(),\n                     string_VkImageUsageFlags(image_stencil_struct->stencilUsage).c_str());\n"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkImageCreateInfo-format-02797\", \"If format is a depth-stencil format, usage includes VK_IMAGE_USAGE_TRANSIENT_ATTACHMENT_BIT, and the pNext chain includes a VkImageStencilUsageCreateInfo structure, then its VkImageStencilUsageCreateInfo::stencilUsage member must also include VK_IMAGE_USAGE_TRANSIENT_ATTACHMENT_BIT\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (((create_info.usage & VK_IMAGE_USAGE_TRANSIENT_ATTACHMENT_BIT) != 0) &&\n    skip |= LogError(\"VUID-VkImageCreateInfo-format-02797\", device, create_info_loc.dot(Field::usage),\n                     \"is (%s), format is %s, and %s is %s\", string_VkImageUsageFlags(create_info.usage).c_str(),\n                     string_VkFormat(create_info.format),\n                     create_info_loc.pNext(Struct::VkImageStencilUsageCreateInfo, Field::stencilUsage).Fields().c_str(),\n                     string_VkImageUsageFlags(image_stencil_struct->stencilUsage).c_str());\n"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkImageCreateInfo-format-02798\", \"If format is a depth-stencil format, usage does not include VK_IMAGE_USAGE_TRANSIENT_ATTACHMENT_BIT, and the pNext chain includes a VkImageStencilUsageCreateInfo structure, then its VkImageStencilUsageCreateInfo::stencilUsage member must also not include VK_IMAGE_USAGE_TRANSIENT_ATTACHMENT_BIT\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "} else if (((create_info.usage & VK_IMAGE_USAGE_TRANSIENT_ATTACHMENT_BIT) == 0) &&\n    skip |= LogError(\"VUID-VkImageCreateInfo-format-02798\", device, create_info_loc.dot(Field::usage),\n                     \"is (%s), format is %s, and %s is %s\", string_VkImageUsageFlags(create_info.usage).c_str(),\n                     string_VkFormat(create_info.format),\n                     create_info_loc.pNext(Struct::VkImageStencilUsageCreateInfo, Field::stencilUsage).Fields().c_str(),\n                     string_VkImageUsageFlags(image_stencil_struct->stencilUsage).c_str());\n"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkImageCreateInfo-pNext-06784\", \"If the pNext chain includes a VkImportMetalTextureInfoEXT structure its plane member must be VK_IMAGE_ASPECT_PLANE_0_BIT, VK_IMAGE_ASPECT_PLANE_1_BIT, or VK_IMAGE_ASPECT_PLANE_2_BIT\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if ((import_metal_texture_info->plane != VK_IMAGE_ASPECT_PLANE_0_BIT) &&\n    skip |= LogError(\"VUID-VkImageCreateInfo-pNext-06784\", device, texture_info_loc,\n                     \"is %s, but only VK_IMAGE_ASPECT_PLANE_0_BIT, VK_IMAGE_ASPECT_PLANE_1_BIT, or \"\n                     \"VK_IMAGE_ASPECT_PLANE_2_BIT are allowed\",\n                     string_VkImageAspectFlags(import_metal_texture_info->plane).c_str());\n"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkImageCreateInfo-pNext-06786\", \"If the pNext chain includes a VkImportMetalTextureInfoEXT structure and the image has a multi-planar format with only two planes, then VkImportMetalTextureInfoEXT::plane must not be VK_IMAGE_ASPECT_PLANE_2_BIT\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if ((format_plane_count == 2) && (import_metal_texture_info->plane == VK_IMAGE_ASPECT_PLANE_2_BIT)) {\n    skip |= LogError(\"VUID-VkImageCreateInfo-pNext-06786\", device, texture_info_loc,\n                     \"is VK_IMAGE_ASPECT_PLANE_2_BIT, which is not allowed for an image created with format %s, \"\n                     \"which has only 2 planes\",\n                     string_VkFormat(create_info.format));\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkImageViewCreateInfo-viewType-01004\", \"If the imageCubeArray feature is not enabled, viewType must not be VK_IMAGE_VIEW_TYPE_CUBE_ARRAY\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if ((pCreateInfo->viewType == VK_IMAGE_VIEW_TYPE_CUBE_ARRAY) && (!enabled_features.imageCubeArray)) {\n    skip |= LogError(\"VUID-VkImageViewCreateInfo-viewType-01004\", pCreateInfo->image, create_info_loc.dot(Field::viewType),\n                     \"is VK_IMAGE_VIEW_TYPE_CUBE_ARRAY but the imageCubeArray feature is not enabled.\");\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkImageViewCreateInfo-viewType-02960\", \"If viewType is VK_IMAGE_VIEW_TYPE_CUBE and subresourceRange.layerCount is not VK_REMAINING_ARRAY_LAYERS, subresourceRange.layerCount must be 6\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (pCreateInfo->viewType == VK_IMAGE_VIEW_TYPE_CUBE && pCreateInfo->subresourceRange.layerCount != 6) {\n    skip |= LogError(\"VUID-VkImageViewCreateInfo-viewType-02960\", pCreateInfo->image,\n                     create_info_loc.dot(Field::subresourceRange).dot(Field::layerCount),\n                     \" (%\" PRIu32 \") must be 6 or VK_REMAINING_ARRAY_LAYERS.\", pCreateInfo->subresourceRange.layerCount);\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkImageViewASTCDecodeModeEXT-decodeMode-02230\", \"decodeMode must be one of VK_FORMAT_R16G16B16A16_SFLOAT, VK_FORMAT_R8G8B8A8_UNORM, or VK_FORMAT_E5B9G9R9_UFLOAT_PACK32\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if ((astc_decode_mode->decodeMode != VK_FORMAT_R16G16B16A16_SFLOAT) &&\n    (astc_decode_mode->decodeMode != VK_FORMAT_R8G8B8A8_UNORM) &&\n    (astc_decode_mode->decodeMode != VK_FORMAT_E5B9G9R9_UFLOAT_PACK32)) {\n    skip |= LogError(\"VUID-VkImageViewASTCDecodeModeEXT-decodeMode-02230\", pCreateInfo->image,\n                     create_info_loc.pNext(Struct::VkImageViewASTCDecodeModeEXT, Field::decodeMode), \"is %s.\",\n                     string_VkFormat(astc_decode_mode->decodeMode));\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkDeviceImageSubresourceInfoKHR-aspectMask-00997\", \"The aspectMask member of pSubresource must only have a single bit set\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (GetBitSetCount(aspect_mask) != 1) {\n    skip |= LogError(\"VUID-VkDeviceImageSubresourceInfoKHR-aspectMask-00997\", device, subresource_loc.dot(Field::aspectMask),\n                     \"(%s) must have exactly 1 bit set.\", string_VkImageAspectFlags(aspect_mask).c_str());\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkDeviceImageSubresourceInfoKHR-mipLevel-01716\", \"The mipLevel member of pSubresource must be less than the mipLevels specified in pCreateInfo\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (subresource.mipLevel >= create_info.mipLevels) {\n    skip |= LogError(\"VUID-VkDeviceImageSubresourceInfoKHR-mipLevel-01716\", device, subresource_loc.dot(Field::mipLevel),\n                     \"(%\" PRIu32 \") must be less than %s (%\" PRIu32 \").\", subresource.mipLevel,\n                     create_info_loc.dot(Field::mipLevel).Fields().c_str(), create_info.mipLevels);\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkDeviceImageSubresourceInfoKHR-arrayLayer-01717\", \"The arrayLayer member of pSubresource must be less than the arrayLayers specified in pCreateInfo\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (subresource.arrayLayer >= create_info.arrayLayers) {\n    skip |= LogError(\"VUID-VkDeviceImageSubresourceInfoKHR-arrayLayer-01717\", device, subresource_loc.dot(Field::arrayLayer),\n                     \"(%\" PRIu32 \") must be less than %s (%\" PRIu32 \").\", subresource.arrayLayer,\n                     create_info_loc.dot(Field::arrayLayers).Fields().c_str(), create_info.arrayLayers);\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkDeviceImageSubresourceInfoKHR-format-04462\", \"If format of the pCreateInfo has a depth component, the aspectMask member of pSubresource must contain VK_IMAGE_ASPECT_DEPTH_BIT\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (vkuFormatHasDepth(image_format) && ((aspect_mask & VK_IMAGE_ASPECT_DEPTH_BIT) == 0)) {\n    skip |= LogError(\"VUID-VkDeviceImageSubresourceInfoKHR-format-04462\", device, subresource_loc.dot(Field::aspectMask),\n                     \"(%s) is invalid with %s (%s).\", string_VkImageAspectFlags(aspect_mask).c_str(),\n                     create_info_loc.dot(Field::format).Fields().c_str(), string_VkFormat(image_format));\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkDeviceImageSubresourceInfoKHR-format-04463\", \"If format of the pCreateInfo has a stencil component, the aspectMask member of pSubresource must contain VK_IMAGE_ASPECT_STENCIL_BIT\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (vkuFormatHasStencil(image_format) && ((aspect_mask & VK_IMAGE_ASPECT_STENCIL_BIT) == 0)) {\n    skip |= LogError(\"VUID-VkDeviceImageSubresourceInfoKHR-format-04463\", device, subresource_loc.dot(Field::aspectMask),\n                     \"(%s) is invalid with %s (%s).\", string_VkImageAspectFlags(aspect_mask).c_str(),\n                     create_info_loc.dot(Field::format).Fields().c_str(), string_VkFormat(image_format));\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkDeviceImageSubresourceInfoKHR-format-04464\", \"If format of the pCreateInfo does not contain a stencil or depth component, the aspectMask member of pSubresource must not contain VK_IMAGE_ASPECT_DEPTH_BIT or VK_IMAGE_ASPECT_STENCIL_BIT\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if ((aspect_mask & (VK_IMAGE_ASPECT_DEPTH_BIT | VK_IMAGE_ASPECT_STENCIL_BIT)) != 0) {\n    skip |= LogError(\"VUID-VkDeviceImageSubresourceInfoKHR-format-04464\", device, subresource_loc.dot(Field::aspectMask),\n                     \"(%s) is invalid with %s (%s).\", string_VkImageAspectFlags(aspect_mask).c_str(),\n                     create_info_loc.dot(Field::format).Fields().c_str(), string_VkFormat(image_format));\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkDeviceImageSubresourceInfoKHR-tiling-08717\", \"If the tiling of the pCreateInfo is VK_IMAGE_TILING_LINEAR and has a multi-planar image format, then the aspectMask member of pSubresource must be a single valid multi-planar aspect mask bit\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (vkuFormatIsMultiplane(image_format) && !IsOnlyOneValidPlaneAspect(image_format, aspect_mask)) {\n    skip |= LogError(\"VUID-VkDeviceImageSubresourceInfoKHR-tiling-08717\", device, subresource_loc.dot(Field::aspectMask),\n                     \"(%s) is invalid for %s (%s).\", string_VkImageAspectFlags(aspect_mask).c_str(),\n                     create_info_loc.dot(Field::format).Fields().c_str(), string_VkFormat(image_format));\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-vkCreateInstance-ppEnabledExtensionNames-01388\", \"All required extensions for each extension in the VkInstanceCreateInfo::ppEnabledExtensionNames list must also be present in that list\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "vvl::Extension extension = GetExtension(pCreateInfo->ppEnabledExtensionNames[i]);\nskip |= ValidateExtensionReqs(local_instance_extensions, \"VUID-vkCreateInstance-ppEnabledExtensionNames-01388\", \"instance\",\n                              extension, create_info_loc.dot(Field::ppEnabledExtensionNames, i));\n"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkInstanceCreateInfo-flags-06559\", \"If flags has the VK_INSTANCE_CREATE_ENUMERATE_PORTABILITY_BIT_KHR bit set, the list of enabled extensions in ppEnabledExtensionNames must contain VK_KHR_portability_enumeration\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (pCreateInfo->flags & VK_INSTANCE_CREATE_ENUMERATE_PORTABILITY_BIT_KHR &&\n    skip |= LogError(\"VUID-VkInstanceCreateInfo-flags-06559\", instance, create_info_loc.dot(Field::flags),\n                     \"has VK_INSTANCE_CREATE_ENUMERATE_PORTABILITY_BIT_KHR set, but \"\n                     \"ppEnabledExtensionNames does not include VK_KHR_portability_enumeration\");\n"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkValidationFeaturesEXT-pEnabledValidationFeatures-02967\", \"If the pEnabledValidationFeatures array contains VK_VALIDATION_FEATURE_ENABLE_GPU_ASSISTED_RESERVE_BINDING_SLOT_EXT, then it must also contain VK_VALIDATION_FEATURE_ENABLE_GPU_ASSISTED_EXT or VK_VALIDATION_FEATURE_ENABLE_DEBUG_PRINTF_EXT\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (reserve_slot && !gpu_assisted && !debug_printf) {\n    skip |= LogError(\"VUID-VkValidationFeaturesEXT-pEnabledValidationFeatures-02967\", instance,\n                     create_info_loc.pNext(Struct::VkValidationFeaturesEXT, Field::pEnabledValidationFeatures),\n                     \"includes VK_VALIDATION_FEATURE_ENABLE_GPU_ASSISTED_RESERVE_BINDING_SLOT_EXT but no \"\n                     \"VK_VALIDATION_FEATURE_ENABLE_GPU_ASSISTED_EXT or VK_VALIDATION_FEATURE_ENABLE_DEBUG_PRINTF_EXT.\");\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkInstanceCreateInfo-pNext-04925\", \"If the pNext chain of VkInstanceCreateInfo includes a VkDebugReportCallbackCreateInfoEXT structure, the list of enabled extensions in ppEnabledExtensionNames must contain VK_EXT_debug_report\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (debug_report_callback && !local_instance_extensions.vk_ext_debug_report) {\n    skip |= LogError(\"VUID-VkInstanceCreateInfo-pNext-04925\", instance, create_info_loc.dot(Field::ppEnabledExtensionNames),\n                     \"does not include VK_EXT_debug_report, but the pNext chain includes VkDebugReportCallbackCreateInfoEXT.\");\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkInstanceCreateInfo-pNext-06779\", \"If the pNext chain includes a VkExportMetalObjectCreateInfoEXT structure, its exportObjectType member must be either VK_EXPORT_METAL_OBJECT_TYPE_METAL_DEVICE_BIT_EXT or VK_EXPORT_METAL_OBJECT_TYPE_METAL_COMMAND_QUEUE_BIT_EXT\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if ((export_metal_object_info->exportObjectType != VK_EXPORT_METAL_OBJECT_TYPE_METAL_DEVICE_BIT_EXT) &&\n    skip |= LogError(\"VUID-VkInstanceCreateInfo-pNext-06779\", instance, error_obj.location,\n                     \"The pNext chain contains a VkExportMetalObjectCreateInfoEXT whose \"\n                     \"exportObjectType = %s, but only VkExportMetalObjectCreateInfoEXT structs with exportObjectType of \"\n                     \"VK_EXPORT_METAL_OBJECT_TYPE_METAL_DEVICE_BIT_EXT or \"\n                     \"VK_EXPORT_METAL_OBJECT_TYPE_METAL_COMMAND_QUEUE_BIT_EXT are allowed\",\n                     string_VkExportMetalObjectTypeFlagBitsEXT(export_metal_object_info->exportObjectType));\n"
        },
        {
            "role": "user",
            "content": "{\"VUID-vkCreateDevice-ppEnabledExtensionNames-01387\", \"All required device extensions for each extension in the VkDeviceCreateInfo::ppEnabledExtensionNames list must also be present in that list\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "skip |=\n    ValidateString(create_info_loc.dot(Field::ppEnabledExtensionNames),\n                   \"VUID-VkDeviceCreateInfo-ppEnabledExtensionNames-parameter\", pCreateInfo->ppEnabledExtensionNames[i]);\nskip |= ValidateExtensionReqs(device_extensions, \"VUID-vkCreateDevice-ppEnabledExtensionNames-01387\", \"device\", extension,\n                              create_info_loc.dot(Field::ppEnabledExtensionNames, i));\n"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkDeviceCreateInfo-ppEnabledExtensionNames-01840\", \"If VkPhysicalDeviceProperties::apiVersion advertises Vulkan 1.1 or later, ppEnabledExtensionNames must not contain VK_AMD_negative_viewport_height\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (api_version >= VK_API_VERSION_1_1) {\n    skip |= LogError(\"VUID-VkDeviceCreateInfo-ppEnabledExtensionNames-01840\", physicalDevice, error_obj.location,\n                     \"ppEnabledExtensionNames must not include \"\n                     \"VK_AMD_negative_viewport_height if api version is greater than or equal to 1.1.\");\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkDeviceCreateInfo-ppEnabledExtensionNames-00374\", \"ppEnabledExtensionNames must not contain both VK_KHR_maintenance1 and VK_AMD_negative_viewport_height\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "\"ppEnabledExtensionNames must not include \"\nskip |= LogError(\"VUID-VkDeviceCreateInfo-ppEnabledExtensionNames-00374\", physicalDevice, error_obj.location,\n\"ppEnabledExtensionNames must not simultaneously include \"\n\"VK_KHR_maintenance1 and VK_AMD_negative_viewport_height.\");\n"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkDeviceCreateInfo-ppEnabledExtensionNames-03328\", \"ppEnabledExtensionNames must not contain both VK_KHR_buffer_device_address and VK_EXT_buffer_device_address\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (khr_bda && ext_bda) {\n    skip |= LogError(\"VUID-VkDeviceCreateInfo-ppEnabledExtensionNames-03328\", physicalDevice, error_obj.location,\n                     \"ppEnabledExtensionNames must not contain both VK_KHR_buffer_device_address and \"\n                     \"VK_EXT_buffer_device_address.\");\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkDeviceCreateInfo-pNext-00373\", \"If the pNext chain includes a VkPhysicalDeviceFeatures2 structure, then pEnabledFeatures must be NULL\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (features2) {\n    skip |= LogError(\"VUID-VkDeviceCreateInfo-pNext-00373\", physicalDevice, error_obj.location,\n                     \"pNext includes a VkPhysicalDeviceFeatures2 struct when \"\n                     \"pCreateInfo->pEnabledFeatures is non-NULL.\");\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkPhysicalDeviceRobustness2FeaturesEXT-robustBufferAccess2-04000\", \"If robustBufferAccess2 is enabled then robustBufferAccess must also be enabled\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (features && robustness2_features && robustness2_features->robustBufferAccess2 && !features->robustBufferAccess) {\n    skip |= LogError(\"VUID-VkPhysicalDeviceRobustness2FeaturesEXT-robustBufferAccess2-04000\", physicalDevice,\n                     error_obj.location, \"If robustBufferAccess2 is enabled then robustBufferAccess must be enabled.\");\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkDeviceCreateInfo-pNext-02829\", \"If the pNext chain includes a VkPhysicalDeviceVulkan11Features structure, then it must not include a VkPhysicalDevice16BitStorageFeatures, VkPhysicalDeviceMultiviewFeatures, VkPhysicalDeviceVariablePointersFeatures, VkPhysicalDeviceProtectedMemoryFeatures, VkPhysicalDeviceSamplerYcbcrConversionFeatures, or VkPhysicalDeviceShaderDrawParametersFeatures structure\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "skip |= LogError(\"VUID-VkDeviceCreateInfo-pNext-02829\", physicalDevice, error_obj.location,\n                 \"If the pNext chain includes a VkPhysicalDeviceVulkan11Features structure, then \"\n                 \"it must not include a %s structure\",\n                 string_VkStructureType(current->sType));\n"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkDeviceCreateInfo-pNext-04748\", \"If the pNext chain includes a VkPhysicalDeviceVulkan12Features structure and VkPhysicalDeviceVulkan12Features::bufferDeviceAddress is VK_TRUE, ppEnabledExtensionNames must not contain VK_EXT_buffer_device_address\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (IsExtEnabledByCreateinfo(ExtensionStateByName(device_extensions, vvl::Extension::_VK_EXT_buffer_device_address))) {\n    skip |= LogError(\"VUID-VkDeviceCreateInfo-pNext-04748\", physicalDevice, error_obj.location,\n                     \"pNext chain includes VkPhysicalDeviceVulkan12Features with bufferDeviceAddress \"\n                     \"set to VK_TRUE and ppEnabledExtensionNames contains VK_EXT_buffer_device_address\");\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkDeviceCreateInfo-pNext-06532\", \"If the pNext chain includes a VkPhysicalDeviceVulkan13Features structure, then it must not include a VkPhysicalDeviceDynamicRenderingFeatures, VkPhysicalDeviceImageRobustnessFeatures, VkPhysicalDeviceInlineUniformBlockFeatures, VkPhysicalDeviceMaintenance4Features, VkPhysicalDevicePipelineCreationCacheControlFeatures, VkPhysicalDevicePrivateDataFeatures, VkPhysicalDeviceShaderDemoteToHelperInvocationFeatures, VkPhysicalDeviceShaderIntegerDotProductFeatures, VkPhysicalDeviceShaderTerminateInvocationFeatures, VkPhysicalDeviceSubgroupSizeControlFeatures, VkPhysicalDeviceSynchronization2Features, VkPhysicalDeviceTextureCompressionASTCHDRFeatures, or VkPhysicalDeviceZeroInitializeWorkgroupMemoryFeatures structure\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "skip |= LogError(\"VUID-VkDeviceCreateInfo-pNext-06532\", physicalDevice, error_obj.location,\n                 \"If the pNext chain includes a VkPhysicalDeviceVulkan13Features structure, then it must not \"\n                 \"include a %s structure\",\n                 string_VkStructureType(current->sType));\n"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkDeviceQueueCreateInfo-pQueuePriorities-00383\", \"Each element of pQueuePriorities must be between 0.0 and 1.0 inclusive\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (!(queue_priority >= 0.f) || !(queue_priority <= 1.f)) {\n    skip |= LogError(\"VUID-VkDeviceQueueCreateInfo-pQueuePriorities-00383\", physicalDevice, error_obj.location,\n                     \"pCreateInfo->pQueueCreateInfos[%\" PRIu32 \"].pQueuePriorities[%\" PRIu32\n                     \"] (=%f) is not between 0 and 1 (inclusive).\",\n                     i, j, queue_priority);\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkDeviceQueueCreateInfo-flags-02861\", \"If the protectedMemory feature is not enabled, the VK_DEVICE_QUEUE_CREATE_PROTECTED_BIT bit of flags must not be set\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (((queue_create_info.flags & VK_DEVICE_QUEUE_CREATE_PROTECTED_BIT) != 0) && (protected_memory == VK_FALSE)) {\n    skip |= LogError(\"VUID-VkDeviceQueueCreateInfo-flags-02861\", physicalDevice, error_obj.location,\n                     \"pCreateInfo->flags contains VK_DEVICE_QUEUE_CREATE_PROTECTED_BIT without the \"\n                     \"protectedMemory feature being enabled as well.\");\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkPhysicalDeviceMultiviewFeatures-multiviewGeometryShader-00580\", \"If multiviewGeometryShader is enabled then multiview must also be enabled\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if ((multiview == VK_FALSE) && (multiview_geometry_shader == VK_TRUE)) {\n    skip |= LogError(\"VUID-VkPhysicalDeviceMultiviewFeatures-multiviewGeometryShader-00580\", physicalDevice, error_obj.location,\n                     \"If multiviewGeometryShader is VK_TRUE then multiview also needs to be VK_TRUE\");\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkPhysicalDeviceMultiviewFeatures-multiviewTessellationShader-00581\", \"If multiviewTessellationShader is enabled then multiview must also be enabled\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if ((multiview == VK_FALSE) && (multiview_tessellation_shader == VK_TRUE)) {\n    skip |= LogError(\"VUID-VkPhysicalDeviceMultiviewFeatures-multiviewTessellationShader-00581\", physicalDevice,\n                     error_obj.location, \"If multiviewTessellationShader is VK_TRUE then multiview also needs to be VK_TRUE\");\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkPhysicalDeviceMeshShaderFeaturesEXT-multiviewMeshShader-07032\", \"If multiviewMeshShader is enabled then VkPhysicalDeviceMultiviewFeaturesKHR::multiview must also be enabled\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if ((multiview == VK_FALSE) && (mesh_shader_features->multiviewMeshShader)) {\n    skip |= LogError(\"VUID-VkPhysicalDeviceMeshShaderFeaturesEXT-multiviewMeshShader-07032\", physicalDevice,\n                     error_obj.location, \"If multiviewMeshShader is VK_TRUE then multiview also needs to be VK_TRUE\");\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkPhysicalDeviceImageFormatInfo2-tiling-02249\", \"tiling must be VK_IMAGE_TILING_DRM_FORMAT_MODIFIER_EXT if and only if the pNext chain includes VkPhysicalDeviceImageDrmFormatModifierInfoEXT\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (pImageFormatInfo->tiling != VK_IMAGE_TILING_DRM_FORMAT_MODIFIER_EXT) {\n    skip |= LogError(\"VUID-VkPhysicalDeviceImageFormatInfo2-tiling-02249\", physicalDevice,\n                     format_info_loc.dot(Field::tiling),\n                     \"(%s) but no VkPhysicalDeviceImageDrmFormatModifierInfoEXT in pNext chain.\",\n                     string_VkImageTiling(pImageFormatInfo->tiling));\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkPhysicalDeviceImageDrmFormatModifierInfoEXT-sharingMode-02316\", \"If sharingMode is VK_SHARING_MODE_CONCURRENT, each element of pQueueFamilyIndices must be unique and must be less than the pQueueFamilyPropertyCount returned by vkGetPhysicalDeviceQueueFamilyProperties2 for the physicalDevice that was used to create device\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (queue_family_indices_set.find(queue_index) != queue_family_indices_set.end()) {\n    skip |= LogError(\"VUID-VkPhysicalDeviceImageDrmFormatModifierInfoEXT-sharingMode-02316\", physicalDevice,\n                     format_info_loc.pNext(Struct::VkPhysicalDeviceImageDrmFormatModifierInfoEXT,\n                                           Field::pQueueFamilyIndices, i),\n                     \"is %\" PRIu32 \", but is duplicated in pQueueFamilyIndices.\", queue_index);\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-vkGetPhysicalDeviceImageFormatProperties-tiling-02248\", \"tiling must not be VK_IMAGE_TILING_DRM_FORMAT_MODIFIER_EXT. (Use vkGetPhysicalDeviceImageFormatProperties2 instead)\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (tiling == VK_IMAGE_TILING_DRM_FORMAT_MODIFIER_EXT) {\n    skip |= LogError(\"VUID-vkGetPhysicalDeviceImageFormatProperties-tiling-02248\", physicalDevice,\n                     error_obj.location.dot(Field::tiling), \"is VK_IMAGE_TILING_DRM_FORMAT_MODIFIER_EXT.\");\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-vkSetDebugUtilsObjectNameEXT-pNameInfo-02587\", \"pNameInfo->objectType must not be VK_OBJECT_TYPE_UNKNOWN\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (pNameInfo->objectType == VK_OBJECT_TYPE_UNKNOWN) {\n    skip |= LogError(\"VUID-vkSetDebugUtilsObjectNameEXT-pNameInfo-02587\", device, name_info_loc.dot(Field::objectType),\n                     \"cannot be VK_OBJECT_TYPE_UNKNOWN.\");\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-vkSetDebugUtilsObjectNameEXT-pNameInfo-02588\", \"pNameInfo->objectHandle must not be VK_NULL_HANDLE\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (pNameInfo->objectHandle == HandleToUint64(VK_NULL_HANDLE)) {\n    skip |= LogError(\"VUID-vkSetDebugUtilsObjectNameEXT-pNameInfo-02588\", device, name_info_loc.dot(Field::objectHandle),\n                     \"cannot be VK_NULL_HANDLE.\");\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkDebugUtilsObjectTagInfoEXT-objectType-01908\", \"objectType must not be VK_OBJECT_TYPE_UNKNOWN\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (pTagInfo->objectType == VK_OBJECT_TYPE_UNKNOWN) {\n    skip |= LogError(\"VUID-VkDebugUtilsObjectTagInfoEXT-objectType-01908\", device, error_obj.location,\n                     \"pTagInfo->objectType cannot be VK_OBJECT_TYPE_UNKNOWN.\");\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkPhysicalDeviceLayeredApiVulkanPropertiesKHR-pNext-10011\", \"Only VkPhysicalDeviceDriverProperties and VkPhysicalDeviceIDProperties are allowed in the pNext chain of properties\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (current->sType != VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DRIVER_PROPERTIES &&\n    skip |= LogError(\"VUID-VkPhysicalDeviceLayeredApiVulkanPropertiesKHR-pNext-10011\", physicalDevice,\n                     error_obj.location.dot(Field::pProperties)\n                         .pNext(Struct::VkPhysicalDeviceLayeredApiPropertiesListKHR, Field::pLayeredApis, i)\n                         .dot(Field::properties)\n                         .dot(Field::pNext),\n                     \"contains an invalid struct (%s).\", string_VkStructureType(current->sType));\n"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkPipelineLayoutCreateInfo-setLayoutCount-00286\", \"setLayoutCount must be less than or equal to VkPhysicalDeviceLimits::maxBoundDescriptorSets\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (pCreateInfo->setLayoutCount > device_limits.maxBoundDescriptorSets) {\n    skip |= LogError(\"VUID-VkPipelineLayoutCreateInfo-setLayoutCount-00286\", device, create_info_loc.dot(Field::setLayoutCount),\n                     \"(%\" PRIu32 \") exceeds physical device maxBoundDescriptorSets limit (%\" PRIu32 \").\",\n                     pCreateInfo->setLayoutCount, device_limits.maxBoundDescriptorSets);\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkPushConstantRange-offset-00294\", \"offset must be less than VkPhysicalDeviceLimits::maxPushConstantsSize\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (offset >= max_push_constants_size) {\n    skip |= LogError(\"VUID-VkPushConstantRange-offset-00294\", device, pc_loc.dot(Field::offset),\n                     \"(%\" PRIu32\n                     \") that exceeds this \"\n                     \"device's maxPushConstantSize of %\" PRIu32 \".\",\n                     offset, max_push_constants_size);\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkPushConstantRange-size-00296\", \"size must be greater than 0\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (size == 0) {\n    skip |= LogError(\"VUID-VkPushConstantRange-size-00296\", device, pc_loc.dot(Field::size),\n                     \"(%\" PRIu32 \") is not greater than zero.\", size);\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkPushConstantRange-size-00297\", \"size must be a multiple of 4\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (size & 0x3) {\n    skip |= LogError(\"VUID-VkPushConstantRange-size-00297\", device, pc_loc.dot(Field::size),\n                     \"(%\" PRIu32 \") is not a multiple of 4.\", size);\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkPushConstantRange-offset-00295\", \"offset must be a multiple of 4\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if ((offset & 0x3) != 0) {\n    skip |= LogError(\"VUID-VkPushConstantRange-offset-00295\", device, pc_loc.dot(Field::offset),\n                     \"(%\" PRIu32 \") is not a multiple of 4.\", offset);\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkPipelineLayoutCreateInfo-pPushConstantRanges-00292\", \"Any two elements of pPushConstantRanges must not include the same stage in stageFlags\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (0 != (pCreateInfo->pPushConstantRanges[i].stageFlags & pCreateInfo->pPushConstantRanges[j].stageFlags)) {\n    skip |= LogError(\"VUID-VkPipelineLayoutCreateInfo-pPushConstantRanges-00292\", device, create_info_loc,\n                     \"pPushConstantRanges[%\" PRIu32 \"].stageFlags is %s and pPushConstantRanges[%\" PRIu32\n                     \"].stageFlags is %s.\",\n                     i, string_VkShaderStageFlags(pCreateInfo->pPushConstantRanges[i].stageFlags).c_str(), j,\n                     string_VkShaderStageFlags(pCreateInfo->pPushConstantRanges[j].stageFlags).c_str());\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkPipelineShaderStageCreateInfo-pName-parameter\", \"pName must be a null-terminated UTF-8 string\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "kRequiredSingleBit, \"VUID-VkPipelineShaderStageCreateInfo-stage-parameter\",\n\"VUID-VkPipelineShaderStageCreateInfo-stage-parameter\");\nskip |= ValidateRequiredPointer(loc.dot(Field::pName), info.pName, \"VUID-VkPipelineShaderStageCreateInfo-pName-parameter\");\n"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkPipelineShaderStageCreateInfo-pNext-02754\", \"If a VkPipelineShaderStageRequiredSubgroupSizeCreateInfo structure is included in the pNext chain, flags must not have the VK_PIPELINE_SHADER_STAGE_CREATE_ALLOW_VARYING_SUBGROUP_SIZE_BIT flag set\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if ((create_info.flags & VK_PIPELINE_SHADER_STAGE_CREATE_ALLOW_VARYING_SUBGROUP_SIZE_BIT_EXT) != 0) {\n    skip |= LogError(\"VUID-VkPipelineShaderStageCreateInfo-pNext-02754\", device, loc.dot(Field::flags),\n                     \"(%s) includes VK_PIPELINE_SHADER_STAGE_CREATE_ALLOW_VARYING_SUBGROUP_SIZE_BIT_EXT while \"\n                     \"VkPipelineShaderStageRequiredSubgroupSizeCreateInfo is included in the pNext chain.\",\n                     string_VkPipelineShaderStageCreateFlags(create_info.flags).c_str());\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkGraphicsPipelineCreateInfo-renderPass-06587\", \"If the pipeline requires fragment output interface state, renderPass is VK_NULL_HANDLE, and VkPipelineRenderingCreateInfo::depthAttachmentFormat is not VK_FORMAT_UNDEFINED, it must be a format that includes a depth component\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (!vkuFormatHasDepth(rendering_struct.depthAttachmentFormat)) {\n    skip |= LogError(\"VUID-VkGraphicsPipelineCreateInfo-renderPass-06587\", device,\n                     loc.pNext(Struct::VkPipelineRenderingCreateInfo, Field::depthAttachmentFormat),\n                     \"(%s) does not have a depth aspect.\", string_VkFormat(rendering_struct.depthAttachmentFormat));\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkGraphicsPipelineCreateInfo-renderPass-06588\", \"If the pipeline requires fragment output interface state, renderPass is VK_NULL_HANDLE, and VkPipelineRenderingCreateInfo::stencilAttachmentFormat is not VK_FORMAT_UNDEFINED, it must be a format that includes a stencil component\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (!vkuFormatHasStencil(rendering_struct.stencilAttachmentFormat)) {\n    skip |= LogError(\"VUID-VkGraphicsPipelineCreateInfo-renderPass-06588\", device,\n                     loc.pNext(Struct::VkPipelineRenderingCreateInfo, Field::stencilAttachmentFormat),\n                     \"(%s) does not have a \"\n                     \"stencil aspect.\",\n                     string_VkFormat(rendering_struct.stencilAttachmentFormat));\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkGraphicsPipelineCreateInfo-flags-09245\", \"If flags includes VK_PIPELINE_CREATE_RETAIN_LINK_TIME_OPTIMIZATION_INFO_BIT_EXT, flags must also include VK_PIPELINE_CREATE_LIBRARY_BIT_KHR\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if ((flags & VK_PIPELINE_CREATE_RETAIN_LINK_TIME_OPTIMIZATION_INFO_BIT_EXT) != 0 &&\n    (flags & VK_PIPELINE_CREATE_LIBRARY_BIT_KHR) == 0) {\n    skip |= LogError(\"VUID-VkGraphicsPipelineCreateInfo-flags-09245\", device, flags_loc, \"is (%s).\",\n                     string_VkPipelineCreateFlags2KHR(flags).c_str());\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkGraphicsPipelineCreateInfo-flags-00764\", \"flags must not contain the VK_PIPELINE_CREATE_DISPATCH_BASE flag\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if ((flags & VK_PIPELINE_CREATE_DISPATCH_BASE) != 0) {\n    skip |= LogError(\"VUID-VkGraphicsPipelineCreateInfo-flags-00764\", device, flags_loc,\n                     \"(%s) must not include \"\n                     \"VK_PIPELINE_CREATE_DISPATCH_BASE.\",\n                     string_VkPipelineCreateFlags2KHR(flags).c_str());\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkGraphicsPipelineCreateInfo-flags-03372\", \"flags must not include VK_PIPELINE_CREATE_RAY_TRACING_NO_NULL_ANY_HIT_SHADERS_BIT_KHR\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if ((flags & VK_PIPELINE_CREATE_RAY_TRACING_NO_NULL_ANY_HIT_SHADERS_BIT_KHR) != 0) {\n    skip |= LogError(\"VUID-VkGraphicsPipelineCreateInfo-flags-03372\", device, flags_loc,\n                     \"(%s) must not include VK_PIPELINE_CREATE_RAY_TRACING_NO_NULL_ANY_HIT_SHADERS_BIT_KHR.\",\n                     string_VkPipelineCreateFlags2KHR(flags).c_str());\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkGraphicsPipelineCreateInfo-flags-03373\", \"flags must not include VK_PIPELINE_CREATE_RAY_TRACING_NO_NULL_CLOSEST_HIT_SHADERS_BIT_KHR\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if ((flags & VK_PIPELINE_CREATE_RAY_TRACING_NO_NULL_CLOSEST_HIT_SHADERS_BIT_KHR) != 0) {\n    skip |= LogError(\"VUID-VkGraphicsPipelineCreateInfo-flags-03373\", device, flags_loc,\n                     \"(%s) must not include VK_PIPELINE_CREATE_RAY_TRACING_NO_NULL_CLOSEST_HIT_SHADERS_BIT_KHR.\",\n                     string_VkPipelineCreateFlags2KHR(flags).c_str());\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkGraphicsPipelineCreateInfo-flags-03375\", \"flags must not include VK_PIPELINE_CREATE_RAY_TRACING_NO_NULL_INTERSECTION_SHADERS_BIT_KHR\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if ((flags & VK_PIPELINE_CREATE_RAY_TRACING_NO_NULL_INTERSECTION_SHADERS_BIT_KHR) != 0) {\n    skip |= LogError(\"VUID-VkGraphicsPipelineCreateInfo-flags-03375\", device, flags_loc,\n                     \"(%s) must not include VK_PIPELINE_CREATE_RAY_TRACING_NO_NULL_INTERSECTION_SHADERS_BIT_KHR.\",\n                     string_VkPipelineCreateFlags2KHR(flags).c_str());\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkGraphicsPipelineCreateInfo-flags-03376\", \"flags must not include VK_PIPELINE_CREATE_RAY_TRACING_SKIP_TRIANGLES_BIT_KHR\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if ((flags & VK_PIPELINE_CREATE_RAY_TRACING_SKIP_TRIANGLES_BIT_KHR) != 0) {\n    skip |= LogError(\"VUID-VkGraphicsPipelineCreateInfo-flags-03376\", device, flags_loc,\n                     \"(%s) must not include VK_PIPELINE_CREATE_RAY_TRACING_SKIP_TRIANGLES_BIT_KHR.\",\n                     string_VkPipelineCreateFlags2KHR(flags).c_str());\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkGraphicsPipelineCreateInfo-flags-03377\", \"flags must not include VK_PIPELINE_CREATE_RAY_TRACING_SKIP_AABBS_BIT_KHR\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if ((flags & VK_PIPELINE_CREATE_RAY_TRACING_SKIP_AABBS_BIT_KHR) != 0) {\n    skip |= LogError(\"VUID-VkGraphicsPipelineCreateInfo-flags-03377\", device, flags_loc,\n                     \"(%s) must not include VK_PIPELINE_CREATE_RAY_TRACING_SKIP_AABBS_BIT_KHR.\",\n                     string_VkPipelineCreateFlags2KHR(flags).c_str());\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkGraphicsPipelineCreateInfo-flags-03577\", \"flags must not include VK_PIPELINE_CREATE_RAY_TRACING_SHADER_GROUP_HANDLE_CAPTURE_REPLAY_BIT_KHR\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if ((flags & VK_PIPELINE_CREATE_RAY_TRACING_SHADER_GROUP_HANDLE_CAPTURE_REPLAY_BIT_KHR) != 0) {\n    skip |= LogError(\"VUID-VkGraphicsPipelineCreateInfo-flags-03577\", device, flags_loc,\n                     \"(%s) must not include VK_PIPELINE_CREATE_RAY_TRACING_SHADER_GROUP_HANDLE_CAPTURE_REPLAY_BIT_KHR.\",\n                     string_VkPipelineCreateFlags2KHR(flags).c_str());\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkGraphicsPipelineCreateInfo-flags-07401\", \"flags must not include VK_PIPELINE_CREATE_RAY_TRACING_OPACITY_MICROMAP_BIT_EXT\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if ((flags & VK_PIPELINE_CREATE_RAY_TRACING_OPACITY_MICROMAP_BIT_EXT) != 0) {\n    skip |= LogError(\"VUID-VkGraphicsPipelineCreateInfo-flags-07401\", device, flags_loc,\n                     \"(%s) must not include VK_PIPELINE_CREATE_RAY_TRACING_OPACITY_MICROMAP_BIT_EXT.\",\n                     string_VkPipelineCreateFlags2KHR(flags).c_str());\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkGraphicsPipelineCreateInfo-flags-07997\", \"flags must not include VK_PIPELINE_CREATE_RAY_TRACING_DISPLACEMENT_MICROMAP_BIT_NV\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if ((flags & VK_PIPELINE_CREATE_RAY_TRACING_DISPLACEMENT_MICROMAP_BIT_NV) != 0) {\n    skip |= LogError(\"VUID-VkGraphicsPipelineCreateInfo-flags-07997\", device, flags_loc,\n                     \"(%s) must not include VK_PIPELINE_CREATE_RAY_TRACING_DISPLACEMENT_MICROMAP_BIT_NV.\",\n                     string_VkPipelineCreateFlags2KHR(flags).c_str());\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkPipelineDynamicStateCreateInfo-pDynamicStates-01442\", \"Each element of pDynamicStates must be unique\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (vvl::Contains(dynamic_state_map, dynamic_state)) {\n    skip |= LogError(\"VUID-VkPipelineDynamicStateCreateInfo-pDynamicStates-01442\", device,\n                     create_info_loc.dot(Field::pDynamicState),\n                     \"has %s at pDynamicStates[%\" PRIu32 \"] and pDynamicStates[%\" PRIu32 \"].\",\n                     string_VkDynamicState(dynamic_state), dynamic_state_map[dynamic_state], state_index);\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkGraphicsPipelineCreateInfo-pDynamicStates-04132\", \"If the pipeline requires pre-rasterization shader state, and VK_DYNAMIC_STATE_VIEWPORT_WITH_COUNT is included in the pDynamicStates array then VK_DYNAMIC_STATE_VIEWPORT must not be present\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (has_pre_raster_state && vvl::Contains(dynamic_state_map, VK_DYNAMIC_STATE_VIEWPORT_WITH_COUNT) &&\n    skip |= LogError(\"VUID-VkGraphicsPipelineCreateInfo-pDynamicStates-04132\", device,\n                     create_info_loc.dot(Field::pDynamicState),\n                     \"pDynamicStates[%\" PRIu32 \"] is VK_DYNAMIC_STATE_VIEWPORT_WITH_COUNT and pDynamicStates[%\" PRIu32\n                     \"] is VK_DYNAMIC_STATE_VIEWPORT.\",\n                     dynamic_state_map[VK_DYNAMIC_STATE_VIEWPORT_WITH_COUNT], dynamic_state_map[VK_DYNAMIC_STATE_VIEWPORT]);\n"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkGraphicsPipelineCreateInfo-pipelineStageCreationFeedbackCount-06594\", \"If VkPipelineCreationFeedbackCreateInfo::pipelineStageCreationFeedbackCount is not 0, it must be equal to stageCount\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if ((feedback_struct != nullptr) && (feedback_struct->pipelineStageCreationFeedbackCount != 0 &&\n                                     feedback_struct->pipelineStageCreationFeedbackCount != create_info.stageCount)) {\n    skip |= LogError(\"VUID-VkGraphicsPipelineCreateInfo-pipelineStageCreationFeedbackCount-06594\", device,\n                     create_info_loc.pNext(Struct::VkPipelineCreationFeedback, Field::pipelineStageCreationFeedbackCount),\n                     \"(%\" PRIu32 \") is different than stageCount(%\" PRIu32 \").\",\n                     feedback_struct->pipelineStageCreationFeedbackCount, create_info.stageCount);\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkPipelineTessellationStateCreateInfo-patchControlPoints-01214\", \"patchControlPoints must be greater than zero and less than or equal to VkPhysicalDeviceLimits::maxTessellationPatchSize\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (create_info.pTessellationState->patchControlPoints == 0 ||\n    create_info.pTessellationState->patchControlPoints > device_limits.maxTessellationPatchSize) {\n    skip |= LogError(\"VUID-VkPipelineTessellationStateCreateInfo-patchControlPoints-01214\", device,\n                     create_info_loc.dot(Field::pTessellationState).dot(Field::patchControlPoints),\n                     \"is %\" PRIu32 \", but should be between 0 and maxTessellationPatchSize (%\" PRIu32 \").\",\n                     create_info.pTessellationState->patchControlPoints, device_limits.maxTessellationPatchSize);\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkPipelineVertexInputStateCreateInfo-vertexBindingDescriptionCount-00613\", \"vertexBindingDescriptionCount must be less than or equal to VkPhysicalDeviceLimits::maxVertexInputBindings\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (vertex_input_state->vertexBindingDescriptionCount > device_limits.maxVertexInputBindings) {\n    skip |= LogError(\"VUID-VkPipelineVertexInputStateCreateInfo-vertexBindingDescriptionCount-00613\", device,\n                     vertex_loc.dot(Field::vertexBindingDescriptionCount),\n                     \"(%\" PRIu32 \") is larger than maxVertexInputBindings (%\" PRIu32 \").\",\n                     vertex_input_state->vertexBindingDescriptionCount, device_limits.maxVertexInputBindings);\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkPipelineVertexInputStateCreateInfo-vertexAttributeDescriptionCount-00614\", \"vertexAttributeDescriptionCount must be less than or equal to VkPhysicalDeviceLimits::maxVertexInputAttributes\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (vertex_input_state->vertexAttributeDescriptionCount > device_limits.maxVertexInputAttributes) {\n    skip |= LogError(\"VUID-VkPipelineVertexInputStateCreateInfo-vertexAttributeDescriptionCount-00614\", device,\n                     vertex_loc.dot(Field::vertexAttributeDescriptionCount),\n                     \"%\" PRIu32 \") is larger than maxVertexInputAttributes (%\" PRIu32 \").\",\n                     vertex_input_state->vertexAttributeDescriptionCount, device_limits.maxVertexInputAttributes);\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkVertexInputBindingDescription-binding-00618\", \"binding must be less than VkPhysicalDeviceLimits::maxVertexInputBindings\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (vertex_bind_desc.binding >= device_limits.maxVertexInputBindings) {\n    skip |= LogError(\"VUID-VkVertexInputBindingDescription-binding-00618\", device, binding_loc.dot(Field::binding),\n                     \"(%\" PRIu32\n                     \") is larger than or equal to VkPhysicalDeviceLimits::maxVertexInputBindings (%\" PRIu32 \").\",\n                     vertex_bind_desc.binding, device_limits.maxVertexInputBindings);\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkVertexInputBindingDescription-stride-00619\", \"stride must be less than or equal to VkPhysicalDeviceLimits::maxVertexInputBindingStride\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (!has_dynamic_binding_stride && vertex_bind_desc.stride > device_limits.maxVertexInputBindingStride) {\n    skip |= LogError(\"VUID-VkVertexInputBindingDescription-stride-00619\", device, binding_loc.dot(Field::stride),\n                     \"(%\" PRIu32\n                     \") is larger \"\n                     \"than maxVertexInputBindingStride (%\" PRIu32 \").\",\n                     vertex_bind_desc.stride, device_limits.maxVertexInputBindingStride);\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkPipelineVertexInputStateCreateInfo-pVertexAttributeDescriptions-00617\", \"All elements of pVertexAttributeDescriptions must describe distinct attribute locations\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (location_it != attribute_locations.cend()) {\n    skip |= LogError(\"VUID-VkPipelineVertexInputStateCreateInfo-pVertexAttributeDescriptions-00617\", device,\n                     attribute_loc.dot(Field::location),\n                     \"(%\" PRIu32 \") is already in pVertexAttributeDescriptions[%\" PRIu32 \"].\",\n                     vertex_attrib_desc.location, *location_it);\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkPipelineVertexInputStateCreateInfo-binding-00615\", \"For every binding specified by each element of pVertexAttributeDescriptions, a VkVertexInputBindingDescription must exist in pVertexBindingDescriptions with the same value of binding\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (binding_it == vertex_bindings.cend()) {\n    skip |= LogError(\"VUID-VkPipelineVertexInputStateCreateInfo-binding-00615\", device,\n                     attribute_loc.dot(Field::binding),\n                     \"(%\" PRIu32 \") does not exist in pVertexBindingDescription.\", vertex_attrib_desc.binding);\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkGraphicsPipelineCreateInfo-pDynamicStates-03379\", \"If the pipeline requires pre-rasterization shader state, and VK_DYNAMIC_STATE_VIEWPORT_WITH_COUNT is included in the pDynamicStates array then viewportCount must be zero\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (viewport_state.viewportCount != 0) {\n    skip |= LogError(\"VUID-VkGraphicsPipelineCreateInfo-pDynamicStates-03379\", device,\n                     viewport_loc.dot(Field::viewportCount),\n                     \"(%\" PRIu32 \") must be zero when VK_DYNAMIC_STATE_VIEWPORT_WITH_COUNT is used.\",\n                     viewport_state.viewportCount);\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkPipelineViewportStateCreateInfo-viewportCount-04135\", \"If the graphics pipeline is being created with VK_DYNAMIC_STATE_VIEWPORT_WITH_COUNT set then viewportCount must be 0, otherwise viewportCount must be greater than 0\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (viewport_state.viewportCount == 0) {\n    skip |= LogError(\"VUID-VkPipelineViewportStateCreateInfo-viewportCount-04135\", device,\n                     viewport_loc.dot(Field::viewportCount),\n                     \"can't be 0 unless VK_DYNAMIC_STATE_VIEWPORT_WITH_COUNT is used.\");\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkPipelineViewportStateCreateInfo-viewportCount-01216\", \"If the multiViewport feature is not enabled, viewportCount must not be greater than 1\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (!enabled_features.multiViewport && (viewport_state.viewportCount > 1)) {\n    skip |= LogError(\"VUID-VkPipelineViewportStateCreateInfo-viewportCount-01216\", device,\n                     viewport_loc.dot(Field::viewportCount),\n                     \"is %\" PRIu32 \" but multiViewport feature is not enabled.\", viewport_state.viewportCount);\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkGraphicsPipelineCreateInfo-pDynamicStates-03380\", \"If the pipeline requires pre-rasterization shader state, and VK_DYNAMIC_STATE_SCISSOR_WITH_COUNT is included in the pDynamicStates array then scissorCount must be zero\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (viewport_state.scissorCount != 0) {\n    skip |= LogError(\"VUID-VkGraphicsPipelineCreateInfo-pDynamicStates-03380\", device,\n                     viewport_loc.dot(Field::scissorCount),\n                     \"(%\" PRIu32 \") must be zero when VK_DYNAMIC_STATE_SCISSOR_WITH_COUNT is used.\",\n                     viewport_state.viewportCount);\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkPipelineViewportStateCreateInfo-scissorCount-01217\", \"If the multiViewport feature is not enabled, scissorCount must not be greater than 1\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (!enabled_features.multiViewport && (viewport_state.scissorCount > 1)) {\n    skip |= LogError(\"VUID-VkPipelineViewportStateCreateInfo-scissorCount-01217\", device,\n                     viewport_loc.dot(Field::scissorCount),\n                     \"is %\" PRIu32 \" but multiViewport feature is not enabled.\", viewport_state.scissorCount);\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkPipelineViewportStateCreateInfo-x-02821\", \"The x and y members of offset member of any element of pScissors must be greater than or equal to 0\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (scissor.offset.x < 0) {\n    skip |= LogError(\"VUID-VkPipelineViewportStateCreateInfo-x-02821\", device,\n                     scissor_loc.dot(Field::offset).dot(Field::x), \"(%\" PRId32 \") is negative.\",\n                     scissor.offset.x);\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkPipelineViewportStateCreateInfo-x-02821\", \"The x and y members of offset member of any element of pScissors must be greater than or equal to 0\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (scissor.offset.y < 0) {\n    skip |= LogError(\"VUID-VkPipelineViewportStateCreateInfo-x-02821\", device,\n                     scissor_loc.dot(Field::offset).dot(Field::y), \"(%\" PRId32 \") is negative.\",\n                     scissor.offset.y);\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkPipelineViewportStateCreateInfo-offset-02822\", \"Evaluation of (offset.x + extent.width) must not cause a signed integer addition overflow for any element of pScissors\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (x_sum > std::numeric_limits<int32_t>::max()) {\n    skip |= LogError(\"VUID-VkPipelineViewportStateCreateInfo-offset-02822\", device, scissor_loc,\n                     \"offset.x (%\" PRId32 \") + extent.width (%\" PRId32 \") is %\" PRIi64\n                     \" which will overflow int32_t.\",\n                     scissor.offset.x, scissor.extent.width, x_sum);\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkPipelineViewportExclusiveScissorStateCreateInfoNV-exclusiveScissorCount-02028\", \"exclusiveScissorCount must be less than or equal to VkPhysicalDeviceLimits::maxViewports\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (exclusive_scissor_struct && exclusive_scissor_struct->exclusiveScissorCount > device_limits.maxViewports) {\n    skip |= LogError(\"VUID-VkPipelineViewportExclusiveScissorStateCreateInfoNV-exclusiveScissorCount-02028\", device,\n                     viewport_loc.pNext(Struct::VkPipelineViewportExclusiveScissorStateCreateInfoNV,\n                                        Field::exclusiveScissorCount),\n                     \"(%\" PRIu32 \") is larger than maxViewports (%\" PRIu32 \").\",\n                     exclusive_scissor_struct->exclusiveScissorCount, device_limits.maxViewports);\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkPipelineViewportStateCreateInfo-scissorCount-04134\", \"If scissorCount and viewportCount are both not dynamic, then scissorCount and viewportCount must be identical\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (!IsExtEnabled(device_extensions.vk_ext_extended_dynamic_state) ||\n    skip |= LogError(\"VUID-VkPipelineViewportStateCreateInfo-scissorCount-04134\", device, viewport_loc,\n                     \"scissorCount (%\" PRIu32 \") is different to viewportCount (%\" PRIu32 \").\",\n                     viewport_state.scissorCount, viewport_state.viewportCount);\n"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkPipelineViewportExclusiveScissorStateCreateInfoNV-exclusiveScissorCount-02029\", \"exclusiveScissorCount must be 0 or greater than or equal to the viewportCount member of VkPipelineViewportStateCreateInfo\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (exclusive_scissor_struct && exclusive_scissor_struct->exclusiveScissorCount != 0 &&\n    exclusive_scissor_struct->exclusiveScissorCount != viewport_state.viewportCount) {\n    skip |= LogError(\"VUID-VkPipelineViewportExclusiveScissorStateCreateInfoNV-exclusiveScissorCount-02029\", device,\n                     viewport_loc.pNext(Struct::VkPipelineViewportExclusiveScissorStateCreateInfoNV,\n                                        Field::exclusiveScissorCount),\n                     \"is %\" PRIu32 \" and viewportCount is (%\" PRIu32 \").\",\n                     exclusive_scissor_struct->exclusiveScissorCount, viewport_state.viewportCount);\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkGraphicsPipelineCreateInfo-pDynamicStates-04130\", \"If the pipeline requires pre-rasterization shader state, and pViewportState->pViewports is not dynamic, then pViewportState->pViewports must be a valid pointer to an array of pViewportState->viewportCount valid VkViewport structures\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (!has_dynamic_viewport && !has_dynamic_viewport_with_count && viewport_state.viewportCount > 0 &&\n    skip |= LogError(\"VUID-VkGraphicsPipelineCreateInfo-pDynamicStates-04130\", device,\n                     viewport_loc.dot(Field::pViewports), \"is NULL, but the viewport state is not dynamic.\");\n"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkGraphicsPipelineCreateInfo-pDynamicStates-04056\", \"If the pipeline requires pre-rasterization shader state, and no element of the pDynamicStates member of pDynamicState is VK_DYNAMIC_STATE_EXCLUSIVE_SCISSOR_NV, and if pViewportState->pNext chain includes a VkPipelineViewportExclusiveScissorStateCreateInfoNV structure, and if its exclusiveScissorCount member is not 0, then its pExclusiveScissors member must be a valid pointer to an array of exclusiveScissorCount VkRect2D structures\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (!has_dynamic_exclusive_scissor_nv && exclusive_scissor_struct &&\n    skip |= LogError(\"VUID-VkGraphicsPipelineCreateInfo-pDynamicStates-04056\", device, viewport_loc,\n                     \"The exclusive scissor state is static (pCreateInfos[%\" PRIu32\n                     \"].pDynamicState->pDynamicStates does not contain VK_DYNAMIC_STATE_EXCLUSIVE_SCISSOR_NV), but \"\n                     \"pCreateInfos[%\" PRIu32 \"] pExclusiveScissors is NULL.\",\n                     i, i);\n"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkPipelineViewportCoarseSampleOrderStateCreateInfoNV-sampleOrderType-02072\", \"If sampleOrderType is not VK_COARSE_SAMPLE_ORDER_TYPE_CUSTOM_NV, customSamplerOrderCount must be 0\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (coarse_sample_order_struct->sampleOrderType != VK_COARSE_SAMPLE_ORDER_TYPE_CUSTOM_NV &&\n    skip |= LogError(\"VUID-VkPipelineViewportCoarseSampleOrderStateCreateInfoNV-sampleOrderType-02072\", device,\n                     coarse_sample_loc.dot(Field::sampleOrderType),\n                     \"is not VK_COARSE_SAMPLE_ORDER_TYPE_CUSTOM_NV and customSampleOrderCount is not 0.\");\n"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkGraphicsPipelineCreateInfo-rasterizerDiscardEnable-09024\", \"If the pipeline requires pre-rasterization shader state, and the VK_DYNAMIC_STATE_RASTERIZER_DISCARD_ENABLE dynamic state is enabled or the rasterizerDiscardEnable member of pRasterizationState is VK_FALSE, and related dynamic state is not set, pViewportState must be a valid pointer to a valid VkPipelineViewportStateCreateInfo structure\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "!create_info.pRasterizationState->rasterizerDiscardEnable))) {\nskip |= LogError(\"VUID-VkGraphicsPipelineCreateInfo-rasterizerDiscardEnable-09024\", device, create_info_loc,\n        \"Rasterization is enabled (pCreateInfos[%\" PRIu32\n        \"].pRasterizationState->rasterizerDiscardEnable is VK_FALSE), but pCreateInfos[%\" PRIu32\n        \"].pViewportState is NULL.\",\n        i, i);\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkPipelineMultisampleStateCreateInfo-sampleShadingEnable-00784\", \"If the sampleRateShading feature is not enabled, sampleShadingEnable must be VK_FALSE\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (!enabled_features.sampleRateShading) {\n    skip |= LogError(\"VUID-VkPipelineMultisampleStateCreateInfo-sampleShadingEnable-00784\", device,\n                     ms_loc.dot(Field::sampleShadingEnable),\n                     \"is VK_TRUE but the sampleRateShading feature was not enabled.\");\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkPipelineColorWriteCreateInfoEXT-attachmentCount-07608\", \"If the pipeline is being created with VK_DYNAMIC_STATE_COLOR_BLEND_ADVANCED_EXT, VK_DYNAMIC_STATE_COLOR_BLEND_ENABLE_EXT, VK_DYNAMIC_STATE_COLOR_BLEND_EQUATION_EXT, or VK_DYNAMIC_STATE_COLOR_WRITE_MASK_EXT dynamic states not set, attachmentCount must be equal to the attachmentCount member of the VkPipelineColorBlendStateCreateInfo structure specified during pipeline creation\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (color_write && (color_write->attachmentCount != color_blend_state.attachmentCount) && dynamic_not_set) {\n    skip |= LogError(\"VUID-VkPipelineColorWriteCreateInfoEXT-attachmentCount-07608\", device,\n                     color_loc.pNext(Struct::VkPipelineColorWriteCreateInfoEXT, Field::attachmentCount),\n                     \"(%\" PRIu32 \") is different than pColorBlendState.attachmentCount (%\" PRIu32 \").\",\n                     color_write->attachmentCount, color_blend_state.attachmentCount);\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkPipelineRasterizationStateCreateInfo-polygonMode-01414\", \"If the VK_NV_fill_rectangle extension is not enabled, polygonMode must not be VK_POLYGON_MODE_FILL_RECTANGLE_NV\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (create_info.pRasterizationState->polygonMode == VK_POLYGON_MODE_FILL_RECTANGLE_NV) {\n    skip |= LogError(\"VUID-VkPipelineRasterizationStateCreateInfo-polygonMode-01414\", device,\n                     rasterization_loc.dot(Field::polygonMode),\n                     \"is VK_POLYGON_MODE_FILL_RECTANGLE_NV, but \"\n                     \"the extension VK_NV_fill_rectangle is not enabled.\");\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkPipelineRasterizationStateCreateInfo-polygonMode-01507\", \"If the fillModeNonSolid feature is not enabled, polygonMode must be VK_POLYGON_MODE_FILL or VK_POLYGON_MODE_FILL_RECTANGLE_NV\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if ((create_info.pRasterizationState->polygonMode != VK_POLYGON_MODE_FILL) &&\n    (create_info.pRasterizationState->polygonMode != VK_POLYGON_MODE_FILL_RECTANGLE_NV) &&\n    skip |= LogError(\"VUID-VkPipelineRasterizationStateCreateInfo-polygonMode-01507\", device,\n                     rasterization_loc.dot(Field::polygonMode), \"is %s, but fillModeNonSolid feature is not enabled.\",\n                     string_VkPolygonMode(create_info.pRasterizationState->polygonMode));\n"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkGraphicsPipelineCreateInfo-pDynamicStates-00749\", \"If the pipeline requires pre-rasterization shader state, and the wideLines feature is not enabled, and no element of the pDynamicStates member of pDynamicState is VK_DYNAMIC_STATE_LINE_WIDTH, the lineWidth member of pRasterizationState must be 1.0\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (!vvl::Contains(dynamic_state_map, VK_DYNAMIC_STATE_LINE_WIDTH) && !enabled_features.wideLines &&\n    skip |= LogError(\"VUID-VkGraphicsPipelineCreateInfo-pDynamicStates-00749\", device,\n                     rasterization_loc.dot(Field::lineWidth),\n                     \"is %f, but the line width state is static (pCreateInfos[%\" PRIu32\n                     \"].pDynamicState->pDynamicStates does not contain VK_DYNAMIC_STATE_LINE_WIDTH) and \"\n                     \"wideLines feature was not enabled.\",\n                     create_info.pRasterizationState->lineWidth, i);\n"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkGraphicsPipelineCreateInfo-lineRasterizationMode-02766\", \"If the pipeline requires pre-rasterization shader state and at least one of fragment output interface state or fragment shader state, and pMultisampleState is not NULL, the lineRasterizationMode member of a VkPipelineRasterizationLineStateCreateInfoKHR structure included in the pNext chain of pRasterizationState is VK_LINE_RASTERIZATION_MODE_BRESENHAM_KHR or VK_LINE_RASTERIZATION_MODE_RECTANGULAR_SMOOTH_KHR, then the alphaToCoverageEnable, alphaToOneEnable, and sampleShadingEnable members of pMultisampleState must all be VK_FALSE\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (create_info.pMultisampleState->alphaToCoverageEnable) {\n    skip |= LogError(\"VUID-VkGraphicsPipelineCreateInfo-lineRasterizationMode-02766\", device,\n                     rasterization_loc.pNext(Struct::VkPipelineRasterizationLineStateCreateInfoKHR,\n                                             Field::lineStippleFactor),\n                     \"is %s, but pCreateInfos[%\" PRIu32\n                     \"].pMultisampleState->alphaToCoverageEnable == VK_TRUE.\",\n                     string_VkLineRasterizationModeKHR(line_state->lineRasterizationMode), i);\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkGraphicsPipelineCreateInfo-lineRasterizationMode-02766\", \"If the pipeline requires pre-rasterization shader state and at least one of fragment output interface state or fragment shader state, and pMultisampleState is not NULL, the lineRasterizationMode member of a VkPipelineRasterizationLineStateCreateInfoKHR structure included in the pNext chain of pRasterizationState is VK_LINE_RASTERIZATION_MODE_BRESENHAM_KHR or VK_LINE_RASTERIZATION_MODE_RECTANGULAR_SMOOTH_KHR, then the alphaToCoverageEnable, alphaToOneEnable, and sampleShadingEnable members of pMultisampleState must all be VK_FALSE\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (create_info.pMultisampleState->alphaToOneEnable) {\n    skip |= LogError(\"VUID-VkGraphicsPipelineCreateInfo-lineRasterizationMode-02766\", device,\n                     rasterization_loc.pNext(Struct::VkPipelineRasterizationLineStateCreateInfoKHR,\n                                             Field::lineStippleFactor),\n                     \"is %s, but pCreateInfos[%\" PRIu32 \"].pMultisampleState->alphaToOneEnable == VK_TRUE.\",\n                     string_VkLineRasterizationModeKHR(line_state->lineRasterizationMode), i);\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkPipelineRasterizationLineStateCreateInfoKHR-lineRasterizationMode-02770\", \"If lineRasterizationMode is VK_LINE_RASTERIZATION_MODE_RECTANGULAR_SMOOTH_KHR, then the smoothLines feature must be enabled\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (line_state->lineRasterizationMode == VK_LINE_RASTERIZATION_MODE_RECTANGULAR_SMOOTH_KHR &&\n    skip |= LogError(\"VUID-VkPipelineRasterizationLineStateCreateInfoKHR-lineRasterizationMode-02770\", device,\n                     rasterization_loc.pNext(Struct::VkPhysicalDeviceLineRasterizationFeaturesKHR,\n                                             Field::lineRasterizationMode),\n                     \"is VK_LINE_RASTERIZATION_MODE_RECTANGULAR_SMOOTH_KHR but the smoothLines feature was not \"\n                     \"enabled.\");\n"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkPipelineRasterizationLineStateCreateInfoKHR-stippledLineEnable-02771\", \"If stippledLineEnable is VK_TRUE and lineRasterizationMode is VK_LINE_RASTERIZATION_MODE_RECTANGULAR_KHR, then the stippledRectangularLines feature must be enabled\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (line_state->lineRasterizationMode == VK_LINE_RASTERIZATION_MODE_RECTANGULAR_KHR &&\n    skip |= LogError(\"VUID-VkPipelineRasterizationLineStateCreateInfoKHR-stippledLineEnable-02771\", device,\n                     rasterization_loc.pNext(Struct::VkPhysicalDeviceLineRasterizationFeaturesKHR,\n                                             Field::lineRasterizationMode),\n                     \"is VK_LINE_RASTERIZATION_MODE_RECTANGULAR_KHR and stippledLineEnable was VK_TRUE, \"\n                     \"but the stippledRectangularLines feature was not enabled.\");\n"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkPipelineRasterizationLineStateCreateInfoKHR-stippledLineEnable-02773\", \"If stippledLineEnable is VK_TRUE and lineRasterizationMode is VK_LINE_RASTERIZATION_MODE_RECTANGULAR_SMOOTH_KHR, then the stippledSmoothLines feature must be enabled\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (line_state->lineRasterizationMode == VK_LINE_RASTERIZATION_MODE_RECTANGULAR_SMOOTH_KHR &&\n    skip |= LogError(\"VUID-VkPipelineRasterizationLineStateCreateInfoKHR-stippledLineEnable-02773\", device,\n                     rasterization_loc.pNext(Struct::VkPhysicalDeviceLineRasterizationFeaturesKHR,\n                                             Field::lineRasterizationMode),\n                     \"is VK_LINE_RASTERIZATION_MODE_RECTANGULAR_SMOOTH_KHR and stippledLineEnable was \"\n                     \"VK_TRUE, but the stippledSmoothLines feature was not enabled.\");\n"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkPipelineRasterizationLineStateCreateInfoKHR-stippledLineEnable-02774\", \"If stippledLineEnable is VK_TRUE and lineRasterizationMode is VK_LINE_RASTERIZATION_MODE_DEFAULT_KHR, then the stippledRectangularLines feature must be enabled and VkPhysicalDeviceLimits::strictLines must be VK_TRUE\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (line_state->lineRasterizationMode == VK_LINE_RASTERIZATION_MODE_DEFAULT_KHR &&\n    skip |= LogError(\"VUID-VkPipelineRasterizationLineStateCreateInfoKHR-stippledLineEnable-02774\", device,\n                     rasterization_loc.pNext(Struct::VkPhysicalDeviceLineRasterizationFeaturesKHR,\n                                             Field::lineRasterizationMode),\n                     \"is VK_LINE_RASTERIZATION_MODE_DEFAULT_KHR and stippledLineEnable was VK_TRUE, but \"\n                     \"the stippledRectangularLines feature was not enabled.\");\n"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkGraphicsPipelineCreateInfo-flags-07986\", \"If flags contains the VK_PIPELINE_CREATE_DERIVATIVE_BIT flag, basePipelineIndex must be -1 or basePipelineHandle must be VK_NULL_HANDLE\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (create_info.basePipelineIndex != -1) {\n    skip |= LogError(\"VUID-VkGraphicsPipelineCreateInfo-flags-07986\", device,\n                     create_info_loc.dot(Field::basePipelineIndex),\n                     \"%\" PRIu32 \" and basePipelineHandle is not VK_NULL_HANDLE.\", create_info.basePipelineIndex);\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkComputePipelineCreateInfo-shaderEnqueue-09177\", \"If shaderEnqueue is not enabled, flags must not include VK_PIPELINE_CREATE_LIBRARY_BIT_KHR\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (!enabled_features.shaderEnqueue) {\n    skip |= LogError(\"VUID-VkComputePipelineCreateInfo-shaderEnqueue-09177\", device, flags_loc,\n                     \"%s must not include VK_PIPELINE_CREATE_LIBRARY_BIT_KHR.\",\n                     string_VkPipelineCreateFlags2KHR(flags).c_str());\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkComputePipelineCreateInfo-flags-03366\", \"flags must not include VK_PIPELINE_CREATE_RAY_TRACING_NO_NULL_CLOSEST_HIT_SHADERS_BIT_KHR\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if ((flags & VK_PIPELINE_CREATE_RAY_TRACING_NO_NULL_CLOSEST_HIT_SHADERS_BIT_KHR) != 0) {\n    skip |= LogError(\"VUID-VkComputePipelineCreateInfo-flags-03366\", device, flags_loc,\n                     \"(%s) must not include VK_PIPELINE_CREATE_RAY_TRACING_NO_NULL_CLOSEST_HIT_SHADERS_BIT_KHR.\",\n                     string_VkPipelineCreateFlags2KHR(flags).c_str());\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkComputePipelineCreateInfo-flags-03367\", \"flags must not include VK_PIPELINE_CREATE_RAY_TRACING_NO_NULL_MISS_SHADERS_BIT_KHR\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if ((flags & VK_PIPELINE_CREATE_RAY_TRACING_NO_NULL_MISS_SHADERS_BIT_KHR) != 0) {\n    skip |= LogError(\"VUID-VkComputePipelineCreateInfo-flags-03367\", device, flags_loc,\n                     \"(%s) must not include VK_PIPELINE_CREATE_RAY_TRACING_NO_NULL_MISS_SHADERS_BIT_KHR.\",\n                     string_VkPipelineCreateFlags2KHR(flags).c_str());\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkComputePipelineCreateInfo-flags-03368\", \"flags must not include VK_PIPELINE_CREATE_RAY_TRACING_NO_NULL_INTERSECTION_SHADERS_BIT_KHR\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if ((flags & VK_PIPELINE_CREATE_RAY_TRACING_NO_NULL_INTERSECTION_SHADERS_BIT_KHR) != 0) {\n    skip |= LogError(\"VUID-VkComputePipelineCreateInfo-flags-03368\", device, flags_loc,\n                     \"(%s) must not include VK_PIPELINE_CREATE_RAY_TRACING_NO_NULL_INTERSECTION_SHADERS_BIT_KHR.\",\n                     string_VkPipelineCreateFlags2KHR(flags).c_str());\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkComputePipelineCreateInfo-flags-03369\", \"flags must not include VK_PIPELINE_CREATE_RAY_TRACING_SKIP_TRIANGLES_BIT_KHR\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if ((flags & VK_PIPELINE_CREATE_RAY_TRACING_SKIP_TRIANGLES_BIT_KHR) != 0) {\n    skip |= LogError(\"VUID-VkComputePipelineCreateInfo-flags-03369\", device, flags_loc,\n                     \"(%s) must not include VK_PIPELINE_CREATE_RAY_TRACING_SKIP_TRIANGLES_BIT_KHR.\",\n                     string_VkPipelineCreateFlags2KHR(flags).c_str());\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkComputePipelineCreateInfo-flags-03576\", \"flags must not include VK_PIPELINE_CREATE_RAY_TRACING_SHADER_GROUP_HANDLE_CAPTURE_REPLAY_BIT_KHR\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if ((flags & VK_PIPELINE_CREATE_RAY_TRACING_SHADER_GROUP_HANDLE_CAPTURE_REPLAY_BIT_KHR) != 0) {\n    skip |= LogError(\"VUID-VkComputePipelineCreateInfo-flags-03576\", device, flags_loc,\n                     \"(%s) must not include VK_PIPELINE_CREATE_RAY_TRACING_SHADER_GROUP_HANDLE_CAPTURE_REPLAY_BIT_KHR.\",\n                     string_VkPipelineCreateFlags2KHR(flags).c_str());\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkComputePipelineCreateInfo-flags-04945\", \"flags must not include VK_PIPELINE_CREATE_RAY_TRACING_ALLOW_MOTION_BIT_NV\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if ((flags & VK_PIPELINE_CREATE_RAY_TRACING_ALLOW_MOTION_BIT_NV) != 0) {\n    skip |= LogError(\"VUID-VkComputePipelineCreateInfo-flags-04945\", device, flags_loc,\n                     \"(%s) must not include VK_PIPELINE_CREATE_RAY_TRACING_ALLOW_MOTION_BIT_NV.\",\n                     string_VkPipelineCreateFlags2KHR(flags).c_str());\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkComputePipelineCreateInfo-flags-07367\", \"flags must not include VK_PIPELINE_CREATE_RAY_TRACING_OPACITY_MICROMAP_BIT_EXT\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if ((flags & VK_PIPELINE_CREATE_RAY_TRACING_OPACITY_MICROMAP_BIT_EXT) != 0) {\n    skip |= LogError(\"VUID-VkComputePipelineCreateInfo-flags-07367\", device, flags_loc,\n                     \"(%s) must not include VK_PIPELINE_CREATE_RAY_TRACING_OPACITY_MICROMAP_BIT_EXT.\",\n                     string_VkPipelineCreateFlags2KHR(flags).c_str());\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkComputePipelineCreateInfo-flags-07996\", \"flags must not include VK_PIPELINE_CREATE_RAY_TRACING_DISPLACEMENT_MICROMAP_BIT_NV\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if ((flags & VK_PIPELINE_CREATE_RAY_TRACING_DISPLACEMENT_MICROMAP_BIT_NV) != 0) {\n    skip |= LogError(\"VUID-VkComputePipelineCreateInfo-flags-07996\", device, flags_loc,\n                     \"(%s) must not include VK_PIPELINE_CREATE_RAY_TRACING_DISPLACEMENT_MICROMAP_BIT_NV.\",\n                     string_VkPipelineCreateFlags2KHR(flags).c_str());\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkComputePipelineCreateInfo-flags-07986\", \"If flags contains the VK_PIPELINE_CREATE_DERIVATIVE_BIT flag, basePipelineIndex must be -1 or basePipelineHandle must be VK_NULL_HANDLE\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (create_info.basePipelineIndex != -1) {\n    skip |= LogError(\"VUID-VkComputePipelineCreateInfo-flags-07986\", device,\n                     create_info_loc.dot(Field::basePipelineIndex),\n                     \"(%\" PRIu32 \") and basePipelineHandle is not VK_NULL_HANDLE.\", create_info.basePipelineIndex);\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkComputePipelineCreateInfo-flags-07985\", \"If flags contains the VK_PIPELINE_CREATE_DERIVATIVE_BIT flag, and basePipelineHandle is VK_NULL_HANDLE, basePipelineIndex must be a valid index into the calling command's pCreateInfos parameter\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (static_cast<uint32_t>(create_info.basePipelineIndex) >= createInfoCount) {\n    skip |= LogError(\"VUID-VkComputePipelineCreateInfo-flags-07985\", device,\n                     create_info_loc.dot(Field::basePipelineIndex),\n                     \"(%\" PRIu32 \") is greater than or equal to createInfoCount %\" PRIu32 \".\",\n                     create_info.basePipelineIndex, createInfoCount);\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-vkMergePipelineCaches-dstCache-00770\", \"dstCache must not appear in the list of source caches\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (pSrcCaches[index0] == dstCache) {\n    skip |= LogError(\"VUID-vkMergePipelineCaches-dstCache-00770\", instance, error_obj.location.dot(Field::dstCache),\n                     \"%s is in pSrcCaches list.\", FormatHandle(dstCache).c_str());\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-vkGetPipelinePropertiesEXT-None-06766\", \"The pipelinePropertiesIdentifier feature must be enabled\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (!enabled_features.pipelinePropertiesIdentifier) {\n    skip |= LogError(\"VUID-vkGetPipelinePropertiesEXT-None-06766\", device, error_obj.location,\n                     \"the pipelinePropertiesIdentifier feature was not enabled.\");\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkGeometryTrianglesNV-vertexOffset-02429\", \"vertexOffset must be a multiple of the component size of vertexFormat\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (vertex_component_size > 0 && SafeModulo(triangles.vertexOffset, vertex_component_size) != 0) {\n    skip |= LogError(\"VUID-VkGeometryTrianglesNV-vertexOffset-02429\", object_handle, loc, \"is invalid.\");\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkGeometryTrianglesNV-indexType-02433\", \"indexType must be VK_INDEX_TYPE_UINT16, VK_INDEX_TYPE_UINT32, or VK_INDEX_TYPE_NONE_NV\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (triangles.indexType != VK_INDEX_TYPE_UINT32 && triangles.indexType != VK_INDEX_TYPE_UINT16 &&\n    triangles.indexType != VK_INDEX_TYPE_NONE_NV) {\n    skip |= LogError(\"VUID-VkGeometryTrianglesNV-indexType-02433\", object_handle, loc, \"is invalid.\");\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkGeometryTrianglesNV-indexOffset-02432\", \"indexOffset must be a multiple of the element size of indexType\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (index_element_size > 0 && SafeModulo(triangles.indexOffset, index_element_size) != 0) {\n    skip |= LogError(\"VUID-VkGeometryTrianglesNV-indexOffset-02432\", object_handle, loc, \"is invalid.\");\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkGeometryTrianglesNV-indexCount-02436\", \"indexCount must be 0 if indexType is VK_INDEX_TYPE_NONE_NV\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (triangles.indexCount != 0) {\n    skip |= LogError(\"VUID-VkGeometryTrianglesNV-indexCount-02436\", object_handle, loc, \"is invalid.\");\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkGeometryTrianglesNV-transformOffset-02438\", \"transformOffset must be a multiple of 16\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (SafeModulo(triangles.transformOffset, 16) != 0) {\n    skip |= LogError(\"VUID-VkGeometryTrianglesNV-transformOffset-02438\", object_handle, loc, \"is invalid.\");\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkGeometryAABBNV-offset-02440\", \"offset must be a multiple of 8\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (SafeModulo(aabbs.offset, 8) != 0) {\n    skip |= LogError(\"VUID-VkGeometryAABBNV-offset-02440\", object_handle, loc, \"is invalid.\");\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkGeometryAABBNV-stride-02441\", \"stride must be a multiple of 8\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (SafeModulo(aabbs.stride, 8) != 0) {\n    skip |= LogError(\"VUID-VkGeometryAABBNV-stride-02441\", object_handle, loc, \"is invalid.\");\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkAccelerationStructureInfoNV-type-02425\", \"If type is VK_ACCELERATION_STRUCTURE_TYPE_TOP_LEVEL_NV then geometryCount must be 0\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (info.type == VK_ACCELERATION_STRUCTURE_TYPE_TOP_LEVEL_NV && info.geometryCount != 0) {\n    skip |= LogError(\"VUID-VkAccelerationStructureInfoNV-type-02425\", object_handle, loc,\n                     \"If type is VK_ACCELERATION_STRUCTURE_TYPE_TOP_LEVEL_NV then \"\n                     \"geometryCount must be 0.\");\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkAccelerationStructureInfoNV-type-04623\", \"type must not be VK_ACCELERATION_STRUCTURE_TYPE_GENERIC_KHR\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (info.type == VK_ACCELERATION_STRUCTURE_TYPE_GENERIC_KHR) {\n    skip |= LogError(\"VUID-VkAccelerationStructureInfoNV-type-04623\", object_handle, loc,\n                     \"type is invalid VK_ACCELERATION_STRUCTURE_TYPE_GENERIC_KHR.\");\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkAccelerationStructureInfoNV-flags-02592\", \"If flags has the VK_BUILD_ACCELERATION_STRUCTURE_PREFER_FAST_TRACE_BIT_NV bit set, then it must not have the VK_BUILD_ACCELERATION_STRUCTURE_PREFER_FAST_BUILD_BIT_NV bit set\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (info.flags & VK_BUILD_ACCELERATION_STRUCTURE_PREFER_FAST_TRACE_BIT_NV &&\n    info.flags & VK_BUILD_ACCELERATION_STRUCTURE_PREFER_FAST_BUILD_BIT_NV) {\n    skip |= LogError(\"VUID-VkAccelerationStructureInfoNV-flags-02592\", object_handle, loc,\n                     \"If flags has the VK_BUILD_ACCELERATION_STRUCTURE_PREFER_FAST_TRACE_BIT_NV\"\n                     \"bit set, then it must not have the VK_BUILD_ACCELERATION_STRUCTURE_PREFER_FAST_BUILD_BIT_NV bit set.\");\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkAccelerationStructureInfoNV-instanceCount-02423\", \"instanceCount must be less than or equal to VkPhysicalDeviceRayTracingPropertiesNV::maxInstanceCount\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (info.instanceCount > phys_dev_ext_props.ray_tracing_props_nv.maxInstanceCount) {\n    skip |= LogError(\"VUID-VkAccelerationStructureInfoNV-instanceCount-02423\", object_handle, loc,\n                     \"instanceCount must be less than or equal to \"\n                     \"VkPhysicalDeviceRayTracingPropertiesNV::maxInstanceCount.\");\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkAccelerationStructureInfoNV-maxTriangleCount-02424\", \"The total number of triangles in all geometries must be less than or equal to VkPhysicalDeviceRayTracingPropertiesNV::maxTriangleCount\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (total_triangle_count > phys_dev_ext_props.ray_tracing_props_nv.maxTriangleCount) {\n    skip |= LogError(\"VUID-VkAccelerationStructureInfoNV-maxTriangleCount-02424\", object_handle, loc,\n                     \"The total number of triangles in all geometries must be less than \"\n                     \"or equal to VkPhysicalDeviceRayTracingPropertiesNV::maxTriangleCount.\");\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkGeometryNV-geometryType-03503\", \"geometryType must be VK_GEOMETRY_TYPE_TRIANGLES_NV or VK_GEOMETRY_TYPE_AABBS_NV\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (!(info.pGeometries[geometry_index].geometryType == VK_GEOMETRY_TYPE_TRIANGLES_NV ||\n      info.pGeometries[geometry_index].geometryType == VK_GEOMETRY_TYPE_AABBS_NV)) {\n    skip |= LogError(\"VUID-VkGeometryNV-geometryType-03503\", object_handle, loc,\n                     \"geometryType must be VK_GEOMETRY_TYPE_TRIANGLES_NV\"\n                     \"or VK_GEOMETRY_TYPE_AABBS_NV.\");\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkAccelerationStructureCreateInfoNV-compactedSize-02421\", \"If compactedSize is not 0 then both info.geometryCount and info.instanceCount must be 0\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if ((pCreateInfo->compactedSize != 0) &&\n    skip |= LogError(\"VUID-VkAccelerationStructureCreateInfoNV-compactedSize-02421\", device, error_obj.location,\n                     \"pCreateInfo->compactedSize nonzero (%\" PRIu64 \") with info.geometryCount (%\" PRIu32\n                     \") or info.instanceCount (%\" PRIu32 \") nonzero.\",\n                     pCreateInfo->compactedSize, pCreateInfo->info.geometryCount, pCreateInfo->info.instanceCount);\n"
        },
        {
            "role": "user",
            "content": "{\"VUID-vkCreateAccelerationStructureKHR-accelerationStructure-03611\", \"The VkPhysicalDeviceAccelerationStructureFeaturesKHR::accelerationStructure feature must be enabled\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (!enabled_features.accelerationStructure) {\n    skip |= LogError(\"VUID-vkCreateAccelerationStructureKHR-accelerationStructure-03611\", device, error_obj.location,\n                     \"accelerationStructure feature was not enabled.\");\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkAccelerationStructureCreateInfoKHR-createFlags-03613\", \"If createFlags includes VK_ACCELERATION_STRUCTURE_CREATE_DEVICE_ADDRESS_CAPTURE_REPLAY_BIT_KHR, VkPhysicalDeviceAccelerationStructureFeaturesKHR::accelerationStructureCaptureReplay must be VK_TRUE\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (pCreateInfo->createFlags & VK_ACCELERATION_STRUCTURE_CREATE_DEVICE_ADDRESS_CAPTURE_REPLAY_BIT_KHR &&\n    skip |= LogError(\"VUID-VkAccelerationStructureCreateInfoKHR-createFlags-03613\", device,\n                     create_info_loc.dot(Field::createFlags),\n                     \"includes \"\n                     \"VK_ACCELERATION_STRUCTURE_CREATE_DEVICE_ADDRESS_CAPTURE_REPLAY_BIT_KHR, \"\n                     \"but accelerationStructureCaptureReplay feature is not enabled.\");\n"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkAccelerationStructureCreateInfoKHR-offset-03734\", \"offset must be a multiple of 256 bytes\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (SafeModulo(pCreateInfo->offset, 256) != 0) {\n    skip |= LogError(\"VUID-VkAccelerationStructureCreateInfoKHR-offset-03734\", device, create_info_loc.dot(Field::offset),\n                     \"%\" PRIu64 \" must be a multiple of 256 bytes\", pCreateInfo->offset);\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkAccelerationStructureCreateInfoKHR-createFlags-08108\", \"If createFlags includes VK_ACCELERATION_STRUCTURE_CREATE_DESCRIPTOR_BUFFER_CAPTURE_REPLAY_BIT_EXT, the descriptorBufferCaptureReplay feature must be enabled\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if ((pCreateInfo->createFlags & VK_ACCELERATION_STRUCTURE_CREATE_DESCRIPTOR_BUFFER_CAPTURE_REPLAY_BIT_EXT) &&\n    skip |= LogError(\"VUID-VkAccelerationStructureCreateInfoKHR-createFlags-08108\", device,\n                     create_info_loc.dot(Field::createFlags),\n                     \"includes VK_ACCELERATION_STRUCTURE_CREATE_DESCRIPTOR_BUFFER_CAPTURE_REPLAY_BIT_EXT, but the \"\n                     \"descriptorBufferCaptureReplay feature was not enabled.\");\n"
        },
        {
            "role": "user",
            "content": "{\"VUID-vkDestroyAccelerationStructureKHR-accelerationStructure-08934\", \"The VkPhysicalDeviceAccelerationStructureFeaturesKHR::accelerationStructure feature must be enabled\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (!enabled_features.accelerationStructure) {\n    skip |= LogError(\"VUID-vkDestroyAccelerationStructureKHR-accelerationStructure-08934\", device, error_obj.location,\n                     \"accelerationStructure feature was not enabled.\");\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-vkGetAccelerationStructureHandleNV-dataSize-02240\", \"dataSize must be large enough to contain the result of the query, as described above\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (dataSize < 8) {\n    skip |= LogError(\"VUID-vkGetAccelerationStructureHandleNV-dataSize-02240\", accelerationStructure,\n                     error_obj.location.dot(Field::dataSize), \"must be greater than or equal to 8.\");\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkRayTracingPipelineCreateInfoNV-flags-02904\", \"flags must not include VK_PIPELINE_CREATE_INDIRECT_BINDABLE_BIT_NV\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (flags & VK_PIPELINE_CREATE_INDIRECT_BINDABLE_BIT_NV) {\n    skip |= LogError(\"VUID-VkRayTracingPipelineCreateInfoNV-flags-02904\", device, flags_loc, \"is %s.\",\n                     string_VkPipelineCreateFlags2KHR(flags).c_str());\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkRayTracingPipelineCreateInfoNV-flags-02957\", \"flags must not include both VK_PIPELINE_CREATE_DEFER_COMPILE_BIT_NV and VK_PIPELINE_CREATE_FAIL_ON_PIPELINE_COMPILE_REQUIRED_BIT at the same time\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if ((flags & VK_PIPELINE_CREATE_DEFER_COMPILE_BIT_NV) &&\n    (flags & VK_PIPELINE_CREATE_FAIL_ON_PIPELINE_COMPILE_REQUIRED_BIT_EXT)) {\n    skip |= LogError(\"VUID-VkRayTracingPipelineCreateInfoNV-flags-02957\", device, flags_loc, \"is %s.\",\n                     string_VkPipelineCreateFlags2KHR(flags).c_str());\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkRayTracingPipelineCreateInfoNV-flags-03456\", \"flags must not include VK_PIPELINE_CREATE_LIBRARY_BIT_KHR\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (flags & VK_PIPELINE_CREATE_LIBRARY_BIT_KHR) {\n    skip |= LogError(\"VUID-VkRayTracingPipelineCreateInfoNV-flags-03456\", device, flags_loc, \"is %s.\",\n                     string_VkPipelineCreateFlags2KHR(flags).c_str());\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkRayTracingPipelineCreateInfoNV-flags-03458\", \"flags must not include VK_PIPELINE_CREATE_RAY_TRACING_NO_NULL_ANY_HIT_SHADERS_BIT_KHR\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (flags & VK_PIPELINE_CREATE_RAY_TRACING_NO_NULL_ANY_HIT_SHADERS_BIT_KHR) {\n    skip |= LogError(\"VUID-VkRayTracingPipelineCreateInfoNV-flags-03458\", device, flags_loc, \"is %s.\",\n                     string_VkPipelineCreateFlags2KHR(flags).c_str());\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkRayTracingPipelineCreateInfoNV-flags-03460\", \"flags must not include VK_PIPELINE_CREATE_RAY_TRACING_NO_NULL_MISS_SHADERS_BIT_KHR\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (flags & VK_PIPELINE_CREATE_RAY_TRACING_NO_NULL_MISS_SHADERS_BIT_KHR) {\n    skip |= LogError(\"VUID-VkRayTracingPipelineCreateInfoNV-flags-03460\", device, flags_loc, \"is %s\",\n                     string_VkPipelineCreateFlags2KHR(flags).c_str());\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkRayTracingPipelineCreateInfoNV-flags-03461\", \"flags must not include VK_PIPELINE_CREATE_RAY_TRACING_NO_NULL_INTERSECTION_SHADERS_BIT_KHR\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (flags & VK_PIPELINE_CREATE_RAY_TRACING_NO_NULL_INTERSECTION_SHADERS_BIT_KHR) {\n    skip |= LogError(\"VUID-VkRayTracingPipelineCreateInfoNV-flags-03461\", device, flags_loc, \"is %s\",\n                     string_VkPipelineCreateFlags2KHR(flags).c_str());\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkRayTracingPipelineCreateInfoNV-flags-03462\", \"flags must not include VK_PIPELINE_CREATE_RAY_TRACING_SKIP_AABBS_BIT_KHR\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (flags & VK_PIPELINE_CREATE_RAY_TRACING_SKIP_AABBS_BIT_KHR) {\n    skip |= LogError(\"VUID-VkRayTracingPipelineCreateInfoNV-flags-03462\", device, flags_loc, \"is %s\",\n                     string_VkPipelineCreateFlags2KHR(flags).c_str());\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkRayTracingPipelineCreateInfoNV-flags-03463\", \"flags must not include VK_PIPELINE_CREATE_RAY_TRACING_SKIP_TRIANGLES_BIT_KHR\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (flags & VK_PIPELINE_CREATE_RAY_TRACING_SKIP_TRIANGLES_BIT_KHR) {\n    skip |= LogError(\"VUID-VkRayTracingPipelineCreateInfoNV-flags-03463\", device, flags_loc, \"is %s\",\n                     string_VkPipelineCreateFlags2KHR(flags).c_str());\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-vkCreateRayTracingPipelinesNV-flags-03816\", \"flags must not contain the VK_PIPELINE_CREATE_DISPATCH_BASE flag\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (flags & VK_PIPELINE_CREATE_DISPATCH_BASE) {\n    skip |= LogError(\"VUID-vkCreateRayTracingPipelinesNV-flags-03816\", device, flags_loc, \"is %s\",\n                     string_VkPipelineCreateFlags2KHR(flags).c_str());\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkRayTracingPipelineCreateInfoNV-flags-04948\", \"flags must not include VK_PIPELINE_CREATE_RAY_TRACING_ALLOW_MOTION_BIT_NV\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (flags & VK_PIPELINE_CREATE_RAY_TRACING_ALLOW_MOTION_BIT_NV) {\n    skip |= LogError(\"VUID-VkRayTracingPipelineCreateInfoNV-flags-04948\", device, flags_loc, \"is %s\",\n                     string_VkPipelineCreateFlags2KHR(flags).c_str());\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkRayTracingPipelineCreateInfoNV-pipelineStageCreationFeedbackCount-06651\", \"If VkPipelineCreationFeedbackCreateInfo::pipelineStageCreationFeedbackCount is not 0, it must be equal to stageCount\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if ((feedback_struct != nullptr) && (feedback_struct->pipelineStageCreationFeedbackCount != 0) &&\n    (feedback_struct->pipelineStageCreationFeedbackCount != create_info.stageCount)) {\n    skip |= LogError(\"VUID-VkRayTracingPipelineCreateInfoNV-pipelineStageCreationFeedbackCount-06651\", device,\n                     create_info_loc.dot(Field::stageCount),\n                     \"(%\" PRIu32 \") must equal VkPipelineCreationFeedbackEXT::pipelineStageCreationFeedbackCount (%\" PRIu32\n                     \").\",\n                     create_info.stageCount, feedback_struct->pipelineStageCreationFeedbackCount);\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkRayTracingPipelineCreateInfoNV-pipelineCreationCacheControl-02905\", \"If the pipelineCreationCacheControl feature is not enabled, flags must not include VK_PIPELINE_CREATE_FAIL_ON_PIPELINE_COMPILE_REQUIRED_BIT or VK_PIPELINE_CREATE_EARLY_RETURN_ON_FAILURE_BIT\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (flags & (VK_PIPELINE_CREATE_FAIL_ON_PIPELINE_COMPILE_REQUIRED_BIT_EXT |\n    skip |= LogError(\"VUID-VkRayTracingPipelineCreateInfoNV-pipelineCreationCacheControl-02905\", device, flags_loc,\n                     \"is %s but the pipelineCreationCacheControl feature is not enabled.\",\n                     string_VkPipelineCreateFlags2KHR(flags).c_str());\n"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkRayTracingPipelineCreateInfoNV-flags-07986\", \"If flags contains the VK_PIPELINE_CREATE_DERIVATIVE_BIT flag, basePipelineIndex must be -1 or basePipelineHandle must be VK_NULL_HANDLE\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (create_info.basePipelineIndex != -1) {\n    skip |= LogError(\"VUID-VkRayTracingPipelineCreateInfoNV-flags-07986\", device, flags_loc,\n                     \"is %s, but %s is %\" PRId32 \".\", string_VkPipelineCreateFlags2KHR(flags).c_str(),\n                     create_info_loc.dot(Field::basePipelineIndex).Fields().c_str(), create_info.basePipelineIndex);\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-vkCreateRayTracingPipelinesNV-flags-03415\", \"If the flags member of any element of pCreateInfos contains the VK_PIPELINE_CREATE_DERIVATIVE_BIT flag, and the basePipelineIndex member of that same element is not -1, basePipelineIndex must be less than the index into pCreateInfos that corresponds to that element\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (create_info.basePipelineIndex > static_cast<int32_t>(i)) {\n    skip |= LogError(\"VUID-vkCreateRayTracingPipelinesNV-flags-03415\", device, flags_loc,\n                     \"is %s, but %s is %\" PRId32 \".\", string_VkPipelineCreateFlags2KHR(flags).c_str(),\n                     create_info_loc.dot(Field::basePipelineIndex).Fields().c_str(), create_info.basePipelineIndex);\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkRayTracingPipelineCreateInfoNV-flags-07985\", \"If flags contains the VK_PIPELINE_CREATE_DERIVATIVE_BIT flag, and basePipelineHandle is VK_NULL_HANDLE, basePipelineIndex must be a valid index into the calling command's pCreateInfos parameter\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (static_cast<uint32_t>(create_info.basePipelineIndex) >= createInfoCount) {\n    skip |= LogError(\"VUID-VkRayTracingPipelineCreateInfoNV-flags-07985\", device,\n                     create_info_loc.dot(Field::basePipelineHandle), \"is VK_NULL_HANDLE, but %s is %s.\",\n                     flags_loc.Fields().c_str(), string_VkPipelineCreateFlags2KHR(flags).c_str());\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkRayTracingPipelineCreateInfoKHR-flags-02904\", \"flags must not include VK_PIPELINE_CREATE_INDIRECT_BINDABLE_BIT_NV\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (flags & VK_PIPELINE_CREATE_INDIRECT_BINDABLE_BIT_NV) {\n    skip |= LogError(\"VUID-VkRayTracingPipelineCreateInfoKHR-flags-02904\", device, flags_loc, \"is %s.\",\n                     string_VkPipelineCreateFlags2KHR(flags).c_str());\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkRayTracingPipelineCreateInfoKHR-flags-03598\", \"If flags includes VK_PIPELINE_CREATE_RAY_TRACING_SHADER_GROUP_HANDLE_CAPTURE_REPLAY_BIT_KHR, rayTracingPipelineShaderGroupHandleCaptureReplay must be enabled\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (flags & VK_PIPELINE_CREATE_RAY_TRACING_SHADER_GROUP_HANDLE_CAPTURE_REPLAY_BIT_KHR &&\n    skip |= LogError(\"VUID-VkRayTracingPipelineCreateInfoKHR-flags-03598\", device, flags_loc, \"is %s.\",\n                     string_VkPipelineCreateFlags2KHR(flags).c_str());\n"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkRayTracingPipelineCreateInfoKHR-rayTraversalPrimitiveCulling-03596\", \"If the rayTraversalPrimitiveCulling feature is not enabled, flags must not include VK_PIPELINE_CREATE_RAY_TRACING_SKIP_AABBS_BIT_KHR\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (flags & VK_PIPELINE_CREATE_RAY_TRACING_SKIP_AABBS_BIT_KHR) {\n    skip |= LogError(\"VUID-VkRayTracingPipelineCreateInfoKHR-rayTraversalPrimitiveCulling-03596\", device, flags_loc,\n                     \"is %s.\", string_VkPipelineCreateFlags2KHR(flags).c_str());\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkRayTracingPipelineCreateInfoKHR-rayTraversalPrimitiveCulling-03597\", \"If the rayTraversalPrimitiveCulling feature is not enabled, flags must not include VK_PIPELINE_CREATE_RAY_TRACING_SKIP_TRIANGLES_BIT_KHR\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (flags & VK_PIPELINE_CREATE_RAY_TRACING_SKIP_TRIANGLES_BIT_KHR) {\n    skip |= LogError(\"VUID-VkRayTracingPipelineCreateInfoKHR-rayTraversalPrimitiveCulling-03597\", device, flags_loc,\n                     \"is %s.\", string_VkPipelineCreateFlags2KHR(flags).c_str());\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-vkCreateRayTracingPipelinesKHR-rayTracingPipeline-03586\", \"The rayTracingPipeline feature must be enabled\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (!enabled_features.rayTracingPipeline) {\n    skip |= LogError(\"VUID-vkCreateRayTracingPipelinesKHR-rayTracingPipeline-03586\", device, error_obj.location,\n                     \"The rayTracingPipeline feature was not enabled.\");\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkRayTracingPipelineCreateInfoKHR-pipelineCreationCacheControl-02905\", \"If the pipelineCreationCacheControl feature is not enabled, flags must not include VK_PIPELINE_CREATE_FAIL_ON_PIPELINE_COMPILE_REQUIRED_BIT or VK_PIPELINE_CREATE_EARLY_RETURN_ON_FAILURE_BIT\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (flags & (VK_PIPELINE_CREATE_FAIL_ON_PIPELINE_COMPILE_REQUIRED_BIT_EXT |\n    skip |= LogError(\"VUID-VkRayTracingPipelineCreateInfoKHR-pipelineCreationCacheControl-02905\", device, flags_loc,\n                     \"vkCreateRayTracingPipelinesKHR(): pCreateInfos[%\" PRIu32 \"].flags is %s.\", i,\n                     string_VkPipelineCreateFlags2KHR(flags).c_str());\n"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkRayTracingPipelineCreateInfoKHR-flags-03470\", \"If flags includes VK_PIPELINE_CREATE_RAY_TRACING_NO_NULL_ANY_HIT_SHADERS_BIT_KHR, for any element of pGroups with a type of VK_RAY_TRACING_SHADER_GROUP_TYPE_TRIANGLES_HIT_GROUP_KHR or VK_RAY_TRACING_SHADER_GROUP_TYPE_PROCEDURAL_HIT_GROUP_KHR, the anyHitShader of that element must not be VK_SHADER_UNUSED_KHR\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if ((flags & VK_PIPELINE_CREATE_RAY_TRACING_NO_NULL_ANY_HIT_SHADERS_BIT_KHR) &&\n    skip |= LogError(\"VUID-VkRayTracingPipelineCreateInfoKHR-flags-03470\", device, flags_loc,\n                     \"is %s, but %s is VK_SHADER_UNUSED_KHR.\", string_VkPipelineCreateFlags2KHR(flags).c_str(),\n                     group_loc.dot(Field::anyHitShader).Fields().c_str());\n"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkRayTracingPipelineCreateInfoKHR-flags-03471\", \"If flags includes VK_PIPELINE_CREATE_RAY_TRACING_NO_NULL_CLOSEST_HIT_SHADERS_BIT_KHR, for any element of pGroups with a type of VK_RAY_TRACING_SHADER_GROUP_TYPE_TRIANGLES_HIT_GROUP_KHR or VK_RAY_TRACING_SHADER_GROUP_TYPE_PROCEDURAL_HIT_GROUP_KHR, the closestHitShader of that element must not be VK_SHADER_UNUSED_KHR\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if ((flags & VK_PIPELINE_CREATE_RAY_TRACING_NO_NULL_CLOSEST_HIT_SHADERS_BIT_KHR) &&\n    skip |= LogError(\"VUID-VkRayTracingPipelineCreateInfoKHR-flags-03471\", device, flags_loc,\n                     \"is %s, but %s is VK_SHADER_UNUSED_KHR.\", string_VkPipelineCreateFlags2KHR(flags).c_str(),\n                     group_loc.dot(Field::closestHitShader).Fields().c_str());\n"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkRayTracingPipelineCreateInfoKHR-flags-07986\", \"If flags contains the VK_PIPELINE_CREATE_DERIVATIVE_BIT flag, basePipelineIndex must be -1 or basePipelineHandle must be VK_NULL_HANDLE\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (create_info.basePipelineHandle != VK_NULL_HANDLE) {\n    skip |= LogError(\"VUID-VkRayTracingPipelineCreateInfoKHR-flags-07986\", device,\n                     create_info_loc.dot(Field::basePipelineIndex),\n                     \"is %\" PRId32 \" and basePipelineHandle is not VK_NULL_HANDLE.\", create_info.basePipelineIndex);\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkRayTracingPipelineCreateInfoKHR-flags-03465\", \"If flags includes VK_PIPELINE_CREATE_LIBRARY_BIT_KHR, pLibraryInterface must not be NULL\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (create_info.pLibraryInterface == nullptr) {\n    skip |= LogError(\"VUID-VkRayTracingPipelineCreateInfoKHR-flags-03465\", device, flags_loc,\n                     \"is %s and pLibraryInterface is null.\", string_VkPipelineCreateFlags2KHR(flags).c_str());\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkRayTracingPipelineCreateInfoKHR-pLibraryInfo-03595\", \"If the VK_KHR_pipeline_library extension is not enabled, pLibraryInfo and pLibraryInterface must be NULL\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (create_info.pLibraryInfo) {\n    skip |= LogError(\"VUID-VkRayTracingPipelineCreateInfoKHR-pLibraryInfo-03595\", device,\n                     create_info_loc.dot(Field::pLibraryInfo), \"is not NULL.\");\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkRayTracingPipelineCreateInfoKHR-pLibraryInfo-03595\", \"If the VK_KHR_pipeline_library extension is not enabled, pLibraryInfo and pLibraryInterface must be NULL\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (create_info.pLibraryInterface) {\n    skip |= LogError(\"VUID-VkRayTracingPipelineCreateInfoKHR-pLibraryInfo-03595\", device,\n                     create_info_loc.dot(Field::pLibraryInterface), \"is not NULL.\");\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkRayTracingPipelineCreateInfoKHR-pLibraryInfo-03590\", \"If pLibraryInfo is not NULL and its libraryCount member is greater than 0, pLibraryInterface must not be NULL\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if ((create_info.pLibraryInfo->libraryCount > 0) && (create_info.pLibraryInterface == nullptr)) {\n    skip |= LogError(\"VUID-VkRayTracingPipelineCreateInfoKHR-pLibraryInfo-03590\", device,\n                     create_info_loc.dot(Field::pLibraryInfo).dot(Field::libraryCount),\n                     \"is %\" PRIu32 \", but pLibraryInterface is NULL.\", create_info.pLibraryInfo->libraryCount);\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkRayTracingPipelineCreateInfoKHR-flags-08700\", \"If flags does not include VK_PIPELINE_CREATE_LIBRARY_BIT_KHR and either pLibraryInfo is NULL or its libraryCount is 0, groupCount must not be 0\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (((flags & VK_PIPELINE_CREATE_LIBRARY_BIT_KHR) == 0) && (create_info.groupCount == 0)) {\n    skip |= LogError(\"VUID-VkRayTracingPipelineCreateInfoKHR-flags-08700\", device,\n                     create_info_loc.dot(Field::pLibraryInfo).dot(Field::libraryCount), \"is zero and flags is %s.\",\n                     string_VkPipelineCreateFlags2KHR(flags).c_str());\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-vkCreateRayTracingPipelinesKHR-deferredOperation-03587\", \"If deferredOperation is not VK_NULL_HANDLE, the flags member of elements of pCreateInfos must not include VK_PIPELINE_CREATE_EARLY_RETURN_ON_FAILURE_BIT\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (flags & VK_PIPELINE_CREATE_EARLY_RETURN_ON_FAILURE_BIT_EXT) {\n    skip |= LogError(\"VUID-vkCreateRayTracingPipelinesKHR-deferredOperation-03587\", device, flags_loc,\n                     \"is %s, but deferredOperation is not VK_NULL_HANDLE.\",\n                     string_VkPipelineCreateFlags2KHR(flags).c_str());\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkRayTracingPipelineCreateInfoKHR-pDynamicStates-03602\", \"Any element of the pDynamicStates member of pDynamicState must be VK_DYNAMIC_STATE_RAY_TRACING_PIPELINE_STACK_SIZE_KHR\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (create_info.pDynamicState->pDynamicStates[j] != VK_DYNAMIC_STATE_RAY_TRACING_PIPELINE_STACK_SIZE_KHR) {\n    skip |= LogError(\"VUID-VkRayTracingPipelineCreateInfoKHR-pDynamicStates-03602\", device,\n                     create_info_loc.dot(Field::pDynamicState).dot(Field::pDynamicStates, j), \"is %s.\",\n                     string_VkDynamicState(create_info.pDynamicState->pDynamicStates[j]));\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkCopyAccelerationStructureToMemoryInfoKHR-mode-03412\", \"mode must be VK_COPY_ACCELERATION_STRUCTURE_MODE_SERIALIZE_KHR\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (pInfo->mode != VK_COPY_ACCELERATION_STRUCTURE_MODE_SERIALIZE_KHR) {\n    skip |= LogError(\"VUID-VkCopyAccelerationStructureToMemoryInfoKHR-mode-03412\", device, info_loc.dot(Field::mode), \"is %s.\",\n                     string_VkCopyAccelerationStructureModeKHR(pInfo->mode));\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-vkCopyAccelerationStructureToMemoryKHR-pInfo-03751\", \"pInfo->dst.hostAddress must be aligned to 16 bytes\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (SafeModulo((VkDeviceSize)pInfo->dst.hostAddress, 16) != 0) {\n    skip |= LogError(\"VUID-vkCopyAccelerationStructureToMemoryKHR-pInfo-03751\", device,\n                     info_loc.dot(Field::dst).dot(Field::hostAddress), \"(0x%\" PRIx64 \") must be aligned to 16 bytes.\",\n                     (VkDeviceAddress)pInfo->dst.hostAddress);\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-vkCmdCopyAccelerationStructureToMemoryKHR-accelerationStructure-08926\", \"The VkPhysicalDeviceAccelerationStructureFeaturesKHR::accelerationStructure feature must be enabled\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (!enabled_features.accelerationStructure) {\n    skip |= LogError(\"VUID-vkCmdCopyAccelerationStructureToMemoryKHR-accelerationStructure-08926\", device, error_obj.location,\n                     \"accelerationStructure feature was not enabled.\");\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-vkCmdCopyAccelerationStructureToMemoryKHR-pInfo-03740\", \"pInfo->dst.deviceAddress must be aligned to 256 bytes\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (SafeModulo(pInfo->dst.deviceAddress, 256) != 0) {\n    skip |= LogError(\"VUID-vkCmdCopyAccelerationStructureToMemoryKHR-pInfo-03740\", commandBuffer,\n                     info_loc.dot(Field::dst).dot(Field::deviceAddress), \"(0x%\" PRIx64 \") must be aligned to 256 bytes.\",\n                     pInfo->dst.deviceAddress);\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkCopyAccelerationStructureInfoKHR-mode-03410\", \"mode must be VK_COPY_ACCELERATION_STRUCTURE_MODE_COMPACT_KHR or VK_COPY_ACCELERATION_STRUCTURE_MODE_CLONE_KHR\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (!(as_info.mode == VK_COPY_ACCELERATION_STRUCTURE_MODE_COMPACT_KHR ||\n      as_info.mode == VK_COPY_ACCELERATION_STRUCTURE_MODE_CLONE_KHR)) {\n    const LogObjectList objlist(handle);\n    skip |= LogError(\"VUID-VkCopyAccelerationStructureInfoKHR-mode-03410\", objlist, info_loc.dot(Field::mode), \"is %s.\",\n                     string_VkCopyAccelerationStructureModeKHR(as_info.mode));\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-vkCmdCopyAccelerationStructureKHR-accelerationStructure-08925\", \"The VkPhysicalDeviceAccelerationStructureFeaturesKHR::accelerationStructure feature must be enabled\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (!enabled_features.accelerationStructure) {\n    skip |= LogError(\"VUID-vkCmdCopyAccelerationStructureKHR-accelerationStructure-08925\", device, error_obj.location,\n                     \"accelerationStructure feature was not enabled.\");\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkCopyMemoryToAccelerationStructureInfoKHR-mode-03413\", \"mode must be VK_COPY_ACCELERATION_STRUCTURE_MODE_DESERIALIZE_KHR\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (as_info.mode != VK_COPY_ACCELERATION_STRUCTURE_MODE_DESERIALIZE_KHR) {\n    const LogObjectList objlist(handle);\n    skip |= LogError(\"VUID-VkCopyMemoryToAccelerationStructureInfoKHR-mode-03413\", objlist, loc.dot(Field::mode), \"is %s.\",\n                     string_VkCopyAccelerationStructureModeKHR(as_info.mode));\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-vkCopyMemoryToAccelerationStructureKHR-accelerationStructureHostCommands-03583\", \"The VkPhysicalDeviceAccelerationStructureFeaturesKHR::accelerationStructureHostCommands feature must be enabled\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (!enabled_features.accelerationStructureHostCommands) {\n    skip |= LogError(\"VUID-vkCopyMemoryToAccelerationStructureKHR-accelerationStructureHostCommands-03583\", device,\n                     error_obj.location, \"accelerationStructureHostCommands feature was not enabled.\");\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-vkCopyMemoryToAccelerationStructureKHR-pInfo-03750\", \"pInfo->src.hostAddress must be aligned to 16 bytes\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (SafeModulo((VkDeviceAddress)pInfo->src.hostAddress, 16) != 0) {\n    skip |= LogError(\"VUID-vkCopyMemoryToAccelerationStructureKHR-pInfo-03750\", device,\n                     info_loc.dot(Field::src).dot(Field::hostAddress), \"(0x%\" PRIx64 \") must be aligned to 16 bytes.\",\n                     (VkDeviceAddress)pInfo->src.hostAddress);\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-vkCmdCopyMemoryToAccelerationStructureKHR-pInfo-03743\", \"pInfo->src.deviceAddress must be aligned to 256 bytes\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (SafeModulo(pInfo->src.deviceAddress, 256) != 0) {\n    skip |= LogError(\"VUID-vkCmdCopyMemoryToAccelerationStructureKHR-pInfo-03743\", commandBuffer,\n                     info_loc.dot(Field::src).dot(Field::deviceAddress), \"(0x%\" PRIx64 \") must be aligned to 256 bytes.\",\n                     pInfo->src.deviceAddress);\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-vkCmdWriteAccelerationStructuresPropertiesKHR-accelerationStructure-08924\", \"The VkPhysicalDeviceAccelerationStructureFeaturesKHR::accelerationStructure feature must be enabled\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (!enabled_features.accelerationStructure) {\n    skip |= LogError(\"VUID-vkCmdWriteAccelerationStructuresPropertiesKHR-accelerationStructure-08924\", commandBuffer,\n                     error_obj.location, \"accelerationStructure feature was not enabled.\");\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-vkCmdWriteAccelerationStructuresPropertiesKHR-queryType-06742\", \"queryType must be VK_QUERY_TYPE_ACCELERATION_STRUCTURE_SIZE_KHR, VK_QUERY_TYPE_ACCELERATION_STRUCTURE_SERIALIZATION_BOTTOM_LEVEL_POINTERS_KHR, VK_QUERY_TYPE_ACCELERATION_STRUCTURE_COMPACTED_SIZE_KHR, or VK_QUERY_TYPE_ACCELERATION_STRUCTURE_SERIALIZATION_SIZE_KHR\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "queryType == VK_QUERY_TYPE_ACCELERATION_STRUCTURE_SERIALIZATION_SIZE_KHR ||\nqueryType == VK_QUERY_TYPE_ACCELERATION_STRUCTURE_SIZE_KHR ||\nqueryType == VK_QUERY_TYPE_ACCELERATION_STRUCTURE_SERIALIZATION_BOTTOM_LEVEL_POINTERS_KHR)) {\nskip |= LogError(\"VUID-vkCmdWriteAccelerationStructuresPropertiesKHR-queryType-06742\", commandBuffer,\n               error_obj.location.dot(Field::queryType), \"(%s) is invalid.\", string_VkQueryType(queryType));\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-vkWriteAccelerationStructuresPropertiesKHR-accelerationStructureHostCommands-03585\", \"The VkPhysicalDeviceAccelerationStructureFeaturesKHR::accelerationStructureHostCommands feature must be enabled\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (!enabled_features.accelerationStructureHostCommands) {\n    skip |= LogError(\"VUID-vkWriteAccelerationStructuresPropertiesKHR-accelerationStructureHostCommands-03585\", device,\n                     error_obj.location, \"accelerationStructureHostCommands feature was not enabled.\");\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-vkWriteAccelerationStructuresPropertiesKHR-queryType-03449\", \"If queryType is VK_QUERY_TYPE_ACCELERATION_STRUCTURE_COMPACTED_SIZE_KHR, then pData must point to a VkDeviceSize\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (dataSize < sizeof(VkDeviceSize)) {\n    switch (queryType) {\n            skip |= LogError(\"VUID-vkWriteAccelerationStructuresPropertiesKHR-queryType-03449\", device, query_type_loc,\n                             \"is %s, but %s is %zu.\", string_VkQueryType(queryType), data_size_loc.Fields().c_str(), dataSize);\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-vkWriteAccelerationStructuresPropertiesKHR-queryType-03451\", \"If queryType is VK_QUERY_TYPE_ACCELERATION_STRUCTURE_SERIALIZATION_SIZE_KHR, then pData must point to a VkDeviceSize\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "\"is %s, but %s is %zu.\", string_VkQueryType(queryType), data_size_loc.Fields().c_str(), dataSize);\nskip |= LogError(\"VUID-vkWriteAccelerationStructuresPropertiesKHR-queryType-03451\", device, query_type_loc,\n\"is %s, but %s is %zu.\", string_VkQueryType(queryType), data_size_loc.Fields().c_str(), dataSize);\n"
        },
        {
            "role": "user",
            "content": "{\"VUID-vkWriteAccelerationStructuresPropertiesKHR-queryType-06734\", \"If queryType is VK_QUERY_TYPE_ACCELERATION_STRUCTURE_SERIALIZATION_BOTTOM_LEVEL_POINTERS_KHR, then pData must point to a VkDeviceSize\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "\"is %s, but %s is %zu.\", string_VkQueryType(queryType), data_size_loc.Fields().c_str(), dataSize);\nskip |= LogError(\"VUID-vkWriteAccelerationStructuresPropertiesKHR-queryType-06734\", device, query_type_loc,\n\"is %s, but %s is %zu.\", string_VkQueryType(queryType), data_size_loc.Fields().c_str(), dataSize);\n"
        },
        {
            "role": "user",
            "content": "{\"VUID-vkWriteAccelerationStructuresPropertiesKHR-queryType-06732\", \"If queryType is VK_QUERY_TYPE_ACCELERATION_STRUCTURE_SIZE_KHR, then pData must point to a VkDeviceSize\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "\"is %s, but %s is %zu.\", string_VkQueryType(queryType), data_size_loc.Fields().c_str(), dataSize);\nskip |= LogError(\"VUID-vkWriteAccelerationStructuresPropertiesKHR-queryType-06732\", device, query_type_loc,\n\"is %s, but %s is %zu.\", string_VkQueryType(queryType), data_size_loc.Fields().c_str(), dataSize);\n"
        },
        {
            "role": "user",
            "content": "{\"VUID-vkWriteAccelerationStructuresPropertiesKHR-queryType-03448\", \"If queryType is VK_QUERY_TYPE_ACCELERATION_STRUCTURE_COMPACTED_SIZE_KHR, then stride must be a multiple of the size of VkDeviceSize\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (queryType == VK_QUERY_TYPE_ACCELERATION_STRUCTURE_COMPACTED_SIZE_KHR) {\n    skip |= LogError(\"VUID-vkWriteAccelerationStructuresPropertiesKHR-queryType-03448\", device,\n                     error_obj.location.dot(Field::queryType),\n                     \"is VK_QUERY_TYPE_ACCELERATION_STRUCTURE_COMPACTED_SIZE_KHR, but then stride (%zu) must be a multiple \"\n                     \"of the size of VkDeviceSize.\",\n                     stride);\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-vkWriteAccelerationStructuresPropertiesKHR-queryType-03450\", \"If queryType is VK_QUERY_TYPE_ACCELERATION_STRUCTURE_SERIALIZATION_SIZE_KHR, then stride must be a multiple of the size of VkDeviceSize\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "} else if (queryType == VK_QUERY_TYPE_ACCELERATION_STRUCTURE_SERIALIZATION_SIZE_KHR) {\n    skip |= LogError(\"VUID-vkWriteAccelerationStructuresPropertiesKHR-queryType-03450\", device,\n                     error_obj.location.dot(Field::queryType),\n                     \"is VK_QUERY_TYPE_ACCELERATION_STRUCTURE_SERIALIZATION_SIZE_KHR, but then stride (%zu) must be a \"\n                     \"multiple of the size of VkDeviceSize.\",\n                     stride);\n"
        },
        {
            "role": "user",
            "content": "{\"VUID-vkWriteAccelerationStructuresPropertiesKHR-queryType-06731\", \"If queryType is VK_QUERY_TYPE_ACCELERATION_STRUCTURE_SIZE_KHR, then stride must be a multiple of the size of VkDeviceSize\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "} else if (queryType == VK_QUERY_TYPE_ACCELERATION_STRUCTURE_SIZE_KHR) {\n    skip |= LogError(\"VUID-vkWriteAccelerationStructuresPropertiesKHR-queryType-06731\", device,\n                     error_obj.location.dot(Field::queryType),\n                     \"is VK_QUERY_TYPE_ACCELERATION_STRUCTURE_SIZE_KHR, but then stride (%zu) must be a multiple of the \"\n                     \"size of VkDeviceSize.\",\n                     stride);\n"
        },
        {
            "role": "user",
            "content": "{\"VUID-vkWriteAccelerationStructuresPropertiesKHR-queryType-06733\", \"If queryType is VK_QUERY_TYPE_ACCELERATION_STRUCTURE_SERIALIZATION_BOTTOM_LEVEL_POINTERS_KHR, then stride must be a multiple of the size of VkDeviceSize\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "} else if (queryType == VK_QUERY_TYPE_ACCELERATION_STRUCTURE_SERIALIZATION_BOTTOM_LEVEL_POINTERS_KHR) {\n    skip |= LogError(\"VUID-vkWriteAccelerationStructuresPropertiesKHR-queryType-06733\", device,\n                     error_obj.location.dot(Field::queryType),\n                     \"is VK_QUERY_TYPE_ACCELERATION_STRUCTURE_SERIALIZATION_BOTTOM_LEVEL_POINTERS_KHR, but then stride \"\n                     \"(%zu) must be a multiple of the size of VkDeviceSize.\",\n                     stride);\n"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkAccelerationStructureBuildGeometryInfoKHR-type-03795\", \"If type is VK_ACCELERATION_STRUCTURE_TYPE_BOTTOM_LEVEL_KHR and the geometryType member of either pGeometries or ppGeometries is VK_GEOMETRY_TYPE_TRIANGLES_KHR, the total number of triangles in all geometries must be less than or equal to VkPhysicalDeviceAccelerationStructurePropertiesKHR::maxPrimitiveCount\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (total_triangles_count > phys_dev_ext_props.acc_structure_props.maxPrimitiveCount) {\n    skip |= LogError(\"VUID-VkAccelerationStructureBuildGeometryInfoKHR-type-03795\", handle, loc,\n                     \"total number of triangles in all geometries (%\" PRIu64\n                     \") is larger than maxPrimitiveCount \"\n                     \"(%\" PRIu64 \")\",\n                     total_triangles_count, phys_dev_ext_props.acc_structure_props.maxPrimitiveCount);\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkAccelerationStructureBuildGeometryInfoKHR-type-03794\", \"If type is VK_ACCELERATION_STRUCTURE_TYPE_BOTTOM_LEVEL_KHR and the geometryType member of either pGeometries or ppGeometries is VK_GEOMETRY_TYPE_AABBS_KHR, the total number of AABBs in all geometries must be less than or equal to VkPhysicalDeviceAccelerationStructurePropertiesKHR::maxPrimitiveCount\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (total_aabbs_count > phys_dev_ext_props.acc_structure_props.maxPrimitiveCount) {\n    skip |= LogError(\"VUID-VkAccelerationStructureBuildGeometryInfoKHR-type-03794\", handle, loc,\n                     \"total number of AABBs in all geometries (%\" PRIu64\n                     \") is larger than maxPrimitiveCount \"\n                     \"(%\" PRIu64 \")\",\n                     total_aabbs_count, phys_dev_ext_props.acc_structure_props.maxPrimitiveCount);\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkAccelerationStructureBuildGeometryInfoKHR-type-03654\", \"type must not be VK_ACCELERATION_STRUCTURE_TYPE_GENERIC_KHR\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (info.type == VK_ACCELERATION_STRUCTURE_TYPE_GENERIC_KHR) {\n    skip |= LogError(\"VUID-VkAccelerationStructureBuildGeometryInfoKHR-type-03654\", handle, info_loc.dot(Field::type),\n                     \"must not be VK_ACCELERATION_STRUCTURE_TYPE_GENERIC_KHR.\");\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkAccelerationStructureBuildGeometryInfoKHR-flags-03796\", \"If flags has the VK_BUILD_ACCELERATION_STRUCTURE_PREFER_FAST_TRACE_BIT_KHR bit set, then it must not have the VK_BUILD_ACCELERATION_STRUCTURE_PREFER_FAST_BUILD_BIT_KHR bit set\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (info.flags & VK_BUILD_ACCELERATION_STRUCTURE_PREFER_FAST_TRACE_BIT_KHR &&\n    info.flags & VK_BUILD_ACCELERATION_STRUCTURE_PREFER_FAST_BUILD_BIT_KHR) {\n    skip |= LogError(\"VUID-VkAccelerationStructureBuildGeometryInfoKHR-flags-03796\", handle, info_loc.dot(Field::flags),\n                     \"has the VK_BUILD_ACCELERATION_STRUCTURE_PREFER_FAST_TRACE_BIT_KHR bit set,\"\n                     \"then it must not have the VK_BUILD_ACCELERATION_STRUCTURE_PREFER_FAST_BUILD_BIT_KHR bit set.\");\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkAccelerationStructureBuildGeometryInfoKHR-pGeometries-03788\", \"If geometryCount is not 0, exactly one of pGeometries or ppGeometries must be a valid pointer, the other must be NULL\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (info.geometryCount > 0 && !info.pGeometries && !info.ppGeometries) {\n    skip |= LogError(\"VUID-VkAccelerationStructureBuildGeometryInfoKHR-pGeometries-03788\", handle,\n                     info_loc.dot(Field::geometryCount), \"is (%\" PRIu32 \") but both pGeometries and ppGeometries are NULL.\",\n                     info.geometryCount);\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkAccelerationStructureBuildGeometryInfoKHR-type-03790\", \"If type is VK_ACCELERATION_STRUCTURE_TYPE_TOP_LEVEL_KHR, geometryCount must be 1\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (info.type == VK_ACCELERATION_STRUCTURE_TYPE_TOP_LEVEL_KHR && info.geometryCount != 1) {\n    skip |= LogError(\"VUID-VkAccelerationStructureBuildGeometryInfoKHR-type-03790\", handle, info_loc.dot(Field::type),\n                     \"is VK_ACCELERATION_STRUCTURE_TYPE_TOP_LEVEL_KHR, but geometryCount is %\" PRIu32 \".\", info.geometryCount);\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkAccelerationStructureBuildGeometryInfoKHR-type-03793\", \"If type is VK_ACCELERATION_STRUCTURE_TYPE_BOTTOM_LEVEL_KHR then geometryCount must be less than or equal to VkPhysicalDeviceAccelerationStructurePropertiesKHR::maxGeometryCount\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (info.type == VK_ACCELERATION_STRUCTURE_TYPE_BOTTOM_LEVEL_KHR &&\n    skip |= LogError(\"VUID-VkAccelerationStructureBuildGeometryInfoKHR-type-03793\", handle, info_loc.dot(Field::type),\n                     \"is VK_ACCELERATION_STRUCTURE_TYPE_BOTTOM_LEVEL_KHR but geometryCount (%\" PRIu32\n                     \") is greater than maxGeometryCount (%\" PRIu64 \").\",\n                     info.geometryCount, phys_dev_ext_props.acc_structure_props.maxGeometryCount);\n"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkAccelerationStructureGeometryTrianglesDataKHR-vertexStride-03819\", \"vertexStride must be less than or equal to 232-1\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (geom.geometry.triangles.vertexStride > vvl::kU32Max) {\n    skip |= LogError(\"VUID-VkAccelerationStructureGeometryTrianglesDataKHR-vertexStride-03819\", handle,\n                     geometry_loc.dot(Field::geometry).dot(Field::triangles).dot(Field::vertexStride),\n                     \"(%\" PRIu64 \") must be less than or equal to 2^32-1.\", geom.geometry.triangles.vertexStride);\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkAccelerationStructureGeometryAabbsDataKHR-stride-03545\", \"stride must be a multiple of 8\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (geom.geometry.aabbs.stride % 8) {\n    skip |= LogError(\"VUID-VkAccelerationStructureGeometryAabbsDataKHR-stride-03545\", handle,\n                     geometry_loc.dot(Field::geometry).dot(Field::aabbs).dot(Field::stride),\n                     \"(%\" PRIu64 \") is not a multiple of 8.\", geom.geometry.aabbs.stride);\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkAccelerationStructureGeometryAabbsDataKHR-stride-03820\", \"stride must be less than or equal to 232-1\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (geom.geometry.aabbs.stride > vvl::kU32Max) {\n    skip |= LogError(\"VUID-VkAccelerationStructureGeometryAabbsDataKHR-stride-03820\", handle,\n                     geometry_loc.dot(Field::geometry).dot(Field::aabbs).dot(Field::stride),\n                     \"(%\" PRIu64 \") must be less than or equal to 2^32-1.\", geom.geometry.aabbs.stride);\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkAccelerationStructureBuildGeometryInfoKHR-type-03789\", \"If type is VK_ACCELERATION_STRUCTURE_TYPE_TOP_LEVEL_KHR, the geometryType member of elements of either pGeometries or ppGeometries must be VK_GEOMETRY_TYPE_INSTANCES_KHR\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (info.type == VK_ACCELERATION_STRUCTURE_TYPE_TOP_LEVEL_KHR && geom.geometryType != VK_GEOMETRY_TYPE_INSTANCES_KHR) {\n    skip |= LogError(\"VUID-VkAccelerationStructureBuildGeometryInfoKHR-type-03789\", handle,\n                     geometry_loc.dot(Field::geometryType), \"is %s but %s is VK_ACCELERATION_STRUCTURE_TYPE_TOP_LEVEL_KHR.\",\n                     string_VkGeometryTypeKHR(geom.geometryType), info_loc.dot(Field::type).Fields().c_str());\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkAccelerationStructureBuildGeometryInfoKHR-type-03791\", \"If type is VK_ACCELERATION_STRUCTURE_TYPE_BOTTOM_LEVEL_KHR the geometryType member of elements of either pGeometries or ppGeometries must not be VK_GEOMETRY_TYPE_INSTANCES_KHR\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (geom.geometryType == VK_GEOMETRY_TYPE_INSTANCES_KHR) {\n    skip |= LogError(\"VUID-VkAccelerationStructureBuildGeometryInfoKHR-type-03791\", handle,\n                     geometry_loc.dot(Field::geometryType),\n                     \"is %s but %s is VK_ACCELERATION_STRUCTURE_TYPE_BOTTOM_LEVEL_KHR.\",\n                     string_VkGeometryTypeKHR(geom.geometryType), info_loc.dot(Field::type).Fields().c_str());\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-vkCmdBuildAccelerationStructuresKHR-accelerationStructure-08923\", \"The VkPhysicalDeviceAccelerationStructureFeaturesKHR::accelerationStructure feature must be enabled\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (!enabled_features.accelerationStructure) {\n    skip |= LogError(\"VUID-vkCmdBuildAccelerationStructuresKHR-accelerationStructure-08923\", commandBuffer, error_obj.location,\n                     \"accelerationStructure feature was not enabled.\");\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-vkCmdBuildAccelerationStructuresKHR-pInfos-03710\", \"For each element of pInfos, its scratchData.deviceAddress member must be a multiple of VkPhysicalDeviceAccelerationStructurePropertiesKHR::minAccelerationStructureScratchOffsetAlignment\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (SafeModulo(info->scratchData.deviceAddress,\n    skip |= LogError(\"VUID-vkCmdBuildAccelerationStructuresKHR-pInfos-03710\", commandBuffer,\n                     info_loc.dot(Field::scratchData).dot(Field::deviceAddress),\n                     \"(%\" PRIu64 \") must be a multiple of minAccelerationStructureScratchOffsetAlignment (%\" PRIu32 \").\",\n                     info->scratchData.deviceAddress,\n                     phys_dev_ext_props.acc_structure_props.minAccelerationStructureScratchOffsetAlignment);\n"
        },
        {
            "role": "user",
            "content": "{\"VUID-vkCmdBuildAccelerationStructuresKHR-pInfos-04630\", \"For each element of pInfos, if its mode member is VK_BUILD_ACCELERATION_STRUCTURE_MODE_UPDATE_KHR, its srcAccelerationStructure member must not be VK_NULL_HANDLE\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (info->mode == VK_BUILD_ACCELERATION_STRUCTURE_MODE_UPDATE_KHR && info->srcAccelerationStructure == VK_NULL_HANDLE) {\n    skip |= LogError(\"VUID-vkCmdBuildAccelerationStructuresKHR-pInfos-04630\", commandBuffer, info_loc.dot(Field::mode),\n                     \"is VK_BUILD_ACCELERATION_STRUCTURE_MODE_UPDATE_KHR, but srcAccelerationStructure is VK_NULL_HANDLE.\");\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-vkCmdBuildAccelerationStructuresKHR-dstAccelerationStructure-03698\", \"The dstAccelerationStructure member of any element of pInfos must not be the same acceleration structure as the dstAccelerationStructure member of any other element of pInfos\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (info->dstAccelerationStructure == other_info->dstAccelerationStructure) {\n    const LogObjectList objlist(commandBuffer, info->dstAccelerationStructure);\n    skip |= LogError(\"VUID-vkCmdBuildAccelerationStructuresKHR-dstAccelerationStructure-03698\", objlist,\n                     info_loc.dot(Field::dstAccelerationStructure),\n                     \"and pInfos[%\" PRIu32 \"].dstAccelerationStructure are both %s.\", other_info_j,\n                     FormatHandle(info->dstAccelerationStructure).c_str());\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-vkCmdBuildAccelerationStructuresKHR-pInfos-03712\", \"For any element of pInfos[i].pGeometries or pInfos[i].ppGeometries with a geometryType of VK_GEOMETRY_TYPE_TRIANGLES_KHR, and with geometry.triangles.indexType not equal to VK_INDEX_TYPE_NONE_KHR, geometry.triangles.indexData.deviceAddress must be aligned to the size in bytes of the type in indexType\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (SafeModulo(as_geometry.geometry.triangles.indexData.deviceAddress, index_buffer_alignment) != 0) {\n    skip |= LogError(\"VUID-vkCmdBuildAccelerationStructuresKHR-pInfos-03712\", commandBuffer,\n                     p_geom_geom_loc.dot(Field::triangles).dot(Field::indexData).dot(Field::deviceAddress),\n                     \"(0x%\" PRIx64\n                     \") is not aligned to the size in bytes of its corresponding index type (%s).\",\n                     as_geometry.geometry.triangles.indexData.deviceAddress,\n                     string_VkIndexType(as_geometry.geometry.triangles.indexType));\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-vkCmdBuildAccelerationStructuresKHR-pInfos-03714\", \"For any element of pInfos[i].pGeometries or pInfos[i].ppGeometries with a geometryType of VK_GEOMETRY_TYPE_AABBS_KHR, geometry.aabbs.data.deviceAddress must be aligned to 8 bytes\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (SafeModulo(as_geometry.geometry.aabbs.data.deviceAddress, 8) != 0) {\n    skip |= LogError(\"VUID-vkCmdBuildAccelerationStructuresKHR-pInfos-03714\", commandBuffer,\n                     p_geom_geom_loc.dot(Field::aabbs).dot(Field::data).dot(Field::deviceAddress),\n                     \"(0x%\" PRIx64\n                     \") must be aligned to 8 bytes when geometryType is VK_GEOMETRY_TYPE_AABBS_KHR.\",\n                     as_geometry.geometry.aabbs.data.deviceAddress);\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-vkCmdBuildAccelerationStructuresIndirectKHR-accelerationStructureIndirectBuild-03650\", \"The VkPhysicalDeviceAccelerationStructureFeaturesKHR::accelerationStructureIndirectBuild feature must be enabled\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (!enabled_features.accelerationStructureIndirectBuild) {\n    skip |= LogError(\"VUID-vkCmdBuildAccelerationStructuresIndirectKHR-accelerationStructureIndirectBuild-03650\", commandBuffer,\n                     error_obj.location, \"the accelerationStructureIndirectBuild feature was not enabled.\");\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-vkCmdBuildAccelerationStructuresIndirectKHR-pInfos-03710\", \"For each element of pInfos, its scratchData.deviceAddress member must be a multiple of VkPhysicalDeviceAccelerationStructurePropertiesKHR::minAccelerationStructureScratchOffsetAlignment\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (SafeModulo(info->scratchData.deviceAddress,\n    skip |= LogError(\"VUID-vkCmdBuildAccelerationStructuresIndirectKHR-pInfos-03710\", commandBuffer,\n                     info_loc.dot(Field::scratchData).dot(Field::deviceAddress),\n                     \"(%\" PRIu64 \") must be a multiple of minAccelerationStructureScratchOffsetAlignment (%\" PRIu32 \").\",\n                     info->scratchData.deviceAddress,\n                     phys_dev_ext_props.acc_structure_props.minAccelerationStructureScratchOffsetAlignment);\n"
        },
        {
            "role": "user",
            "content": "{\"VUID-vkCmdBuildAccelerationStructuresIndirectKHR-pInfos-03403\", \"The srcAccelerationStructure member of any element of pInfos must not be the same acceleration structure as the dstAccelerationStructure member of any other element of pInfos\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (info->srcAccelerationStructure == pInfos[info_k].dstAccelerationStructure) {\n    const LogObjectList objlist(commandBuffer, info->srcAccelerationStructure);\n    skip |= LogError(\"VUID-vkCmdBuildAccelerationStructuresIndirectKHR-pInfos-03403\", objlist,\n                     info_loc.dot(Field::srcAccelerationStructure),\n                     \"and pInfos[%\" PRIu32 \"].dstAccelerationStructure are both %s.\", info_k,\n                     FormatHandle(info->srcAccelerationStructure).c_str());\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-vkCmdBuildAccelerationStructuresIndirectKHR-pInfos-03810\", \"For any element of pInfos[i].pGeometries or pInfos[i].ppGeometries with a geometryType of VK_GEOMETRY_TYPE_TRIANGLES_KHR, if geometry.triangles.transformData.deviceAddress is not 0, it must be aligned to 16 bytes\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (SafeModulo(as_geometry.geometry.triangles.indexData.deviceAddress, 16) != 0) {\n    skip |= LogError(\"VUID-vkCmdBuildAccelerationStructuresIndirectKHR-pInfos-03810\", commandBuffer,\n                     geometry_loc.dot(Field::geometry)\n                         .dot(Field::triangles)\n                         .dot(Field::transformData)\n                         .dot(Field::deviceAddress),\n                     \"(%\" PRIu64\n                     \") must be aligned to 16 bytes when geometryType is VK_GEOMETRY_TYPE_TRIANGLES_KHR.\",\n                     as_geometry.geometry.triangles.transformData.deviceAddress);\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-vkCmdBuildAccelerationStructuresIndirectKHR-pInfos-03810\", \"For any element of pInfos[i].pGeometries or pInfos[i].ppGeometries with a geometryType of VK_GEOMETRY_TYPE_TRIANGLES_KHR, if geometry.triangles.transformData.deviceAddress is not 0, it must be aligned to 16 bytes\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (SafeModulo(as_geometry->geometry.triangles.indexData.deviceAddress, 16) != 0) {\n    skip |= LogError(\"VUID-vkCmdBuildAccelerationStructuresIndirectKHR-pInfos-03810\", commandBuffer,\n                     geometry_loc.dot(Field::geometry)\n                         .dot(Field::triangles)\n                         .dot(Field::transformData)\n                         .dot(Field::deviceAddress),\n                     \"(%\" PRIu64\n                     \") must be aligned to 16 bytes when geometryType is VK_GEOMETRY_TYPE_TRIANGLES_KHR.\",\n                     info->pGeometries[j].geometry.triangles.transformData.deviceAddress);\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-vkCmdBuildAccelerationStructuresIndirectKHR-pIndirectDeviceAddresses-03648\", \"Each element of pIndirectDeviceAddresses must be a multiple of 4\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (SafeModulo(pIndirectDeviceAddresses[info_i], 4) != 0) {\n    skip |= LogError(\"VUID-vkCmdBuildAccelerationStructuresIndirectKHR-pIndirectDeviceAddresses-03648\", commandBuffer,\n                     error_obj.location.dot(Field::pIndirectStrides, info_i), \"is 0x%\" PRIx64 \".\",\n                     pIndirectDeviceAddresses[info_i]);\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-vkBuildAccelerationStructuresKHR-accelerationStructureHostCommands-03581\", \"The VkPhysicalDeviceAccelerationStructureFeaturesKHR::accelerationStructureHostCommands feature must be enabled\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (!enabled_features.accelerationStructureHostCommands) {\n    skip |= LogError(\"VUID-vkBuildAccelerationStructuresKHR-accelerationStructureHostCommands-03581\", device,\n                     error_obj.location, \"accelerationStructureHostCommands feature was not enabled.\");\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-vkBuildAccelerationStructuresKHR-pInfos-03725\", \"If pInfos[i].mode is VK_BUILD_ACCELERATION_STRUCTURE_MODE_BUILD_KHR, all addresses between pInfos[i].scratchData.hostAddress and pInfos[i].scratchData.hostAddress + N - 1 must be valid host memory, where N is given by the buildScratchSize member of the VkAccelerationStructureBuildSizesInfoKHR structure returned from a call to vkGetAccelerationStructureBuildSizesKHR with an identical VkAccelerationStructureBuildGeometryInfoKHR structure and primitive count\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (info->scratchData.hostAddress == nullptr) {\n    skip |= LogError(\"VUID-vkBuildAccelerationStructuresKHR-pInfos-03725\", device,\n                     info_loc.dot(Field::scratchData).dot(Field::hostAddress), \"is NULL.\");\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-vkBuildAccelerationStructuresKHR-pInfos-03726\", \"If pInfos[i].mode is VK_BUILD_ACCELERATION_STRUCTURE_MODE_UPDATE_KHR, all addresses between pInfos[i].scratchData.hostAddress and pInfos[i].scratchData.hostAddress + N - 1 must be valid host memory, where N is given by the updateScratchSize member of the VkAccelerationStructureBuildSizesInfoKHR structure returned from a call to vkGetAccelerationStructureBuildSizesKHR with an identical VkAccelerationStructureBuildGeometryInfoKHR structure and primitive count\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (info->scratchData.hostAddress == nullptr) {\n    skip |= LogError(\"VUID-vkBuildAccelerationStructuresKHR-pInfos-03726\", device,\n                     info_loc.dot(Field::scratchData).dot(Field::hostAddress), \"is NULL.\");\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-vkBuildAccelerationStructuresKHR-pInfos-04630\", \"For each element of pInfos, if its mode member is VK_BUILD_ACCELERATION_STRUCTURE_MODE_UPDATE_KHR, its srcAccelerationStructure member must not be VK_NULL_HANDLE\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (info->srcAccelerationStructure == VK_NULL_HANDLE) {\n    skip |= LogError(\"VUID-vkBuildAccelerationStructuresKHR-pInfos-04630\", device, info_loc.dot(Field::mode),\n                     \"is VK_BUILD_ACCELERATION_STRUCTURE_MODE_UPDATE_KHR, but %s is VK_NULL_HANDLE.\",\n                     info_loc.dot(Field::srcAccelerationStructure).Fields().c_str());\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-vkBuildAccelerationStructuresKHR-pInfos-03774\", \"For any element of pInfos[i].pGeometries or pInfos[i].ppGeometries with a geometryType of VK_GEOMETRY_TYPE_AABBS_KHR, geometry.aabbs.data.hostAddress must be a valid host address\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (geom.geometry.aabbs.data.hostAddress == nullptr) {\n    skip |= LogError(\"VUID-vkBuildAccelerationStructuresKHR-pInfos-03774\", device,\n                     info_loc.dot(Field::aabbs).dot(Field::data).dot(Field::hostAddress), \"is NULL.\");\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-vkBuildAccelerationStructuresKHR-pInfos-03778\", \"For any element of pInfos[i].pGeometries or pInfos[i].ppGeometries with a geometryType of VK_GEOMETRY_TYPE_INSTANCES_KHR, geometry.instances.data.hostAddress must be a valid host address\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (geom.geometry.instances.data.hostAddress == nullptr) {\n    skip |= LogError(\"VUID-vkBuildAccelerationStructuresKHR-pInfos-03778\", device,\n                     info_loc.dot(Field::instances).dot(Field::data).dot(Field::hostAddress), \"is NULL.\");\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-vkBuildAccelerationStructuresKHR-dstAccelerationStructure-03698\", \"The dstAccelerationStructure member of any element of pInfos must not be the same acceleration structure as the dstAccelerationStructure member of any other element of pInfos\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (info->dstAccelerationStructure == pInfos[info_k].dstAccelerationStructure) {\n    skip |= LogError(\"VUID-vkBuildAccelerationStructuresKHR-dstAccelerationStructure-03698\", device,\n                     info_loc.dot(Field::dstAccelerationStructure),\n                     \"and pInfos[%\" PRIu32 \"].dstAccelerationStructure are both %s.\", info_k,\n                     FormatHandle(info->dstAccelerationStructure).c_str());\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-vkBuildAccelerationStructuresKHR-pInfos-03403\", \"The srcAccelerationStructure member of any element of pInfos must not be the same acceleration structure as the dstAccelerationStructure member of any other element of pInfos\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (info->srcAccelerationStructure == pInfos[info_k].dstAccelerationStructure) {\n    skip |= LogError(\"VUID-vkBuildAccelerationStructuresKHR-pInfos-03403\", device,\n                     info_loc.dot(Field::srcAccelerationStructure),\n                     \"and pInfos[%\" PRIu32 \"].dstAccelerationStructure are both %s.\", info_k,\n                     FormatHandle(info->srcAccelerationStructure).c_str());\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-vkGetAccelerationStructureBuildSizesKHR-pBuildInfo-03619\", \"If pBuildInfo->geometryCount is not 0, pMaxPrimitiveCounts must be a valid pointer to an array of pBuildInfo->geometryCount uint32_t values\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (pBuildInfo->geometryCount != 0 && !pMaxPrimitiveCounts) {\n    skip |= LogError(\"VUID-vkGetAccelerationStructureBuildSizesKHR-pBuildInfo-03619\", device,\n                     error_obj.location.dot(Field::pBuildInfo).dot(Field::geometryCount),\n                     \"is %\" PRIu32 \", but pMaxPrimitiveCounts is NULL.\", pBuildInfo->geometryCount);\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-vkCmdTraceRaysKHR-width-03641\", \"width \u00d7 height \u00d7 depth must be less than or equal to VkPhysicalDeviceRayTracingPipelinePropertiesKHR::maxRayDispatchInvocationCount\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (width * depth * height > phys_dev_ext_props.ray_tracing_props_khr.maxRayDispatchInvocationCount) {\n    skip |= LogError(\"VUID-vkCmdTraceRaysKHR-width-03641\", commandBuffer, error_obj.location,\n                     \"width x height x depth (%\" PRIu32 \" x %\" PRIu32 \" x %\" PRIu32\n                     \") must be less than or equal to \"\n                     \"VkPhysicalDeviceRayTracingPipelinePropertiesKHR::maxRayDispatchInvocationCount (%\" PRIu32 \").\",\n                     width, depth, height, phys_dev_ext_props.ray_tracing_props_khr.maxRayDispatchInvocationCount);\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-vkCmdTraceRaysKHR-width-03638\", \"width must be less than or equal to VkPhysicalDeviceLimits::maxComputeWorkGroupCount[0] \u00d7 VkPhysicalDeviceLimits::maxComputeWorkGroupSize[0]\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (width > device_limits.maxComputeWorkGroupCount[0] * device_limits.maxComputeWorkGroupSize[0]) {\n    skip |= LogError(\"VUID-vkCmdTraceRaysKHR-width-03638\", commandBuffer, error_obj.location.dot(Field::width),\n                     \"(%\" PRIu32\n                     \") must be less than or equal to VkPhysicalDeviceLimits::maxComputeWorkGroupCount[0] \"\n                     \"x VkPhysicalDeviceLimits::maxComputeWorkGroupSize[0] (%\" PRIu32 \" x %\" PRIu32 \").\",\n                     width, device_limits.maxComputeWorkGroupCount[0], device_limits.maxComputeWorkGroupSize[0]);\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-vkCmdTraceRaysKHR-height-03639\", \"height must be less than or equal to VkPhysicalDeviceLimits::maxComputeWorkGroupCount[1] \u00d7 VkPhysicalDeviceLimits::maxComputeWorkGroupSize[1]\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (height > device_limits.maxComputeWorkGroupCount[1] * device_limits.maxComputeWorkGroupSize[1]) {\n    skip |= LogError(\"VUID-vkCmdTraceRaysKHR-height-03639\", commandBuffer, error_obj.location.dot(Field::height),\n                     \"(%\" PRIu32\n                     \") must be less than or equal to VkPhysicalDeviceLimits::maxComputeWorkGroupCount[1] \"\n                     \"x VkPhysicalDeviceLimits::maxComputeWorkGroupSize[1] (%\" PRIu32 \" x %\" PRIu32 \").\",\n                     height, device_limits.maxComputeWorkGroupCount[1], device_limits.maxComputeWorkGroupSize[1]);\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-vkCmdTraceRaysIndirectKHR-rayTracingPipelineTraceRaysIndirect-03637\", \"The rayTracingPipelineTraceRaysIndirect feature must be enabled\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (!enabled_features.rayTracingPipelineTraceRaysIndirect) {\n    skip |= LogError(\"VUID-vkCmdTraceRaysIndirectKHR-rayTracingPipelineTraceRaysIndirect-03637\", commandBuffer,\n                     error_obj.location, \"rayTracingPipelineTraceRaysIndirect feature must be enabled.\");\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-vkCmdTraceRaysIndirectKHR-indirectDeviceAddress-03634\", \"indirectDeviceAddress must be a multiple of 4\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (SafeModulo(indirectDeviceAddress, 4) != 0) {\n    skip |= LogError(\"VUID-vkCmdTraceRaysIndirectKHR-indirectDeviceAddress-03634\", commandBuffer,\n                     error_obj.location.dot(Field::indirectDeviceAddress), \"(%\" PRIu64 \") must be a multiple of 4.\",\n                     indirectDeviceAddress);\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-vkCmdTraceRaysIndirect2KHR-rayTracingPipelineTraceRaysIndirect2-03637\", \"The rayTracingPipelineTraceRaysIndirect2 feature must be enabled\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (!enabled_features.rayTracingPipelineTraceRaysIndirect2) {\n    skip |= LogError(\"VUID-vkCmdTraceRaysIndirect2KHR-rayTracingPipelineTraceRaysIndirect2-03637\", commandBuffer,\n                     error_obj.location, \"rayTracingPipelineTraceRaysIndirect2 feature was not enabled.\");\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-vkCmdTraceRaysIndirect2KHR-indirectDeviceAddress-03634\", \"indirectDeviceAddress must be a multiple of 4\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (SafeModulo(indirectDeviceAddress, 4) != 0) {\n    skip |= LogError(\"VUID-vkCmdTraceRaysIndirect2KHR-indirectDeviceAddress-03634\", commandBuffer,\n                     error_obj.location.dot(Field::indirectDeviceAddress), \"(%\" PRIu64 \") must be a multiple of 4.\",\n                     indirectDeviceAddress);\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkAttachmentDescriptionStencilLayout-stencilInitialLayout-03308\", \"stencilInitialLayout must not be VK_IMAGE_LAYOUT_COLOR_ATTACHMENT_OPTIMAL, VK_IMAGE_LAYOUT_DEPTH_ATTACHMENT_OPTIMAL, VK_IMAGE_LAYOUT_DEPTH_READ_ONLY_OPTIMAL, VK_IMAGE_LAYOUT_DEPTH_STENCIL_ATTACHMENT_OPTIMAL, VK_IMAGE_LAYOUT_DEPTH_STENCIL_READ_ONLY_OPTIMAL, VK_IMAGE_LAYOUT_DEPTH_ATTACHMENT_STENCIL_READ_ONLY_OPTIMAL, or VK_IMAGE_LAYOUT_DEPTH_READ_ONLY_STENCIL_ATTACHMENT_OPTIMAL\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "skip |= LogError(\"VUID-VkAttachmentDescriptionStencilLayout-stencilInitialLayout-03308\", device,\n                 attachment_loc.pNext(Struct::VkAttachmentDescriptionStencilLayout, Field::stencilInitialLayout),\n                 \"is %s.\", string_VkImageLayout(stencil_initial_layout));\n"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkAttachmentDescriptionStencilLayout-stencilFinalLayout-03309\", \"stencilFinalLayout must not be VK_IMAGE_LAYOUT_COLOR_ATTACHMENT_OPTIMAL, VK_IMAGE_LAYOUT_DEPTH_ATTACHMENT_OPTIMAL, VK_IMAGE_LAYOUT_DEPTH_READ_ONLY_OPTIMAL, VK_IMAGE_LAYOUT_DEPTH_STENCIL_ATTACHMENT_OPTIMAL, VK_IMAGE_LAYOUT_DEPTH_STENCIL_READ_ONLY_OPTIMAL, VK_IMAGE_LAYOUT_DEPTH_ATTACHMENT_STENCIL_READ_ONLY_OPTIMAL, or VK_IMAGE_LAYOUT_DEPTH_READ_ONLY_STENCIL_ATTACHMENT_OPTIMAL\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "skip |= LogError(\"VUID-VkAttachmentDescriptionStencilLayout-stencilFinalLayout-03309\", device,\n                 attachment_loc.pNext(Struct::VkAttachmentDescriptionStencilLayout, Field::stencilFinalLayout),\n                 \"is %s.\", string_VkImageLayout(stencil_final_layout));\n"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkAttachmentDescriptionStencilLayout-stencilFinalLayout-03310\", \"stencilFinalLayout must not be VK_IMAGE_LAYOUT_UNDEFINED or VK_IMAGE_LAYOUT_PREINITIALIZED\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (stencil_final_layout == VK_IMAGE_LAYOUT_UNDEFINED || stencil_final_layout == VK_IMAGE_LAYOUT_PREINITIALIZED) {\n    skip |= LogError(\"VUID-VkAttachmentDescriptionStencilLayout-stencilFinalLayout-03310\", device,\n                     attachment_loc.pNext(Struct::VkAttachmentDescriptionStencilLayout, Field::stencilFinalLayout),\n                     \"is %s.\", string_VkImageLayout(stencil_final_layout));\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkRenderPassStripeBeginInfoARM-stripeInfoCount-09450\", \"stripeInfoCount must be less than or equal to VkPhysicalDeviceRenderPassStripedPropertiesARM::maxRenderPassStripes\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (rp_stripe_begin->stripeInfoCount > phys_dev_ext_props.renderpass_striped_props.maxRenderPassStripes) {\n    skip |= LogError(\"VUID-VkRenderPassStripeBeginInfoARM-stripeInfoCount-09450\", commandBuffer,\n                     loc.pNext(Struct::VkRenderPassStripeBeginInfoARM, Field::stripeInfoCount),\n                     \"= %\" PRIu32 \" is greater than maxRenderPassStripes (%\" PRIu32 \").\", rp_stripe_begin->stripeInfoCount,\n                     phys_dev_ext_props.renderpass_striped_props.maxRenderPassStripes);\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkRenderPassStripeInfoARM-stripeArea-09452\", \"stripeArea.offset.x must be a multiple of VkPhysicalDeviceRenderPassStripedPropertiesARM::renderPassStripeGranularity.width\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (width_granularity > 0 && (stripe_area.offset.x % width_granularity) != 0) {\n    skip |= LogError(\"VUID-VkRenderPassStripeInfoARM-stripeArea-09452\", commandBuffer,\n                     stripe_info_loc.dot(Field::stripeArea).dot(Field::offset).dot(Field::x),\n                     \"= %\" PRIu32 \" is not multiple of %\" PRIu32 \". \", stripe_area.offset.x, width_granularity);\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkRenderPassStripeInfoARM-stripeArea-09453\", \"stripeArea.extent.width must be a multiple of VkPhysicalDeviceRenderPassStripedPropertiesARM::renderPassStripeGranularity.width, or the sum of stripeArea.offset.x and stripeArea.extent.width must be equal to the renderArea.extent.width of the render pass instance\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (width_granularity > 0 && (stripe_area.extent.width % width_granularity) != 0 &&\n    skip |= LogError(\"VUID-VkRenderPassStripeInfoARM-stripeArea-09453\", commandBuffer,\n                     stripe_info_loc.dot(Field::stripeArea).dot(Field::extent).dot(Field::width),\n                     \"= %\" PRIu32 \" is not multiple of %\" PRIu32\n                     \", or when added to the stripeArea.offset.x is not equal render area width (%\" PRIu32 \")\",\n                     stripe_area.extent.width, width_granularity, render_area.extent.width);\n"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkRenderPassStripeInfoARM-stripeArea-09454\", \"stripeArea.offset.y must be a multiple of VkPhysicalDeviceRenderPassStripedPropertiesARM::renderPassStripeGranularity.height\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (height_granularity > 0 && (stripe_area.offset.y % height_granularity) != 0) {\n    skip |= LogError(\"VUID-VkRenderPassStripeInfoARM-stripeArea-09454\", commandBuffer,\n                     stripe_info_loc.dot(Field::stripeArea).dot(Field::offset).dot(Field::y),\n                     \"= %\" PRIu32 \") is not multiple of %\" PRIu32 \". \", stripe_area.offset.y, height_granularity);\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkRenderPassStripeInfoARM-stripeArea-09455\", \"stripeArea.extent.height must be a multiple of VkPhysicalDeviceRenderPassStripedPropertiesARM::renderPassStripeGranularity.height, or the sum of stripeArea.offset.y and stripeArea.extent.height must be equal to the renderArea.extent.height of the render pass instance\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (height_granularity > 0 && (stripe_area.extent.height % height_granularity) != 0 &&\n    skip |= LogError(\"VUID-VkRenderPassStripeInfoARM-stripeArea-09455\", commandBuffer,\n                     stripe_info_loc.dot(Field::stripeArea).dot(Field::extent).dot(Field::height),\n                     \"= %\" PRIu32 \" is not multiple of %\" PRIu32\n                     \", or when added to the stripeArea.offset.y is not equal to render area height (%\" PRIu32 \")\",\n                     stripe_area.extent.height, height_granularity, render_area.extent.height);\n"
        },
        {
            "role": "user",
            "content": "{\"VUID-vkCmdBeginRendering-dynamicRendering-06446\", \"The dynamicRendering feature must be enabled\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (!enabled_features.dynamicRendering) {\n    skip |= LogError(\"VUID-vkCmdBeginRendering-dynamicRendering-06446\", commandBuffer, error_obj.location,\n                     \"dynamicRendering is not enabled.\");\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkRenderingInfo-viewMask-06069\", \"If viewMask is 0, layerCount must not be 0\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (pRenderingInfo->viewMask == 0 && pRenderingInfo->layerCount == 0) {\n    skip |= LogError(\"VUID-VkRenderingInfo-viewMask-06069\", commandBuffer, rendering_info_loc,\n                     \"viewMask and layerCount are both zero\");\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkRenderingInfo-colorAttachmentCount-06106\", \"colorAttachmentCount must be less than or equal to VkPhysicalDeviceLimits::maxColorAttachments\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (pRenderingInfo->colorAttachmentCount > device_limits.maxColorAttachments) {\n    skip |= LogError(\"VUID-VkRenderingInfo-colorAttachmentCount-06106\", commandBuffer,\n                     rendering_info_loc.dot(Field::colorAttachmentCount),\n                     \"(%\" PRIu32\n                     \") must be less than or equal to \"\n                     \"maxColorAttachments (%\" PRIu32 \").\",\n                     pRenderingInfo->colorAttachmentCount, device_limits.maxColorAttachments);\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkRenderingInfo-flags-10012\", \"If flags includes VK_RENDERING_CONTENTS_INLINE_BIT_KHR then at least one of the following features must be enabled maintenance7 nestedCommandBuffer\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if ((pRenderingInfo->flags & VK_RENDERING_CONTENTS_INLINE_BIT_EXT) != 0 && !enabled_features.nestedCommandBuffer &&\n    skip |= LogError(\"VUID-VkRenderingInfo-flags-10012\", commandBuffer, rendering_info_loc.dot(Field::flags),\n                     \"are %s, but nestedCommandBuffer and maintenance7 feature were not enabled.\",\n                     string_VkRenderingFlags(pRenderingInfo->flags).c_str());\n"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkRenderingInfo-multiview-06127\", \"If the multiview feature is not enabled, viewMask must be 0\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (!enabled_features.multiview && (pRenderingInfo->viewMask != 0)) {\n    skip |= LogError(\"VUID-VkRenderingInfo-multiview-06127\", commandBuffer, rendering_info_loc.dot(Field::viewMask),\n                     \"%\" PRId32 \" but the multiview feature is not enabled.\", pRenderingInfo->viewMask);\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkRenderingInfo-imageView-06116\", \"If the imageView member of a VkRenderingFragmentDensityMapAttachmentInfoEXT structure included in the pNext chain is not VK_NULL_HANDLE, it must not be equal to the imageView or resolveImageView member of pDepthAttachment, pStencilAttachment, or any element of pColorAttachments\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (UniqueRenderingInfoImageViews(*pRenderingInfo, fragment_density_map_attachment_info->imageView) == false) {\n    skip |= LogError(\"VUID-VkRenderingInfo-imageView-06116\", commandBuffer,\n                     rendering_info_loc.pNext(Struct::VkRenderingFragmentDensityMapAttachmentInfoEXT, Field::imageView),\n                     \"is %s.\", FormatHandle(fragment_density_map_attachment_info->imageView).c_str());\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkRenderingFragmentDensityMapAttachmentInfoEXT-imageView-06157\", \"If imageView is not VK_NULL_HANDLE, imageLayout must be VK_IMAGE_LAYOUT_GENERAL or VK_IMAGE_LAYOUT_FRAGMENT_DENSITY_MAP_OPTIMAL_EXT\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (fragment_density_map_attachment_info->imageLayout != VK_IMAGE_LAYOUT_GENERAL &&\n    skip |= LogError(\"VUID-VkRenderingFragmentDensityMapAttachmentInfoEXT-imageView-06157\", commandBuffer,\n                     rendering_info_loc.pNext(Struct::VkRenderingFragmentDensityMapAttachmentInfoEXT, Field::imageView),\n                     \"is %s, but \"\n                     \"VkRenderingFragmentDensityMapAttachmentInfoEXT::imageLayout is %s.\",\n                     FormatHandle(fragment_density_map_attachment_info->imageView).c_str(),\n                     string_VkImageLayout(fragment_density_map_attachment_info->imageLayout));\n"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkRenderingInfo-imageView-06126\", \"If the imageView member of a VkRenderingFragmentShadingRateAttachmentInfoKHR structure included in the pNext chain is not VK_NULL_HANDLE, it must not be equal to the imageView member of a VkRenderingFragmentDensityMapAttachmentInfoEXT structure included in the pNext chain\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (rendering_fsr_attachment_info &&\n    (rendering_fsr_attachment_info->imageView == fragment_density_map_attachment_info->imageView)) {\n    skip |= LogError(\"VUID-VkRenderingInfo-imageView-06126\", commandBuffer,\n                     rendering_info_loc.pNext(Struct::VkRenderingFragmentDensityMapAttachmentInfoEXT, Field::imageView),\n                     \"and VkRenderingFragmentShadingRateAttachmentInfoKHR::imageView are the same (%s).\",\n                     FormatHandle(fragment_density_map_attachment_info->imageView).c_str());\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkRenderingInfo-colorAttachmentCount-06091\", \"If colorAttachmentCount is not 0 and the imageView member of an element of pColorAttachments is not VK_NULL_HANDLE, if the resolveMode member of that element of pColorAttachments is not VK_RESOLVE_MODE_NONE, its resolveImageLayout member must not be VK_IMAGE_LAYOUT_DEPTH_STENCIL_ATTACHMENT_OPTIMAL or VK_IMAGE_LAYOUT_DEPTH_STENCIL_READ_ONLY_OPTIMAL\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (resolve_image_layout == VK_IMAGE_LAYOUT_DEPTH_STENCIL_ATTACHMENT_OPTIMAL ||\n    skip |= LogError(\"VUID-VkRenderingInfo-colorAttachmentCount-06091\", commandBuffer,\n                     attachment_loc.dot(Field::resolveImageLayout), \"is %s and resolve_mode is %s.\",\n                     string_VkImageLayout(resolve_image_layout), string_VkResolveModeFlagBits(resolve_mode));\n"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkRenderingInfo-colorAttachmentCount-06096\", \"If colorAttachmentCount is not 0 and the imageView member of an element of pColorAttachments is not VK_NULL_HANDLE, the layout member of that element of pColorAttachments must not be VK_IMAGE_LAYOUT_DEPTH_READ_ONLY_STENCIL_ATTACHMENT_OPTIMAL or VK_IMAGE_LAYOUT_DEPTH_ATTACHMENT_STENCIL_READ_ONLY_OPTIMAL\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (image_layout == VK_IMAGE_LAYOUT_DEPTH_READ_ONLY_STENCIL_ATTACHMENT_OPTIMAL ||\n    skip |= LogError(\"VUID-VkRenderingInfo-colorAttachmentCount-06096\", commandBuffer,\n                     attachment_loc.dot(Field::imageLayout), \"is %s.\", string_VkImageLayout(image_layout));\n"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkRenderingInfo-colorAttachmentCount-06097\", \"If colorAttachmentCount is not 0 and the imageView member of an element of pColorAttachments is not VK_NULL_HANDLE, if the resolveMode member of that element of pColorAttachments is not VK_RESOLVE_MODE_NONE, its resolveImageLayout member must not be VK_IMAGE_LAYOUT_DEPTH_READ_ONLY_STENCIL_ATTACHMENT_OPTIMAL or VK_IMAGE_LAYOUT_DEPTH_ATTACHMENT_STENCIL_READ_ONLY_OPTIMAL\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (resolve_image_layout == VK_IMAGE_LAYOUT_DEPTH_READ_ONLY_STENCIL_ATTACHMENT_OPTIMAL ||\n    skip |= LogError(\"VUID-VkRenderingInfo-colorAttachmentCount-06097\", commandBuffer,\n                     attachment_loc.dot(Field::resolveImageLayout), \"is %s and resolve_mode is %s.\",\n                     string_VkImageLayout(resolve_image_layout), string_VkResolveModeFlagBits(resolve_mode));\n"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkRenderingInfo-colorAttachmentCount-06100\", \"If colorAttachmentCount is not 0 and the imageView member of an element of pColorAttachments is not VK_NULL_HANDLE, the layout member of that element of pColorAttachments must not be VK_IMAGE_LAYOUT_DEPTH_ATTACHMENT_OPTIMAL, VK_IMAGE_LAYOUT_DEPTH_READ_ONLY_OPTIMAL, VK_IMAGE_LAYOUT_STENCIL_ATTACHMENT_OPTIMAL, or VK_IMAGE_LAYOUT_STENCIL_READ_ONLY_OPTIMAL\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (IsImageLayoutDepthOnly(image_layout) || IsImageLayoutStencilOnly(image_layout)) {\n    skip |= LogError(\"VUID-VkRenderingInfo-colorAttachmentCount-06100\", commandBuffer,\n                     attachment_loc.dot(Field::imageLayout), \"is %s.\", string_VkImageLayout(image_layout));\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkRenderingInfo-pDepthAttachment-06092\", \"If pDepthAttachment is not NULL and pDepthAttachment->imageView is not VK_NULL_HANDLE, pDepthAttachment->layout must not be VK_IMAGE_LAYOUT_COLOR_ATTACHMENT_OPTIMAL\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (layout == VK_IMAGE_LAYOUT_COLOR_ATTACHMENT_OPTIMAL) {\n    skip |= LogError(\"VUID-VkRenderingInfo-pDepthAttachment-06092\", commandBuffer, attachment_loc.dot(Field::imageLayout),\n                     \"is VK_IMAGE_LAYOUT_COLOR_ATTACHMENT_OPTIMAL.\");\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkRenderingInfo-pDepthAttachment-07732\", \"If pDepthAttachment is not NULL and pDepthAttachment->imageView is not VK_NULL_HANDLE, pDepthAttachment->layout must not be VK_IMAGE_LAYOUT_STENCIL_ATTACHMENT_OPTIMAL or VK_IMAGE_LAYOUT_STENCIL_READ_ONLY_OPTIMAL\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "skip |= LogError(\"VUID-VkRenderingInfo-pDepthAttachment-06092\", commandBuffer, attachment_loc.dot(Field::imageLayout),\nskip |= LogError(\"VUID-VkRenderingInfo-pDepthAttachment-07732\", commandBuffer, attachment_loc.dot(Field::imageLayout),\n                 \"is %s.\", string_VkImageLayout(layout));\n"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkRenderingInfo-pDepthAttachment-06093\", \"If pDepthAttachment is not NULL, pDepthAttachment->imageView is not VK_NULL_HANDLE, and pDepthAttachment->resolveMode is not VK_RESOLVE_MODE_NONE, pDepthAttachment->resolveImageLayout must not be VK_IMAGE_LAYOUT_COLOR_ATTACHMENT_OPTIMAL\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (resolve_layout == VK_IMAGE_LAYOUT_COLOR_ATTACHMENT_OPTIMAL) {\n    skip |= LogError(\"VUID-VkRenderingInfo-pDepthAttachment-06093\", commandBuffer,\n                     attachment_loc.dot(Field::resolveImageLayout),\n                     \"is VK_IMAGE_LAYOUT_COLOR_ATTACHMENT_OPTIMAL and resolve_mode is %s.\",\n                     string_VkResolveModeFlagBits(pRenderingInfo->pDepthAttachment->resolveMode));\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkRenderingInfo-pDepthAttachment-07733\", \"If pDepthAttachment is not NULL, pDepthAttachment->imageView is not VK_NULL_HANDLE, and pDepthAttachment->resolveMode is not VK_RESOLVE_MODE_NONE, pDepthAttachment->resolveImageLayout must not be VK_IMAGE_LAYOUT_STENCIL_ATTACHMENT_OPTIMAL or VK_IMAGE_LAYOUT_STENCIL_READ_ONLY_OPTIMAL\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "string_VkResolveModeFlagBits(pRenderingInfo->pDepthAttachment->resolveMode));\nskip |= LogError(\"VUID-VkRenderingInfo-pDepthAttachment-07733\", commandBuffer,\nattachment_loc.dot(Field::resolveImageLayout), \"is %s and resolve_mode is %s.\",\nstring_VkImageLayout(resolve_layout),\nstring_VkResolveModeFlagBits(pRenderingInfo->pDepthAttachment->resolveMode));\n"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkRenderingInfo-pStencilAttachment-06094\", \"If pStencilAttachment is not NULL and pStencilAttachment->imageView is not VK_NULL_HANDLE, pStencilAttachment->layout must not be VK_IMAGE_LAYOUT_COLOR_ATTACHMENT_OPTIMAL\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (layout == VK_IMAGE_LAYOUT_COLOR_ATTACHMENT_OPTIMAL) {\n    skip |= LogError(\"VUID-VkRenderingInfo-pStencilAttachment-06094\", commandBuffer, attachment_loc.dot(Field::imageLayout),\n                     \"is VK_IMAGE_LAYOUT_COLOR_ATTACHMENT_OPTIMAL.\");\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkRenderingInfo-pStencilAttachment-07734\", \"If pStencilAttachment is not NULL and pStencilAttachment->imageView is not VK_NULL_HANDLE, pStencilAttachment->layout must not be VK_IMAGE_LAYOUT_DEPTH_ATTACHMENT_OPTIMAL or VK_IMAGE_LAYOUT_DEPTH_READ_ONLY_OPTIMAL\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "skip |= LogError(\"VUID-VkRenderingInfo-pStencilAttachment-06094\", commandBuffer, attachment_loc.dot(Field::imageLayout),\nskip |= LogError(\"VUID-VkRenderingInfo-pStencilAttachment-07734\", commandBuffer, attachment_loc.dot(Field::imageLayout),\n                 \"is %s.\", string_VkImageLayout(layout));\n"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkRenderingInfo-pStencilAttachment-06095\", \"If pStencilAttachment is not NULL, pStencilAttachment->imageView is not VK_NULL_HANDLE, and pStencilAttachment->resolveMode is not VK_RESOLVE_MODE_NONE, pStencilAttachment->resolveImageLayout must not be VK_IMAGE_LAYOUT_COLOR_ATTACHMENT_OPTIMAL\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (resolve_layout == VK_IMAGE_LAYOUT_COLOR_ATTACHMENT_OPTIMAL) {\n    skip |= LogError(\"VUID-VkRenderingInfo-pStencilAttachment-06095\", commandBuffer,\n                     attachment_loc.dot(Field::resolveImageLayout),\n                     \"is VK_IMAGE_LAYOUT_COLOR_ATTACHMENT_OPTIMAL and resolve_mode is %s.\",\n                     string_VkResolveModeFlagBits(pRenderingInfo->pStencilAttachment->resolveMode));\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkRenderingInfo-pStencilAttachment-07735\", \"If pStencilAttachment is not NULL, pStencilAttachment->imageView is not VK_NULL_HANDLE, and pStencilAttachment->resolveMode is not VK_RESOLVE_MODE_NONE, pStencilAttachment->resolveImageLayout must not be VK_IMAGE_LAYOUT_DEPTH_ATTACHMENT_OPTIMAL or VK_IMAGE_LAYOUT_DEPTH_READ_ONLY_OPTIMAL\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "string_VkResolveModeFlagBits(pRenderingInfo->pStencilAttachment->resolveMode));\nskip |= LogError(\"VUID-VkRenderingInfo-pStencilAttachment-07735\", commandBuffer,\nattachment_loc.dot(Field::resolveImageLayout), \"is %s and resolve_mode is %s.\",\nstring_VkImageLayout(resolve_layout),\nstring_VkResolveModeFlagBits(pRenderingInfo->pStencilAttachment->resolveMode));\n"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkRenderingInfo-imageView-06125\", \"If the imageView member of a VkRenderingFragmentShadingRateAttachmentInfoKHR structure included in the pNext chain is not VK_NULL_HANDLE, it must not be equal to the imageView or resolveImageView member of pDepthAttachment, pStencilAttachment, or any element of pColorAttachments\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (UniqueRenderingInfoImageViews(rendering_info, rendering_fsr_attachment_info.imageView) == false) {\n    skip |= LogError(\"VUID-VkRenderingInfo-imageView-06125\", commandBuffer,\n                     rendering_info_loc.pNext(Struct::VkRenderingFragmentShadingRateAttachmentInfoKHR, Field::imageView),\n                     \"is %s.\", FormatHandle(rendering_fsr_attachment_info.imageView).c_str());\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkRenderingFragmentShadingRateAttachmentInfoKHR-imageView-06147\", \"If imageView is not VK_NULL_HANDLE, layout must be VK_IMAGE_LAYOUT_GENERAL or VK_IMAGE_LAYOUT_FRAGMENT_SHADING_RATE_ATTACHMENT_OPTIMAL_KHR\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (image_layout != VK_IMAGE_LAYOUT_GENERAL && image_layout != VK_IMAGE_LAYOUT_FRAGMENT_SHADING_RATE_ATTACHMENT_OPTIMAL_KHR) {\n    skip |= LogError(\"VUID-VkRenderingFragmentShadingRateAttachmentInfoKHR-imageView-06147\", commandBuffer,\n                     rendering_info_loc.pNext(Struct::VkRenderingFragmentShadingRateAttachmentInfoKHR, Field::layout),\n                     \"is (%s).\", string_VkImageLayout(image_layout));\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkRenderingFragmentShadingRateAttachmentInfoKHR-imageView-06155\", \"If imageView is not VK_NULL_HANDLE, the quotient of shadingRateAttachmentTexelSize.width and shadingRateAttachmentTexelSize.height must be less than or equal to maxFragmentShadingRateAttachmentTexelSizeAspectRatio\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if ((rendering_fsr_attachment_info.shadingRateAttachmentTexelSize.width /\n    skip |= LogError(\"VUID-VkRenderingFragmentShadingRateAttachmentInfoKHR-imageView-06155\", commandBuffer,\n                     rendering_info_loc.pNext(Struct::VkRenderingFragmentShadingRateAttachmentInfoKHR,\n                                              Field::shadingRateAttachmentTexelSize),\n                     \"the quotient of width (%\" PRIu32 \") and height (%\" PRIu32\n                     \") \"\n                     \"must be less than or equal to maxFragmentShadingRateAttachmentTexelSizeAspectRatio (%\" PRIu32 \").\",\n                     rendering_fsr_attachment_info.shadingRateAttachmentTexelSize.width,\n                     rendering_fsr_attachment_info.shadingRateAttachmentTexelSize.height, max_frs_attach_texel_aspect_ratio);\n"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkRenderingFragmentShadingRateAttachmentInfoKHR-imageView-06156\", \"If imageView is not VK_NULL_HANDLE, the quotient of shadingRateAttachmentTexelSize.height and shadingRateAttachmentTexelSize.width must be less than or equal to maxFragmentShadingRateAttachmentTexelSizeAspectRatio\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if ((rendering_fsr_attachment_info.shadingRateAttachmentTexelSize.height /\n    skip |= LogError(\"VUID-VkRenderingFragmentShadingRateAttachmentInfoKHR-imageView-06156\", commandBuffer,\n                     rendering_info_loc.pNext(Struct::VkRenderingFragmentShadingRateAttachmentInfoKHR,\n                                              Field::shadingRateAttachmentTexelSize),\n                     \"the quotient of height (%\" PRIu32 \") and width (%\" PRIu32\n                     \") \"\n                     \"must be less than or equal to maxFragmentShadingRateAttachmentTexelSizeAspectRatio (%\" PRIu32 \").\",\n                     rendering_fsr_attachment_info.shadingRateAttachmentTexelSize.height,\n                     rendering_fsr_attachment_info.shadingRateAttachmentTexelSize.width, max_frs_attach_texel_aspect_ratio);\n"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkShaderCreateInfoEXT-pCode-08492\", \"If codeType is VK_SHADER_CODE_TYPE_BINARY_EXT, pCode must be aligned to 16 bytes\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (SafeModulo(pCode, 16 * sizeof(unsigned char)) != 0) {\n    skip |= LogError(\"VUID-VkShaderCreateInfoEXT-pCode-08492\", device, create_info_loc.dot(Field::codeType),\n                     \"is VK_SHADER_CODE_TYPE_BINARY_EXT, but pCodde is not aligned to 16 bytes.\");\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkShaderCreateInfoEXT-pCode-08493\", \"If codeType is VK_SHADER_CODE_TYPE_SPIRV_EXT, pCode must be aligned to 4 bytes\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (SafeModulo(pCode, 4 * sizeof(unsigned char)) != 0) {\n    skip |= LogError(\"VUID-VkShaderCreateInfoEXT-pCode-08493\", device, create_info_loc.dot(Field::codeType),\n                     \"is VK_SHADER_CODE_TYPE_SPIRV_EXT, but pCodde is not aligned to 4 bytes.\");\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkShaderCreateInfoEXT-flags-08412\", \"If stage is not VK_SHADER_STAGE_TASK_BIT_EXT, VK_SHADER_STAGE_MESH_BIT_EXT, VK_SHADER_STAGE_VERTEX_BIT, VK_SHADER_STAGE_TESSELLATION_CONTROL_BIT, VK_SHADER_STAGE_TESSELLATION_EVALUATION_BIT, VK_SHADER_STAGE_GEOMETRY_BIT, or VK_SHADER_STAGE_FRAGMENT_BIT, flags must not include VK_SHADER_CREATE_LINK_STAGE_BIT_EXT\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if ((createInfo.stage & linkedStages) == 0 && (createInfo.flags & VK_SHADER_CREATE_LINK_STAGE_BIT_EXT) != 0) {\n    skip |= LogError(\"VUID-VkShaderCreateInfoEXT-flags-08412\", device, create_info_loc.dot(Field::flags),\n                     \"is %s and stage is %s.\", string_VkShaderCreateFlagsEXT(createInfo.flags).c_str(),\n                     string_VkShaderStageFlagBits(createInfo.stage));\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkShaderCreateInfoEXT-flags-08485\", \"If stage is not VK_SHADER_STAGE_COMPUTE_BIT, flags must not include VK_SHADER_CREATE_DISPATCH_BASE_BIT_EXT\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if ((createInfo.stage != VK_SHADER_STAGE_COMPUTE_BIT) &&\n    ((createInfo.flags & VK_SHADER_CREATE_DISPATCH_BASE_BIT_EXT) != 0)) {\n    skip |= LogError(\"VUID-VkShaderCreateInfoEXT-flags-08485\", device, create_info_loc.dot(Field::flags),\n                     \"is %s and stage is %s.\", string_VkShaderCreateFlagsEXT(createInfo.flags).c_str(),\n                     string_VkShaderStageFlagBits(createInfo.stage));\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkShaderCreateInfoEXT-flags-08488\", \"If stage is not VK_SHADER_STAGE_FRAGMENT_BIT, flags must not include VK_SHADER_CREATE_FRAGMENT_DENSITY_MAP_ATTACHMENT_BIT_EXT\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if ((createInfo.flags & VK_SHADER_CREATE_FRAGMENT_DENSITY_MAP_ATTACHMENT_BIT_EXT) != 0) {\n    skip |= LogError(\"VUID-VkShaderCreateInfoEXT-flags-08488\", device, create_info_loc.dot(Field::flags),\n                     \"is %s and stage is %s.\", string_VkShaderCreateFlagsEXT(createInfo.flags).c_str(),\n                     string_VkShaderStageFlagBits(createInfo.stage));\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkShaderCreateInfoEXT-flags-08414\", \"If stage is not VK_SHADER_STAGE_MESH_BIT_EXT, flags must not include VK_SHADER_CREATE_NO_TASK_SHADER_BIT_EXT\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (createInfo.stage != VK_SHADER_STAGE_MESH_BIT_EXT && (createInfo.flags & VK_SHADER_CREATE_NO_TASK_SHADER_BIT_EXT) != 0) {\n    skip |= LogError(\"VUID-VkShaderCreateInfoEXT-flags-08414\", device, create_info_loc.dot(Field::flags),\n                     \"is %s and stage is %s.\", string_VkShaderCreateFlagsEXT(createInfo.flags).c_str(),\n                     string_VkShaderStageFlagBits(createInfo.stage));\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkShaderCreateInfoEXT-nextStage-08427\", \"If stage is VK_SHADER_STAGE_VERTEX_BIT, nextStage must not include any bits other than VK_SHADER_STAGE_TESSELLATION_CONTROL_BIT, VK_SHADER_STAGE_GEOMETRY_BIT, and VK_SHADER_STAGE_FRAGMENT_BIT\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if ((createInfo.nextStage &\n    skip |= LogError(\"VUID-VkShaderCreateInfoEXT-nextStage-08427\", device, create_info_loc.dot(Field::stage),\n                     \"is VK_SHADER_STAGE_VERTEX_BIT, but nextStage is %s.\",\n                     string_VkShaderStageFlags(createInfo.nextStage).c_str());\n"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkShaderCreateInfoEXT-stage-08418\", \"stage must not be VK_SHADER_STAGE_ALL_GRAPHICS or VK_SHADER_STAGE_ALL\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "} else if (createInfo.stage == VK_SHADER_STAGE_ALL_GRAPHICS) {\n    skip |= LogError(\"VUID-VkShaderCreateInfoEXT-stage-08418\", device, create_info_loc.dot(Field::stage),\n                     \"is VK_SHADER_STAGE_ALL_GRAPHICS.\");\n"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkShaderCreateInfoEXT-stage-08425\", \"stage must not be VK_SHADER_STAGE_SUBPASS_SHADING_BIT_HUAWEI\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "skip |= LogError(\"VUID-VkShaderCreateInfoEXT-stage-08418\", device, create_info_loc.dot(Field::stage),\n} else if (createInfo.stage == VK_SHADER_STAGE_SUBPASS_SHADING_BIT_HUAWEI) {\nskip |= LogError(\"VUID-VkShaderCreateInfoEXT-stage-08425\", device, create_info_loc.dot(Field::stage),\n                 \"is VK_SHADER_STAGE_SUBPASS_SHADING_BIT_HUAWEI.\");\n"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkShaderCreateInfoEXT-stage-08426\", \"stage must not be VK_SHADER_STAGE_CLUSTER_CULLING_BIT_HUAWEI\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "skip |= LogError(\"VUID-VkShaderCreateInfoEXT-stage-08425\", device, create_info_loc.dot(Field::stage),\n} else if (createInfo.stage == VK_SHADER_STAGE_CLUSTER_CULLING_BIT_HUAWEI) {\nskip |= LogError(\"VUID-VkShaderCreateInfoEXT-stage-08426\", device, create_info_loc.dot(Field::stage),\n                 \"is VK_SHADER_STAGE_CLUSTER_CULLING_BIT_HUAWEI.\");\n"
        },
        {
            "role": "user",
            "content": "{\"VUID-vkGetShaderBinaryDataEXT-None-08499\", \"If pData is not NULL, it must be aligned to 16 bytes\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (SafeModulo(ptr, 16 * sizeof(unsigned char)) != 0) {\n    skip |= LogError(\"VUID-vkGetShaderBinaryDataEXT-None-08499\", device, error_obj.location.dot(Field::pData),\n                     \"is not aligned to 16 bytes.\");\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-vkAcquireNextImageKHR-semaphore-01780\", \"semaphore and fence must not both be equal to VK_NULL_HANDLE\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (semaphore == VK_NULL_HANDLE && fence == VK_NULL_HANDLE) {\n    skip |= LogError(\"VUID-vkAcquireNextImageKHR-semaphore-01780\", swapchain, error_obj.location,\n                     \"semaphore and fence are both VK_NULL_HANDLE.\");\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkSwapchainCreateInfoKHR-imageSharingMode-01278\", \"If imageSharingMode is VK_SHARING_MODE_CONCURRENT, queueFamilyIndexCount must be greater than 1\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (create_info.queueFamilyIndexCount <= 1) {\n    skip |= LogError(\"VUID-VkSwapchainCreateInfoKHR-imageSharingMode-01278\", device, loc.dot(Field::imageSharingMode),\n                     \"is VK_SHARING_MODE_CONCURRENT, but queueFamilyIndexCount is %\" PRIu32 \".\",\n                     create_info.queueFamilyIndexCount);\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkSwapchainCreateInfoKHR-imageSharingMode-01277\", \"If imageSharingMode is VK_SHARING_MODE_CONCURRENT, pQueueFamilyIndices must be a valid pointer to an array of queueFamilyIndexCount uint32_t values\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (create_info.pQueueFamilyIndices == nullptr) {\n    skip |= LogError(\"VUID-VkSwapchainCreateInfoKHR-imageSharingMode-01277\", device, loc.dot(Field::imageSharingMode),\n                     \"is VK_SHARING_MODE_CONCURRENT, but pQueueFamilyIndices is NULL.\");\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkSwapchainCreateInfoKHR-imageArrayLayers-01275\", \"imageArrayLayers must be greater than 0 and less than or equal to the maxImageArrayLayers member of the VkSurfaceCapabilitiesKHR structure returned by vkGetPhysicalDeviceSurfaceCapabilitiesKHR for the surface\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "skip |= ValidateNotZero(create_info.imageArrayLayers == 0, \"VUID-VkSwapchainCreateInfoKHR-imageArrayLayers-01275\",\n                        loc.dot(Field::imageArrayLayers));\n"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkSwapchainCreateInfoKHR-flags-04100\", \"If flags does not contain VK_SWAPCHAIN_CREATE_MUTABLE_FORMAT_BIT_KHR and the pNext chain include a VkImageFormatListCreateInfo structure then VkImageFormatListCreateInfo::viewFormatCount must be 0 or 1\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (((create_info.flags & VK_SWAPCHAIN_CREATE_MUTABLE_FORMAT_BIT_KHR) == 0) && (view_format_count > 1)) {\n    skip |= LogError(\"VUID-VkSwapchainCreateInfoKHR-flags-04100\", device,\n                     loc.pNext(Struct::VkImageFormatListCreateInfo, Field::viewFormatCount),\n                     \"is %\" PRIu32 \" but flag (%s) does not includes VK_SWAPCHAIN_CREATE_MUTABLE_FORMAT_BIT_KHR.\",\n                     view_format_count, string_VkImageCreateFlags(create_info.flags).c_str());\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkSwapchainCreateInfoKHR-flags-03168\", \"If flags contains VK_SWAPCHAIN_CREATE_MUTABLE_FORMAT_BIT_KHR then the pNext chain must include a VkImageFormatListCreateInfo structure with a viewFormatCount greater than zero and pViewFormats must have an element equal to imageFormat\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (format_list_info == nullptr) {\n    skip |= LogError(\"VUID-VkSwapchainCreateInfoKHR-flags-03168\", device, loc.dot(Field::flags),\n                     \"includes VK_SWAPCHAIN_CREATE_MUTABLE_FORMAT_BIT_KHR but the pNext does not contain \"\n                     \"VkImageFormatListCreateInfo.\");\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkSwapchainCreateInfoKHR-flags-03168\", \"If flags contains VK_SWAPCHAIN_CREATE_MUTABLE_FORMAT_BIT_KHR then the pNext chain must include a VkImageFormatListCreateInfo structure with a viewFormatCount greater than zero and pViewFormats must have an element equal to imageFormat\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "skip |= LogError(\"VUID-VkSwapchainCreateInfoKHR-flags-03168\", device, loc.dot(Field::flags),\n                 \"includes VK_SWAPCHAIN_CREATE_MUTABLE_FORMAT_BIT_KHR but %s is zero.\",\n                 loc.pNext(Struct::VkImageFormatListCreateInfo, Field::viewFormatCount).Fields().c_str());\n"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkSwapchainCreateInfoKHR-flags-03168\", \"If flags contains VK_SWAPCHAIN_CREATE_MUTABLE_FORMAT_BIT_KHR then the pNext chain must include a VkImageFormatListCreateInfo structure with a viewFormatCount greater than zero and pViewFormats must have an element equal to imageFormat\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (!found_base_format) {\n    skip |= LogError(\"VUID-VkSwapchainCreateInfoKHR-flags-03168\", device, loc.dot(Field::flags),\n                     \"includes VK_SWAPCHAIN_CREATE_MUTABLE_FORMAT_BIT_KHR but none of the \"\n                     \"elements of the pViewFormats member of VkImageFormatListCreateInfo match \"\n                     \"imageFormat (%s).\",\n                     string_VkFormat(create_info.imageFormat));\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkPresentRegionsKHR-swapchainCount-01260\", \"swapchainCount must be the same value as VkPresentInfoKHR::swapchainCount, where VkPresentInfoKHR is included in the pNext chain of this VkPresentRegionsKHR structure\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (present_regions->swapchainCount != pPresentInfo->swapchainCount) {\n    skip |= LogError(\"VUID-VkPresentRegionsKHR-swapchainCount-01260\", device,\n                     error_obj.location.pNext(Struct::VkPresentRegionsKHR, Field::swapchainCount),\n                     \"(%\" PRIu32 \") is not equal to %s (%\" PRIu32 \").\", present_regions->swapchainCount,\n                     error_obj.location.dot(Field::pPresentInfo).dot(Field::swapchainCount).Fields().c_str(),\n                     pPresentInfo->swapchainCount);\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkDisplayModeParametersKHR-width-01990\", \"The width member of visibleRegion must be greater than 0\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "skip |= ValidateNotZero(display_mode_parameters.visibleRegion.width == 0, \"VUID-VkDisplayModeParametersKHR-width-01990\",\n                        param_loc.dot(Field::visibleRegion).dot(Field::width));\n"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkDisplayModeParametersKHR-height-01991\", \"The height member of visibleRegion must be greater than 0\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "skip |= ValidateNotZero(display_mode_parameters.visibleRegion.width == 0, \"VUID-VkDisplayModeParametersKHR-width-01990\",\n                        param_loc.dot(Field::visibleRegion).dot(Field::width));\nskip |= ValidateNotZero(display_mode_parameters.visibleRegion.height == 0, \"VUID-VkDisplayModeParametersKHR-height-01991\",\n                        param_loc.dot(Field::visibleRegion).dot(Field::width));\n"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkDisplayModeParametersKHR-refreshRate-01992\", \"refreshRate must be greater than 0\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "skip |= ValidateNotZero(display_mode_parameters.visibleRegion.height == 0, \"VUID-VkDisplayModeParametersKHR-height-01991\",\nskip |= ValidateNotZero(display_mode_parameters.refreshRate == 0, \"VUID-VkDisplayModeParametersKHR-refreshRate-01992\",\n                        param_loc.dot(Field::refreshRate));\n"
        },
        {
            "role": "user",
            "content": "{\"VUID-vkGetPhysicalDeviceSurfaceCapabilities2KHR-pSurfaceInfo-06521\", \"If the VK_GOOGLE_surfaceless_query extension is not enabled, pSurfaceInfo->surface must be a valid VkSurfaceKHR handle\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (pSurfaceInfo && pSurfaceInfo->surface == VK_NULL_HANDLE && !IsExtEnabled(instance_extensions.vk_google_surfaceless_query)) {\n    skip |= LogError(\"VUID-vkGetPhysicalDeviceSurfaceCapabilities2KHR-pSurfaceInfo-06521\", physicalDevice,\n                     error_obj.location.dot(Field::pSurfaceInfo).dot(Field::surface),\n                     \"is VK_NULL_HANDLE and VK_GOOGLE_surfaceless_query is not enabled.\");\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-vkGetPhysicalDeviceSurfaceCapabilities2KHR-pNext-07776\", \"If a VkSurfacePresentModeCompatibilityEXT structure is included in the pNext chain of pSurfaceCapabilities, a VkSurfacePresentModeEXT structure must be included in the pNext chain of pSurfaceInfo\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (surface_present_mode_compatibility) {\n    skip |= LogError(\"VUID-vkGetPhysicalDeviceSurfaceCapabilities2KHR-pNext-07776\", physicalDevice, error_obj.location,\n                     \"pSurfaceCapabilities->pNext contains VkSurfacePresentModeCompatibilityEXT, but \"\n                     \"pSurfaceInfo->pNext does not contain a VkSurfacePresentModeEXT structure.\");\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-vkGetPhysicalDeviceSurfaceCapabilities2KHR-pNext-07777\", \"If a VkSurfacePresentScalingCapabilitiesEXT structure is included in the pNext chain of pSurfaceCapabilities, a VkSurfacePresentModeEXT structure must be included in the pNext chain of pSurfaceInfo\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (surface_present_scaling_compatibilities) {\n    skip |= LogError(\"VUID-vkGetPhysicalDeviceSurfaceCapabilities2KHR-pNext-07777\", physicalDevice, error_obj.location,\n                     \"pSurfaceCapabilities->pNext contains VkSurfacePresentScalingCapabilitiesEXT, but \"\n                     \"pSurfaceInfo->pNext does not contain a VkSurfacePresentModeEXT structure.\");\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-vkGetPhysicalDeviceSurfaceCapabilities2KHR-pNext-07778\", \"If a VkSurfacePresentModeCompatibilityEXT structure is included in the pNext chain of pSurfaceCapabilities, pSurfaceInfo->surface must be a valid VkSurfaceKHR handle\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (surface_present_mode_compatibility) {\n    skip |= LogError(\"VUID-vkGetPhysicalDeviceSurfaceCapabilities2KHR-pNext-07778\", physicalDevice, error_obj.location,\n                     \"pSurfaceCapabilities->pNext contains a \"\n                     \"VkSurfacePresentModeCompatibilityEXT structure, but pSurfaceInfo->surface is VK_NULL_HANDLE.\");\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-vkGetPhysicalDeviceSurfaceCapabilities2KHR-pNext-07779\", \"If a VkSurfacePresentScalingCapabilitiesEXT structure is included in the pNext chain of pSurfaceCapabilities, pSurfaceInfo->surface must be a valid VkSurfaceKHR handle\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (surface_present_scaling_compatibilities) {\n    skip |= LogError(\"VUID-vkGetPhysicalDeviceSurfaceCapabilities2KHR-pNext-07779\", physicalDevice, error_obj.location,\n                     \"pSurfaceCapabilities->pNext contains a \"\n                     \"VkSurfacePresentScalingCapabilitiesEXT structure, but pSurfaceInfo->surface is VK_NULL_HANDLE.\");\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-vkGetPhysicalDeviceSurfacePresentModes2EXT-pSurfaceInfo-06521\", \"If the VK_GOOGLE_surfaceless_query extension is not enabled, pSurfaceInfo->surface must be a valid VkSurfaceKHR handle\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (pSurfaceInfo && pSurfaceInfo->surface == VK_NULL_HANDLE && !IsExtEnabled(instance_extensions.vk_google_surfaceless_query)) {\n    skip |= LogError(\"VUID-vkGetPhysicalDeviceSurfacePresentModes2EXT-pSurfaceInfo-06521\", physicalDevice,\n                     error_obj.location.dot(Field::pSurfaceInfo).dot(Field::surface),\n                     \"is VK_NULL_HANDLE and VK_GOOGLE_surfaceless_query is not enabled.\");\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-vkGetPhysicalDeviceSurfacePresentModes2EXT-pSurfaceInfo-06521\", \"If the VK_GOOGLE_surfaceless_query extension is not enabled, pSurfaceInfo->surface must be a valid VkSurfaceKHR handle\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (pSurfaceInfo->surface == VK_NULL_HANDLE && !IsExtEnabled(instance_extensions.vk_google_surfaceless_query)) {\n    skip |= LogError(\"VUID-vkGetPhysicalDeviceSurfacePresentModes2EXT-pSurfaceInfo-06521\", device,\n                     error_obj.location.dot(Field::pSurfaceInfo).dot(Field::surface),\n                     \"is VK_NULL_HANDLE and VK_GOOGLE_surfaceless_query is not enabled.\");\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkWin32SurfaceCreateInfoKHR-hwnd-01308\", \"hwnd must be a valid Win32 HWND\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (pCreateInfo->hwnd == nullptr) {\n    skip |= LogError(\"VUID-VkWin32SurfaceCreateInfoKHR-hwnd-01308\", instance, error_obj.location, \"pCreateInfo->hwnd is NULL.\");\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-vkGetDeviceGroupSurfacePresentModes2EXT-pModes-parameter\", \"pModes must be a valid pointer to a VkDeviceGroupPresentModeFlagsKHR value\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (!pModes) {\n    skip |= LogError(\"VUID-vkGetDeviceGroupSurfacePresentModes2EXT-pModes-parameter\", device,\n                     error_obj.location.dot(Field::pModes), \"is NULL.\");\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkWaylandSurfaceCreateInfoKHR-surface-01305\", \"surface must point to a valid Wayland wl_surface\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (surface == nullptr) {\n    skip |= LogError(\"VUID-VkWaylandSurfaceCreateInfoKHR-surface-01305\", instance,\n                     error_obj.location.dot(Field::pCreateInfo).dot(Field::surface), \"is NULL!\");\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkXcbSurfaceCreateInfoKHR-connection-01310\", \"connection must point to a valid X11 xcb_connection_t\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (connection == nullptr) {\n    skip |= LogError(\"VUID-VkXcbSurfaceCreateInfoKHR-connection-01310\", instance,\n                     error_obj.location.dot(Field::pCreateInfo).dot(Field::connection), \"is NULL!\");\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkXcbSurfaceCreateInfoKHR-window-01311\", \"window must be a valid X11 xcb_window_t\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "skip |= ValidateNotZero(window == 0, \"VUID-VkXcbSurfaceCreateInfoKHR-window-01311\",\n                        error_obj.location.dot(Field::pCreateInfo).dot(Field::window));\n"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkXlibSurfaceCreateInfoKHR-dpy-01313\", \"dpy must point to a valid Xlib Display\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (display == nullptr) {\n    skip |= LogError(\"VUID-VkXlibSurfaceCreateInfoKHR-dpy-01313\", instance,\n                     error_obj.location.dot(Field::pCreateInfo).dot(Field::dpy), \"is NULL!\");\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkAndroidSurfaceCreateInfoKHR-window-01248\", \"window must point to a valid Android ANativeWindow\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (pCreateInfo->window == nullptr) {\n    skip |= LogError(\"VUID-VkAndroidSurfaceCreateInfoKHR-window-01248\", instance,\n                     error_obj.location.dot(Field::pCreateInfo).dot(Field::window), \"is NULL.\");\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-vkCmdBeginVideoCodingKHR-pBeginInfo-08254\", \"If pBeginInfo->videoSession was created with a video encode operation and the pNext chain of pBeginInfo includes an instance of the VkVideoEncodeRateControlInfoKHR structure, then it must match the rate control state configured for pBeginInfo->videoSession at the time the command is executed on the device\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (mismatch_recorder.HasMismatch()) {\n    skip |= dev_data.LogError(\"VUID-vkCmdBeginVideoCodingKHR-pBeginInfo-08254\", vs_state->Handle(), loc,\n                              \"The video encode rate control information specified when beginning the video coding scope \"\n                              \"does not match the currently configured video encode rate control state for %s:\\n%s\",\n                              dev_data.FormatHandle(vs_state->Handle()).c_str(), mismatch_recorder.c_str());\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-vkQueueSubmit-fence-parameter\", \"If fence is not VK_NULL_HANDLE, fence must be a valid VkFence handle\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "skip |= ValidateObject(fence, kVulkanObjectTypeFence, true, \"VUID-vkQueueSubmit-fence-parameter\",\n                       \"VUID-vkQueueSubmit-commonparent\", error_obj.location.dot(Field::fence));\n"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkMemoryDedicatedAllocateInfo-image-parameter\", \"If image is not VK_NULL_HANDLE, image must be a valid VkImage handle\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if ([[maybe_unused]] auto pNext = vku::FindStructInPNextChain<VkMemoryDedicatedAllocateInfo>(pAllocateInfo->pNext)) {\n    [[maybe_unused]] const Location pNext_loc = pAllocateInfo_loc.pNext(Struct::VkMemoryDedicatedAllocateInfo);\n    skip |= ValidateObject(pNext->image, kVulkanObjectTypeImage, true, \"VUID-VkMemoryDedicatedAllocateInfo-image-parameter\",\n                           \"VUID-VkMemoryDedicatedAllocateInfo-commonparent\", pNext_loc.dot(Field::image));\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-vkMapMemory-memory-parameter\", \"memory must be a valid VkDeviceMemory handle\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "bool skip = false;\n// Checked by chassis: device: \"VUID-vkMapMemory-device-parameter\"\nskip |= ValidateObject(memory, kVulkanObjectTypeDeviceMemory, false, \"VUID-vkMapMemory-memory-parameter\",\n                       \"VUID-vkMapMemory-memory-parent\", error_obj.location.dot(Field::memory));\n"
        },
        {
            "role": "user",
            "content": "{\"VUID-vkUnmapMemory-memory-parameter\", \"memory must be a valid VkDeviceMemory handle\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "bool ObjectLifetimes::PreCallValidateUnmapMemory(VkDevice device, VkDeviceMemory memory, const ErrorObject& error_obj) const {\n    bool skip = false;\n    // Checked by chassis: device: \"VUID-vkUnmapMemory-device-parameter\"\n    skip |= ValidateObject(memory, kVulkanObjectTypeDeviceMemory, false, \"VUID-vkUnmapMemory-memory-parameter\",\n                           \"VUID-vkUnmapMemory-memory-parent\", error_obj.location.dot(Field::memory));\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-vkGetDeviceMemoryCommitment-memory-parameter\", \"memory must be a valid VkDeviceMemory handle\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "bool skip = false;\n// Checked by chassis: device: \"VUID-vkGetDeviceMemoryCommitment-device-parameter\"\nskip |= ValidateObject(memory, kVulkanObjectTypeDeviceMemory, false, \"VUID-vkGetDeviceMemoryCommitment-memory-parameter\",\n                       \"VUID-vkGetDeviceMemoryCommitment-memory-parent\", error_obj.location.dot(Field::memory));\n"
        },
        {
            "role": "user",
            "content": "{\"VUID-vkBindBufferMemory-buffer-parameter\", \"buffer must be a valid VkBuffer handle\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "bool skip = false;\n// Checked by chassis: device: \"VUID-vkBindBufferMemory-device-parameter\"\nskip |= ValidateObject(buffer, kVulkanObjectTypeBuffer, false, \"VUID-vkBindBufferMemory-buffer-parameter\",\n                       \"VUID-vkBindBufferMemory-buffer-parent\", error_obj.location.dot(Field::buffer));\n"
        },
        {
            "role": "user",
            "content": "{\"VUID-vkBindImageMemory-image-parameter\", \"image must be a valid VkImage handle\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "bool skip = false;\n// Checked by chassis: device: \"VUID-vkBindImageMemory-device-parameter\"\nskip |= ValidateObject(image, kVulkanObjectTypeImage, false, \"VUID-vkBindImageMemory-image-parameter\",\n                       \"VUID-vkBindImageMemory-image-parent\", error_obj.location.dot(Field::image));\n"
        },
        {
            "role": "user",
            "content": "{\"VUID-vkBindImageMemory-memory-parameter\", \"memory must be a valid VkDeviceMemory handle\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "// Checked by chassis: device: \"VUID-vkBindImageMemory-device-parameter\"\nskip |= ValidateObject(image, kVulkanObjectTypeImage, false, \"VUID-vkBindImageMemory-image-parameter\",\n                       \"VUID-vkBindImageMemory-image-parent\", error_obj.location.dot(Field::image));\nskip |= ValidateObject(memory, kVulkanObjectTypeDeviceMemory, false, \"VUID-vkBindImageMemory-memory-parameter\",\n                       \"VUID-vkBindImageMemory-memory-parent\", error_obj.location.dot(Field::memory));\n"
        },
        {
            "role": "user",
            "content": "{\"VUID-vkGetBufferMemoryRequirements-buffer-parameter\", \"buffer must be a valid VkBuffer handle\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "bool skip = false;\n// Checked by chassis: device: \"VUID-vkGetBufferMemoryRequirements-device-parameter\"\nskip |= ValidateObject(buffer, kVulkanObjectTypeBuffer, false, \"VUID-vkGetBufferMemoryRequirements-buffer-parameter\",\n                       \"VUID-vkGetBufferMemoryRequirements-buffer-parent\", error_obj.location.dot(Field::buffer));\n"
        },
        {
            "role": "user",
            "content": "{\"VUID-vkGetImageMemoryRequirements-image-parameter\", \"image must be a valid VkImage handle\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "bool skip = false;\n// Checked by chassis: device: \"VUID-vkGetImageMemoryRequirements-device-parameter\"\nskip |= ValidateObject(image, kVulkanObjectTypeImage, false, \"VUID-vkGetImageMemoryRequirements-image-parameter\",\n                       \"VUID-vkGetImageMemoryRequirements-image-parent\", error_obj.location.dot(Field::image));\n"
        },
        {
            "role": "user",
            "content": "{\"VUID-vkQueueBindSparse-fence-parameter\", \"If fence is not VK_NULL_HANDLE, fence must be a valid VkFence handle\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "skip |= ValidateObject(fence, kVulkanObjectTypeFence, true, \"VUID-vkQueueBindSparse-fence-parameter\",\n                       \"VUID-vkQueueBindSparse-commonparent\", error_obj.location.dot(Field::fence));\n"
        },
        {
            "role": "user",
            "content": "{\"VUID-vkDestroyFence-fence-parameter\", \"If fence is not VK_NULL_HANDLE, fence must be a valid VkFence handle\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "bool skip = false;\n// Checked by chassis: device: \"VUID-vkDestroyFence-device-parameter\"\nskip |= ValidateObject(fence, kVulkanObjectTypeFence, true, \"VUID-vkDestroyFence-fence-parameter\",\n                       \"VUID-vkDestroyFence-fence-parent\", error_obj.location.dot(Field::fence));\n"
        },
        {
            "role": "user",
            "content": "{\"VUID-vkDestroyFence-fence-01121\", \"If VkAllocationCallbacks were provided when fence was created, a compatible set of callbacks must be provided here\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "// Checked by chassis: device: \"VUID-vkDestroyFence-device-parameter\"\nskip |= ValidateObject(fence, kVulkanObjectTypeFence, true, \"VUID-vkDestroyFence-fence-parameter\",\n                       \"VUID-vkDestroyFence-fence-parent\", error_obj.location.dot(Field::fence));\nskip |= ValidateDestroyObject(fence, kVulkanObjectTypeFence, pAllocator, \"VUID-vkDestroyFence-fence-01121\",\n                              \"VUID-vkDestroyFence-fence-01122\", error_obj.location);\n"
        },
        {
            "role": "user",
            "content": "{\"VUID-vkResetFences-pFences-parameter\", \"pFences must be a valid pointer to an array of fenceCount valid VkFence handles\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if ((fenceCount > 0) && (pFences)) {\n    for (uint32_t index0 = 0; index0 < fenceCount; ++index0) {\n        skip |= ValidateObject(pFences[index0], kVulkanObjectTypeFence, false, \"VUID-vkResetFences-pFences-parameter\",\n                               \"VUID-vkResetFences-pFences-parent\", error_obj.location.dot(Field::pFences, index0));\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-vkWaitForFences-pFences-parameter\", \"pFences must be a valid pointer to an array of fenceCount valid VkFence handles\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if ((fenceCount > 0) && (pFences)) {\n    for (uint32_t index0 = 0; index0 < fenceCount; ++index0) {\n        skip |= ValidateObject(pFences[index0], kVulkanObjectTypeFence, false, \"VUID-vkWaitForFences-pFences-parameter\",\n                               \"VUID-vkWaitForFences-pFences-parent\", error_obj.location.dot(Field::pFences, index0));\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-vkDestroySemaphore-semaphore-parameter\", \"If semaphore is not VK_NULL_HANDLE, semaphore must be a valid VkSemaphore handle\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "bool skip = false;\n// Checked by chassis: device: \"VUID-vkDestroySemaphore-device-parameter\"\nskip |= ValidateObject(semaphore, kVulkanObjectTypeSemaphore, true, \"VUID-vkDestroySemaphore-semaphore-parameter\",\n                       \"VUID-vkDestroySemaphore-semaphore-parent\", error_obj.location.dot(Field::semaphore));\n"
        },
        {
            "role": "user",
            "content": "{\"VUID-vkDestroySemaphore-semaphore-01138\", \"If VkAllocationCallbacks were provided when semaphore was created, a compatible set of callbacks must be provided here\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "// Checked by chassis: device: \"VUID-vkDestroySemaphore-device-parameter\"\nskip |= ValidateObject(semaphore, kVulkanObjectTypeSemaphore, true, \"VUID-vkDestroySemaphore-semaphore-parameter\",\n                       \"VUID-vkDestroySemaphore-semaphore-parent\", error_obj.location.dot(Field::semaphore));\nskip |= ValidateDestroyObject(semaphore, kVulkanObjectTypeSemaphore, pAllocator, \"VUID-vkDestroySemaphore-semaphore-01138\",\n                              \"VUID-vkDestroySemaphore-semaphore-01139\", error_obj.location);\n"
        },
        {
            "role": "user",
            "content": "{\"VUID-vkDestroyEvent-event-parameter\", \"If event is not VK_NULL_HANDLE, event must be a valid VkEvent handle\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "bool skip = false;\n// Checked by chassis: device: \"VUID-vkDestroyEvent-device-parameter\"\nskip |= ValidateObject(event, kVulkanObjectTypeEvent, true, \"VUID-vkDestroyEvent-event-parameter\",\n                       \"VUID-vkDestroyEvent-event-parent\", error_obj.location.dot(Field::event));\n"
        },
        {
            "role": "user",
            "content": "{\"VUID-vkGetEventStatus-event-parameter\", \"event must be a valid VkEvent handle\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "bool ObjectLifetimes::PreCallValidateGetEventStatus(VkDevice device, VkEvent event, const ErrorObject& error_obj) const {\n    bool skip = false;\n    // Checked by chassis: device: \"VUID-vkGetEventStatus-device-parameter\"\n    skip |= ValidateObject(event, kVulkanObjectTypeEvent, false, \"VUID-vkGetEventStatus-event-parameter\",\n                           \"VUID-vkGetEventStatus-event-parent\", error_obj.location.dot(Field::event));\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-vkSetEvent-event-parameter\", \"event must be a valid VkEvent handle\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "bool ObjectLifetimes::PreCallValidateSetEvent(VkDevice device, VkEvent event, const ErrorObject& error_obj) const {\n    bool skip = false;\n    // Checked by chassis: device: \"VUID-vkSetEvent-device-parameter\"\n    skip |= ValidateObject(event, kVulkanObjectTypeEvent, false, \"VUID-vkSetEvent-event-parameter\", \"VUID-vkSetEvent-event-parent\",\n                           error_obj.location.dot(Field::event));\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-vkSetEvent-event-parent\", \"event must have been created, allocated, or retrieved from device\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "bool ObjectLifetimes::PreCallValidateSetEvent(VkDevice device, VkEvent event, const ErrorObject& error_obj) const {\n    bool skip = false;\n    // Checked by chassis: device: \"VUID-vkSetEvent-device-parameter\"\n    skip |= ValidateObject(event, kVulkanObjectTypeEvent, false, \"VUID-vkSetEvent-event-parameter\", \"VUID-vkSetEvent-event-parent\",\n                           error_obj.location.dot(Field::event));\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-vkResetEvent-event-parameter\", \"event must be a valid VkEvent handle\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "bool ObjectLifetimes::PreCallValidateResetEvent(VkDevice device, VkEvent event, const ErrorObject& error_obj) const {\n    bool skip = false;\n    // Checked by chassis: device: \"VUID-vkResetEvent-device-parameter\"\n    skip |= ValidateObject(event, kVulkanObjectTypeEvent, false, \"VUID-vkResetEvent-event-parameter\",\n                           \"VUID-vkResetEvent-event-parent\", error_obj.location.dot(Field::event));\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-vkDestroyQueryPool-queryPool-00794\", \"If VkAllocationCallbacks were provided when queryPool was created, a compatible set of callbacks must be provided here\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "// Checked by chassis: device: \"VUID-vkDestroyQueryPool-device-parameter\"\nskip |= ValidateObject(queryPool, kVulkanObjectTypeQueryPool, true, \"VUID-vkDestroyQueryPool-queryPool-parameter\",\n                       \"VUID-vkDestroyQueryPool-queryPool-parent\", error_obj.location.dot(Field::queryPool));\nskip |= ValidateDestroyObject(queryPool, kVulkanObjectTypeQueryPool, pAllocator, \"VUID-vkDestroyQueryPool-queryPool-00794\",\n                              \"VUID-vkDestroyQueryPool-queryPool-00795\", error_obj.location);\n"
        },
        {
            "role": "user",
            "content": "{\"VUID-vkGetQueryPoolResults-queryPool-parameter\", \"queryPool must be a valid VkQueryPool handle\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "bool skip = false;\n// Checked by chassis: device: \"VUID-vkGetQueryPoolResults-device-parameter\"\nskip |= ValidateObject(queryPool, kVulkanObjectTypeQueryPool, false, \"VUID-vkGetQueryPoolResults-queryPool-parameter\",\n                       \"VUID-vkGetQueryPoolResults-queryPool-parent\", error_obj.location.dot(Field::queryPool));\n"
        },
        {
            "role": "user",
            "content": "{\"VUID-vkDestroyBuffer-buffer-parameter\", \"If buffer is not VK_NULL_HANDLE, buffer must be a valid VkBuffer handle\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "bool skip = false;\n// Checked by chassis: device: \"VUID-vkDestroyBuffer-device-parameter\"\nskip |= ValidateObject(buffer, kVulkanObjectTypeBuffer, true, \"VUID-vkDestroyBuffer-buffer-parameter\",\n                       \"VUID-vkDestroyBuffer-buffer-parent\", error_obj.location.dot(Field::buffer));\n"
        },
        {
            "role": "user",
            "content": "{\"VUID-vkDestroyBuffer-buffer-00923\", \"If VkAllocationCallbacks were provided when buffer was created, a compatible set of callbacks must be provided here\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "// Checked by chassis: device: \"VUID-vkDestroyBuffer-device-parameter\"\nskip |= ValidateObject(buffer, kVulkanObjectTypeBuffer, true, \"VUID-vkDestroyBuffer-buffer-parameter\",\n                       \"VUID-vkDestroyBuffer-buffer-parent\", error_obj.location.dot(Field::buffer));\nskip |= ValidateDestroyObject(buffer, kVulkanObjectTypeBuffer, pAllocator, \"VUID-vkDestroyBuffer-buffer-00923\",\n                              \"VUID-vkDestroyBuffer-buffer-00924\", error_obj.location);\n"
        },
        {
            "role": "user",
            "content": "{\"VUID-vkDestroyBufferView-bufferView-parameter\", \"If bufferView is not VK_NULL_HANDLE, bufferView must be a valid VkBufferView handle\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "bool skip = false;\n// Checked by chassis: device: \"VUID-vkDestroyBufferView-device-parameter\"\nskip |= ValidateObject(bufferView, kVulkanObjectTypeBufferView, true, \"VUID-vkDestroyBufferView-bufferView-parameter\",\n                       \"VUID-vkDestroyBufferView-bufferView-parent\", error_obj.location.dot(Field::bufferView));\n"
        },
        {
            "role": "user",
            "content": "{\"VUID-vkDestroyBufferView-bufferView-00937\", \"If VkAllocationCallbacks were provided when bufferView was created, a compatible set of callbacks must be provided here\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "// Checked by chassis: device: \"VUID-vkDestroyBufferView-device-parameter\"\nskip |= ValidateObject(bufferView, kVulkanObjectTypeBufferView, true, \"VUID-vkDestroyBufferView-bufferView-parameter\",\n                       \"VUID-vkDestroyBufferView-bufferView-parent\", error_obj.location.dot(Field::bufferView));\nskip |= ValidateDestroyObject(bufferView, kVulkanObjectTypeBufferView, pAllocator, \"VUID-vkDestroyBufferView-bufferView-00937\",\n                              \"VUID-vkDestroyBufferView-bufferView-00938\", error_obj.location);\n"
        },
        {
            "role": "user",
            "content": "{\"VUID-vkDestroyImage-image-parameter\", \"If image is not VK_NULL_HANDLE, image must be a valid VkImage handle\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "bool skip = false;\n// Checked by chassis: device: \"VUID-vkDestroyImage-device-parameter\"\nskip |= ValidateObject(image, kVulkanObjectTypeImage, true, \"VUID-vkDestroyImage-image-parameter\",\n                       \"VUID-vkDestroyImage-image-parent\", error_obj.location.dot(Field::image));\n"
        },
        {
            "role": "user",
            "content": "{\"VUID-vkDestroyImage-image-01001\", \"If VkAllocationCallbacks were provided when image was created, a compatible set of callbacks must be provided here\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "// Checked by chassis: device: \"VUID-vkDestroyImage-device-parameter\"\nskip |= ValidateObject(image, kVulkanObjectTypeImage, true, \"VUID-vkDestroyImage-image-parameter\",\n                       \"VUID-vkDestroyImage-image-parent\", error_obj.location.dot(Field::image));\nskip |= ValidateDestroyObject(image, kVulkanObjectTypeImage, pAllocator, \"VUID-vkDestroyImage-image-01001\",\n                              \"VUID-vkDestroyImage-image-01002\", error_obj.location);\n"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkImageViewCreateInfo-image-parameter\", \"image must be a valid VkImage handle\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (pCreateInfo) {\n    [[maybe_unused]] const Location pCreateInfo_loc = error_obj.location.dot(Field::pCreateInfo);\n    skip |= ValidateObject(pCreateInfo->image, kVulkanObjectTypeImage, false, \"VUID-VkImageViewCreateInfo-image-parameter\",\n                           \"VUID-vkCreateImageView-image-09179\", pCreateInfo_loc.dot(Field::image));\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-vkDestroyImageView-imageView-parameter\", \"If imageView is not VK_NULL_HANDLE, imageView must be a valid VkImageView handle\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "bool skip = false;\n// Checked by chassis: device: \"VUID-vkDestroyImageView-device-parameter\"\nskip |= ValidateObject(imageView, kVulkanObjectTypeImageView, true, \"VUID-vkDestroyImageView-imageView-parameter\",\n                       \"VUID-vkDestroyImageView-imageView-parent\", error_obj.location.dot(Field::imageView));\n"
        },
        {
            "role": "user",
            "content": "{\"VUID-vkDestroyImageView-imageView-01027\", \"If VkAllocationCallbacks were provided when imageView was created, a compatible set of callbacks must be provided here\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "// Checked by chassis: device: \"VUID-vkDestroyImageView-device-parameter\"\nskip |= ValidateObject(imageView, kVulkanObjectTypeImageView, true, \"VUID-vkDestroyImageView-imageView-parameter\",\n                       \"VUID-vkDestroyImageView-imageView-parent\", error_obj.location.dot(Field::imageView));\nskip |= ValidateDestroyObject(imageView, kVulkanObjectTypeImageView, pAllocator, \"VUID-vkDestroyImageView-imageView-01027\",\n                              \"VUID-vkDestroyImageView-imageView-01028\", error_obj.location);\n"
        },
        {
            "role": "user",
            "content": "{\"VUID-vkDestroyShaderModule-shaderModule-parameter\", \"If shaderModule is not VK_NULL_HANDLE, shaderModule must be a valid VkShaderModule handle\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "bool skip = false;\n// Checked by chassis: device: \"VUID-vkDestroyShaderModule-device-parameter\"\nskip |= ValidateObject(shaderModule, kVulkanObjectTypeShaderModule, true, \"VUID-vkDestroyShaderModule-shaderModule-parameter\",\n                       \"VUID-vkDestroyShaderModule-shaderModule-parent\", error_obj.location.dot(Field::shaderModule));\n"
        },
        {
            "role": "user",
            "content": "{\"VUID-vkDestroyPipeline-pipeline-parameter\", \"If pipeline is not VK_NULL_HANDLE, pipeline must be a valid VkPipeline handle\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "bool skip = false;\n// Checked by chassis: device: \"VUID-vkDestroyPipeline-device-parameter\"\nskip |= ValidateObject(pipeline, kVulkanObjectTypePipeline, true, \"VUID-vkDestroyPipeline-pipeline-parameter\",\n                       \"VUID-vkDestroyPipeline-pipeline-parent\", error_obj.location.dot(Field::pipeline));\n"
        },
        {
            "role": "user",
            "content": "{\"VUID-vkDestroyPipeline-pipeline-00766\", \"If VkAllocationCallbacks were provided when pipeline was created, a compatible set of callbacks must be provided here\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "// Checked by chassis: device: \"VUID-vkDestroyPipeline-device-parameter\"\nskip |= ValidateObject(pipeline, kVulkanObjectTypePipeline, true, \"VUID-vkDestroyPipeline-pipeline-parameter\",\n                       \"VUID-vkDestroyPipeline-pipeline-parent\", error_obj.location.dot(Field::pipeline));\nskip |= ValidateDestroyObject(pipeline, kVulkanObjectTypePipeline, pAllocator, \"VUID-vkDestroyPipeline-pipeline-00766\",\n                              \"VUID-vkDestroyPipeline-pipeline-00767\", error_obj.location);\n"
        },
        {
            "role": "user",
            "content": "{\"VUID-vkDestroySampler-sampler-parameter\", \"If sampler is not VK_NULL_HANDLE, sampler must be a valid VkSampler handle\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "bool skip = false;\n// Checked by chassis: device: \"VUID-vkDestroySampler-device-parameter\"\nskip |= ValidateObject(sampler, kVulkanObjectTypeSampler, true, \"VUID-vkDestroySampler-sampler-parameter\",\n                       \"VUID-vkDestroySampler-sampler-parent\", error_obj.location.dot(Field::sampler));\n"
        },
        {
            "role": "user",
            "content": "{\"VUID-vkDestroySampler-sampler-01083\", \"If VkAllocationCallbacks were provided when sampler was created, a compatible set of callbacks must be provided here\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "// Checked by chassis: device: \"VUID-vkDestroySampler-device-parameter\"\nskip |= ValidateObject(sampler, kVulkanObjectTypeSampler, true, \"VUID-vkDestroySampler-sampler-parameter\",\n                       \"VUID-vkDestroySampler-sampler-parent\", error_obj.location.dot(Field::sampler));\nskip |= ValidateDestroyObject(sampler, kVulkanObjectTypeSampler, pAllocator, \"VUID-vkDestroySampler-sampler-01083\",\n                              \"VUID-vkDestroySampler-sampler-01084\", error_obj.location);\n"
        },
        {
            "role": "user",
            "content": "{\"VUID-vkDestroyRenderPass-renderPass-parameter\", \"If renderPass is not VK_NULL_HANDLE, renderPass must be a valid VkRenderPass handle\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "bool skip = false;\n// Checked by chassis: device: \"VUID-vkDestroyRenderPass-device-parameter\"\nskip |= ValidateObject(renderPass, kVulkanObjectTypeRenderPass, true, \"VUID-vkDestroyRenderPass-renderPass-parameter\",\n                       \"VUID-vkDestroyRenderPass-renderPass-parent\", error_obj.location.dot(Field::renderPass));\n"
        },
        {
            "role": "user",
            "content": "{\"VUID-vkDestroyRenderPass-renderPass-00874\", \"If VkAllocationCallbacks were provided when renderPass was created, a compatible set of callbacks must be provided here\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "// Checked by chassis: device: \"VUID-vkDestroyRenderPass-device-parameter\"\nskip |= ValidateObject(renderPass, kVulkanObjectTypeRenderPass, true, \"VUID-vkDestroyRenderPass-renderPass-parameter\",\n                       \"VUID-vkDestroyRenderPass-renderPass-parent\", error_obj.location.dot(Field::renderPass));\nskip |= ValidateDestroyObject(renderPass, kVulkanObjectTypeRenderPass, pAllocator, \"VUID-vkDestroyRenderPass-renderPass-00874\",\n                              \"VUID-vkDestroyRenderPass-renderPass-00875\", error_obj.location);\n"
        },
        {
            "role": "user",
            "content": "{\"VUID-vkGetRenderAreaGranularity-renderPass-parameter\", \"renderPass must be a valid VkRenderPass handle\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "bool skip = false;\n// Checked by chassis: device: \"VUID-vkGetRenderAreaGranularity-device-parameter\"\nskip |= ValidateObject(renderPass, kVulkanObjectTypeRenderPass, false, \"VUID-vkGetRenderAreaGranularity-renderPass-parameter\",\n                       \"VUID-vkGetRenderAreaGranularity-renderPass-parent\", error_obj.location.dot(Field::renderPass));\n"
        },
        {
            "role": "user",
            "content": "{\"VUID-vkResetCommandPool-commandPool-parameter\", \"commandPool must be a valid VkCommandPool handle\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "bool skip = false;\n// Checked by chassis: device: \"VUID-vkResetCommandPool-device-parameter\"\nskip |= ValidateObject(commandPool, kVulkanObjectTypeCommandPool, false, \"VUID-vkResetCommandPool-commandPool-parameter\",\n                       \"VUID-vkResetCommandPool-commandPool-parent\", error_obj.location.dot(Field::commandPool));\n"
        },
        {
            "role": "user",
            "content": "{\"VUID-vkCmdBindDescriptorSets-layout-parameter\", \"layout must be a valid VkPipelineLayout handle\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "bool skip = false;\n// Checked by chassis: commandBuffer: \"VUID-vkCmdBindDescriptorSets-commandBuffer-parameter\"\n// Checked by chassis: commandBuffer: \"VUID-vkCmdBindDescriptorSets-commonparent\"\nskip |= ValidateObject(layout, kVulkanObjectTypePipelineLayout, false, \"VUID-vkCmdBindDescriptorSets-layout-parameter\",\n                       \"VUID-vkCmdBindDescriptorSets-commonparent\", error_obj.location.dot(Field::layout));\n"
        },
        {
            "role": "user",
            "content": "{\"VUID-vkCmdBindIndexBuffer-buffer-parameter\", \"If buffer is not VK_NULL_HANDLE, buffer must be a valid VkBuffer handle\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "bool skip = false;\n// Checked by chassis: commandBuffer: \"VUID-vkCmdBindIndexBuffer-commandBuffer-parameter\"\n// Checked by chassis: commandBuffer: \"VUID-vkCmdBindIndexBuffer-commonparent\"\nskip |= ValidateObject(buffer, kVulkanObjectTypeBuffer, true, \"VUID-vkCmdBindIndexBuffer-buffer-parameter\",\n                       \"VUID-vkCmdBindIndexBuffer-commonparent\", error_obj.location.dot(Field::buffer));\n"
        },
        {
            "role": "user",
            "content": "{\"VUID-vkCmdDrawIndirect-buffer-parameter\", \"buffer must be a valid VkBuffer handle\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "bool skip = false;\n// Checked by chassis: commandBuffer: \"VUID-vkCmdDrawIndirect-commandBuffer-parameter\"\n// Checked by chassis: commandBuffer: \"VUID-vkCmdDrawIndirect-commonparent\"\nskip |= ValidateObject(buffer, kVulkanObjectTypeBuffer, false, \"VUID-vkCmdDrawIndirect-buffer-parameter\",\n                       \"VUID-vkCmdDrawIndirect-commonparent\", error_obj.location.dot(Field::buffer));\n"
        },
        {
            "role": "user",
            "content": "{\"VUID-vkCmdDrawIndexedIndirect-buffer-parameter\", \"buffer must be a valid VkBuffer handle\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "bool skip = false;\n// Checked by chassis: commandBuffer: \"VUID-vkCmdDrawIndexedIndirect-commandBuffer-parameter\"\n// Checked by chassis: commandBuffer: \"VUID-vkCmdDrawIndexedIndirect-commonparent\"\nskip |= ValidateObject(buffer, kVulkanObjectTypeBuffer, false, \"VUID-vkCmdDrawIndexedIndirect-buffer-parameter\",\n                       \"VUID-vkCmdDrawIndexedIndirect-commonparent\", error_obj.location.dot(Field::buffer));\n"
        },
        {
            "role": "user",
            "content": "{\"VUID-vkCmdCopyBuffer-srcBuffer-parameter\", \"srcBuffer must be a valid VkBuffer handle\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "bool skip = false;\n// Checked by chassis: commandBuffer: \"VUID-vkCmdCopyBuffer-commandBuffer-parameter\"\n// Checked by chassis: commandBuffer: \"VUID-vkCmdCopyBuffer-commonparent\"\nskip |= ValidateObject(srcBuffer, kVulkanObjectTypeBuffer, false, \"VUID-vkCmdCopyBuffer-srcBuffer-parameter\",\n                       \"VUID-vkCmdCopyBuffer-commonparent\", error_obj.location.dot(Field::srcBuffer));\n"
        },
        {
            "role": "user",
            "content": "{\"VUID-vkCmdCopyBuffer-dstBuffer-parameter\", \"dstBuffer must be a valid VkBuffer handle\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "// Checked by chassis: commandBuffer: \"VUID-vkCmdCopyBuffer-commonparent\"\nskip |= ValidateObject(srcBuffer, kVulkanObjectTypeBuffer, false, \"VUID-vkCmdCopyBuffer-srcBuffer-parameter\",\n                       \"VUID-vkCmdCopyBuffer-commonparent\", error_obj.location.dot(Field::srcBuffer));\nskip |= ValidateObject(dstBuffer, kVulkanObjectTypeBuffer, false, \"VUID-vkCmdCopyBuffer-dstBuffer-parameter\",\n                       \"VUID-vkCmdCopyBuffer-commonparent\", error_obj.location.dot(Field::dstBuffer));\n"
        },
        {
            "role": "user",
            "content": "{\"VUID-vkCmdCopyImage-srcImage-parameter\", \"srcImage must be a valid VkImage handle\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "bool skip = false;\n// Checked by chassis: commandBuffer: \"VUID-vkCmdCopyImage-commandBuffer-parameter\"\n// Checked by chassis: commandBuffer: \"VUID-vkCmdCopyImage-commonparent\"\nskip |= ValidateObject(srcImage, kVulkanObjectTypeImage, false, \"VUID-vkCmdCopyImage-srcImage-parameter\",\n                       \"VUID-vkCmdCopyImage-commonparent\", error_obj.location.dot(Field::srcImage));\n"
        },
        {
            "role": "user",
            "content": "{\"VUID-vkCmdCopyImage-dstImage-parameter\", \"dstImage must be a valid VkImage handle\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "// Checked by chassis: commandBuffer: \"VUID-vkCmdCopyImage-commonparent\"\nskip |= ValidateObject(srcImage, kVulkanObjectTypeImage, false, \"VUID-vkCmdCopyImage-srcImage-parameter\",\n                       \"VUID-vkCmdCopyImage-commonparent\", error_obj.location.dot(Field::srcImage));\nskip |= ValidateObject(dstImage, kVulkanObjectTypeImage, false, \"VUID-vkCmdCopyImage-dstImage-parameter\",\n                       \"VUID-vkCmdCopyImage-commonparent\", error_obj.location.dot(Field::dstImage));\n"
        },
        {
            "role": "user",
            "content": "{\"VUID-vkCmdBlitImage-dstImage-parameter\", \"dstImage must be a valid VkImage handle\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "// Checked by chassis: commandBuffer: \"VUID-vkCmdBlitImage-commonparent\"\nskip |= ValidateObject(srcImage, kVulkanObjectTypeImage, false, \"VUID-vkCmdBlitImage-srcImage-parameter\",\n                       \"VUID-vkCmdBlitImage-commonparent\", error_obj.location.dot(Field::srcImage));\nskip |= ValidateObject(dstImage, kVulkanObjectTypeImage, false, \"VUID-vkCmdBlitImage-dstImage-parameter\",\n                       \"VUID-vkCmdBlitImage-commonparent\", error_obj.location.dot(Field::dstImage));\n"
        },
        {
            "role": "user",
            "content": "{\"VUID-vkCmdCopyBufferToImage-srcBuffer-parameter\", \"srcBuffer must be a valid VkBuffer handle\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "bool skip = false;\n// Checked by chassis: commandBuffer: \"VUID-vkCmdCopyBufferToImage-commandBuffer-parameter\"\n// Checked by chassis: commandBuffer: \"VUID-vkCmdCopyBufferToImage-commonparent\"\nskip |= ValidateObject(srcBuffer, kVulkanObjectTypeBuffer, false, \"VUID-vkCmdCopyBufferToImage-srcBuffer-parameter\",\n                       \"VUID-vkCmdCopyBufferToImage-commonparent\", error_obj.location.dot(Field::srcBuffer));\n"
        },
        {
            "role": "user",
            "content": "{\"VUID-vkCmdCopyBufferToImage-dstImage-parameter\", \"dstImage must be a valid VkImage handle\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "// Checked by chassis: commandBuffer: \"VUID-vkCmdCopyBufferToImage-commonparent\"\nskip |= ValidateObject(srcBuffer, kVulkanObjectTypeBuffer, false, \"VUID-vkCmdCopyBufferToImage-srcBuffer-parameter\",\n                       \"VUID-vkCmdCopyBufferToImage-commonparent\", error_obj.location.dot(Field::srcBuffer));\nskip |= ValidateObject(dstImage, kVulkanObjectTypeImage, false, \"VUID-vkCmdCopyBufferToImage-dstImage-parameter\",\n                       \"VUID-vkCmdCopyBufferToImage-commonparent\", error_obj.location.dot(Field::dstImage));\n"
        },
        {
            "role": "user",
            "content": "{\"VUID-vkCmdCopyImageToBuffer-srcImage-parameter\", \"srcImage must be a valid VkImage handle\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "bool skip = false;\n// Checked by chassis: commandBuffer: \"VUID-vkCmdCopyImageToBuffer-commandBuffer-parameter\"\n// Checked by chassis: commandBuffer: \"VUID-vkCmdCopyImageToBuffer-commonparent\"\nskip |= ValidateObject(srcImage, kVulkanObjectTypeImage, false, \"VUID-vkCmdCopyImageToBuffer-srcImage-parameter\",\n                       \"VUID-vkCmdCopyImageToBuffer-commonparent\", error_obj.location.dot(Field::srcImage));\n"
        },
        {
            "role": "user",
            "content": "{\"VUID-vkCmdUpdateBuffer-dstBuffer-parameter\", \"dstBuffer must be a valid VkBuffer handle\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "bool skip = false;\n// Checked by chassis: commandBuffer: \"VUID-vkCmdUpdateBuffer-commandBuffer-parameter\"\n// Checked by chassis: commandBuffer: \"VUID-vkCmdUpdateBuffer-commonparent\"\nskip |= ValidateObject(dstBuffer, kVulkanObjectTypeBuffer, false, \"VUID-vkCmdUpdateBuffer-dstBuffer-parameter\",\n                       \"VUID-vkCmdUpdateBuffer-commonparent\", error_obj.location.dot(Field::dstBuffer));\n"
        },
        {
            "role": "user",
            "content": "{\"VUID-vkCmdFillBuffer-dstBuffer-parameter\", \"dstBuffer must be a valid VkBuffer handle\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "bool skip = false;\n// Checked by chassis: commandBuffer: \"VUID-vkCmdFillBuffer-commandBuffer-parameter\"\n// Checked by chassis: commandBuffer: \"VUID-vkCmdFillBuffer-commonparent\"\nskip |= ValidateObject(dstBuffer, kVulkanObjectTypeBuffer, false, \"VUID-vkCmdFillBuffer-dstBuffer-parameter\",\n                       \"VUID-vkCmdFillBuffer-commonparent\", error_obj.location.dot(Field::dstBuffer));\n"
        },
        {
            "role": "user",
            "content": "{\"VUID-vkCmdClearColorImage-image-parameter\", \"image must be a valid VkImage handle\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "bool skip = false;\n// Checked by chassis: commandBuffer: \"VUID-vkCmdClearColorImage-commandBuffer-parameter\"\n// Checked by chassis: commandBuffer: \"VUID-vkCmdClearColorImage-commonparent\"\nskip |= ValidateObject(image, kVulkanObjectTypeImage, false, \"VUID-vkCmdClearColorImage-image-parameter\",\n                       \"VUID-vkCmdClearColorImage-commonparent\", error_obj.location.dot(Field::image));\n"
        },
        {
            "role": "user",
            "content": "{\"VUID-vkCmdClearDepthStencilImage-image-parameter\", \"image must be a valid VkImage handle\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "bool skip = false;\n// Checked by chassis: commandBuffer: \"VUID-vkCmdClearDepthStencilImage-commandBuffer-parameter\"\n// Checked by chassis: commandBuffer: \"VUID-vkCmdClearDepthStencilImage-commonparent\"\nskip |= ValidateObject(image, kVulkanObjectTypeImage, false, \"VUID-vkCmdClearDepthStencilImage-image-parameter\",\n                       \"VUID-vkCmdClearDepthStencilImage-commonparent\", error_obj.location.dot(Field::image));\n"
        },
        {
            "role": "user",
            "content": "{\"VUID-vkCmdResolveImage-dstImage-parameter\", \"dstImage must be a valid VkImage handle\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "// Checked by chassis: commandBuffer: \"VUID-vkCmdResolveImage-commonparent\"\nskip |= ValidateObject(srcImage, kVulkanObjectTypeImage, false, \"VUID-vkCmdResolveImage-srcImage-parameter\",\n                       \"VUID-vkCmdResolveImage-commonparent\", error_obj.location.dot(Field::srcImage));\nskip |= ValidateObject(dstImage, kVulkanObjectTypeImage, false, \"VUID-vkCmdResolveImage-dstImage-parameter\",\n                       \"VUID-vkCmdResolveImage-commonparent\", error_obj.location.dot(Field::dstImage));\n"
        },
        {
            "role": "user",
            "content": "{\"VUID-vkCmdSetEvent-event-parameter\", \"event must be a valid VkEvent handle\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "bool skip = false;\n// Checked by chassis: commandBuffer: \"VUID-vkCmdSetEvent-commandBuffer-parameter\"\n// Checked by chassis: commandBuffer: \"VUID-vkCmdSetEvent-commonparent\"\nskip |= ValidateObject(event, kVulkanObjectTypeEvent, false, \"VUID-vkCmdSetEvent-event-parameter\",\n                       \"VUID-vkCmdSetEvent-commonparent\", error_obj.location.dot(Field::event));\n"
        },
        {
            "role": "user",
            "content": "{\"VUID-vkCmdResetEvent-event-parameter\", \"event must be a valid VkEvent handle\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "bool skip = false;\n// Checked by chassis: commandBuffer: \"VUID-vkCmdResetEvent-commandBuffer-parameter\"\n// Checked by chassis: commandBuffer: \"VUID-vkCmdResetEvent-commonparent\"\nskip |= ValidateObject(event, kVulkanObjectTypeEvent, false, \"VUID-vkCmdResetEvent-event-parameter\",\n                       \"VUID-vkCmdResetEvent-commonparent\", error_obj.location.dot(Field::event));\n"
        },
        {
            "role": "user",
            "content": "{\"VUID-vkCmdWaitEvents-pEvents-parameter\", \"pEvents must be a valid pointer to an array of eventCount valid VkEvent handles\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if ((eventCount > 0) && (pEvents)) {\n    for (uint32_t index0 = 0; index0 < eventCount; ++index0) {\n        skip |= ValidateObject(pEvents[index0], kVulkanObjectTypeEvent, false, \"VUID-vkCmdWaitEvents-pEvents-parameter\",\n                               \"VUID-vkCmdWaitEvents-commonparent\", error_obj.location.dot(Field::pEvents, index0));\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-vkCmdEndQuery-queryPool-parameter\", \"queryPool must be a valid VkQueryPool handle\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "bool skip = false;\n// Checked by chassis: commandBuffer: \"VUID-vkCmdEndQuery-commandBuffer-parameter\"\n// Checked by chassis: commandBuffer: \"VUID-vkCmdEndQuery-commonparent\"\nskip |= ValidateObject(queryPool, kVulkanObjectTypeQueryPool, false, \"VUID-vkCmdEndQuery-queryPool-parameter\",\n                       \"VUID-vkCmdEndQuery-commonparent\", error_obj.location.dot(Field::queryPool));\n"
        },
        {
            "role": "user",
            "content": "{\"VUID-vkCmdResetQueryPool-queryPool-parameter\", \"queryPool must be a valid VkQueryPool handle\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "bool skip = false;\n// Checked by chassis: commandBuffer: \"VUID-vkCmdResetQueryPool-commandBuffer-parameter\"\n// Checked by chassis: commandBuffer: \"VUID-vkCmdResetQueryPool-commonparent\"\nskip |= ValidateObject(queryPool, kVulkanObjectTypeQueryPool, false, \"VUID-vkCmdResetQueryPool-queryPool-parameter\",\n                       \"VUID-vkCmdResetQueryPool-commonparent\", error_obj.location.dot(Field::queryPool));\n"
        },
        {
            "role": "user",
            "content": "{\"VUID-vkCmdWriteTimestamp-queryPool-parameter\", \"queryPool must be a valid VkQueryPool handle\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "bool skip = false;\n// Checked by chassis: commandBuffer: \"VUID-vkCmdWriteTimestamp-commandBuffer-parameter\"\n// Checked by chassis: commandBuffer: \"VUID-vkCmdWriteTimestamp-commonparent\"\nskip |= ValidateObject(queryPool, kVulkanObjectTypeQueryPool, false, \"VUID-vkCmdWriteTimestamp-queryPool-parameter\",\n                       \"VUID-vkCmdWriteTimestamp-commonparent\", error_obj.location.dot(Field::queryPool));\n"
        },
        {
            "role": "user",
            "content": "{\"VUID-vkCmdCopyQueryPoolResults-queryPool-parameter\", \"queryPool must be a valid VkQueryPool handle\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "bool skip = false;\n// Checked by chassis: commandBuffer: \"VUID-vkCmdCopyQueryPoolResults-commandBuffer-parameter\"\n// Checked by chassis: commandBuffer: \"VUID-vkCmdCopyQueryPoolResults-commonparent\"\nskip |= ValidateObject(queryPool, kVulkanObjectTypeQueryPool, false, \"VUID-vkCmdCopyQueryPoolResults-queryPool-parameter\",\n                       \"VUID-vkCmdCopyQueryPoolResults-commonparent\", error_obj.location.dot(Field::queryPool));\n"
        },
        {
            "role": "user",
            "content": "{\"VUID-vkCmdPushConstants-layout-parameter\", \"layout must be a valid VkPipelineLayout handle\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "bool skip = false;\n// Checked by chassis: commandBuffer: \"VUID-vkCmdPushConstants-commandBuffer-parameter\"\n// Checked by chassis: commandBuffer: \"VUID-vkCmdPushConstants-commonparent\"\nskip |= ValidateObject(layout, kVulkanObjectTypePipelineLayout, false, \"VUID-vkCmdPushConstants-layout-parameter\",\n                       \"VUID-vkCmdPushConstants-commonparent\", error_obj.location.dot(Field::layout));\n"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkImageMemoryRequirementsInfo2-image-parameter\", \"image must be a valid VkImage handle\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (pInfo) {\n    [[maybe_unused]] const Location pInfo_loc = error_obj.location.dot(Field::pInfo);\n    skip |= ValidateObject(pInfo->image, kVulkanObjectTypeImage, false, \"VUID-VkImageMemoryRequirementsInfo2-image-parameter\",\n                           \"UNASSIGNED-VkSemaphoreSignalInfo-image-parent\", pInfo_loc.dot(Field::image));\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-vkTrimCommandPool-commandPool-parameter\", \"commandPool must be a valid VkCommandPool handle\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "bool skip = false;\n// Checked by chassis: device: \"VUID-vkTrimCommandPool-device-parameter\"\nskip |= ValidateObject(commandPool, kVulkanObjectTypeCommandPool, false, \"VUID-vkTrimCommandPool-commandPool-parameter\",\n                       \"VUID-vkTrimCommandPool-commandPool-parent\", error_obj.location.dot(Field::commandPool));\n"
        },
        {
            "role": "user",
            "content": "{\"VUID-vkCmdDrawIndirectCount-buffer-parameter\", \"buffer must be a valid VkBuffer handle\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "bool skip = false;\n// Checked by chassis: commandBuffer: \"VUID-vkCmdDrawIndirectCount-commandBuffer-parameter\"\n// Checked by chassis: commandBuffer: \"VUID-vkCmdDrawIndirectCount-commonparent\"\nskip |= ValidateObject(buffer, kVulkanObjectTypeBuffer, false, \"VUID-vkCmdDrawIndirectCount-buffer-parameter\",\n                       \"VUID-vkCmdDrawIndirectCount-commonparent\", error_obj.location.dot(Field::buffer));\n"
        },
        {
            "role": "user",
            "content": "{\"VUID-vkCmdDrawIndexedIndirectCount-buffer-parameter\", \"buffer must be a valid VkBuffer handle\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "bool skip = false;\n// Checked by chassis: commandBuffer: \"VUID-vkCmdDrawIndexedIndirectCount-commandBuffer-parameter\"\n// Checked by chassis: commandBuffer: \"VUID-vkCmdDrawIndexedIndirectCount-commonparent\"\nskip |= ValidateObject(buffer, kVulkanObjectTypeBuffer, false, \"VUID-vkCmdDrawIndexedIndirectCount-buffer-parameter\",\n                       \"VUID-vkCmdDrawIndexedIndirectCount-commonparent\", error_obj.location.dot(Field::buffer));\n"
        },
        {
            "role": "user",
            "content": "{\"VUID-vkCmdDrawIndexedIndirectCount-countBuffer-parameter\", \"countBuffer must be a valid VkBuffer handle\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "// Checked by chassis: commandBuffer: \"VUID-vkCmdDrawIndexedIndirectCount-commonparent\"\nskip |= ValidateObject(buffer, kVulkanObjectTypeBuffer, false, \"VUID-vkCmdDrawIndexedIndirectCount-buffer-parameter\",\n                       \"VUID-vkCmdDrawIndexedIndirectCount-commonparent\", error_obj.location.dot(Field::buffer));\nskip |= ValidateObject(countBuffer, kVulkanObjectTypeBuffer, false, \"VUID-vkCmdDrawIndexedIndirectCount-countBuffer-parameter\",\n                       \"VUID-vkCmdDrawIndexedIndirectCount-commonparent\", error_obj.location.dot(Field::countBuffer));\n"
        },
        {
            "role": "user",
            "content": "{\"VUID-vkResetQueryPool-queryPool-parameter\", \"queryPool must be a valid VkQueryPool handle\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "bool skip = false;\n// Checked by chassis: device: \"VUID-vkResetQueryPool-device-parameter\"\nskip |= ValidateObject(queryPool, kVulkanObjectTypeQueryPool, false, \"VUID-vkResetQueryPool-queryPool-parameter\",\n                       \"VUID-vkResetQueryPool-queryPool-parent\", error_obj.location.dot(Field::queryPool));\n"
        },
        {
            "role": "user",
            "content": "{\"VUID-vkGetSemaphoreCounterValue-semaphore-parameter\", \"semaphore must be a valid VkSemaphore handle\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "bool skip = false;\n// Checked by chassis: device: \"VUID-vkGetSemaphoreCounterValue-device-parameter\"\nskip |= ValidateObject(semaphore, kVulkanObjectTypeSemaphore, false, \"VUID-vkGetSemaphoreCounterValue-semaphore-parameter\",\n                       \"VUID-vkGetSemaphoreCounterValue-semaphore-parent\", error_obj.location.dot(Field::semaphore));\n"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkBufferDeviceAddressInfo-buffer-parameter\", \"buffer must be a valid VkBuffer handle\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (pInfo) {\n    [[maybe_unused]] const Location pInfo_loc = error_obj.location.dot(Field::pInfo);\n    skip |= ValidateObject(pInfo->buffer, kVulkanObjectTypeBuffer, false, \"VUID-VkBufferDeviceAddressInfo-buffer-parameter\",\n                           \"UNASSIGNED-VkBufferDeviceAddressInfo-buffer-parent\", pInfo_loc.dot(Field::buffer));\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-vkCmdSetEvent2-event-parameter\", \"event must be a valid VkEvent handle\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "bool skip = false;\n// Checked by chassis: commandBuffer: \"VUID-vkCmdSetEvent2-commandBuffer-parameter\"\n// Checked by chassis: commandBuffer: \"VUID-vkCmdSetEvent2-commonparent\"\nskip |= ValidateObject(event, kVulkanObjectTypeEvent, false, \"VUID-vkCmdSetEvent2-event-parameter\",\n                       \"VUID-vkCmdSetEvent2-commonparent\", error_obj.location.dot(Field::event));\n"
        },
        {
            "role": "user",
            "content": "{\"VUID-vkCmdResetEvent2-event-parameter\", \"event must be a valid VkEvent handle\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "bool skip = false;\n// Checked by chassis: commandBuffer: \"VUID-vkCmdResetEvent2-commandBuffer-parameter\"\n// Checked by chassis: commandBuffer: \"VUID-vkCmdResetEvent2-commonparent\"\nskip |= ValidateObject(event, kVulkanObjectTypeEvent, false, \"VUID-vkCmdResetEvent2-event-parameter\",\n                       \"VUID-vkCmdResetEvent2-commonparent\", error_obj.location.dot(Field::event));\n"
        },
        {
            "role": "user",
            "content": "{\"VUID-vkCmdWaitEvents2-pEvents-parameter\", \"pEvents must be a valid pointer to an array of eventCount valid VkEvent handles\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if ((eventCount > 0) && (pEvents)) {\n    for (uint32_t index0 = 0; index0 < eventCount; ++index0) {\n        skip |= ValidateObject(pEvents[index0], kVulkanObjectTypeEvent, false, \"VUID-vkCmdWaitEvents2-pEvents-parameter\",\n                               \"VUID-vkCmdWaitEvents2-commonparent\", error_obj.location.dot(Field::pEvents, index0));\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-vkQueueSubmit2-fence-parameter\", \"If fence is not VK_NULL_HANDLE, fence must be a valid VkFence handle\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "skip |= ValidateObject(fence, kVulkanObjectTypeFence, true, \"VUID-vkQueueSubmit2-fence-parameter\",\n                       \"VUID-vkQueueSubmit2-commonparent\", error_obj.location.dot(Field::fence));\n"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkCopyImageInfo2-srcImage-parameter\", \"srcImage must be a valid VkImage handle\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (pCopyImageInfo) {\n    [[maybe_unused]] const Location pCopyImageInfo_loc = error_obj.location.dot(Field::pCopyImageInfo);\n    skip |= ValidateObject(pCopyImageInfo->srcImage, kVulkanObjectTypeImage, false, \"VUID-VkCopyImageInfo2-srcImage-parameter\",\n                           \"VUID-VkCopyImageInfo2-commonparent\", pCopyImageInfo_loc.dot(Field::srcImage));\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkCopyImageInfo2-dstImage-parameter\", \"dstImage must be a valid VkImage handle\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "[[maybe_unused]] const Location pCopyImageInfo_loc = error_obj.location.dot(Field::pCopyImageInfo);\nskip |= ValidateObject(pCopyImageInfo->srcImage, kVulkanObjectTypeImage, false, \"VUID-VkCopyImageInfo2-srcImage-parameter\",\n                       \"VUID-VkCopyImageInfo2-commonparent\", pCopyImageInfo_loc.dot(Field::srcImage));\nskip |= ValidateObject(pCopyImageInfo->dstImage, kVulkanObjectTypeImage, false, \"VUID-VkCopyImageInfo2-dstImage-parameter\",\n                       \"VUID-VkCopyImageInfo2-commonparent\", pCopyImageInfo_loc.dot(Field::dstImage));\n"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkBlitImageInfo2-srcImage-parameter\", \"srcImage must be a valid VkImage handle\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (pBlitImageInfo) {\n    [[maybe_unused]] const Location pBlitImageInfo_loc = error_obj.location.dot(Field::pBlitImageInfo);\n    skip |= ValidateObject(pBlitImageInfo->srcImage, kVulkanObjectTypeImage, false, \"VUID-VkBlitImageInfo2-srcImage-parameter\",\n                           \"VUID-VkBlitImageInfo2-commonparent\", pBlitImageInfo_loc.dot(Field::srcImage));\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-vkDestroySurfaceKHR-surface-parameter\", \"If surface is not VK_NULL_HANDLE, surface must be a valid VkSurfaceKHR handle\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "bool skip = false;\n// Checked by chassis: instance: \"VUID-vkDestroySurfaceKHR-instance-parameter\"\nskip |= ValidateObject(surface, kVulkanObjectTypeSurfaceKHR, true, \"VUID-vkDestroySurfaceKHR-surface-parameter\",\n                       \"VUID-vkDestroySurfaceKHR-surface-parent\", error_obj.location.dot(Field::surface),\n                       kVulkanObjectTypeInstance);\n"
        },
        {
            "role": "user",
            "content": "{\"VUID-vkDestroySurfaceKHR-surface-01267\", \"If VkAllocationCallbacks were provided when surface was created, a compatible set of callbacks must be provided here\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "skip |= ValidateObject(surface, kVulkanObjectTypeSurfaceKHR, true, \"VUID-vkDestroySurfaceKHR-surface-parameter\",\n                       \"VUID-vkDestroySurfaceKHR-surface-parent\", error_obj.location.dot(Field::surface),\nskip |= ValidateDestroyObject(surface, kVulkanObjectTypeSurfaceKHR, pAllocator, \"VUID-vkDestroySurfaceKHR-surface-01267\",\n                              \"VUID-vkDestroySurfaceKHR-surface-01268\", error_obj.location);\n"
        },
        {
            "role": "user",
            "content": "{\"VUID-vkDestroySwapchainKHR-swapchain-parameter\", \"If swapchain is not VK_NULL_HANDLE, swapchain must be a valid VkSwapchainKHR handle\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "bool skip = false;\n// Checked by chassis: device: \"VUID-vkDestroySwapchainKHR-device-parameter\"\nskip |= ValidateObject(swapchain, kVulkanObjectTypeSwapchainKHR, true, \"VUID-vkDestroySwapchainKHR-swapchain-parameter\",\n                       \"VUID-vkDestroySwapchainKHR-swapchain-parent\", error_obj.location.dot(Field::swapchain));\n"
        },
        {
            "role": "user",
            "content": "{\"VUID-vkGetSwapchainImagesKHR-swapchain-parameter\", \"swapchain must be a valid VkSwapchainKHR handle\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "bool skip = false;\n// Checked by chassis: device: \"VUID-vkGetSwapchainImagesKHR-device-parameter\"\nskip |= ValidateObject(swapchain, kVulkanObjectTypeSwapchainKHR, false, \"VUID-vkGetSwapchainImagesKHR-swapchain-parameter\",\n                       \"VUID-vkGetSwapchainImagesKHR-swapchain-parent\", error_obj.location.dot(Field::swapchain));\n"
        },
        {
            "role": "user",
            "content": "{\"VUID-vkAcquireNextImageKHR-semaphore-parameter\", \"If semaphore is not VK_NULL_HANDLE, semaphore must be a valid VkSemaphore handle\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "// Checked by chassis: device: \"VUID-vkAcquireNextImageKHR-device-parameter\"\nskip |= ValidateObject(swapchain, kVulkanObjectTypeSwapchainKHR, false, \"VUID-vkAcquireNextImageKHR-swapchain-parameter\",\n                       \"VUID-vkAcquireNextImageKHR-swapchain-parent\", error_obj.location.dot(Field::swapchain));\nskip |= ValidateObject(semaphore, kVulkanObjectTypeSemaphore, true, \"VUID-vkAcquireNextImageKHR-semaphore-parameter\",\n                       \"VUID-vkAcquireNextImageKHR-semaphore-parent\", error_obj.location.dot(Field::semaphore));\n"
        },
        {
            "role": "user",
            "content": "{\"VUID-vkAcquireNextImageKHR-fence-parameter\", \"If fence is not VK_NULL_HANDLE, fence must be a valid VkFence handle\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "\"VUID-vkAcquireNextImageKHR-swapchain-parent\", error_obj.location.dot(Field::swapchain));\nskip |= ValidateObject(semaphore, kVulkanObjectTypeSemaphore, true, \"VUID-vkAcquireNextImageKHR-semaphore-parameter\",\n\"VUID-vkAcquireNextImageKHR-semaphore-parent\", error_obj.location.dot(Field::semaphore));\nskip |= ValidateObject(fence, kVulkanObjectTypeFence, true, \"VUID-vkAcquireNextImageKHR-fence-parameter\",\n\"VUID-vkAcquireNextImageKHR-fence-parent\", error_obj.location.dot(Field::fence));\n"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkAcquireNextImageInfoKHR-fence-parameter\", \"If fence is not VK_NULL_HANDLE, fence must be a valid VkFence handle\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "skip |= ValidateObject(pAcquireInfo->semaphore, kVulkanObjectTypeSemaphore, true,\n                       \"VUID-VkAcquireNextImageInfoKHR-semaphore-parameter\", \"VUID-VkAcquireNextImageInfoKHR-commonparent\",\nskip |= ValidateObject(pAcquireInfo->fence, kVulkanObjectTypeFence, true, \"VUID-VkAcquireNextImageInfoKHR-fence-parameter\",\n                       \"VUID-VkAcquireNextImageInfoKHR-commonparent\", pAcquireInfo_loc.dot(Field::fence));\n"
        },
        {
            "role": "user",
            "content": "{\"VUID-vkGetDisplayModePropertiesKHR-display-parameter\", \"display must be a valid VkDisplayKHR handle\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "bool skip = false;\n// Checked by chassis: physicalDevice: \"VUID-vkGetDisplayModePropertiesKHR-physicalDevice-parameter\"\nskip |= ValidateObject(display, kVulkanObjectTypeDisplayKHR, false, \"VUID-vkGetDisplayModePropertiesKHR-display-parameter\",\n                       \"VUID-vkGetDisplayModePropertiesKHR-display-parent\", error_obj.location.dot(Field::display),\n                       kVulkanObjectTypePhysicalDevice);\n"
        },
        {
            "role": "user",
            "content": "{\"VUID-vkGetDisplayPlaneCapabilitiesKHR-mode-parameter\", \"mode must be a valid VkDisplayModeKHR handle\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "bool skip = false;\n// Checked by chassis: physicalDevice: \"VUID-vkGetDisplayPlaneCapabilitiesKHR-physicalDevice-parameter\"\nskip |= ValidateObject(mode, kVulkanObjectTypeDisplayModeKHR, false, \"VUID-vkGetDisplayPlaneCapabilitiesKHR-mode-parameter\",\n                       \"VUID-vkGetDisplayPlaneCapabilitiesKHR-mode-parent\", error_obj.location.dot(Field::mode),\n                       kVulkanObjectTypePhysicalDevice);\n"
        },
        {
            "role": "user",
            "content": "{\"VUID-vkGetSwapchainStatusKHR-swapchain-parameter\", \"swapchain must be a valid VkSwapchainKHR handle\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "bool skip = false;\n// Checked by chassis: device: \"VUID-vkGetSwapchainStatusKHR-device-parameter\"\nskip |= ValidateObject(swapchain, kVulkanObjectTypeSwapchainKHR, false, \"VUID-vkGetSwapchainStatusKHR-swapchain-parameter\",\n                       \"VUID-vkGetSwapchainStatusKHR-swapchain-parent\", error_obj.location.dot(Field::swapchain));\n"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkFenceGetFdInfoKHR-fence-parameter\", \"fence must be a valid VkFence handle\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (pGetFdInfo) {\n    [[maybe_unused]] const Location pGetFdInfo_loc = error_obj.location.dot(Field::pGetFdInfo);\n    skip |= ValidateObject(pGetFdInfo->fence, kVulkanObjectTypeFence, false, \"VUID-VkFenceGetFdInfoKHR-fence-parameter\",\n                           \"UNASSIGNED-VkFenceGetFdInfoKHR-fence-parent\", pGetFdInfo_loc.dot(Field::fence));\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-vkGetDisplayModeProperties2KHR-display-parameter\", \"display must be a valid VkDisplayKHR handle\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "bool skip = false;\n// Checked by chassis: physicalDevice: \"VUID-vkGetDisplayModeProperties2KHR-physicalDevice-parameter\"\nskip |= ValidateObject(display, kVulkanObjectTypeDisplayKHR, false, \"VUID-vkGetDisplayModeProperties2KHR-display-parameter\",\n                       \"VUID-vkGetDisplayModeProperties2KHR-display-parent\", error_obj.location.dot(Field::display),\n                       kVulkanObjectTypePhysicalDevice);\n"
        },
        {
            "role": "user",
            "content": "{\"VUID-vkCmdWriteBufferMarker2AMD-dstBuffer-parameter\", \"dstBuffer must be a valid VkBuffer handle\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "bool skip = false;\n// Checked by chassis: commandBuffer: \"VUID-vkCmdWriteBufferMarker2AMD-commandBuffer-parameter\"\n// Checked by chassis: commandBuffer: \"VUID-vkCmdWriteBufferMarker2AMD-commonparent\"\nskip |= ValidateObject(dstBuffer, kVulkanObjectTypeBuffer, false, \"VUID-vkCmdWriteBufferMarker2AMD-dstBuffer-parameter\",\n                       \"VUID-vkCmdWriteBufferMarker2AMD-commonparent\", error_obj.location.dot(Field::dstBuffer));\n"
        },
        {
            "role": "user",
            "content": "{\"VUID-vkCmdBindIndexBuffer2KHR-buffer-parameter\", \"If buffer is not VK_NULL_HANDLE, buffer must be a valid VkBuffer handle\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "bool skip = false;\n// Checked by chassis: commandBuffer: \"VUID-vkCmdBindIndexBuffer2KHR-commandBuffer-parameter\"\n// Checked by chassis: commandBuffer: \"VUID-vkCmdBindIndexBuffer2KHR-commonparent\"\nskip |= ValidateObject(buffer, kVulkanObjectTypeBuffer, true, \"VUID-vkCmdBindIndexBuffer2KHR-buffer-parameter\",\n                       \"VUID-vkCmdBindIndexBuffer2KHR-commonparent\", error_obj.location.dot(Field::buffer));\n"
        },
        {
            "role": "user",
            "content": "{\"VUID-vkGetImageSubresourceLayout2KHR-image-parameter\", \"image must be a valid VkImage handle\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "bool skip = false;\n// Checked by chassis: device: \"VUID-vkGetImageSubresourceLayout2KHR-device-parameter\"\nskip |= ValidateObject(image, kVulkanObjectTypeImage, false, \"VUID-vkGetImageSubresourceLayout2KHR-image-parameter\",\n                       \"VUID-vkGetImageSubresourceLayout2KHR-image-parent\", error_obj.location.dot(Field::image));\n"
        },
        {
            "role": "user",
            "content": "{\"VUID-vkCmdCopyMemoryToImageIndirectKHR-dstImage-parameter\", \"dstImage must be a valid VkImage handle\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "bool skip = false;\n// Checked by chassis: commandBuffer: \"VUID-vkCmdCopyMemoryToImageIndirectKHR-commandBuffer-parameter\"\n// Checked by chassis: commandBuffer: \"VUID-vkCmdCopyMemoryToImageIndirectKHR-commonparent\"\nskip |= ValidateObject(dstImage, kVulkanObjectTypeImage, false, \"VUID-vkCmdCopyMemoryToImageIndirectKHR-dstImage-parameter\",\n                       \"VUID-vkCmdCopyMemoryToImageIndirectKHR-commonparent\", error_obj.location.dot(Field::dstImage));\n"
        },
        {
            "role": "user",
            "content": "{\"VUID-vkCmdEndQueryIndexedEXT-queryPool-parameter\", \"queryPool must be a valid VkQueryPool handle\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "bool skip = false;\n// Checked by chassis: commandBuffer: \"VUID-vkCmdEndQueryIndexedEXT-commandBuffer-parameter\"\n// Checked by chassis: commandBuffer: \"VUID-vkCmdEndQueryIndexedEXT-commonparent\"\nskip |= ValidateObject(queryPool, kVulkanObjectTypeQueryPool, false, \"VUID-vkCmdEndQueryIndexedEXT-queryPool-parameter\",\n                       \"VUID-vkCmdEndQueryIndexedEXT-commonparent\", error_obj.location.dot(Field::queryPool));\n"
        },
        {
            "role": "user",
            "content": "{\"VUID-vkDestroyCuModuleNVX-module-parameter\", \"module must be a valid VkCuModuleNVX handle\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "bool skip = false;\n// Checked by chassis: device: \"VUID-vkDestroyCuModuleNVX-device-parameter\"\nskip |= ValidateObject(module, kVulkanObjectTypeCuModuleNVX, false, \"VUID-vkDestroyCuModuleNVX-module-parameter\",\n                       \"VUID-vkDestroyCuModuleNVX-module-parent\", error_obj.location.dot(Field::module));\n"
        },
        {
            "role": "user",
            "content": "{\"VUID-vkDestroyCuFunctionNVX-function-parameter\", \"function must be a valid VkCuFunctionNVX handle\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "bool skip = false;\n// Checked by chassis: device: \"VUID-vkDestroyCuFunctionNVX-device-parameter\"\nskip |= ValidateObject(function, kVulkanObjectTypeCuFunctionNVX, false, \"VUID-vkDestroyCuFunctionNVX-function-parameter\",\n                       \"VUID-vkDestroyCuFunctionNVX-function-parent\", error_obj.location.dot(Field::function));\n"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkImageViewHandleInfoNVX-sampler-parameter\", \"If sampler is not VK_NULL_HANDLE, sampler must be a valid VkSampler handle\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "skip |=\n    ValidateObject(pInfo->imageView, kVulkanObjectTypeImageView, false, \"VUID-VkImageViewHandleInfoNVX-imageView-parameter\",\n                   \"VUID-VkImageViewHandleInfoNVX-commonparent\", pInfo_loc.dot(Field::imageView));\nskip |= ValidateObject(pInfo->sampler, kVulkanObjectTypeSampler, true, \"VUID-VkImageViewHandleInfoNVX-sampler-parameter\",\n                       \"VUID-VkImageViewHandleInfoNVX-commonparent\", pInfo_loc.dot(Field::sampler));\n"
        },
        {
            "role": "user",
            "content": "{\"VUID-vkGetShaderInfoAMD-pipeline-parameter\", \"pipeline must be a valid VkPipeline handle\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "bool skip = false;\n// Checked by chassis: device: \"VUID-vkGetShaderInfoAMD-device-parameter\"\nskip |= ValidateObject(pipeline, kVulkanObjectTypePipeline, false, \"VUID-vkGetShaderInfoAMD-pipeline-parameter\",\n                       \"VUID-vkGetShaderInfoAMD-pipeline-parent\", error_obj.location.dot(Field::pipeline));\n"
        },
        {
            "role": "user",
            "content": "{\"VUID-vkGetMemoryWin32HandleNV-memory-parameter\", \"memory must be a valid VkDeviceMemory handle\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "bool skip = false;\n// Checked by chassis: device: \"VUID-vkGetMemoryWin32HandleNV-device-parameter\"\nskip |= ValidateObject(memory, kVulkanObjectTypeDeviceMemory, false, \"VUID-vkGetMemoryWin32HandleNV-memory-parameter\",\n                       \"VUID-vkGetMemoryWin32HandleNV-memory-parent\", error_obj.location.dot(Field::memory));\n"
        },
        {
            "role": "user",
            "content": "{\"VUID-vkReleaseDisplayEXT-display-parameter\", \"display must be a valid VkDisplayKHR handle\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "bool skip = false;\n// Checked by chassis: physicalDevice: \"VUID-vkReleaseDisplayEXT-physicalDevice-parameter\"\nskip |= ValidateObject(display, kVulkanObjectTypeDisplayKHR, false, \"VUID-vkReleaseDisplayEXT-display-parameter\",\n                       \"VUID-vkReleaseDisplayEXT-display-parent\", error_obj.location.dot(Field::display),\n                       kVulkanObjectTypePhysicalDevice);\n"
        },
        {
            "role": "user",
            "content": "{\"VUID-vkAcquireXlibDisplayEXT-display-parameter\", \"display must be a valid VkDisplayKHR handle\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "bool skip = false;\n// Checked by chassis: physicalDevice: \"VUID-vkAcquireXlibDisplayEXT-physicalDevice-parameter\"\nskip |= ValidateObject(display, kVulkanObjectTypeDisplayKHR, false, \"VUID-vkAcquireXlibDisplayEXT-display-parameter\",\n                       \"VUID-vkAcquireXlibDisplayEXT-display-parent\", error_obj.location.dot(Field::display),\n                       kVulkanObjectTypePhysicalDevice);\n"
        },
        {
            "role": "user",
            "content": "{\"VUID-vkGetImageDrmFormatModifierPropertiesEXT-image-parameter\", \"image must be a valid VkImage handle\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "bool skip = false;\n// Checked by chassis: device: \"VUID-vkGetImageDrmFormatModifierPropertiesEXT-device-parameter\"\nskip |= ValidateObject(image, kVulkanObjectTypeImage, false, \"VUID-vkGetImageDrmFormatModifierPropertiesEXT-image-parameter\",\n                       \"VUID-vkGetImageDrmFormatModifierPropertiesEXT-image-parent\", error_obj.location.dot(Field::image));\n"
        },
        {
            "role": "user",
            "content": "{\"VUID-vkCmdBindShadingRateImageNV-imageView-parameter\", \"If imageView is not VK_NULL_HANDLE, imageView must be a valid VkImageView handle\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "bool skip = false;\n// Checked by chassis: commandBuffer: \"VUID-vkCmdBindShadingRateImageNV-commandBuffer-parameter\"\n// Checked by chassis: commandBuffer: \"VUID-vkCmdBindShadingRateImageNV-commonparent\"\nskip |= ValidateObject(imageView, kVulkanObjectTypeImageView, true, \"VUID-vkCmdBindShadingRateImageNV-imageView-parameter\",\n                       \"VUID-vkCmdBindShadingRateImageNV-commonparent\", error_obj.location.dot(Field::imageView));\n"
        },
        {
            "role": "user",
            "content": "{\"VUID-vkCmdBuildAccelerationStructureNV-scratch-parameter\", \"scratch must be a valid VkBuffer handle\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "skip |=\n    ValidateObject(src, kVulkanObjectTypeAccelerationStructureNV, true, \"VUID-vkCmdBuildAccelerationStructureNV-src-parameter\",\n                   \"VUID-vkCmdBuildAccelerationStructureNV-commonparent\", error_obj.location.dot(Field::src));\nskip |= ValidateObject(scratch, kVulkanObjectTypeBuffer, false, \"VUID-vkCmdBuildAccelerationStructureNV-scratch-parameter\",\n                       \"VUID-vkCmdBuildAccelerationStructureNV-commonparent\", error_obj.location.dot(Field::scratch));\n"
        },
        {
            "role": "user",
            "content": "{\"VUID-vkCompileDeferredNV-pipeline-parameter\", \"pipeline must be a valid VkPipeline handle\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "bool skip = false;\n// Checked by chassis: device: \"VUID-vkCompileDeferredNV-device-parameter\"\nskip |= ValidateObject(pipeline, kVulkanObjectTypePipeline, false, \"VUID-vkCompileDeferredNV-pipeline-parameter\",\n                       \"VUID-vkCompileDeferredNV-pipeline-parent\", error_obj.location.dot(Field::pipeline));\n"
        },
        {
            "role": "user",
            "content": "{\"VUID-vkCmdDrawMeshTasksIndirectNV-buffer-parameter\", \"buffer must be a valid VkBuffer handle\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "bool skip = false;\n// Checked by chassis: commandBuffer: \"VUID-vkCmdDrawMeshTasksIndirectNV-commandBuffer-parameter\"\n// Checked by chassis: commandBuffer: \"VUID-vkCmdDrawMeshTasksIndirectNV-commonparent\"\nskip |= ValidateObject(buffer, kVulkanObjectTypeBuffer, false, \"VUID-vkCmdDrawMeshTasksIndirectNV-buffer-parameter\",\n                       \"VUID-vkCmdDrawMeshTasksIndirectNV-commonparent\", error_obj.location.dot(Field::buffer));\n"
        },
        {
            "role": "user",
            "content": "{\"VUID-vkCmdDrawMeshTasksIndirectCountNV-buffer-parameter\", \"buffer must be a valid VkBuffer handle\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "bool skip = false;\n// Checked by chassis: commandBuffer: \"VUID-vkCmdDrawMeshTasksIndirectCountNV-commandBuffer-parameter\"\n// Checked by chassis: commandBuffer: \"VUID-vkCmdDrawMeshTasksIndirectCountNV-commonparent\"\nskip |= ValidateObject(buffer, kVulkanObjectTypeBuffer, false, \"VUID-vkCmdDrawMeshTasksIndirectCountNV-buffer-parameter\",\n                       \"VUID-vkCmdDrawMeshTasksIndirectCountNV-commonparent\", error_obj.location.dot(Field::buffer));\n"
        },
        {
            "role": "user",
            "content": "{\"VUID-vkSetLocalDimmingAMD-swapChain-parameter\", \"swapChain must be a valid VkSwapchainKHR handle\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "bool skip = false;\n// Checked by chassis: device: \"VUID-vkSetLocalDimmingAMD-device-parameter\"\nskip |= ValidateObject(swapChain, kVulkanObjectTypeSwapchainKHR, false, \"VUID-vkSetLocalDimmingAMD-swapChain-parameter\",\n                       \"VUID-vkSetLocalDimmingAMD-swapChain-parent\", error_obj.location.dot(Field::swapChain));\n"
        },
        {
            "role": "user",
            "content": "{\"VUID-vkCmdBindPipelineShaderGroupNV-pipeline-parameter\", \"pipeline must be a valid VkPipeline handle\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "bool skip = false;\n// Checked by chassis: commandBuffer: \"VUID-vkCmdBindPipelineShaderGroupNV-commandBuffer-parameter\"\n// Checked by chassis: commandBuffer: \"VUID-vkCmdBindPipelineShaderGroupNV-commonparent\"\nskip |= ValidateObject(pipeline, kVulkanObjectTypePipeline, false, \"VUID-vkCmdBindPipelineShaderGroupNV-pipeline-parameter\",\n                       \"VUID-vkCmdBindPipelineShaderGroupNV-commonparent\", error_obj.location.dot(Field::pipeline));\n"
        },
        {
            "role": "user",
            "content": "{\"VUID-vkGetCudaModuleCacheNV-module-parameter\", \"module must be a valid VkCudaModuleNV handle\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "bool skip = false;\n// Checked by chassis: device: \"VUID-vkGetCudaModuleCacheNV-device-parameter\"\nskip |= ValidateObject(module, kVulkanObjectTypeCudaModuleNV, false, \"VUID-vkGetCudaModuleCacheNV-module-parameter\",\n                       \"VUID-vkGetCudaModuleCacheNV-module-parent\", error_obj.location.dot(Field::module));\n"
        },
        {
            "role": "user",
            "content": "{\"VUID-vkDestroyCudaModuleNV-module-parameter\", \"module must be a valid VkCudaModuleNV handle\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "bool skip = false;\n// Checked by chassis: device: \"VUID-vkDestroyCudaModuleNV-device-parameter\"\nskip |= ValidateObject(module, kVulkanObjectTypeCudaModuleNV, false, \"VUID-vkDestroyCudaModuleNV-module-parameter\",\n                       \"VUID-vkDestroyCudaModuleNV-module-parent\", error_obj.location.dot(Field::module));\n"
        },
        {
            "role": "user",
            "content": "{\"VUID-vkDestroyCudaFunctionNV-function-parameter\", \"function must be a valid VkCudaFunctionNV handle\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "bool skip = false;\n// Checked by chassis: device: \"VUID-vkDestroyCudaFunctionNV-device-parameter\"\nskip |= ValidateObject(function, kVulkanObjectTypeCudaFunctionNV, false, \"VUID-vkDestroyCudaFunctionNV-function-parameter\",\n                       \"VUID-vkDestroyCudaFunctionNV-function-parent\", error_obj.location.dot(Field::function));\n"
        },
        {
            "role": "user",
            "content": "{\"VUID-vkAcquireWinrtDisplayNV-display-parameter\", \"display must be a valid VkDisplayKHR handle\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "bool skip = false;\n// Checked by chassis: physicalDevice: \"VUID-vkAcquireWinrtDisplayNV-physicalDevice-parameter\"\nskip |= ValidateObject(display, kVulkanObjectTypeDisplayKHR, false, \"VUID-vkAcquireWinrtDisplayNV-display-parameter\",\n                       \"VUID-vkAcquireWinrtDisplayNV-display-parent\", error_obj.location.dot(Field::display),\n                       kVulkanObjectTypePhysicalDevice);\n"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkMicromapCreateInfoEXT-buffer-parameter\", \"buffer must be a valid VkBuffer handle\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (pCreateInfo) {\n    [[maybe_unused]] const Location pCreateInfo_loc = error_obj.location.dot(Field::pCreateInfo);\n    skip |= ValidateObject(pCreateInfo->buffer, kVulkanObjectTypeBuffer, false, \"VUID-VkMicromapCreateInfoEXT-buffer-parameter\",\n                           \"UNASSIGNED-VkMicromapCreateInfoEXT-buffer-parent\", pCreateInfo_loc.dot(Field::buffer));\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-vkDestroyMicromapEXT-micromap-parameter\", \"If micromap is not VK_NULL_HANDLE, micromap must be a valid VkMicromapEXT handle\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "bool skip = false;\n// Checked by chassis: device: \"VUID-vkDestroyMicromapEXT-device-parameter\"\nskip |= ValidateObject(micromap, kVulkanObjectTypeMicromapEXT, true, \"VUID-vkDestroyMicromapEXT-micromap-parameter\",\n                       \"VUID-vkDestroyMicromapEXT-micromap-parent\", error_obj.location.dot(Field::micromap));\n"
        },
        {
            "role": "user",
            "content": "{\"VUID-vkDestroyMicromapEXT-micromap-07442\", \"If VkAllocationCallbacks were provided when micromap was created, a compatible set of callbacks must be provided here\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "// Checked by chassis: device: \"VUID-vkDestroyMicromapEXT-device-parameter\"\nskip |= ValidateObject(micromap, kVulkanObjectTypeMicromapEXT, true, \"VUID-vkDestroyMicromapEXT-micromap-parameter\",\n                       \"VUID-vkDestroyMicromapEXT-micromap-parent\", error_obj.location.dot(Field::micromap));\nskip |= ValidateDestroyObject(micromap, kVulkanObjectTypeMicromapEXT, pAllocator, \"VUID-vkDestroyMicromapEXT-micromap-07442\",\n                              \"VUID-vkDestroyMicromapEXT-micromap-07443\", error_obj.location);\n"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkCopyMicromapInfoEXT-src-parameter\", \"src must be a valid VkMicromapEXT handle\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (pInfo) {\n    [[maybe_unused]] const Location pInfo_loc = error_obj.location.dot(Field::pInfo);\n    skip |= ValidateObject(pInfo->src, kVulkanObjectTypeMicromapEXT, false, \"VUID-VkCopyMicromapInfoEXT-src-parameter\",\n                           \"VUID-VkCopyMicromapInfoEXT-commonparent\", pInfo_loc.dot(Field::src));\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkCopyMicromapInfoEXT-dst-parameter\", \"dst must be a valid VkMicromapEXT handle\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "[[maybe_unused]] const Location pInfo_loc = error_obj.location.dot(Field::pInfo);\nskip |= ValidateObject(pInfo->src, kVulkanObjectTypeMicromapEXT, false, \"VUID-VkCopyMicromapInfoEXT-src-parameter\",\n                       \"VUID-VkCopyMicromapInfoEXT-commonparent\", pInfo_loc.dot(Field::src));\nskip |= ValidateObject(pInfo->dst, kVulkanObjectTypeMicromapEXT, false, \"VUID-VkCopyMicromapInfoEXT-dst-parameter\",\n                       \"VUID-VkCopyMicromapInfoEXT-commonparent\", pInfo_loc.dot(Field::dst));\n"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkCopyMicromapInfoEXT-dst-parameter\", \"dst must be a valid VkMicromapEXT handle\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "[[maybe_unused]] const Location pInfo_loc = error_obj.location.dot(Field::pInfo);\nskip |= ValidateObject(pInfo->src, kVulkanObjectTypeMicromapEXT, false, \"VUID-VkCopyMicromapInfoEXT-src-parameter\",\n                       \"VUID-VkCopyMicromapInfoEXT-commonparent\", pInfo_loc.dot(Field::src));\nskip |= ValidateObject(pInfo->dst, kVulkanObjectTypeMicromapEXT, false, \"VUID-VkCopyMicromapInfoEXT-dst-parameter\",\n                       \"VUID-VkCopyMicromapInfoEXT-commonparent\", pInfo_loc.dot(Field::dst));\n"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkCopyMicromapToMemoryInfoEXT-src-parameter\", \"src must be a valid VkMicromapEXT handle\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (pInfo) {\n    [[maybe_unused]] const Location pInfo_loc = error_obj.location.dot(Field::pInfo);\n    skip |= ValidateObject(pInfo->src, kVulkanObjectTypeMicromapEXT, false, \"VUID-VkCopyMicromapToMemoryInfoEXT-src-parameter\",\n                           \"UNASSIGNED-VkCopyMicromapToMemoryInfoEXT-src-parent\", pInfo_loc.dot(Field::src));\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkCopyMicromapToMemoryInfoEXT-src-parameter\", \"src must be a valid VkMicromapEXT handle\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (pInfo) {\n    [[maybe_unused]] const Location pInfo_loc = error_obj.location.dot(Field::pInfo);\n    skip |= ValidateObject(pInfo->src, kVulkanObjectTypeMicromapEXT, false, \"VUID-VkCopyMicromapToMemoryInfoEXT-src-parameter\",\n                           \"UNASSIGNED-VkCopyMicromapToMemoryInfoEXT-src-parent\", pInfo_loc.dot(Field::src));\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkCopyMemoryToMicromapInfoEXT-dst-parameter\", \"dst must be a valid VkMicromapEXT handle\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (pInfo) {\n    [[maybe_unused]] const Location pInfo_loc = error_obj.location.dot(Field::pInfo);\n    skip |= ValidateObject(pInfo->dst, kVulkanObjectTypeMicromapEXT, false, \"VUID-VkCopyMemoryToMicromapInfoEXT-dst-parameter\",\n                           \"UNASSIGNED-VkCopyMemoryToMicromapInfoEXT-dst-parent\", pInfo_loc.dot(Field::dst));\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-vkCmdDrawClusterIndirectHUAWEI-buffer-parameter\", \"buffer must be a valid VkBuffer handle\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "bool skip = false;\n// Checked by chassis: commandBuffer: \"VUID-vkCmdDrawClusterIndirectHUAWEI-commandBuffer-parameter\"\n// Checked by chassis: commandBuffer: \"VUID-vkCmdDrawClusterIndirectHUAWEI-commonparent\"\nskip |= ValidateObject(buffer, kVulkanObjectTypeBuffer, false, \"VUID-vkCmdDrawClusterIndirectHUAWEI-buffer-parameter\",\n                       \"VUID-vkCmdDrawClusterIndirectHUAWEI-commonparent\", error_obj.location.dot(Field::buffer));\n"
        },
        {
            "role": "user",
            "content": "{\"VUID-vkSetDeviceMemoryPriorityEXT-memory-parameter\", \"memory must be a valid VkDeviceMemory handle\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "bool skip = false;\n// Checked by chassis: device: \"VUID-vkSetDeviceMemoryPriorityEXT-device-parameter\"\nskip |= ValidateObject(memory, kVulkanObjectTypeDeviceMemory, false, \"VUID-vkSetDeviceMemoryPriorityEXT-memory-parameter\",\n                       \"VUID-vkSetDeviceMemoryPriorityEXT-memory-parent\", error_obj.location.dot(Field::memory));\n"
        },
        {
            "role": "user",
            "content": "{\"VUID-vkBindOpticalFlowSessionImageNV-view-parameter\", \"If view is not VK_NULL_HANDLE, view must be a valid VkImageView handle\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "skip |= ValidateObject(session, kVulkanObjectTypeOpticalFlowSessionNV, false,\n                       \"VUID-vkBindOpticalFlowSessionImageNV-session-parameter\",\n                       \"VUID-vkBindOpticalFlowSessionImageNV-session-parent\", error_obj.location.dot(Field::session));\nskip |= ValidateObject(view, kVulkanObjectTypeImageView, true, \"VUID-vkBindOpticalFlowSessionImageNV-view-parameter\",\n                       \"VUID-vkBindOpticalFlowSessionImageNV-view-parent\", error_obj.location.dot(Field::view));\n"
        },
        {
            "role": "user",
            "content": "{\"VUID-vkDestroyShaderEXT-pAllocator-08483\", \"If VkAllocationCallbacks were provided when shader was created, a compatible set of callbacks must be provided here\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "// Checked by chassis: device: \"VUID-vkDestroyShaderEXT-device-parameter\"\nskip |= ValidateObject(shader, kVulkanObjectTypeShaderEXT, true, \"VUID-vkDestroyShaderEXT-shader-parameter\",\n                       \"VUID-vkDestroyShaderEXT-shader-parent\", error_obj.location.dot(Field::shader));\nskip |= ValidateDestroyObject(shader, kVulkanObjectTypeShaderEXT, pAllocator, \"VUID-vkDestroyShaderEXT-pAllocator-08483\",\n                              \"VUID-vkDestroyShaderEXT-pAllocator-08484\", error_obj.location);\n"
        },
        {
            "role": "user",
            "content": "{\"VUID-vkGetShaderBinaryDataEXT-shader-parameter\", \"shader must be a valid VkShaderEXT handle\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "bool skip = false;\n// Checked by chassis: device: \"VUID-vkGetShaderBinaryDataEXT-device-parameter\"\nskip |= ValidateObject(shader, kVulkanObjectTypeShaderEXT, false, \"VUID-vkGetShaderBinaryDataEXT-shader-parameter\",\n                       \"VUID-vkGetShaderBinaryDataEXT-shader-parent\", error_obj.location.dot(Field::shader));\n"
        },
        {
            "role": "user",
            "content": "{\"VUID-vkSetLatencySleepModeNV-swapchain-parameter\", \"swapchain must be a valid VkSwapchainKHR handle\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "bool skip = false;\n// Checked by chassis: device: \"VUID-vkSetLatencySleepModeNV-device-parameter\"\nskip |= ValidateObject(swapchain, kVulkanObjectTypeSwapchainKHR, false, \"VUID-vkSetLatencySleepModeNV-swapchain-parameter\",\n                       \"VUID-vkSetLatencySleepModeNV-swapchain-parent\", error_obj.location.dot(Field::swapchain));\n"
        },
        {
            "role": "user",
            "content": "{\"VUID-vkLatencySleepNV-swapchain-parameter\", \"swapchain must be a valid VkSwapchainKHR handle\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "bool skip = false;\n// Checked by chassis: device: \"VUID-vkLatencySleepNV-device-parameter\"\nskip |= ValidateObject(swapchain, kVulkanObjectTypeSwapchainKHR, false, \"VUID-vkLatencySleepNV-swapchain-parameter\",\n                       \"VUID-vkLatencySleepNV-swapchain-parent\", error_obj.location.dot(Field::swapchain));\n"
        },
        {
            "role": "user",
            "content": "{\"VUID-vkGetLatencyTimingsNV-swapchain-parameter\", \"swapchain must be a valid VkSwapchainKHR handle\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "bool skip = false;\n// Checked by chassis: device: \"VUID-vkGetLatencyTimingsNV-device-parameter\"\nskip |= ValidateObject(swapchain, kVulkanObjectTypeSwapchainKHR, false, \"VUID-vkGetLatencyTimingsNV-swapchain-parameter\",\n                       \"VUID-vkGetLatencyTimingsNV-swapchain-parent\", error_obj.location.dot(Field::swapchain));\n"
        },
        {
            "role": "user",
            "content": "{\"VUID-vkCmdDrawMeshTasksIndirectEXT-buffer-parameter\", \"buffer must be a valid VkBuffer handle\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "bool skip = false;\n// Checked by chassis: commandBuffer: \"VUID-vkCmdDrawMeshTasksIndirectEXT-commandBuffer-parameter\"\n// Checked by chassis: commandBuffer: \"VUID-vkCmdDrawMeshTasksIndirectEXT-commonparent\"\nskip |= ValidateObject(buffer, kVulkanObjectTypeBuffer, false, \"VUID-vkCmdDrawMeshTasksIndirectEXT-buffer-parameter\",\n                       \"VUID-vkCmdDrawMeshTasksIndirectEXT-commonparent\", error_obj.location.dot(Field::buffer));\n"
        },
        {
            "role": "user",
            "content": "{\"VUID-vkCmdDrawMeshTasksIndirectCountEXT-buffer-parameter\", \"buffer must be a valid VkBuffer handle\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "bool skip = false;\n// Checked by chassis: commandBuffer: \"VUID-vkCmdDrawMeshTasksIndirectCountEXT-commandBuffer-parameter\"\n// Checked by chassis: commandBuffer: \"VUID-vkCmdDrawMeshTasksIndirectCountEXT-commonparent\"\nskip |= ValidateObject(buffer, kVulkanObjectTypeBuffer, false, \"VUID-vkCmdDrawMeshTasksIndirectCountEXT-buffer-parameter\",\n                       \"VUID-vkCmdDrawMeshTasksIndirectCountEXT-commonparent\", error_obj.location.dot(Field::buffer));\n"
        },
        {
            "role": "user",
            "content": "{\"VUID-RuntimeSpirv-shaderSampleRateInterpolationFunctions-06325\", \"If the VK_KHR_portability_subset extension is enabled, and VkPhysicalDevicePortabilitySubsetFeaturesKHR::shaderSampleRateInterpolationFunctions is VK_FALSE, then GLSL.std.450 fragment interpolation functions are not supported by the implementation and OpCapability must not be set to InterpolationFunction\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if ((VK_FALSE == enabled_features.shaderSampleRateInterpolationFunctions) &&\n    skip |= LogError(\"VUID-RuntimeSpirv-shaderSampleRateInterpolationFunctions-06325\", device, loc,\n                     \"SPIR-V (portability error) InterpolationFunction Capability are not supported \"\n                     \"by this platform\");\n"
        },
        {
            "role": "user",
            "content": "{\"VUID-vkGetPhysicalDeviceFeatures-pFeatures-parameter\", \"pFeatures must be a valid pointer to a VkPhysicalDeviceFeatures structure\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "bool skip = false;\n[[maybe_unused]] const Location loc = error_obj.location;\nskip |= ValidateRequiredPointer(loc.dot(Field::pFeatures), pFeatures, \"VUID-vkGetPhysicalDeviceFeatures-pFeatures-parameter\");\n"
        },
        {
            "role": "user",
            "content": "{\"VUID-vkCreateDevice-pDevice-parameter\", \"pDevice must be a valid pointer to a VkDevice handle\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "[[maybe_unused]] const Location pAllocator_loc = loc.dot(Field::pAllocator);\nskip |= ValidateAllocationCallbacks(*pAllocator, pAllocator_loc);\nskip |= ValidateRequiredPointer(loc.dot(Field::pDevice), pDevice, \"VUID-vkCreateDevice-pDevice-parameter\");\n"
        },
        {
            "role": "user",
            "content": "{\"VUID-vkGetDeviceQueue-pQueue-parameter\", \"pQueue must be a valid pointer to a VkQueue handle\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "VkQueue* pQueue, const ErrorObject& error_obj) const {\nbool skip = false;\n[[maybe_unused]] const Location loc = error_obj.location;\nskip |= ValidateRequiredPointer(loc.dot(Field::pQueue), pQueue, \"VUID-vkGetDeviceQueue-pQueue-parameter\");\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-vkAllocateMemory-pMemory-parameter\", \"pMemory must be a valid pointer to a VkDeviceMemory handle\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "[[maybe_unused]] const Location pAllocator_loc = loc.dot(Field::pAllocator);\nskip |= ValidateAllocationCallbacks(*pAllocator, pAllocator_loc);\nskip |= ValidateRequiredPointer(loc.dot(Field::pMemory), pMemory, \"VUID-vkAllocateMemory-pMemory-parameter\");\n"
        },
        {
            "role": "user",
            "content": "{\"VUID-vkCreateFence-pFence-parameter\", \"pFence must be a valid pointer to a VkFence handle\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "[[maybe_unused]] const Location pAllocator_loc = loc.dot(Field::pAllocator);\nskip |= ValidateAllocationCallbacks(*pAllocator, pAllocator_loc);\nskip |= ValidateRequiredPointer(loc.dot(Field::pFence), pFence, \"VUID-vkCreateFence-pFence-parameter\");\n"
        },
        {
            "role": "user",
            "content": "{\"VUID-vkCreateSemaphore-pSemaphore-parameter\", \"pSemaphore must be a valid pointer to a VkSemaphore handle\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "[[maybe_unused]] const Location pAllocator_loc = loc.dot(Field::pAllocator);\nskip |= ValidateAllocationCallbacks(*pAllocator, pAllocator_loc);\nskip |= ValidateRequiredPointer(loc.dot(Field::pSemaphore), pSemaphore, \"VUID-vkCreateSemaphore-pSemaphore-parameter\");\n"
        },
        {
            "role": "user",
            "content": "{\"VUID-vkCreateEvent-pEvent-parameter\", \"pEvent must be a valid pointer to a VkEvent handle\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "[[maybe_unused]] const Location pAllocator_loc = loc.dot(Field::pAllocator);\nskip |= ValidateAllocationCallbacks(*pAllocator, pAllocator_loc);\nskip |= ValidateRequiredPointer(loc.dot(Field::pEvent), pEvent, \"VUID-vkCreateEvent-pEvent-parameter\");\n"
        },
        {
            "role": "user",
            "content": "{\"VUID-vkCreateQueryPool-pQueryPool-parameter\", \"pQueryPool must be a valid pointer to a VkQueryPool handle\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "[[maybe_unused]] const Location pAllocator_loc = loc.dot(Field::pAllocator);\nskip |= ValidateAllocationCallbacks(*pAllocator, pAllocator_loc);\nskip |= ValidateRequiredPointer(loc.dot(Field::pQueryPool), pQueryPool, \"VUID-vkCreateQueryPool-pQueryPool-parameter\");\n"
        },
        {
            "role": "user",
            "content": "{\"VUID-vkCreateBufferView-pView-parameter\", \"pView must be a valid pointer to a VkBufferView handle\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "[[maybe_unused]] const Location pAllocator_loc = loc.dot(Field::pAllocator);\nskip |= ValidateAllocationCallbacks(*pAllocator, pAllocator_loc);\nskip |= ValidateRequiredPointer(loc.dot(Field::pView), pView, \"VUID-vkCreateBufferView-pView-parameter\");\n"
        },
        {
            "role": "user",
            "content": "{\"VUID-vkCreateImage-pImage-parameter\", \"pImage must be a valid pointer to a VkImage handle\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "[[maybe_unused]] const Location pAllocator_loc = loc.dot(Field::pAllocator);\nskip |= ValidateAllocationCallbacks(*pAllocator, pAllocator_loc);\nskip |= ValidateRequiredPointer(loc.dot(Field::pImage), pImage, \"VUID-vkCreateImage-pImage-parameter\");\n"
        },
        {
            "role": "user",
            "content": "{\"VUID-vkGetImageSubresourceLayout-pLayout-parameter\", \"pLayout must be a valid pointer to a VkSubresourceLayout structure\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "\"VUID-VkImageSubresource-aspectMask-parameter\", \"VUID-VkImageSubresource-aspectMask-requiredbitmask\");\nskip |= ValidateRequiredPointer(loc.dot(Field::pLayout), pLayout, \"VUID-vkGetImageSubresourceLayout-pLayout-parameter\");\n"
        },
        {
            "role": "user",
            "content": "{\"VUID-vkCreateImageView-pView-parameter\", \"pView must be a valid pointer to a VkImageView handle\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "[[maybe_unused]] const Location pAllocator_loc = loc.dot(Field::pAllocator);\nskip |= ValidateAllocationCallbacks(*pAllocator, pAllocator_loc);\nskip |= ValidateRequiredPointer(loc.dot(Field::pView), pView, \"VUID-vkCreateImageView-pView-parameter\");\n"
        },
        {
            "role": "user",
            "content": "{\"VUID-vkResetDescriptorPool-flags-zerobitmask\", \"flags must be 0\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "bool skip = false;\n[[maybe_unused]] const Location loc = error_obj.location;\nskip |= ValidateRequiredHandle(loc.dot(Field::descriptorPool), descriptorPool);\nskip |= ValidateReservedFlags(loc.dot(Field::flags), flags, \"VUID-vkResetDescriptorPool-flags-zerobitmask\");\n"
        },
        {
            "role": "user",
            "content": "{\"VUID-vkCreateFramebuffer-pFramebuffer-parameter\", \"pFramebuffer must be a valid pointer to a VkFramebuffer handle\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "[[maybe_unused]] const Location pAllocator_loc = loc.dot(Field::pAllocator);\nskip |= ValidateAllocationCallbacks(*pAllocator, pAllocator_loc);\nskip |= ValidateRequiredPointer(loc.dot(Field::pFramebuffer), pFramebuffer, \"VUID-vkCreateFramebuffer-pFramebuffer-parameter\");\n"
        },
        {
            "role": "user",
            "content": "{\"VUID-vkCreateRenderPass-pRenderPass-parameter\", \"pRenderPass must be a valid pointer to a VkRenderPass handle\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "[[maybe_unused]] const Location pAllocator_loc = loc.dot(Field::pAllocator);\nskip |= ValidateAllocationCallbacks(*pAllocator, pAllocator_loc);\nskip |= ValidateRequiredPointer(loc.dot(Field::pRenderPass), pRenderPass, \"VUID-vkCreateRenderPass-pRenderPass-parameter\");\n"
        },
        {
            "role": "user",
            "content": "{\"VUID-vkCreateCommandPool-pCommandPool-parameter\", \"pCommandPool must be a valid pointer to a VkCommandPool handle\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "[[maybe_unused]] const Location pAllocator_loc = loc.dot(Field::pAllocator);\nskip |= ValidateAllocationCallbacks(*pAllocator, pAllocator_loc);\nskip |= ValidateRequiredPointer(loc.dot(Field::pCommandPool), pCommandPool, \"VUID-vkCreateCommandPool-pCommandPool-parameter\");\n"
        },
        {
            "role": "user",
            "content": "{\"VUID-vkTrimCommandPool-flags-zerobitmask\", \"flags must be 0\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "bool skip = false;\n[[maybe_unused]] const Location loc = error_obj.location;\nskip |= ValidateRequiredHandle(loc.dot(Field::commandPool), commandPool);\nskip |= ValidateReservedFlags(loc.dot(Field::flags), flags, \"VUID-vkTrimCommandPool-flags-zerobitmask\");\n"
        },
        {
            "role": "user",
            "content": "{\"VUID-vkGetDeviceQueue2-pQueue-parameter\", \"pQueue must be a valid pointer to a VkQueue handle\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "\"VUID-VkDeviceQueueInfo2-flags-parameter\");\nskip |= ValidateRequiredPointer(loc.dot(Field::pQueue), pQueue, \"VUID-vkGetDeviceQueue2-pQueue-parameter\");\n"
        },
        {
            "role": "user",
            "content": "{\"VUID-vkCreateRenderPass2-pRenderPass-parameter\", \"pRenderPass must be a valid pointer to a VkRenderPass handle\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "[[maybe_unused]] const Location pAllocator_loc = loc.dot(Field::pAllocator);\nskip |= ValidateAllocationCallbacks(*pAllocator, pAllocator_loc);\nskip |= ValidateRequiredPointer(loc.dot(Field::pRenderPass), pRenderPass, \"VUID-vkCreateRenderPass2-pRenderPass-parameter\");\n"
        },
        {
            "role": "user",
            "content": "{\"VUID-vkGetSemaphoreCounterValue-pValue-parameter\", \"pValue must be a valid pointer to a uint64_t value\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "bool skip = false;\n[[maybe_unused]] const Location loc = error_obj.location;\nskip |= ValidateRequiredHandle(loc.dot(Field::semaphore), semaphore);\nskip |= ValidateRequiredPointer(loc.dot(Field::pValue), pValue, \"VUID-vkGetSemaphoreCounterValue-pValue-parameter\");\n"
        },
        {
            "role": "user",
            "content": "{\"VUID-vkCmdSetStencilOp-failOp-parameter\", \"failOp must be a valid VkStencilOp value\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "skip |= ValidateFlags(loc.dot(Field::faceMask), vvl::FlagBitmask::VkStencilFaceFlagBits, AllVkStencilFaceFlagBits, faceMask,\n                      kRequiredFlags, \"VUID-vkCmdSetStencilOp-faceMask-parameter\",\n                      \"VUID-vkCmdSetStencilOp-faceMask-requiredbitmask\");\nskip |= ValidateRangedEnum(loc.dot(Field::failOp), vvl::Enum::VkStencilOp, failOp, \"VUID-vkCmdSetStencilOp-failOp-parameter\");\n"
        },
        {
            "role": "user",
            "content": "{\"VUID-vkCmdSetStencilOp-passOp-parameter\", \"passOp must be a valid VkStencilOp value\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "kRequiredFlags, \"VUID-vkCmdSetStencilOp-faceMask-parameter\",\n\"VUID-vkCmdSetStencilOp-faceMask-requiredbitmask\");\nskip |= ValidateRangedEnum(loc.dot(Field::failOp), vvl::Enum::VkStencilOp, failOp, \"VUID-vkCmdSetStencilOp-failOp-parameter\");\nskip |= ValidateRangedEnum(loc.dot(Field::passOp), vvl::Enum::VkStencilOp, passOp, \"VUID-vkCmdSetStencilOp-passOp-parameter\");\n"
        },
        {
            "role": "user",
            "content": "{\"VUID-vkCreateSwapchainKHR-pSwapchain-parameter\", \"pSwapchain must be a valid pointer to a VkSwapchainKHR handle\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "[[maybe_unused]] const Location pAllocator_loc = loc.dot(Field::pAllocator);\nskip |= ValidateAllocationCallbacks(*pAllocator, pAllocator_loc);\nskip |= ValidateRequiredPointer(loc.dot(Field::pSwapchain), pSwapchain, \"VUID-vkCreateSwapchainKHR-pSwapchain-parameter\");\n"
        },
        {
            "role": "user",
            "content": "{\"VUID-vkAcquireNextImageKHR-pImageIndex-parameter\", \"pImageIndex must be a valid pointer to a uint32_t value\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (!IsExtEnabled(device_extensions.vk_khr_swapchain)) skip |= OutputExtensionError(loc, {vvl::Extension::_VK_KHR_swapchain});\nskip |= ValidateRequiredHandle(loc.dot(Field::swapchain), swapchain);\nskip |= ValidateRequiredPointer(loc.dot(Field::pImageIndex), pImageIndex, \"VUID-vkAcquireNextImageKHR-pImageIndex-parameter\");\n"
        },
        {
            "role": "user",
            "content": "{\"VUID-vkAcquireNextImage2KHR-pImageIndex-parameter\", \"pImageIndex must be a valid pointer to a uint32_t value\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "skip |= ValidateRequiredHandle(pAcquireInfo_loc.dot(Field::swapchain), pAcquireInfo->swapchain);\nskip |= ValidateRequiredPointer(loc.dot(Field::pImageIndex), pImageIndex, \"VUID-vkAcquireNextImage2KHR-pImageIndex-parameter\");\n"
        },
        {
            "role": "user",
            "content": "{\"VUID-vkCreateDisplayModeKHR-pMode-parameter\", \"pMode must be a valid pointer to a VkDisplayModeKHR handle\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "[[maybe_unused]] const Location pAllocator_loc = loc.dot(Field::pAllocator);\nskip |= ValidateAllocationCallbacks(*pAllocator, pAllocator_loc);\nskip |= ValidateRequiredPointer(loc.dot(Field::pMode), pMode, \"VUID-vkCreateDisplayModeKHR-pMode-parameter\");\n"
        },
        {
            "role": "user",
            "content": "{\"VUID-vkCreateDisplayPlaneSurfaceKHR-pSurface-parameter\", \"pSurface must be a valid pointer to a VkSurfaceKHR handle\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "[[maybe_unused]] const Location pAllocator_loc = loc.dot(Field::pAllocator);\nskip |= ValidateAllocationCallbacks(*pAllocator, pAllocator_loc);\nskip |= ValidateRequiredPointer(loc.dot(Field::pSurface), pSurface, \"VUID-vkCreateDisplayPlaneSurfaceKHR-pSurface-parameter\");\n"
        },
        {
            "role": "user",
            "content": "{\"VUID-vkCreateXlibSurfaceKHR-pSurface-parameter\", \"pSurface must be a valid pointer to a VkSurfaceKHR handle\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "[[maybe_unused]] const Location pAllocator_loc = loc.dot(Field::pAllocator);\nskip |= ValidateAllocationCallbacks(*pAllocator, pAllocator_loc);\nskip |= ValidateRequiredPointer(loc.dot(Field::pSurface), pSurface, \"VUID-vkCreateXlibSurfaceKHR-pSurface-parameter\");\n"
        },
        {
            "role": "user",
            "content": "{\"VUID-vkCreateXcbSurfaceKHR-pSurface-parameter\", \"pSurface must be a valid pointer to a VkSurfaceKHR handle\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "[[maybe_unused]] const Location pAllocator_loc = loc.dot(Field::pAllocator);\nskip |= ValidateAllocationCallbacks(*pAllocator, pAllocator_loc);\nskip |= ValidateRequiredPointer(loc.dot(Field::pSurface), pSurface, \"VUID-vkCreateXcbSurfaceKHR-pSurface-parameter\");\n"
        },
        {
            "role": "user",
            "content": "{\"VUID-vkCreateWaylandSurfaceKHR-pSurface-parameter\", \"pSurface must be a valid pointer to a VkSurfaceKHR handle\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "[[maybe_unused]] const Location pAllocator_loc = loc.dot(Field::pAllocator);\nskip |= ValidateAllocationCallbacks(*pAllocator, pAllocator_loc);\nskip |= ValidateRequiredPointer(loc.dot(Field::pSurface), pSurface, \"VUID-vkCreateWaylandSurfaceKHR-pSurface-parameter\");\n"
        },
        {
            "role": "user",
            "content": "{\"VUID-vkCreateAndroidSurfaceKHR-pSurface-parameter\", \"pSurface must be a valid pointer to a VkSurfaceKHR handle\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "[[maybe_unused]] const Location pAllocator_loc = loc.dot(Field::pAllocator);\nskip |= ValidateAllocationCallbacks(*pAllocator, pAllocator_loc);\nskip |= ValidateRequiredPointer(loc.dot(Field::pSurface), pSurface, \"VUID-vkCreateAndroidSurfaceKHR-pSurface-parameter\");\n"
        },
        {
            "role": "user",
            "content": "{\"VUID-vkCreateWin32SurfaceKHR-pSurface-parameter\", \"pSurface must be a valid pointer to a VkSurfaceKHR handle\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "[[maybe_unused]] const Location pAllocator_loc = loc.dot(Field::pAllocator);\nskip |= ValidateAllocationCallbacks(*pAllocator, pAllocator_loc);\nskip |= ValidateRequiredPointer(loc.dot(Field::pSurface), pSurface, \"VUID-vkCreateWin32SurfaceKHR-pSurface-parameter\");\n"
        },
        {
            "role": "user",
            "content": "{\"VUID-vkGetMemoryFdKHR-pFd-parameter\", \"pFd must be a valid pointer to an int value\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "\"VUID-VkMemoryGetFdInfoKHR-handleType-parameter\", \"VUID-VkMemoryGetFdInfoKHR-handleType-parameter\");\nskip |= ValidateRequiredPointer(loc.dot(Field::pFd), pFd, \"VUID-vkGetMemoryFdKHR-pFd-parameter\");\n"
        },
        {
            "role": "user",
            "content": "{\"VUID-vkGetSemaphoreWin32HandleKHR-pHandle-parameter\", \"pHandle must be a valid pointer to a HANDLE value\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "\"VUID-VkSemaphoreGetWin32HandleInfoKHR-handleType-parameter\",\n\"VUID-VkSemaphoreGetWin32HandleInfoKHR-handleType-parameter\");\nskip |= ValidateRequiredPointer(loc.dot(Field::pHandle), pHandle, \"VUID-vkGetSemaphoreWin32HandleKHR-pHandle-parameter\");\n"
        },
        {
            "role": "user",
            "content": "{\"VUID-vkGetSemaphoreFdKHR-pFd-parameter\", \"pFd must be a valid pointer to an int value\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "\"VUID-VkSemaphoreGetFdInfoKHR-handleType-parameter\", \"VUID-VkSemaphoreGetFdInfoKHR-handleType-parameter\");\nskip |= ValidateRequiredPointer(loc.dot(Field::pFd), pFd, \"VUID-vkGetSemaphoreFdKHR-pFd-parameter\");\n"
        },
        {
            "role": "user",
            "content": "{\"VUID-vkGetFenceWin32HandleKHR-pHandle-parameter\", \"pHandle must be a valid pointer to a HANDLE value\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "\"VUID-VkFenceGetWin32HandleInfoKHR-handleType-parameter\",\n\"VUID-VkFenceGetWin32HandleInfoKHR-handleType-parameter\");\nskip |= ValidateRequiredPointer(loc.dot(Field::pHandle), pHandle, \"VUID-vkGetFenceWin32HandleKHR-pHandle-parameter\");\n"
        },
        {
            "role": "user",
            "content": "{\"VUID-vkMapMemory2KHR-ppData-parameter\", \"ppData must be a valid pointer to a pointer value\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "skip |= ValidateRequiredHandle(pMemoryMapInfo_loc.dot(Field::memory), pMemoryMapInfo->memory);\nskip |= ValidateRequiredPointer(loc.dot(Field::ppData), ppData, \"VUID-vkMapMemory2KHR-ppData-parameter\");\n"
        },
        {
            "role": "user",
            "content": "{\"VUID-vkDebugReportMessageEXT-pMessage-parameter\", \"pMessage must be a null-terminated UTF-8 string\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "\"VUID-vkDebugReportMessageEXT-objectType-parameter\");\nskip |=\nValidateRequiredPointer(loc.dot(Field::pLayerPrefix), pLayerPrefix, \"VUID-vkDebugReportMessageEXT-pLayerPrefix-parameter\");\nskip |= ValidateRequiredPointer(loc.dot(Field::pMessage), pMessage, \"VUID-vkDebugReportMessageEXT-pMessage-parameter\");\n"
        },
        {
            "role": "user",
            "content": "{\"VUID-vkCreateCuModuleNVX-pModule-parameter\", \"pModule must be a valid pointer to a VkCuModuleNVX handle\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "[[maybe_unused]] const Location pAllocator_loc = loc.dot(Field::pAllocator);\nskip |= ValidateAllocationCallbacks(*pAllocator, pAllocator_loc);\nskip |= ValidateRequiredPointer(loc.dot(Field::pModule), pModule, \"VUID-vkCreateCuModuleNVX-pModule-parameter\");\n"
        },
        {
            "role": "user",
            "content": "{\"VUID-vkCreateCuFunctionNVX-pFunction-parameter\", \"pFunction must be a valid pointer to a VkCuFunctionNVX handle\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "[[maybe_unused]] const Location pAllocator_loc = loc.dot(Field::pAllocator);\nskip |= ValidateAllocationCallbacks(*pAllocator, pAllocator_loc);\nskip |= ValidateRequiredPointer(loc.dot(Field::pFunction), pFunction, \"VUID-vkCreateCuFunctionNVX-pFunction-parameter\");\n"
        },
        {
            "role": "user",
            "content": "{\"VUID-vkCreateViSurfaceNN-pSurface-parameter\", \"pSurface must be a valid pointer to a VkSurfaceKHR handle\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "[[maybe_unused]] const Location pAllocator_loc = loc.dot(Field::pAllocator);\nskip |= ValidateAllocationCallbacks(*pAllocator, pAllocator_loc);\nskip |= ValidateRequiredPointer(loc.dot(Field::pSurface), pSurface, \"VUID-vkCreateViSurfaceNN-pSurface-parameter\");\n"
        },
        {
            "role": "user",
            "content": "{\"VUID-vkAcquireXlibDisplayEXT-dpy-parameter\", \"dpy must be a valid pointer to a Display value\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (!IsExtEnabled(instance_extensions.vk_ext_acquire_xlib_display))\n    skip |= OutputExtensionError(loc, {vvl::Extension::_VK_EXT_acquire_xlib_display});\nskip |= ValidateRequiredPointer(loc.dot(Field::dpy), dpy, \"VUID-vkAcquireXlibDisplayEXT-dpy-parameter\");\n"
        },
        {
            "role": "user",
            "content": "{\"VUID-vkGetRandROutputDisplayEXT-dpy-parameter\", \"dpy must be a valid pointer to a Display value\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (!IsExtEnabled(instance_extensions.vk_ext_acquire_xlib_display))\n    skip |= OutputExtensionError(loc, {vvl::Extension::_VK_EXT_acquire_xlib_display});\nskip |= ValidateRequiredPointer(loc.dot(Field::dpy), dpy, \"VUID-vkGetRandROutputDisplayEXT-dpy-parameter\");\n"
        },
        {
            "role": "user",
            "content": "{\"VUID-vkGetRandROutputDisplayEXT-pDisplay-parameter\", \"pDisplay must be a valid pointer to a VkDisplayKHR handle\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (!IsExtEnabled(instance_extensions.vk_ext_acquire_xlib_display))\n    skip |= OutputExtensionError(loc, {vvl::Extension::_VK_EXT_acquire_xlib_display});\nskip |= ValidateRequiredPointer(loc.dot(Field::dpy), dpy, \"VUID-vkGetRandROutputDisplayEXT-dpy-parameter\");\nskip |= ValidateRequiredPointer(loc.dot(Field::pDisplay), pDisplay, \"VUID-vkGetRandROutputDisplayEXT-pDisplay-parameter\");\n"
        },
        {
            "role": "user",
            "content": "{\"VUID-vkRegisterDisplayEventEXT-pFence-parameter\", \"pFence must be a valid pointer to a VkFence handle\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "[[maybe_unused]] const Location pAllocator_loc = loc.dot(Field::pAllocator);\nskip |= ValidateAllocationCallbacks(*pAllocator, pAllocator_loc);\nskip |= ValidateRequiredPointer(loc.dot(Field::pFence), pFence, \"VUID-vkRegisterDisplayEventEXT-pFence-parameter\");\n"
        },
        {
            "role": "user",
            "content": "{\"VUID-vkCreateIOSSurfaceMVK-pSurface-parameter\", \"pSurface must be a valid pointer to a VkSurfaceKHR handle\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "[[maybe_unused]] const Location pAllocator_loc = loc.dot(Field::pAllocator);\nskip |= ValidateAllocationCallbacks(*pAllocator, pAllocator_loc);\nskip |= ValidateRequiredPointer(loc.dot(Field::pSurface), pSurface, \"VUID-vkCreateIOSSurfaceMVK-pSurface-parameter\");\n"
        },
        {
            "role": "user",
            "content": "{\"VUID-vkCreateMacOSSurfaceMVK-pSurface-parameter\", \"pSurface must be a valid pointer to a VkSurfaceKHR handle\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "[[maybe_unused]] const Location pAllocator_loc = loc.dot(Field::pAllocator);\nskip |= ValidateAllocationCallbacks(*pAllocator, pAllocator_loc);\nskip |= ValidateRequiredPointer(loc.dot(Field::pSurface), pSurface, \"VUID-vkCreateMacOSSurfaceMVK-pSurface-parameter\");\n"
        },
        {
            "role": "user",
            "content": "{\"VUID-vkCmdDispatchGraphAMDX-pCountInfo-parameter\", \"pCountInfo must be a valid pointer to a valid VkDispatchGraphCountInfoAMDX structure\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (!IsExtEnabled(device_extensions.vk_amdx_shader_enqueue))\n    skip |= OutputExtensionError(loc, {vvl::Extension::_VK_AMDX_shader_enqueue});\nskip |= ValidateRequiredPointer(loc.dot(Field::pCountInfo), pCountInfo, \"VUID-vkCmdDispatchGraphAMDX-pCountInfo-parameter\");\n"
        },
        {
            "role": "user",
            "content": "{\"VUID-vkCreateImagePipeSurfaceFUCHSIA-pSurface-parameter\", \"pSurface must be a valid pointer to a VkSurfaceKHR handle\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "[[maybe_unused]] const Location pAllocator_loc = loc.dot(Field::pAllocator);\nskip |= ValidateAllocationCallbacks(*pAllocator, pAllocator_loc);\nskip |= ValidateRequiredPointer(loc.dot(Field::pSurface), pSurface, \"VUID-vkCreateImagePipeSurfaceFUCHSIA-pSurface-parameter\");\n"
        },
        {
            "role": "user",
            "content": "{\"VUID-vkCreateMetalSurfaceEXT-pSurface-parameter\", \"pSurface must be a valid pointer to a VkSurfaceKHR handle\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "[[maybe_unused]] const Location pAllocator_loc = loc.dot(Field::pAllocator);\nskip |= ValidateAllocationCallbacks(*pAllocator, pAllocator_loc);\nskip |= ValidateRequiredPointer(loc.dot(Field::pSurface), pSurface, \"VUID-vkCreateMetalSurfaceEXT-pSurface-parameter\");\n"
        },
        {
            "role": "user",
            "content": "{\"VUID-vkCreateHeadlessSurfaceEXT-pSurface-parameter\", \"pSurface must be a valid pointer to a VkSurfaceKHR handle\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "[[maybe_unused]] const Location pAllocator_loc = loc.dot(Field::pAllocator);\nskip |= ValidateAllocationCallbacks(*pAllocator, pAllocator_loc);\nskip |= ValidateRequiredPointer(loc.dot(Field::pSurface), pSurface, \"VUID-vkCreateHeadlessSurfaceEXT-pSurface-parameter\");\n"
        },
        {
            "role": "user",
            "content": "{\"VUID-vkGetDrmDisplayEXT-display-parameter\", \"display must be a valid pointer to a VkDisplayKHR handle\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (!IsExtEnabled(instance_extensions.vk_ext_acquire_drm_display))\n    skip |= OutputExtensionError(loc, {vvl::Extension::_VK_EXT_acquire_drm_display});\nskip |= ValidateRequiredPointer(loc.dot(Field::display), display, \"VUID-vkGetDrmDisplayEXT-display-parameter\");\n"
        },
        {
            "role": "user",
            "content": "{\"VUID-vkCreateCudaFunctionNV-pFunction-parameter\", \"pFunction must be a valid pointer to a VkCudaFunctionNV handle\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "[[maybe_unused]] const Location pAllocator_loc = loc.dot(Field::pAllocator);\nskip |= ValidateAllocationCallbacks(*pAllocator, pAllocator_loc);\nskip |= ValidateRequiredPointer(loc.dot(Field::pFunction), pFunction, \"VUID-vkCreateCudaFunctionNV-pFunction-parameter\");\n"
        },
        {
            "role": "user",
            "content": "{\"VUID-vkGetBufferOpaqueCaptureDescriptorDataEXT-pData-parameter\", \"pData must be a pointer value\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "skip |= ValidateRequiredHandle(pInfo_loc.dot(Field::buffer), pInfo->buffer);\nskip |= ValidateRequiredPointer(loc.dot(Field::pData), pData, \"VUID-vkGetBufferOpaqueCaptureDescriptorDataEXT-pData-parameter\");\n"
        },
        {
            "role": "user",
            "content": "{\"VUID-vkGetImageOpaqueCaptureDescriptorDataEXT-pData-parameter\", \"pData must be a pointer value\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "skip |= ValidateRequiredHandle(pInfo_loc.dot(Field::image), pInfo->image);\nskip |= ValidateRequiredPointer(loc.dot(Field::pData), pData, \"VUID-vkGetImageOpaqueCaptureDescriptorDataEXT-pData-parameter\");\n"
        },
        {
            "role": "user",
            "content": "{\"VUID-vkGetWinrtDisplayNV-pDisplay-parameter\", \"pDisplay must be a valid pointer to a VkDisplayKHR handle\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "VkDisplayKHR* pDisplay, const ErrorObject& error_obj) const {\nbool skip = false;\n[[maybe_unused]] const Location loc = error_obj.location;\nskip |= ValidateRequiredPointer(loc.dot(Field::pDisplay), pDisplay, \"VUID-vkGetWinrtDisplayNV-pDisplay-parameter\");\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-vkGetMemoryRemoteAddressNV-pAddress-parameter\", \"pAddress must be a valid pointer to a VkRemoteAddressNV value\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "\"VUID-VkMemoryGetRemoteAddressInfoNV-handleType-parameter\", \"VUID-VkMemoryGetRemoteAddressInfoNV-handleType-parameter\");\nskip |= ValidateRequiredPointer(loc.dot(Field::pAddress), pAddress, \"VUID-vkGetMemoryRemoteAddressNV-pAddress-parameter\");\n"
        },
        {
            "role": "user",
            "content": "{\"VUID-vkCmdSetLogicOpEXT-logicOp-parameter\", \"logicOp must be a valid VkLogicOp value\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (!(IsExtEnabled(device_extensions.vk_ext_extended_dynamic_state2) || IsExtEnabled(device_extensions.vk_ext_shader_object)))\n    skip |= OutputExtensionError(loc, {vvl::Extension::_VK_EXT_extended_dynamic_state2, vvl::Extension::_VK_EXT_shader_object});\nskip |= ValidateRangedEnum(loc.dot(Field::logicOp), vvl::Enum::VkLogicOp, logicOp, \"VUID-vkCmdSetLogicOpEXT-logicOp-parameter\");\n"
        },
        {
            "role": "user",
            "content": "{\"VUID-vkCreateScreenSurfaceQNX-pSurface-parameter\", \"pSurface must be a valid pointer to a VkSurfaceKHR handle\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "[[maybe_unused]] const Location pAllocator_loc = loc.dot(Field::pAllocator);\nskip |= ValidateAllocationCallbacks(*pAllocator, pAllocator_loc);\nskip |= ValidateRequiredPointer(loc.dot(Field::pSurface), pSurface, \"VUID-vkCreateScreenSurfaceQNX-pSurface-parameter\");\n"
        },
        {
            "role": "user",
            "content": "{\"VUID-vkCreateMicromapEXT-pMicromap-parameter\", \"pMicromap must be a valid pointer to a VkMicromapEXT handle\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "[[maybe_unused]] const Location pAllocator_loc = loc.dot(Field::pAllocator);\nskip |= ValidateAllocationCallbacks(*pAllocator, pAllocator_loc);\nskip |= ValidateRequiredPointer(loc.dot(Field::pMicromap), pMicromap, \"VUID-vkCreateMicromapEXT-pMicromap-parameter\");\n"
        },
        {
            "role": "user",
            "content": "{\"VUID-vkCreateOpticalFlowSessionNV-pSession-parameter\", \"pSession must be a valid pointer to a VkOpticalFlowSessionNV handle\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "[[maybe_unused]] const Location pAllocator_loc = loc.dot(Field::pAllocator);\nskip |= ValidateAllocationCallbacks(*pAllocator, pAllocator_loc);\nskip |= ValidateRequiredPointer(loc.dot(Field::pSession), pSession, \"VUID-vkCreateOpticalFlowSessionNV-pSession-parameter\");\n"
        },
        {
            "role": "user",
            "content": "{\"VUID-vkGetScreenBufferPropertiesQNX-buffer-parameter\", \"buffer must be a valid pointer to a valid _screen_buffer value\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (!IsExtEnabled(device_extensions.vk_qnx_external_memory_screen_buffer))\n    skip |= OutputExtensionError(loc, {vvl::Extension::_VK_QNX_external_memory_screen_buffer});\nskip |= ValidateRequiredPointer(loc.dot(Field::buffer), buffer, \"VUID-vkGetScreenBufferPropertiesQNX-buffer-parameter\");\n"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkPipelineViewportStateCreateInfo-flags-zerobitmask\", \"flags must be 0\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "\"VUID-VkPipelineViewportStateCreateInfo-pNext-pNext\",\n\"VUID-VkPipelineViewportStateCreateInfo-sType-unique\", VK_NULL_HANDLE, true);\nskip |= ValidateReservedFlags(loc.dot(Field::flags), info.flags, \"VUID-VkPipelineViewportStateCreateInfo-flags-zerobitmask\");\n"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkPipelineVertexInputStateCreateInfo-flags-zerobitmask\", \"flags must be 0\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "\"VUID-VkPipelineVertexInputStateCreateInfo-pNext-pNext\",\n\"VUID-VkPipelineVertexInputStateCreateInfo-sType-unique\", VK_NULL_HANDLE, true);\nskip |= ValidateReservedFlags(loc.dot(Field::flags), info.flags, \"VUID-VkPipelineVertexInputStateCreateInfo-flags-zerobitmask\");\n"
        },
            {
            "role": "user",
            "content": "{\"VUID-VkMemoryGetAndroidHardwareBufferInfoANDROID-handleTypes-01882\", \"VK_EXTERNAL_MEMORY_HANDLE_TYPE_ANDROID_HARDWARE_BUFFER_BIT_ANDROID must have been included in VkExportMemoryAllocateInfo::handleTypes when memory was created\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (!mem_info->IsExport() ||\n    skip |= LogError(\"VUID-VkMemoryGetAndroidHardwareBufferInfoANDROID-handleTypes-01882\", device,\n                     error_obj.location.dot(Field::pInfo).dot(Field::memory),\n                     \"(%s) was not allocated for export, or the \"\n                     \"export handleTypes (0x%\" PRIx32\n                     \") did not contain VK_EXTERNAL_MEMORY_HANDLE_TYPE_ANDROID_HARDWARE_BUFFER_BIT_ANDROID.\",\n                     FormatHandle(pInfo->memory).c_str(), mem_info->export_handle_types);\n"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkMemoryAllocateInfo-pNext-02586\", \"If the parameters define an import operation, the external handle is an Android hardware buffer, and the pNext chain includes a VkMemoryDedicatedAllocateInfo structure with image that is not VK_NULL_HANDLE, and the Android hardware buffer's AHardwareBuffer::usage does not include AHARDWAREBUFFER_USAGE_GPU_MIPMAP_COMPLETE, the image must have exactly one mipmap level\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (ici->mipLevels != 1) {\n    skip |= LogError(\"VUID-VkMemoryAllocateInfo-pNext-02586\", mem_ded_alloc_info->image, ahb_loc,\n                     \"AHardwareBuffer_Desc's  usage is 0x%\" PRIx64 \" but %s mipLevels is %\" PRIu32 \". (AHB = %p).\",\n                     ahb_desc.usage, dedicated_image_loc.Fields().c_str(), ici->mipLevels, import_ahb_info->buffer);\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkImageCreateInfo-pNext-01974\", \"If the pNext chain includes a VkExternalFormatANDROID structure, and its externalFormat member is non-zero the format must be VK_FORMAT_UNDEFINED\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (VK_FORMAT_UNDEFINED != create_info.format) {\n    skip |= LogError(\"VUID-VkImageCreateInfo-pNext-01974\", device,\n                     create_info_loc.pNext(Struct::VkExternalFormatANDROID, Field::externalFormat),\n                     \"(%\" PRIu64 \") is non-zero, format is %s.\", ext_fmt_android->externalFormat,\n                     string_VkFormat(create_info.format));\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkImageCreateInfo-pNext-01975\", \"If the pNext chain does not include a VkExternalFormatANDROID structure, or does and its externalFormat member is 0, the format must not be VK_FORMAT_UNDEFINED\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (ext_fmt_android) {\n    skip |= LogError(\"VUID-VkImageCreateInfo-pNext-01975\", device, create_info_loc.dot(Field::format),\n                     \"is VK_FORMAT_UNDEFINED, but the chained VkExternalFormatANDROID has an externalFormat of 0.\");\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkImageViewCreateInfo-image-02400\", \"If image has an Android external format, the pNext chain must include a VkSamplerYcbcrConversionInfo structure with a conversion object created with the same external format as image\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (!conv_found) {\n    const LogObjectList objlist(create_info.image);\n    skip |= LogError(\"VUID-VkImageViewCreateInfo-image-02400\", objlist,\n                     create_info_loc.pNext(Struct::VkSamplerYcbcrConversionInfo, Field::conversion),\n                     \"is not valid (or forgot to add VkSamplerYcbcrConversionInfo).\");\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkBufferViewCreateInfo-range-04059\", \"If range is equal to VK_WHOLE_SIZE, the number of texel buffer elements given by (\u230a(size - offset) / (texel block size)\u230b \u00d7 (texels per block)) where size is the size of buffer, and texel block size and texels per block are as defined in the Compatible Formats table for format, must be less than or equal to VkPhysicalDeviceLimits::maxTexelBufferElements\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (texels > static_cast<VkDeviceSize>(phys_dev_props.limits.maxTexelBufferElements)) {\n    skip |= LogError(\"VUID-VkBufferViewCreateInfo-range-04059\", buffer_state.Handle(), loc.dot(Field::range),\n                     \"is VK_WHOLE_SIZE, but the buffer's size (%\" PRIuLEAST64 \"), offset (%\" PRIuLEAST64\n                     \"), %s texel block size (%\" PRIu32 \"), and texels-per-block (%\" PRIuLEAST64\n                     \") is a total of (%\" PRIuLEAST64\n                     \") texels which is more than VkPhysicalDeviceLimits::maxTexelBufferElements (%\" PRIuLEAST32 \").\",\n                     buffer_state.create_info.size, create_info.offset, string_VkFormat(format), format_info.block_size,\n                     texel_per_block, texels, phys_dev_props.limits.maxTexelBufferElements);\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkBufferCreateInfo-flags-03338\", \"If flags includes VK_BUFFER_CREATE_DEVICE_ADDRESS_CAPTURE_REPLAY_BIT, the bufferDeviceAddressCaptureReplay feature must be enabled\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if ((create_info.flags & VK_BUFFER_CREATE_DEVICE_ADDRESS_CAPTURE_REPLAY_BIT) &&\n    skip |= LogError(\"VUID-VkBufferCreateInfo-flags-03338\", device, create_info_loc.dot(Field::flags),\n                     \"has VK_BUFFER_CREATE_DEVICE_ADDRESS_CAPTURE_REPLAY_BIT set but the bufferDeviceAddressCaptureReplay \"\n                     \"device feature is not enabled.\");\n"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkBufferCreateInfo-usage-08101\", \"If usage includes VK_BUFFER_USAGE_PUSH_DESCRIPTORS_DESCRIPTOR_BUFFER_BIT_EXT, the descriptorBufferPushDescriptors feature must be enabled\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (!enabled_features.descriptorBufferPushDescriptors) {\n    skip |= LogError(\"VUID-VkBufferCreateInfo-usage-08101\", device, create_info_loc.dot(Field::usage),\n                     \"has VK_BUFFER_USAGE_PUSH_DESCRIPTORS_DESCRIPTOR_BUFFER_BIT_EXT set but the \"\n                     \"descriptorBufferPushDescriptors device feature is not enabled.\");\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkBufferCreateInfo-None-01888\", \"If any of the bits VK_BUFFER_CREATE_SPARSE_BINDING_BIT, VK_BUFFER_CREATE_SPARSE_RESIDENCY_BIT, or VK_BUFFER_CREATE_SPARSE_ALIASED_BIT are set, VK_BUFFER_CREATE_PROTECTED_BIT must not also be set\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if ((pCreateInfo->flags & invalid_flags) != 0) {\n    skip |= LogError(\"VUID-VkBufferCreateInfo-None-01888\", device, create_info_loc.dot(Field::flags),\n                     \"is %s but can't mix protected with sparse flags.\",\n                     string_VkBufferCreateFlags(pCreateInfo->flags).c_str());\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkBufferViewCreateInfo-pNext-08780\", \"If the pNext chain includes a VkBufferUsageFlags2CreateInfoKHR, its usage must not contain any other bit than VK_BUFFER_USAGE_2_UNIFORM_TEXEL_BUFFER_BIT_KHR or VK_BUFFER_USAGE_2_STORAGE_TEXEL_BUFFER_BIT_KHR\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if ((usage & ~(VK_BUFFER_USAGE_2_UNIFORM_TEXEL_BUFFER_BIT_KHR | VK_BUFFER_USAGE_2_STORAGE_TEXEL_BUFFER_BIT_KHR)) != 0) {\n    skip |= LogError(\"VUID-VkBufferViewCreateInfo-pNext-08780\", objlist,\n                     create_info_loc.pNext(Struct::VkBufferUsageFlags2CreateInfoKHR, Field::usage), \"is %s.\",\n                     string_VkBufferUsageFlags2KHR(usage).c_str());\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-vkCmdFillBuffer-commandBuffer-01811\", \"If commandBuffer is an unprotected command buffer and protectedNoFault is not supported, dstBuffer must not be a protected buffer\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "skip |= ValidateBufferUsageFlags(objlist, *buffer_state, VK_BUFFER_USAGE_TRANSFER_DST_BIT, true,\n                                 \"VUID-vkCmdFillBuffer-dstBuffer-00029\", buffer_loc);\nskip |= ValidateProtectedBuffer(cb_state, *buffer_state, buffer_loc, \"VUID-vkCmdFillBuffer-commandBuffer-01811\");\n"
        },
        {
            "role": "user",
            "content": "{\"VUID-vkFreeCommandBuffers-pCommandBuffers-00047\", \"All elements of pCommandBuffers must not be in the pending state\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (cb_state && cb_state->InUse()) {\n    const LogObjectList objlist(pCommandBuffers[i], commandPool);\n    skip |= LogError(\"VUID-vkFreeCommandBuffers-pCommandBuffers-00047\", objlist,\n                     error_obj.location.dot(Field::pCommandBuffers, i), \"(%s) is in use.\",\n                     FormatHandle(pCommandBuffers[i]).c_str());\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkCommandBufferBeginInfo-flags-06000\", \"If flags contains VK_COMMAND_BUFFER_USAGE_RENDER_PASS_CONTINUE_BIT and the renderPass member of pInheritanceInfo is not VK_NULL_HANDLE, the renderPass member of pInheritanceInfo must be a valid VkRenderPass\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (!render_pass) {\n    skip |= LogError(\"VUID-VkCommandBufferBeginInfo-flags-06000\", commandBuffer,\n                     inheritance_loc.dot(Field::renderPass), \"is not a valid VkRenderPass.\");\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkCommandBufferInheritanceRenderingInfo-viewMask-06009\", \"The index of the most significant bit in viewMask must be less than maxMultiviewViewCount\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (MostSignificantBit(p_inherited_rendering_info->viewMask) >=\n    skip |= LogError(\"VUID-VkCommandBufferInheritanceRenderingInfo-viewMask-06009\", commandBuffer,\n                     inheritance_loc.pNext(Struct::VkCommandBufferInheritanceRenderingInfo, Field::viewMask),\n                     \"(0x%\" PRIx32 \") most significant bit is superior or equal to maxMultiviewViewCount (%\" PRIu32\n                     \").\",\n                     p_inherited_rendering_info->viewMask, phys_dev_props_core11.maxMultiviewViewCount);\n"
        },
        {
            "role": "user",
            "content": "{\"VUID-vkEndCommandBuffer-commandBuffer-00059\", \"commandBuffer must be in the recording state\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (cb_state.state == CbState::InvalidComplete || cb_state.state == CbState::InvalidIncomplete) {\n    skip |= ReportInvalidCommandBuffer(cb_state, error_obj.location, \"VUID-vkEndCommandBuffer-commandBuffer-00059\");\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-vkResetCommandBuffer-commandBuffer-00046\", \"commandBuffer must have been allocated from a pool that was created with the VK_COMMAND_POOL_CREATE_RESET_COMMAND_BUFFER_BIT\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (!(VK_COMMAND_POOL_CREATE_RESET_COMMAND_BUFFER_BIT & pool->createFlags)) {\n    const LogObjectList objlist(commandBuffer, cmd_pool);\n    skip |= LogError(\"VUID-vkResetCommandBuffer-commandBuffer-00046\", objlist, error_obj.location,\n                     \"%s was created from %s  which was created with %s.\", FormatHandle(commandBuffer).c_str(),\n                     FormatHandle(cmd_pool).c_str(), string_VkCommandPoolCreateFlags(pool->createFlags).c_str());\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-vkCmdUpdateBuffer-dstBuffer-00035\", \"If dstBuffer is non-sparse then it must be bound completely and contiguously to a single VkDeviceMemory object\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "const LogObjectList objlist(commandBuffer, dstBuffer);\nconst Location buffer_loc = error_obj.location.dot(Field::dstBuffer);\nskip |= ValidateMemoryIsBoundToBuffer(commandBuffer, *dst_buffer_state, buffer_loc, \"VUID-vkCmdUpdateBuffer-dstBuffer-00035\");\n"
        },
        {
            "role": "user",
            "content": "{\"VUID-vkCmdExecuteCommands-pCommandBuffers-00105\", \"Each element of pCommandBuffers must not begin any query types that are active in commandBuffer\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (active_types.count(query_pool_state->create_info.queryType)) {\n    const LogObjectList objlist(cb_state.Handle(), sub_cb_state.Handle(), query_object.pool);\n    skip |= LogError(\"VUID-vkCmdExecuteCommands-pCommandBuffers-00105\", objlist, cb_loc,\n                     \"called with invalid %s which has invalid active %s\"\n                     \" of type %s but a query of that type has been started on secondary command buffer %s.\",\n                     FormatHandle(cb_state).c_str(), FormatHandle(query_object.pool).c_str(),\n                     string_VkQueryType(query_pool_state->create_info.queryType), FormatHandle(sub_cb_state).c_str());\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-vkCmdExecuteCommands-flags-06024\", \"If vkCmdExecuteCommands is being called within a render pass instance begun with vkCmdBeginRendering, its VkRenderingInfo::flags parameter must have included VK_RENDERING_CONTENTS_SECONDARY_COMMAND_BUFFERS_BIT\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "(cb_state.activeRenderPass->inheritance_rendering_info.flags &\nconst LogObjectList objlist(commandBuffer, cb_state.activeRenderPass->Handle());\nskip |= LogError(\"VUID-vkCmdExecuteCommands-flags-06024\", objlist, error_obj.location,\n              \"VkRenderingInfo::flags must include \"\n              \"VK_RENDERING_CONTENTS_SECONDARY_COMMAND_BUFFERS_BIT_KHR when calling vkCmdExecuteCommands() within a \"\n              \"render pass instance begun with vkCmdBeginRendering().\");\n"
        },
        {
            "role": "user",
            "content": "{\"VUID-vkCmdExecuteCommands-pBeginInfo-06025\", \"If vkCmdExecuteCommands is being called within a render pass instance begun with vkCmdBeginRendering, the render passes specified in the pBeginInfo->pInheritanceInfo->renderPass members of the vkBeginCommandBuffer commands used to begin recording each element of pCommandBuffers must be VK_NULL_HANDLE\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (inheritance_render_pass != VK_NULL_HANDLE) {\n    const LogObjectList objlist(commandBuffer, pCommandBuffers[i], cb_state.activeRenderPass->Handle());\n    skip |= LogError(\"VUID-vkCmdExecuteCommands-pBeginInfo-06025\", objlist, cb_loc,\n                     \"(%s) is executed within a dynamic renderpass instance scope begun \"\n                     \"by vkCmdBeginRendering(), but \"\n                     \"VkCommandBufferInheritanceInfo::pInheritanceInfo::renderPass is not VK_NULL_HANDLE.\",\n                     FormatHandle(pCommandBuffers[i]).c_str());\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-vkCmdExecuteCommands-pStencilAttachment-06030\", \"If vkCmdExecuteCommands is being called within a render pass instance begun with vkCmdBeginRendering, if the VkRenderingInfo::pStencilAttachment->imageView parameter to vkCmdBeginRendering is not VK_NULL_HANDLE, the value of the stencilAttachmentFormat member of the VkCommandBufferInheritanceRenderingInfo structure included in the pNext chain of VkCommandBufferBeginInfo::pInheritanceInfo used to begin recording each element of pCommandBuffers must be equal to the format used to create that image view\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (image_view_state &&\n    const LogObjectList objlist(commandBuffer, pCommandBuffers[i], cb_state.activeRenderPass->Handle());\n    skip |= LogError(\"VUID-vkCmdExecuteCommands-pStencilAttachment-06030\", objlist, cb_loc,\n                     \"(%s) is executed within a dynamic renderpass \"\n                     \"instance scope begun \"\n                     \"by vkCmdBeginRendering(), but \"\n                     \"VkCommandBufferInheritanceRenderingInfo::stencilAttachmentFormat does \"\n                     \"not match the format of the imageView in VkRenderingInfo::pStencilAttachment.\",\n                     FormatHandle(pCommandBuffers[i]).c_str());\n"
        },
        {
            "role": "user",
            "content": "{\"VUID-vkCmdExecuteCommands-pNext-06037\", \"If vkCmdExecuteCommands is being called within a render pass instance begun with vkCmdBeginRendering and the pNext chain of VkCommandBufferInheritanceInfo does not include a VkAttachmentSampleCountInfoAMD or VkAttachmentSampleCountInfoNV structure, if the VkRenderingInfo::pStencilAttachment->imageView parameter to vkCmdBeginRendering is not VK_NULL_HANDLE, the value of VkCommandBufferInheritanceRenderingInfo::rasterizationSamples must be equal to the sample count used to create that image view\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "const LogObjectList objlist(commandBuffer, pCommandBuffers[i],\nskip |= LogError(\"VUID-vkCmdExecuteCommands-pNext-06037\", objlist, cb_loc,\n                 \"(%s) is executed within a dynamic renderpass \"\n                 \"instance scope begun \"\n                 \"by vkCmdBeginRenderingKHR(), but the sample count of the image view for \"\n                 \"VkRenderingInfoKHR::pStencilAttachment does not match \"\n                 \"VkCommandBufferInheritanceRenderingInfo::rasterizationSamples.\",\n                 FormatHandle(pCommandBuffers[i]).c_str());\n"
        },
        {
            "role": "user",
            "content": "{\"VUID-vkCmdExecuteCommands-pCommandBuffers-00093\", \"If any element of pCommandBuffers was not recorded with the VK_COMMAND_BUFFER_USAGE_SIMULTANEOUS_USE_BIT flag, it must not appear more than once in pCommandBuffers\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (!insert_pair.second) {\n    const LogObjectList objlist(commandBuffer, pCommandBuffers[i]);\n    skip |= LogError(\"VUID-vkCmdExecuteCommands-pCommandBuffers-00093\", objlist, cb_loc,\n                     \"Cannot duplicate %s in pCommandBuffers without \"\n                     \"VK_COMMAND_BUFFER_USAGE_SIMULTANEOUS_USE_BIT set.\",\n                     FormatHandle(commandBuffer).c_str());\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-vkCmdExecuteCommands-commandBuffer-00103\", \"If commandBuffer has a VK_QUERY_TYPE_OCCLUSION query active, then each element of pCommandBuffers must have been recorded with VkCommandBufferInheritanceInfo::queryFlags having all bits set that are set for the query\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if ((sub_cb_state.inheritanceInfo.queryFlags & active_occlusion_query->control_flags) !=\n    const LogObjectList objlist(commandBuffer, pCommandBuffers[i]);\n    skip |= LogError(\"VUID-vkCmdExecuteCommands-commandBuffer-00103\", objlist, cb_loc,\n                     \"(%s) was recorded with VkCommandBufferInheritanceInfo::queryFlags %s, but primary command buffer \"\n                     \"%s has an active occlusion query with VkQueryControlFlags %s.\",\n                     FormatHandle(pCommandBuffers[i]).c_str(),\n                     string_VkQueryControlFlags(sub_cb_state.inheritanceInfo.queryFlags).c_str(),\n                     FormatHandle(commandBuffer).c_str(),\n                     string_VkQueryControlFlags(active_occlusion_query->control_flags).c_str());\n"
        },
        {
            "role": "user",
            "content": "{\"VUID-vkCmdBindTransformFeedbackBuffersEXT-pOffsets-02363\", \"All elements of pOffsets plus pSizes, where the pSizes, element is not VK_WHOLE_SIZE, must be less than or equal to the size of the corresponding buffer in pBuffers\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "} else if (pOffsets[i] + pSizes[i] > buffer_state->create_info.size) {\n    const LogObjectList objlist(commandBuffer, pBuffers[i]);\n    skip |= LogError(\"VUID-vkCmdBindTransformFeedbackBuffersEXT-pOffsets-02363\", objlist, error_obj.location,\n                     \"The sum of pOffsets[%\" PRIu32 \"] (%\" PRIu64 \") and pSizes[%\" PRIu32 \"] (%\" PRIu64\n                     \") is greater than the size of pBuffers[%\" PRIu32 \"] (%\" PRIu64 \").\",\n                     i, pOffsets[i], i, pSizes[i], i, buffer_state->create_info.size);\n"
        },
        {
            "role": "user",
            "content": "{\"VUID-vkCmdBeginTransformFeedbackEXT-firstCounterBuffer-09630\", \"The sum of firstCounterBuffer and counterBufferCount must be less than or equal to the number of transform feedback buffers currently bound by vkCmdBindTransformFeedbackBuffersEXT\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if ((counterBufferCount + firstCounterBuffer) > cb_state->transform_feedback_buffers_bound) {\n    skip |= LogError(\"VUID-vkCmdBeginTransformFeedbackEXT-firstCounterBuffer-09630\", commandBuffer,\n                     error_obj.location.dot(Field::firstCounterBuffer),\n                     \"is %\" PRIu32 \" and counterBufferCount is %\" PRIu32\n                     \" but vkCmdBindTransformFeedbackBuffersEXT only bound %\" PRIu32 \" buffers.\",\n                     firstCounterBuffer, counterBufferCount, cb_state->transform_feedback_buffers_bound);\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-vkCmdEndTransformFeedbackEXT-pCounterBufferOffsets-02378\", \"For each buffer handle in the array, if it is not VK_NULL_HANDLE it must reference a buffer large enough to hold 4 bytes at the corresponding offset from the pCounterBufferOffsets array\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (pCounterBufferOffsets != nullptr && pCounterBufferOffsets[i] + 4 > buffer_state->create_info.size) {\n    const LogObjectList objlist(commandBuffer, pCounterBuffers[i]);\n    skip |= LogError(\"VUID-vkCmdEndTransformFeedbackEXT-pCounterBufferOffsets-02378\", objlist,\n                     error_obj.location.dot(Field::pCounterBuffers, i),\n                     \"is not large enough to hold 4 bytes at pCounterBufferOffsets[%\" PRIu32 \"](0x%\" PRIx64 \").\", i,\n                     pCounterBufferOffsets[i]);\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-vkCmdBeginConditionalRenderingEXT-None-01980\", \"Conditional rendering must not already be active\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (cb_state && cb_state->conditional_rendering_active) {\n    skip |= LogError(\"VUID-vkCmdBeginConditionalRenderingEXT-None-01980\", commandBuffer, error_obj.location,\n                     \"Conditional rendering is already active.\");\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-vkCmdBindShadingRateImageNV-imageView-02059\", \"If imageView is not VK_NULL_HANDLE, it must be a valid VkImageView handle of type VK_IMAGE_VIEW_TYPE_2D or VK_IMAGE_VIEW_TYPE_2D_ARRAY\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (!view_state) {\n    const LogObjectList objlist(commandBuffer, imageView);\n    skip |= LogError(\"VUID-vkCmdBindShadingRateImageNV-imageView-02059\", objlist, error_obj.location,\n                     \"If imageView is not VK_NULL_HANDLE, it must be a valid \"\n                     \"VkImageView handle.\");\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-vkCmdSetViewport-commandBuffer-04821\", \"commandBuffer must not have VkCommandBufferInheritanceViewportScissorInfoNV::viewportScissor2D enabled\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "auto cb_state = GetRead<vvl::CommandBuffer>(commandBuffer);\nbool skip = false;\nskip |= ValidateExtendedDynamicState(*cb_state, error_obj.location, VK_TRUE, nullptr, nullptr);\nskip |= ForbidInheritedViewportScissor(*cb_state, \"VUID-vkCmdSetViewport-commandBuffer-04821\", error_obj.location);\n"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkDepthBiasInfoEXT-depthBiasClamp-08950\", \"If the depthBiasClamp feature is not enabled, depthBiasClamp must be 0.0\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if ((pDepthBiasInfo->depthBiasClamp != 0.0) && !enabled_features.depthBiasClamp) {\n    skip |= LogError(\"VUID-VkDepthBiasInfoEXT-depthBiasClamp-08950\", commandBuffer,\n                     error_obj.location.dot(Field::pDepthBiasInfo).dot(Field::depthBiasClamp),\n                     \"is %f, but the depthBiasClamp device feature was not enabled.\", pDepthBiasInfo->depthBiasClamp);\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-vkCmdSetViewportWithCount-commandBuffer-04819\", \"commandBuffer must not have VkCommandBufferInheritanceViewportScissorInfoNV::viewportScissor2D enabled\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "auto cb_state = GetRead<vvl::CommandBuffer>(commandBuffer);\nbool skip = false;\nskip |= ValidateExtendedDynamicState(*cb_state, error_obj.location, VK_TRUE, nullptr, nullptr);\nskip |= ForbidInheritedViewportScissor(*cb_state, \"VUID-vkCmdSetViewportWithCount-commandBuffer-04819\", error_obj.location);\n"
        },
        {
            "role": "user",
            "content": "{\"VUID-vkCmdSetDepthClampEnableEXT-depthClamp-07449\", \"If the depthClamp feature is not enabled, depthClampEnable must be VK_FALSE\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (depthClampEnable != VK_FALSE && !enabled_features.depthClamp) {\n    skip |= LogError(\"VUID-vkCmdSetDepthClampEnableEXT-depthClamp-07449\", commandBuffer,\n                     error_obj.location.dot(Field::depthClampEnable), \"is VK_TRUE but the depthClamp feature was not enabled.\");\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkColorBlendEquationEXT-constantAlphaColorBlendFactors-07362\", \"If the VK_KHR_portability_subset extension is enabled, and VkPhysicalDevicePortabilitySubsetFeaturesKHR::constantAlphaColorBlendFactors is VK_FALSE, srcColorBlendFactor must not be VK_BLEND_FACTOR_CONSTANT_ALPHA or VK_BLEND_FACTOR_ONE_MINUS_CONSTANT_ALPHA\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (equation.srcColorBlendFactor == VK_BLEND_FACTOR_CONSTANT_ALPHA ||\n    skip |= LogError(\"VUID-VkColorBlendEquationEXT-constantAlphaColorBlendFactors-07362\", commandBuffer,\n                     equation_loc.dot(Field::srcColorBlendFactor),\n                     \"is %s but the constantAlphaColorBlendFactors feature was not supported.\",\n                     string_VkBlendFactor(equation.srcColorBlendFactor));\n"
        },
        {
            "role": "user",
            "content": "{\"VUID-vkCmdSetExtraPrimitiveOverestimationSizeEXT-extraPrimitiveOverestimationSize-07428\", \"extraPrimitiveOverestimationSize must be in the range of 0.0 to VkPhysicalDeviceConservativeRasterizationPropertiesEXT::maxExtraPrimitiveOverestimationSize inclusive\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (extraPrimitiveOverestimationSize < 0.0f ||\n    extraPrimitiveOverestimationSize >\n    skip |= LogError(\"VUID-vkCmdSetExtraPrimitiveOverestimationSizeEXT-extraPrimitiveOverestimationSize-07428\", commandBuffer,\n                     error_obj.location.dot(Field::extraPrimitiveOverestimationSize),\n                     \"(%f) must be less then zero or greater than maxExtraPrimitiveOverestimationSize (%f).\",\n                     extraPrimitiveOverestimationSize,\n                     phys_dev_ext_props.conservative_rasterization_props.maxExtraPrimitiveOverestimationSize);\n"
        },
        {
            "role": "user",
            "content": "{\"VUID-vkCmdSetProvokingVertexModeEXT-provokingVertexMode-07447\", \"If provokingVertexMode is VK_PROVOKING_VERTEX_MODE_LAST_VERTEX_EXT, then the provokingVertexLast feature must be enabled\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (provokingVertexMode == VK_PROVOKING_VERTEX_MODE_LAST_VERTEX_EXT && enabled_features.provokingVertexLast == VK_FALSE) {\n    skip |= LogError(\"VUID-vkCmdSetProvokingVertexModeEXT-provokingVertexMode-07447\", commandBuffer,\n                     error_obj.location.dot(Field::provokingVertexMode),\n                     \"is VK_PROVOKING_VERTEX_MODE_LAST_VERTEX_EXT but the provokingVertexLast feature was not enabled.\");\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-vkCreateEvent-events-04468\", \"If the VK_KHR_portability_subset extension is enabled, and VkPhysicalDevicePortabilitySubsetFeaturesKHR::events is VK_FALSE, then the implementation does not support events, and vkCreateEvent must not be used\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (VK_FALSE == enabled_features.events) {\n    skip |= LogError(\"VUID-vkCreateEvent-events-04468\", device, error_obj.location,\n                     \"events are not supported via VK_KHR_portability_subset\");\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-vkCmdSetFragmentShadingRateKHR-pFragmentSize-04513\", \"pFragmentSize->width must be greater than or equal to 1\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (pFragmentSize->width == 0) {\n    skip |= LogError(\"VUID-vkCmdSetFragmentShadingRateKHR-pFragmentSize-04513\", commandBuffer,\n                     error_obj.location.dot(Field::pFragmentSize).dot(Field::width), \"is zero\");\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-vkCmdSetFragmentShadingRateKHR-pFragmentSize-04518\", \"pFragmentSize->height must be less than or equal to 4\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (pFragmentSize->height > 4) {\n    skip |= LogError(\"VUID-vkCmdSetFragmentShadingRateKHR-pFragmentSize-04518\", commandBuffer,\n                     error_obj.location.dot(Field::pFragmentSize).dot(Field::height), \"(%\" PRIu32 \") is larger than 4.\",\n                     pFragmentSize->height);\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkImageSubresourceLayers-aspectMask-00168\", \"aspectMask must not contain VK_IMAGE_ASPECT_METADATA_BIT\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (aspect_mask & VK_IMAGE_ASPECT_METADATA_BIT) {\n    skip |= LogError(\"VUID-VkImageSubresourceLayers-aspectMask-00168\", handle, subresource_loc.dot(Field::aspectMask), \"is %s.\",\n                     string_VkImageAspectFlags(aspect_mask).c_str());\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkCopyImageToImageInfoEXT-srcImage-09109\", \"If srcImage is sparse then all memory ranges accessed by the copy command must be bound as described in Binding Resource Memory\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (src_image_state->sparse && (!src_image_state->HasFullRangeBound())) {\n    skip |= LogError(\"VUID-VkCopyImageToImageInfoEXT-srcImage-09109\", src_image_state->Handle(), loc.dot(Field::srcImage),\n                     \"is a sparse image with no memory bound\");\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkDescriptorSetLayoutCreateInfo-flags-03000\", \"If any binding has the VK_DESCRIPTOR_BINDING_UPDATE_AFTER_BIND_BIT bit set, flags must include VK_DESCRIPTOR_SET_LAYOUT_CREATE_UPDATE_AFTER_BIND_POOL_BIT\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if ((create_info.flags & VK_DESCRIPTOR_SET_LAYOUT_CREATE_UPDATE_AFTER_BIND_POOL_BIT) == 0) {\n    skip |= LogError(\"VUID-VkDescriptorSetLayoutCreateInfo-flags-03000\", device, binding_flags_loc,\n                     \"includes VK_DESCRIPTOR_BINDING_UPDATE_AFTER_BIND_BIT but pCreateInfo->flags is %s.\",\n                     string_VkDescriptorSetLayoutCreateFlags(create_info.flags).c_str());\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkDescriptorSetLayoutBindingFlagsCreateInfo-descriptorBindingVariableDescriptorCount-03014\", \"If VkPhysicalDeviceDescriptorIndexingFeatures::descriptorBindingVariableDescriptorCount is not enabled, all elements of pBindingFlags must not include VK_DESCRIPTOR_BINDING_VARIABLE_DESCRIPTOR_COUNT_BIT\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (!enabled_features.descriptorBindingVariableDescriptorCount) {\n    skip |= LogError(\"VUID-VkDescriptorSetLayoutBindingFlagsCreateInfo-descriptorBindingVariableDescriptorCount-03014\",\n                     device, binding_flags_loc,\n                     \"includes VK_DESCRIPTOR_BINDING_VARIABLE_DESCRIPTOR_COUNT_BIT, but the \"\n                     \"descriptorBindingVariableDescriptorCount feature was not enabled.\");\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkDescriptorSetLayoutBinding-descriptorType-02209\", \"If descriptorType is VK_DESCRIPTOR_TYPE_INLINE_UNIFORM_BLOCK then descriptorCount must be a multiple of 4\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if ((binding_info.descriptorCount % 4) != 0) {\n    skip |= LogError(\"VUID-VkDescriptorSetLayoutBinding-descriptorType-02209\", device,\n                     binding_loc.dot(Field::descriptorCount), \"(%\" PRIu32 \") (must be a multiple of 4).\",\n                     binding_info.descriptorCount);\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkDescriptorSetLayoutCreateInfo-descriptorType-03001\", \"If any binding has the VK_DESCRIPTOR_BINDING_UPDATE_AFTER_BIND_BIT bit set, then all bindings must not have descriptorType of VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER_DYNAMIC or VK_DESCRIPTOR_TYPE_STORAGE_BUFFER_DYNAMIC\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (uniform_buffer_dynamic < create_info.bindingCount) {\n    skip |= LogError(\"VUID-VkDescriptorSetLayoutCreateInfo-descriptorType-03001\", device,\n                     create_info_loc.dot(Field::pBindings, update_after_bind),\n                     \"has VK_DESCRIPTOR_BINDING_UPDATE_AFTER_BIND_BIT \"\n                     \"flag, but pBindings[%\" PRIu32 \"] has descriptor type VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER_DYNAMIC.\",\n                     uniform_buffer_dynamic);\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkCopyDescriptorSet-srcSet-01918\", \"If srcSet's layout was created with the VK_DESCRIPTOR_SET_LAYOUT_CREATE_UPDATE_AFTER_BIND_POOL_BIT flag set, then dstSet's layout must also have been created with the VK_DESCRIPTOR_SET_LAYOUT_CREATE_UPDATE_AFTER_BIND_POOL_BIT flag set\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if ((src_layout->GetCreateFlags() & VK_DESCRIPTOR_SET_LAYOUT_CREATE_UPDATE_AFTER_BIND_POOL_BIT) &&\n    const LogObjectList objlist(update.srcSet, update.dstSet, src_layout->Handle(), dst_layout->Handle());\n    skip |= LogError(\"VUID-VkCopyDescriptorSet-srcSet-01918\", objlist, copy_loc.dot(Field::srcSet),\n                     \"layout was created with %s, but dstSet layout was created with %s.\",\n                     string_VkDescriptorSetLayoutCreateFlags(src_layout->GetCreateFlags()).c_str(),\n                     string_VkDescriptorSetLayoutCreateFlags(dst_layout->GetCreateFlags()).c_str());\n"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkCopyDescriptorSet-dstBinding-02224\", \"If the descriptor type of the descriptor set binding specified by dstBinding is VK_DESCRIPTOR_TYPE_INLINE_UNIFORM_BLOCK, dstArrayElement must be an integer multiple of 4\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (dst_type == VK_DESCRIPTOR_TYPE_INLINE_UNIFORM_BLOCK_EXT && ((update.dstArrayElement % 4) != 0)) {\n    const LogObjectList objlist(update.dstSet, dst_layout->Handle());\n    skip |= LogError(\"VUID-VkCopyDescriptorSet-dstBinding-02224\", objlist, copy_loc.dot(Field::dstArrayElement),\n                     \"is %\" PRIu32 \", but dstBinding (%\" PRIu32 \") type is VK_DESCRIPTOR_TYPE_INLINE_UNIFORM_BLOCK_EXT.\",\n                     update.dstArrayElement, update.dstBinding);\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkDescriptorImageInfo-descriptorType-06713\", \"If the image2DViewOf3D feature is not enabled or descriptorType is not VK_DESCRIPTOR_TYPE_STORAGE_IMAGE then imageView must not be a 2D view created from a 3D image\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (type == VK_DESCRIPTOR_TYPE_STORAGE_IMAGE && !enabled_features.image2DViewOf3D) {\n    skip |= LogError(\"VUID-VkDescriptorImageInfo-descriptorType-06713\", objlist, image_info_loc.dot(Field::imageView),\n                     \"is VK_IMAGE_VIEW_TYPE_2D, the image is VK_IMAGE_VIEW_TYPE_3D, and the descriptorType is \"\n                     \"VK_DESCRIPTOR_TYPE_STORAGE_IMAGE, but the image2DViewOf3D feature was not enabled.\");\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkDescriptorImageInfo-imageLayout-09426\", \"If imageLayout is VK_IMAGE_LAYOUT_DEPTH_READ_ONLY_STENCIL_ATTACHMENT_OPTIMAL, VK_IMAGE_LAYOUT_DEPTH_ATTACHMENT_STENCIL_READ_ONLY_OPTIMAL, VK_IMAGE_LAYOUT_DEPTH_READ_ONLY_OPTIMAL, VK_IMAGE_LAYOUT_DEPTH_ATTACHMENT_OPTIMAL, VK_IMAGE_LAYOUT_STENCIL_READ_ONLY_OPTIMAL, VK_IMAGE_LAYOUT_STENCIL_ATTACHMENT_OPTIMAL, VK_IMAGE_LAYOUT_DEPTH_STENCIL_ATTACHMENT_OPTIMAL or VK_IMAGE_LAYOUT_DEPTH_STENCIL_READ_ONLY_OPTIMAL, then the aspectMask used to create imageView must not include VK_IMAGE_ASPECT_COLOR_BIT\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (aspect_mask & VK_IMAGE_ASPECT_COLOR_BIT) {\n    skip |= LogError(\"VUID-VkDescriptorImageInfo-imageLayout-09426\", objlist, image_info_loc.dot(Field::imageView),\n                     \"uses layout %s but aspectMask (%s) includes color bit.\", string_VkImageLayout(image_layout),\n                     string_VkImageAspectFlags(aspect_mask).c_str());\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkWriteDescriptorSet-descriptorType-04152\", \"If descriptorType is VK_DESCRIPTOR_TYPE_STORAGE_IMAGE the imageLayout member of each element of pImageInfo must be a member of the list given in Storage Image\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "skip |= LogError(\"VUID-VkWriteDescriptorSet-descriptorType-04152\", objlist, image_info_loc.dot(Field::imageView),\n                 \"image layout is %s, but descriptorType is VK_DESCRIPTOR_TYPE_STORAGE_IMAGE. (allowed layouts are \"\n                 \"VK_IMAGE_LAYOUT_GENERAL or VK_IMAGE_LAYOUT_SHARED_PRESENT_KHR).\",\n                 string_VkImageLayout(image_layout));\n"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkWriteDescriptorSet-descriptorType-08765\", \"If descriptorType is VK_DESCRIPTOR_TYPE_UNIFORM_TEXEL_BUFFER, the pTexelBufferView buffer view usage must include VK_BUFFER_USAGE_UNIFORM_TEXEL_BUFFER_BIT\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (!(buffer_state.usage & VK_BUFFER_USAGE_UNIFORM_TEXEL_BUFFER_BIT)) {\n    skip |= LogError(\"VUID-VkWriteDescriptorSet-descriptorType-08765\", buffer_state.Handle(), buffer_loc,\n                     \"was created with %s, but descriptorType is VK_DESCRIPTOR_TYPE_UNIFORM_TEXEL_BUFFER.\",\n                     string_VkBufferUsageFlags2KHR(buffer_state.usage).c_str());\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkDescriptorBufferInfo-range-00341\", \"If range is not equal to VK_WHOLE_SIZE, range must be greater than 0\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (buffer_info.range == 0) {\n    skip |= LogError(\"VUID-VkDescriptorBufferInfo-range-00341\", buffer_info.buffer, buffer_info_loc.dot(Field::range),\n                     \"is not VK_WHOLE_SIZE and is zero.\");\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkWriteDescriptorSet-descriptorType-00325\", \"If descriptorType is VK_DESCRIPTOR_TYPE_SAMPLER or VK_DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER, and dstSet was not allocated with a layout that included immutable samplers for dstBinding with descriptorType, the sampler member of each element of pImageInfo must be a valid VkSampler object\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (!ValidateSampler(update.pImageInfo[di].sampler)) {\n    const LogObjectList objlist(update.dstSet, update.pImageInfo[di].sampler);\n    skip |= LogError(\"VUID-VkWriteDescriptorSet-descriptorType-00325\", objlist, write_loc,\n                     \"Attempted write update to sampler descriptor with invalid sample (%s).\",\n                     FormatHandle(update.pImageInfo[di].sampler).c_str());\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkWriteDescriptorSet-dstBinding-00316\", \"dstBinding must be a binding with a non-zero descriptorCount\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "update.dstBinding, FormatHandle(dst_layout->Handle()).c_str());\nreturn skip;  // the rest of checks assume a valid DescriptorBinding state\nskip |= LogError(\"VUID-VkWriteDescriptorSet-dstBinding-00316\", objlist, dst_binding_loc,\n\"(%\" PRIu32 \") has VkDescriptorSetLayoutBinding::descriptorCount of zero in %s.\", update.dstBinding,\nFormatHandle(dst_layout->Handle()).c_str());\n"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkWriteDescriptorSet-descriptorType-02221\", \"If descriptorType is VK_DESCRIPTOR_TYPE_INLINE_UNIFORM_BLOCK, the pNext chain must include a VkWriteDescriptorSetInlineUniformBlock structure whose dataSize member equals descriptorCount\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (!write_inline_info) {\n    skip |= LogError(\"VUID-VkWriteDescriptorSet-descriptorType-02221\", objlist, dst_binding_loc,\n                     \"(%\" PRIu32\n                     \") is of type VK_DESCRIPTOR_TYPE_INLINE_UNIFORM_BLOCK_EXT, but there is no \"\n                     \"VkWriteDescriptorSetInlineUniformBlock in the pNext chain.\",\n                     update.dstBinding);\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkWriteDescriptorSet-dstSet-04611\", \"If the VkDescriptorSetLayoutBinding for dstSet at dstBinding is VK_DESCRIPTOR_TYPE_MUTABLE_EXT, the new active descriptor type descriptorType must exist in the corresponding pMutableDescriptorTypeLists list for dstBinding\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (!dst_set.Layout().IsTypeMutable(update.descriptorType, update.dstBinding)) {\n    skip |= LogError(\"VUID-VkWriteDescriptorSet-dstSet-04611\", objlist, dst_binding_loc,\n                     \"(%\" PRIu32\n                     \") is of type VK_DESCRIPTOR_TYPE_MUTABLE_EXT, but the new descriptorType (%s) was not in \"\n                     \"VkMutableDescriptorTypeListEXT::pDescriptorTypes.\",\n                     update.dstBinding, string_VkDescriptorType(update.descriptorType));\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkDescriptorImageInfo-sampler-01564\", \"If sampler is used and the VkFormat of the image is a multi-planar format, the image must have been created with VK_IMAGE_CREATE_MUTABLE_FORMAT_BIT, and the aspectMask of the imageView must be a valid multi-planar aspect mask bit\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (!IsValidPlaneAspect(image_format, image_aspect)) {\n    const LogObjectList objlist(update.dstSet, image_state->Handle(), iv_state->Handle());\n    skip |= LogError(\"VUID-VkDescriptorImageInfo-sampler-01564\", objlist, write_loc,\n                     \"combined image sampler is a multi-planar format %s and imageView aspectMask is %s.\",\n                     string_VkFormat(image_format), string_VkImageAspectFlags(image_aspect).c_str());\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkDescriptorBufferBindingPushDescriptorBufferHandleEXT-bufferlessPushDescriptors-08059\", \"VkPhysicalDeviceDescriptorBufferPropertiesEXT::bufferlessPushDescriptors must be VK_FALSE\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (buffer_handle && phys_dev_ext_props.descriptor_buffer_props.bufferlessPushDescriptors) {\n    skip |= LogError(\"VUID-VkDescriptorBufferBindingPushDescriptorBufferHandleEXT-bufferlessPushDescriptors-08059\",\n                     commandBuffer, binding_loc.dot(Field::pNext),\n                     \"contains a VkDescriptorBufferBindingPushDescriptorBufferHandleEXT structure, \"\n                     \"but bufferlessPushDescriptors is VK_TRUE\");\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-vkGetDescriptorSetLayoutBindingOffsetEXT-None-08013\", \"The descriptorBuffer feature must be enabled\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (!enabled_features.descriptorBuffer) {\n    skip |= LogError(\"VUID-vkGetDescriptorSetLayoutBindingOffsetEXT-None-08013\", device, error_obj.location,\n                     \"descriptorBuffer feature was not enabled.\");\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-vkGetImageOpaqueCaptureDescriptorDataEXT-None-08076\", \"The descriptorBufferCaptureReplay feature must be enabled\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (!enabled_features.descriptorBufferCaptureReplay) {\n    skip |= LogError(\"VUID-vkGetImageOpaqueCaptureDescriptorDataEXT-None-08076\", pInfo->image, error_obj.location,\n                     \"descriptorBufferCaptureReplay feature was not enabled.\");\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkImageViewCaptureDescriptorDataInfoEXT-imageView-08083\", \"imageView must have been created with VK_IMAGE_VIEW_CREATE_DESCRIPTOR_BUFFER_CAPTURE_REPLAY_BIT_EXT set in VkImageViewCreateInfo::flags\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (!(image_view_state->create_info.flags & VK_IMAGE_VIEW_CREATE_DESCRIPTOR_BUFFER_CAPTURE_REPLAY_BIT_EXT)) {\n    skip |= LogError(\"VUID-VkImageViewCaptureDescriptorDataInfoEXT-imageView-08083\", pInfo->imageView,\n                     error_obj.location.dot(Field::pInfo).dot(Field::imageView), \"is %s.\",\n                     string_VkImageViewCreateFlags(image_view_state->create_info.flags).c_str());\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-vkGetAccelerationStructureOpaqueCaptureDescriptorDataEXT-device-08090\", \"If device was created with multiple physical devices, then the bufferDeviceAddressMultiDevice feature must be enabled\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (physical_device_count > 1 && !enabled_features.bufferDeviceAddressMultiDevice &&\n    skip |= LogError(\"VUID-vkGetAccelerationStructureOpaqueCaptureDescriptorDataEXT-device-08090\", device, error_obj.location,\n                     \"device was created with multiple physical devices (%\" PRIu32\n                     \"), but the \"\n                     \"bufferDeviceAddressMultiDevice feature was not enabled.\",\n                     physical_device_count);\n"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkDescriptorAddressInfoEXT-None-08044\", \"If address is not zero, address must be a valid device address at an offset within a VkBuffer\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if ((address_info->address != 0) && buffer_states.empty()) {\n    skip |= LogError(\"VUID-VkDescriptorAddressInfoEXT-None-08044\", device, address_loc.dot(Field::address),\n                     \"(0x%\" PRIx64 \") is not a valid buffer address.\", address_info->address);\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkDescriptorGetInfoEXT-type-08020\", \"If type is VK_DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER, the pCombinedImageSampler->imageView member of data must be a VkImageView created on device, or VK_NULL_HANDLE\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if ((pDescriptorInfo->data.pCombinedImageSampler->imageView != VK_NULL_HANDLE) &&\n    skip |= LogError(\"VUID-VkDescriptorGetInfoEXT-type-08020\", device, descriptor_info_loc.dot(Field::type),\n                     \"is VK_DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER, but \"\n                     \"pCombinedImageSampler->imageView is not a valid image view.\");\n"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkDescriptorGetInfoEXT-type-08025\", \"If type is VK_DESCRIPTOR_TYPE_STORAGE_TEXEL_BUFFER, pStorageTexelBuffer is not NULL and pStorageTexelBuffer->address is not zero, pStorageTexelBuffer->address must be an address within a VkBuffer created on device\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (address_info && (address_info->address != 0) && (GetBuffersByAddress(address_info->address).empty())) {\n    skip |= LogError(\"VUID-VkDescriptorGetInfoEXT-type-08025\", device, descriptor_info_loc.dot(Field::type),\n                     \"is VK_DESCRIPTOR_TYPE_STORAGE_TEXEL_BUFFER, but \"\n                     \"pStorageTexelBuffer->address (%\" PRIu64\n                     \") is not zero or \"\n                     \"an address within a buffer.\",\n                     address_info->address);\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkDescriptorDataEXT-type-08040\", \"If VkDescriptorGetInfoEXT:type is VK_DESCRIPTOR_TYPE_STORAGE_BUFFER, and the nullDescriptor feature is not enabled, pStorageBuffer must not be NULL\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (!address_info && !enabled_features.nullDescriptor) {\n    skip |= LogError(\"VUID-VkDescriptorDataEXT-type-08040\", device, descriptor_info_loc.dot(Field::type),\n                     \"is VK_DESCRIPTOR_TYPE_STORAGE_BUFFER, but \"\n                     \"pStorageBuffer is NULL and the nullDescriptor feature was not enabled.\");\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkDescriptorDataEXT-type-08035\", \"If VkDescriptorGetInfoEXT:type is VK_DESCRIPTOR_TYPE_SAMPLED_IMAGE, and the nullDescriptor feature is not enabled, pSampledImage must not be NULL and pSampledImage->imageView must not be VK_NULL_HANDLE\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (!enabled_features.nullDescriptor &&\n    skip |= LogError(\"VUID-VkDescriptorDataEXT-type-08035\", device, descriptor_info_loc.dot(Field::type),\n                     \"is VK_DESCRIPTOR_TYPE_SAMPLED_IMAGE, but \"\n                     \"pSampledImage is NULL, or pSampledImage->imageView is VK_NULL_HANDLE, and the nullDescriptor \"\n                     \"feature is not enabled.\");\n"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkDescriptorSetAllocateInfo-pSetLayouts-04610\", \"If any element of pSetLayouts was created with the VK_DESCRIPTOR_SET_LAYOUT_CREATE_HOST_ONLY_POOL_BIT_EXT bit set, descriptorPool must have been created with the VK_DESCRIPTOR_POOL_CREATE_HOST_ONLY_BIT_EXT flag set\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (ds_layout_state->GetCreateFlags() & VK_DESCRIPTOR_SET_LAYOUT_CREATE_HOST_ONLY_POOL_BIT_EXT &&\n    const LogObjectList objlist(pAllocateInfo->descriptorPool, pAllocateInfo->pSetLayouts[i]);\n    skip |= LogError(\"VUID-VkDescriptorSetAllocateInfo-pSetLayouts-04610\", objlist, set_layout_loc,\n                     \"was created with %s but the descriptorPool was created with %s\",\n                     string_VkDescriptorSetLayoutCreateFlags(ds_layout_state->GetCreateFlags()).c_str(),\n                     string_VkDescriptorPoolCreateFlags(ds_pool_state->create_info.flags).c_str());\n"
        },
        {
            "role": "user",
            "content": "{\"VUID-vkFreeDescriptorSets-descriptorPool-00312\", \"descriptorPool must have been created with the VK_DESCRIPTOR_POOL_CREATE_FREE_DESCRIPTOR_SET_BIT flag\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (!(VK_DESCRIPTOR_POOL_CREATE_FREE_DESCRIPTOR_SET_BIT & ds_pool_state->create_info.flags)) {\n    skip |= LogError(\"VUID-vkFreeDescriptorSets-descriptorPool-00312\", descriptorPool,\n                     error_obj.location.dot(Field::descriptorPool), \"with a pool created with %s.\",\n                     string_VkDescriptorPoolCreateFlags(ds_pool_state->create_info.flags).c_str());\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkDescriptorUpdateTemplateEntry-descriptor-02227\", \"If descriptor type is VK_DESCRIPTOR_TYPE_INLINE_UNIFORM_BLOCK, descriptorCount must be an integer multiple of 4\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (descriptor_update.descriptorCount & 3) {\n    skip |= LogError(\"VUID-VkDescriptorUpdateTemplateEntry-descriptor-02227\", pCreateInfo->pipelineLayout,\n                     create_info_loc.dot(Field::pDescriptorUpdateEntries, i),\n                     \"has descriptorType VK_DESCRIPTOR_TYPE_INLINE_UNIFORM_BLOCK_EXT, but descriptorCount (%\" PRIu32\n                     \") is not a \"\n                     \"multiple of 4).\",\n                     descriptor_update.descriptorCount);\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkPipelineLayoutCreateInfo-descriptorType-03017\", \"The total number of descriptors in descriptor set layouts created without the VK_DESCRIPTOR_SET_LAYOUT_CREATE_UPDATE_AFTER_BIND_POOL_BIT bit set with a descriptorType of VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER and VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER_DYNAMIC accessible to any given shader stage across all elements of pSetLayouts must be less than or equal to VkPhysicalDeviceLimits::maxPerStageDescriptorUniformBuffers\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (max_descriptors_per_stage[DSL_TYPE_UNIFORM_BUFFERS] > phys_dev_props.limits.maxPerStageDescriptorUniformBuffers) {\n    skip |= LogError(\"VUID-VkPipelineLayoutCreateInfo-descriptorType-03017\", device, error_obj.location,\n                     \"max per-stage uniform buffer bindings count (%\" PRIu32\n                     \") exceeds device \"\n                     \"maxPerStageDescriptorUniformBuffers limit (%\" PRIu32 \").\",\n                     max_descriptors_per_stage[DSL_TYPE_UNIFORM_BUFFERS],\n                     phys_dev_props.limits.maxPerStageDescriptorUniformBuffers);\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkPipelineLayoutCreateInfo-descriptorType-03028\", \"The total number of descriptors in descriptor set layouts created without the VK_DESCRIPTOR_SET_LAYOUT_CREATE_UPDATE_AFTER_BIND_POOL_BIT bit set with a descriptorType of VK_DESCRIPTOR_TYPE_SAMPLER and VK_DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER accessible across all shader stages and across all elements of pSetLayouts must be less than or equal to VkPhysicalDeviceLimits::maxDescriptorSetSamplers\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (sum > phys_dev_props.limits.maxDescriptorSetSamplers) {\n    skip |= LogError(\"VUID-VkPipelineLayoutCreateInfo-descriptorType-03028\", device, error_obj.location,\n                     \"sum of sampler bindings among all stages (%\" PRIu32\n                     \") exceeds device \"\n                     \"maxDescriptorSetSamplers limit (%\" PRIu32 \").\",\n                     sum, phys_dev_props.limits.maxDescriptorSetSamplers);\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkPipelineLayoutCreateInfo-None-10005\", \"The total number of descriptors in descriptor set layouts created without the VK_DESCRIPTOR_SET_LAYOUT_CREATE_UPDATE_AFTER_BIND_POOL_BIT bit set with a descriptorType of VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER_DYNAMIC or VK_DESCRIPTOR_TYPE_STORAGE_BUFFER_DYNAMIC accessible across all shader stages and across all elements of pSetLayouts must be less than or equal to VkPhysicalDeviceMaintenance7PropertiesKHR::maxDescriptorSetTotalBuffersDynamic\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (total_sum > phys_dev_ext_props.maintenance7_props.maxDescriptorSetTotalBuffersDynamic) {\n    skip |= LogError(\"VUID-VkPipelineLayoutCreateInfo-None-10005\", device, error_obj.location,\n                     \"sum of both dynamic storage buffer bindings (%\" PRIu32\n                     \") and dynamic uniform buffer bindings (%\" PRIu32 \") among all stages (%\" PRIu64\n                     \") exceeds device \"\n                     \"maxDescriptorSetTotalBuffersDynamic limit (%\" PRIu32 \").\",\n                     sum_all_uniform_buffer_dynamic, sum_all_storage_buffer_dynamic, total_sum,\n                     phys_dev_ext_props.maintenance7_props.maxDescriptorSetTotalBuffersDynamic);\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkPipelineLayoutCreateInfo-descriptorType-02216\", \"The total number of bindings in descriptor set layouts created without the VK_DESCRIPTOR_SET_LAYOUT_CREATE_UPDATE_AFTER_BIND_POOL_BIT bit set with a descriptorType of VK_DESCRIPTOR_TYPE_INLINE_UNIFORM_BLOCK accessible across all shader stages and across all elements of pSetLayouts must be less than or equal to VkPhysicalDeviceInlineUniformBlockProperties::maxDescriptorSetInlineUniformBlocks\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (inline_uniform_block_bindings_all_stages >\n    skip |= LogError(\"VUID-VkPipelineLayoutCreateInfo-descriptorType-02216\", device, error_obj.location,\n                     \"sum of inline uniform block bindings among all stages (%\" PRIu32\n                     \") exceeds device \"\n                     \"maxDescriptorSetInlineUniformBlocks limit (%\" PRIu32 \").\",\n                     inline_uniform_block_bindings_all_stages,\n                     phys_dev_ext_props.inline_uniform_block_props.maxDescriptorSetInlineUniformBlocks);\n"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkPipelineLayoutCreateInfo-descriptorType-03024\", \"The total number of descriptors with a descriptorType of VK_DESCRIPTOR_TYPE_STORAGE_BUFFER and VK_DESCRIPTOR_TYPE_STORAGE_BUFFER_DYNAMIC accessible to any given shader stage across all elements of pSetLayouts must be less than or equal to VkPhysicalDeviceDescriptorIndexingProperties::maxPerStageDescriptorUpdateAfterBindStorageBuffers\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (max_descriptors_per_stage_update_after_bind[DSL_TYPE_STORAGE_BUFFERS] >\n    skip |= LogError(\"VUID-VkPipelineLayoutCreateInfo-descriptorType-03024\", device, error_obj.location,\n                     \"max per-stage storage buffer bindings count (%\" PRIu32\n                     \") exceeds device \"\n                     \"maxPerStageDescriptorUpdateAfterBindStorageBuffers limit (%\" PRIu32 \").\",\n                     max_descriptors_per_stage_update_after_bind[DSL_TYPE_STORAGE_BUFFERS],\n                     phys_dev_props_core12.maxPerStageDescriptorUpdateAfterBindStorageBuffers);\n"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkPipelineLayoutCreateInfo-descriptorType-03572\", \"The total number of bindings with a descriptorType of VK_DESCRIPTOR_TYPE_ACCELERATION_STRUCTURE_KHR accessible to any given shader stage across all elements of pSetLayouts must be less than or equal to VkPhysicalDeviceAccelerationStructurePropertiesKHR::maxPerStageDescriptorUpdateAfterBindAccelerationStructures\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (max_descriptors_per_stage_update_after_bind[DSL_TYPE_ACCELERATION_STRUCTURE] >\n    skip |= LogError(\"VUID-VkPipelineLayoutCreateInfo-descriptorType-03572\", device, error_obj.location,\n                     \"max per-stage acceleration structure bindings count (%\" PRIu32\n                     \") exceeds device \"\n                     \"maxPerStageDescriptorUpdateAfterBindAccelerationStructures limit (%\" PRIu32 \").\",\n                     max_descriptors_per_stage_update_after_bind[DSL_TYPE_ACCELERATION_STRUCTURE],\n                     phys_dev_ext_props.acc_structure_props.maxPerStageDescriptorUpdateAfterBindAccelerationStructures);\n"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkPipelineLayoutCreateInfo-maintenance7-10008\", \"If the maintenance7 feature is enabled, the total number of descriptors of the type VK_DESCRIPTOR_TYPE_STORAGE_BUFFER_DYNAMIC accessible across all shader stages and across all elements of pSetLayouts must be less than or equal to VkPhysicalDeviceMaintenance7PropertiesKHR::maxDescriptorSetUpdateAfterBindTotalStorageBuffersDynamic\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (sum_all_after_bind_storage_buffer_dynamic >\n    skip |= LogError(\"VUID-VkPipelineLayoutCreateInfo-maintenance7-10008\", device, error_obj.location,\n                     \"sum of dynamic storage buffer bindings among all stages (%\" PRIu32\n                     \") exceeds device \"\n                     \"maxDescriptorSetUpdateAfterBindTotalStorageBuffersDynamic limit (%\" PRIu32 \").\",\n                     sum_all_after_bind_storage_buffer_dynamic,\n                     phys_dev_ext_props.maintenance7_props.maxDescriptorSetUpdateAfterBindTotalStorageBuffersDynamic);\n"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkPipelineLayoutCreateInfo-pSetLayouts-03042\", \"The total number of descriptors of the type VK_DESCRIPTOR_TYPE_STORAGE_IMAGE, and VK_DESCRIPTOR_TYPE_STORAGE_TEXEL_BUFFER accessible across all shader stages and across all elements of pSetLayouts must be less than or equal to VkPhysicalDeviceDescriptorIndexingProperties::maxDescriptorSetUpdateAfterBindStorageImages\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (sum > phys_dev_props_core12.maxDescriptorSetUpdateAfterBindStorageImages) {\n    skip |= LogError(\"VUID-VkPipelineLayoutCreateInfo-pSetLayouts-03042\", device, error_obj.location,\n                     \"sum of storage image bindings among all stages (%\" PRIu32\n                     \") exceeds device \"\n                     \"maxDescriptorSetUpdateAfterBindStorageImages limit (%\" PRIu32 \").\",\n                     sum, phys_dev_props_core12.maxDescriptorSetUpdateAfterBindStorageImages);\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkPipelineLayoutCreateInfo-graphicsPipelineLibrary-06753\", \"If graphicsPipelineLibrary is not enabled, elements of pSetLayouts must be valid VkDescriptorSetLayout objects\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (!pCreateInfo->pSetLayouts[i]) {\n    skip |= LogError(\"VUID-VkPipelineLayoutCreateInfo-graphicsPipelineLibrary-06753\", device,\n                     create_info_loc.dot(Field::pSetLayouts, i),\n                     \"is VK_NULL_HANDLE, but the graphicsPipelineLibrary feature is not enabled.\");\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkDeviceQueueCreateInfo-queueFamilyIndex-00381\", \"queueFamilyIndex must be less than pQueueFamilyPropertyCount returned by vkGetPhysicalDeviceQueueFamilyProperties\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "const uint32_t requested_queue_family = infos[i].queueFamilyIndex;\nskip |= ValidateQueueFamilyIndex(pd_state, requested_queue_family, \"VUID-VkDeviceQueueCreateInfo-queueFamilyIndex-00381\",\n                                 info_loc.dot(Field::queueFamilyIndex));\n"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkDeviceQueueCreateInfo-flags-06449\", \"If flags includes VK_DEVICE_QUEUE_CREATE_PROTECTED_BIT, queueFamilyIndex must be the index of a queue family that includes the VK_QUEUE_PROTECTED_BIT capability\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (protected_create_bit && ((requested_queue_family_props.queueFlags & VK_QUEUE_PROTECTED_BIT) == 0)) {\n    skip |= LogError(\"VUID-VkDeviceQueueCreateInfo-flags-06449\", pd_state.Handle(), info_loc.dot(Field::queueFamilyIndex),\n                     \"(%\" PRIu32 \") does not have VK_QUEUE_PROTECTED_BIT supported, but pQueueCreateInfos[%\" PRIu32\n                     \"].flags has VK_DEVICE_QUEUE_CREATE_PROTECTED_BIT.\",\n                     requested_queue_family, i);\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkDeviceCreateInfo-shadingRateImage-04480\", \"If the shadingRateImage feature is enabled, the attachmentFragmentShadingRate feature must not be enabled\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (fragment_shading_rate_features->attachmentFragmentShadingRate) {\n    skip |= LogError(\"VUID-VkDeviceCreateInfo-shadingRateImage-04480\", pd_state->Handle(), error_obj.location,\n                     \"Cannot enable shadingRateImage and attachmentFragmentShadingRate features \"\n                     \"simultaneously.\");\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkDeviceCreateInfo-None-04897\", \"If sparseImageFloat32Atomics is enabled, shaderImageFloat32Atomics must be enabled\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (shader_atomic_float_features->sparseImageFloat32Atomics &&\n    skip |= LogError(\"VUID-VkDeviceCreateInfo-None-04897\", pd_state->Handle(), error_obj.location,\n                     \"if sparseImageFloat32Atomics feature is enabled then shaderImageFloat32Atomics \"\n                     \"feature must also be enabled.\");\n"
        },
        {
            "role": "user",
            "content": "{\"VUID-vkGetPhysicalDeviceImageFormatProperties2-pNext-09004\", \"If the pNext chain of pImageFormatProperties includes a VkHostImageCopyDevicePerformanceQueryEXT structure, pImageFormatInfo->usage must contain VK_IMAGE_USAGE_HOST_TRANSFER_BIT_EXT\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if ((pImageFormatInfo->usage & VK_IMAGE_USAGE_HOST_TRANSFER_BIT_EXT) == 0) {\n    skip |= LogError(\"VUID-vkGetPhysicalDeviceImageFormatProperties2-pNext-09004\", physical_device, error_obj.location,\n                     \"pImageFormatProperties includes a chained \"\n                     \"VkHostImageCopyDevicePerformanceQueryEXT struct, but pImageFormatInfo->usage (%s) does not contain \"\n                     \"VK_IMAGE_USAGE_HOST_TRANSFER_BIT_EXT\",\n                     string_VkBufferUsageFlags(pImageFormatInfo->usage).c_str());\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-vkCmdSetDeviceMask-deviceMask-00111\", \"If vkCmdSetDeviceMask is called inside a render pass instance, deviceMask must not include any set bits that were not in the VkDeviceGroupRenderPassBeginInfo::deviceMask value when the render pass instance began recording\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (cb_state.activeRenderPass) {\n    skip |= ValidateDeviceMaskToRenderPass(cb_state, deviceMask, loc, \"VUID-vkCmdSetDeviceMask-deviceMask-00111\");\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-vkGetCalibratedTimestampsEXT-timeDomain-09246\", \"The timeDomain value of each VkCalibratedTimestampInfoKHR in pTimestampInfos must be unique\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (it != time_domain_map.end()) {\n    skip |= LogError(\"VUID-vkGetCalibratedTimestampsEXT-timeDomain-09246\", device,\n                     error_obj.location.dot(Field::pTimestampInfos, i).dot(Field::timeDomain),\n                     \"and pTimestampInfos[%\" PRIu32 \"].timeDomain are both %s.\", it->second,\n                     string_VkTimeDomainKHR(time_domain));\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-vkAllocateMemory-pAllocateInfo-01713\", \"pAllocateInfo->allocationSize must be less than or equal to VkPhysicalDeviceMemoryProperties::memoryHeaps[memindex].size where memindex = VkPhysicalDeviceMemoryProperties::memoryTypes[pAllocateInfo->memoryTypeIndex].heapIndex as returned by vkGetPhysicalDeviceMemoryProperties for the VkPhysicalDevice that device was created from\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (!IgnoreAllocationSize(*pAllocateInfo) &&\n    pAllocateInfo->allocationSize > phys_dev_mem_props.memoryHeaps[memory_type.heapIndex].size) {\n    skip |= LogError(\"VUID-vkAllocateMemory-pAllocateInfo-01713\", device, allocate_info_loc.dot(Field::allocationSize),\n                     \"is %\" PRIu64 \" bytes from heap %\" PRIu32\n                     \",\"\n                     \"but size of that heap is only %\" PRIu64 \" bytes.\",\n                     pAllocateInfo->allocationSize, memory_type.heapIndex,\n                     phys_dev_mem_props.memoryHeaps[memory_type.heapIndex].size);\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkMemoryDedicatedAllocateInfo-buffer-02965\", \"If buffer is not VK_NULL_HANDLE and the memory is not an imported Android Hardware Buffer or an imported QNX Screen buffer , VkMemoryAllocateInfo::allocationSize must equal the VkMemoryRequirements::size of the buffer\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (!IgnoreAllocationSize(*pAllocateInfo) && (pAllocateInfo->allocationSize != buffer_state->requirements.size) &&\n    skip |= LogError(\"VUID-VkMemoryDedicatedAllocateInfo-buffer-02965\", objlist,\n                     allocate_info_loc.dot(Field::allocationSize),\n                     \"(%\" PRIu64 \") needs to be equal to %s (%s) VkMemoryRequirements::size (%\" PRIu64 \").\",\n                     pAllocateInfo->allocationSize, buffer_loc.Fields().c_str(),\n                     FormatHandle(dedicated_buffer).c_str(), buffer_state->requirements.size);\n"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkMemoryDedicatedAllocateInfo-buffer-01879\", \"If buffer is not VK_NULL_HANDLE and VkMemoryAllocateInfo defines a memory import operation with handle type VK_EXTERNAL_MEMORY_HANDLE_TYPE_OPAQUE_FD_BIT, the memory being imported must also be a dedicated buffer allocation and buffer must be identical to the buffer associated with the imported memory\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "// TODO - Print out info about buffer creation info\nconst LogObjectList objlist(payload_info->dedicated_buffer, dedicated_buffer);\nskip |= LogError(\"VUID-VkMemoryDedicatedAllocateInfo-buffer-01879\", objlist,\n                 allocate_info_loc.pNext(Struct::VkMemoryDedicatedAllocateInfo, Field::buffer),\n                 \"is %s but %s (%d) was created with a dedicated buffer %s.\",\n                 FormatHandle(dedicated_buffer).c_str(), import_loc.Fields().c_str(),\n                 import_memory_fd_info->fd, FormatHandle(payload_info->dedicated_buffer).c_str());\n"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkMemoryDedicatedAllocateInfo-image-01876\", \"If image is not VK_NULL_HANDLE and VkMemoryAllocateInfo defines a memory import operation with handle type VK_EXTERNAL_MEMORY_HANDLE_TYPE_OPAQUE_WIN32_BIT, VK_EXTERNAL_MEMORY_HANDLE_TYPE_OPAQUE_WIN32_KMT_BIT, VK_EXTERNAL_MEMORY_HANDLE_TYPE_D3D11_TEXTURE_BIT, VK_EXTERNAL_MEMORY_HANDLE_TYPE_D3D11_TEXTURE_KMT_BIT, VK_EXTERNAL_MEMORY_HANDLE_TYPE_D3D12_HEAP_BIT, or VK_EXTERNAL_MEMORY_HANDLE_TYPE_D3D12_RESOURCE_BIT, and the external handle was created by the Vulkan API, then the memory being imported must also be a dedicated image allocation and image must be identical to the image associated with the imported memory\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "// TODO - Print out info about image creation info\nconst LogObjectList objlist(payload_info->dedicated_image, dedicated_image);\nskip |= LogError(\"VUID-VkMemoryDedicatedAllocateInfo-image-01876\", objlist,\n                 allocate_info_loc.pNext(Struct::VkMemoryDedicatedAllocateInfo, Field::image),\n                 \"is %s but %s (0x%\" PRIxPTR \") was created with a dedicated image %s.\",\n                 FormatHandle(dedicated_image).c_str(), import_loc.Fields().c_str(),\n                 reinterpret_cast<std::uintptr_t>(import_memory_win32_info->handle),\n                 FormatHandle(payload_info->dedicated_image).c_str());\n"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkExportMemoryAllocateInfo-handleTypes-00656\", \"The bits in handleTypes must be supported and compatible, as reported by VkExternalImageFormatProperties or VkExternalBufferProperties\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if ((external_features & VK_EXTERNAL_MEMORY_FEATURE_EXPORTABLE_BIT) == 0) {\n    const LogObjectList objlist(bind_info.image, bind_info.memory);\n    skip |= LogError(\"VUID-VkExportMemoryAllocateInfo-handleTypes-00656\", objlist, loc.dot(Field::memory),\n                     \"(%s) has VkExportMemoryAllocateInfo::handleTypes with the %s \"\n                     \"flag set, which does not support VK_EXTERNAL_MEMORY_FEATURE_EXPORTABLE_BIT with the \"\n                     \"image create format (%s), type (%s), tiling (%s), usage (%s), flags (%s).\",\n                     FormatHandle(bind_info.memory).c_str(),\n                     string_VkExternalMemoryHandleTypeFlagBits(flag), string_VkFormat(image_info.format),\n                     string_VkImageType(image_info.type), string_VkImageTiling(image_info.tiling),\n                     string_VkImageUsageFlags(image_info.usage).c_str(),\n                     string_VkImageCreateFlags(image_info.flags).c_str());\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkImageMemoryRequirementsInfo2-image-01590\", \"If image was not created with the VK_IMAGE_CREATE_DISJOINT_BIT flag, there must not be a VkImagePlaneMemoryRequirementsInfo included in the pNext chain of the VkImageMemoryRequirementsInfo2 structure\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if ((image_state->disjoint == false)) {\n    skip |= LogError(\"VUID-VkImageMemoryRequirementsInfo2-image-01590\", pInfo->image, image_loc,\n                     \"(%s) was not created with VK_IMAGE_CREATE_DISJOINT_BIT,\"\n                     \"but the current pNext includes a VkImagePlaneMemoryRequirementsInfo struct\",\n                     FormatHandle(pInfo->image).c_str());\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-vkMapMemory-memory-00683\", \"memory must not have been allocated with multiple instances\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (mem_info.multi_instance) {\n    skip |= LogError(map2 ? \"VUID-VkMemoryMapInfoKHR-memory-07963\" : \"VUID-vkMapMemory-memory-00683\", instance, loc,\n                     \"Memory allocated with multiple instances.\");\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkMemoryMapInfoKHR-offset-07959\", \"offset must be less than the size of memory\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (offset >= allocationSize) {\n    skip |= LogError(map2 ? \"VUID-VkMemoryMapInfoKHR-offset-07959\" : \"VUID-vkMapMemory-offset-00679\", memory, offset_loc,\n                     \"0x%\" PRIx64 \" is larger than the total array size 0x%\" PRIx64, offset, allocationSize);\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkMemoryMapInfoKHR-flags-09571\", \"If VK_MEMORY_MAP_PLACED_BIT_EXT is set in flags and the memoryMapRangePlaced feature is not enabled, offset must be zero\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (pMemoryMapInfo->offset != 0) {\n    skip |= LogError(\"VUID-VkMemoryMapInfoKHR-flags-09571\", pMemoryMapInfo->memory, info_loc.dot(Field::offset),\n                     \"(0x%\" PRIx64\n                     \") is not zero while VK_MEMORY_MAP_PLACED_BIT_EXT is set and \"\n                     \"memoryMapRangePlaced is not enabled.\",\n                     pMemoryMapInfo->offset);\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkMemoryMapInfoKHR-flags-09570\", \"If VK_MEMORY_MAP_PLACED_BIT_EXT is set in flags, the pNext chain must include a VkMemoryMapPlacedInfoEXT structure and VkMemoryMapPlacedInfoEXT::pPlacedAddress must not be NULL\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (placed_info == NULL) {\n    skip |= LogError(\"VUID-VkMemoryMapInfoKHR-flags-09570\", pMemoryMapInfo->memory, info_loc.dot(Field::pNext),\n                     \"does not contain VkMemoryMapPlacedInfoEXT, but VK_MEMORY_MAP_PLACED_BIT_EXT was set in flags (%s)\",\n                     string_VkMemoryMapFlags(pMemoryMapInfo->flags).c_str());\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkMemoryUnmapInfoKHR-flags-09579\", \"If VK_MEMORY_UNMAP_RESERVE_BIT_EXT is set in flags, the memoryUnmapReserve must be enabled\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (!enabled_features.memoryUnmapReserve) {\n    skip |= LogError(\"VUID-VkMemoryUnmapInfoKHR-flags-09579\", pMemoryUnmapInfo->memory, info_loc.dot(Field::flags),\n                     \"VK_MEMORY_MAP_PLACED_BIT_EXT is set but memoryUnmapReserve is not enabled\");\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkMappedMemoryRange-offset-00687\", \"offset must be a multiple of VkPhysicalDeviceLimits::nonCoherentAtomSize\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (SafeModulo(offset, atom_size) != 0) {\n    skip |= LogError(\"VUID-VkMappedMemoryRange-offset-00687\", mem_ranges->memory, memory_range_loc.dot(Field::offset),\n                     \"(%\" PRIu64 \") is not a multiple of VkPhysicalDeviceLimits::nonCoherentAtomSize (%\" PRIu64 \").\",\n                     offset, atom_size);\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-vkBindImageMemory2-pBindInfos-04006\", \"pBindInfos must not refer to the same image subresource more than once\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "const LogObjectList objlist(bind_info.image, bind_info.memory);\nskip |= LogError(\"VUID-vkBindImageMemory2-pBindInfos-04006\", objlist, loc.dot(Field::image),\n                 \"is non-disjoint and is being bound twice at pBindInfos[%d]\", it->second[0]);\n"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkBindImageMemorySwapchainInfoKHR-swapchain-07756\", \"If the swapchain has been created with VK_SWAPCHAIN_CREATE_DEFERRED_MEMORY_ALLOCATION_BIT_EXT, imageIndex must be one that has previously been returned by vkAcquireNextImageKHR or vkAcquireNextImage2KHR\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (swapchain_state->images[swapchain_info->imageIndex].acquired == false) {\n    const LogObjectList objlist(bind_info.image, bind_info.memory);\n    skip |= LogError(\"VUID-VkBindImageMemorySwapchainInfoKHR-swapchain-07756\", objlist,\n                     loc.pNext(Struct::VkBindImageMemorySwapchainInfoKHR, Field::swapchain),\n                     \"was created with VK_SWAPCHAIN_CREATE_DEFERRED_MEMORY_ALLOCATION_BIT_EXT but \"\n                     \"imageIndex (%\" PRIu32 \") has not been acquired\",\n                     swapchain_info->imageIndex);\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkBindImagePlaneMemoryInfo-planeAspect-02284\", \"If the image's tiling is VK_IMAGE_TILING_DRM_FORMAT_MODIFIER_EXT, then planeAspect must be a single valid memory plane for the image (that is, aspectMask must specify a plane index that is less than the VkDrmFormatModifierPropertiesEXT::drmFormatModifierPlaneCount associated with the image's format and VkImageDrmFormatModifierPropertiesEXT::drmFormatModifier)\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "const LogObjectList objlist(bind_info.image, bind_info.memory);\nskip |= LogError(\"VUID-VkBindImagePlaneMemoryInfo-planeAspect-02284\", objlist,\n                 loc.pNext(Struct::VkBindImagePlaneMemoryInfo, Field::planeAspect),\n                 \"is %s but is invalid for %s.\", string_VkImageAspectFlags(aspect).c_str(),\n                 string_VkFormat(image_format));\n"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkSparseMemoryBind-resourceOffset-09491\", \"If the resource being bound is a VkBuffer, resourceOffset, memoryOffset and size must be an integer multiple of the alignment of the VkMemoryRequirements structure returned from a call to vkGetBufferMemoryRequirements with the buffer resource\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (SafeModulo(bind.memoryOffset, buffer.requirements.alignment) != 0) {\n    const LogObjectList objlist(bind.memory, buffer.Handle());\n    skip |= LogError(\"VUID-VkSparseMemoryBind-resourceOffset-09491\", objlist, buffer_bind_info_loc.dot(Field::buffer),\n                     \"(%s) is being bound, but %s.memoryOffset (%\" PRIu64\n                     \") is not a multiple of required memory alignment (%\" PRIu64 \").\",\n                     FormatHandle(buffer).c_str(), bind_loc.Fields().c_str(), bind.memoryOffset, buffer.requirements.alignment);\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkSparseMemoryBind-memoryOffset-01101\", \"memoryOffset must be less than the size of memory\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (bind.memoryOffset >= mem_state->allocate_info.allocationSize) {\n    skip |= LogError(\"VUID-VkSparseMemoryBind-memoryOffset-01101\", bind.memory, bind_loc.dot(Field::memoryOffset),\n                     \"(%\" PRIu64 \") is not less than the size (%\" PRIu64 \") of memory.\", bind.memoryOffset,\n                     mem_state->allocate_info.allocationSize);\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkSparseMemoryBind-size-01100\", \"size must be less than or equal to the size of the resource minus resourceOffset\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if ((resource_size - bind.resourceOffset) < bind.size) {\n    const LogObjectList objlist(bind.memory, resource_handle);\n    skip |= LogError(\"VUID-VkSparseMemoryBind-size-01100\", objlist, loc.dot(Field::size),\n                     \"(%\" PRIu64 \") must be less than or equal to the size of the resource (%\" PRIu64\n                     \") minus resourceOffset (%\" PRIu64 \").\",\n                     bind.size, resource_size, bind.resourceOffset);\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkSparseImageMemoryBind-offset-01109\", \"offset.y must be a multiple of the sparse image block height (VkSparseImageFormatProperties::imageGranularity.height) of the image\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (SafeModulo(bind.offset.y, granularity.height) != 0) {\n    skip |= LogError(\"VUID-VkSparseImageMemoryBind-offset-01109\", image_state->Handle(),\n                     bind_loc.dot(Field::offset).dot(Field::y),\n                     \"(%\" PRId32\n                     \") must be a multiple of the sparse image block height \"\n                     \"(VkSparseImageFormatProperties::imageGranularity.height (%\" PRIu32 \")) of the image.\",\n                     bind.offset.y, granularity.height);\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-vkCmdCopyMemoryIndirectNV-None-07653\", \"The indirectMemoryCopy feature must be enabled\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (!enabled_features.indirectMemoryCopy) {\n    skip |= LogError(\"VUID-vkCmdCopyMemoryIndirectNV-None-07653\", commandBuffer, error_obj.location, \n                     \"The indirectMemoryCopy feature must be enabled\");\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-vkCmdCopyMemoryToImageIndirectNV-dstImage-07661\", \"dstImage must not be a protected image\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (!dst_image_state->unprotected) {\n    const LogObjectList objlist(commandBuffer, dstImage);\n    skip |= LogError(\"VUID-vkCmdCopyMemoryToImageIndirectNV-dstImage-07661\", objlist, error_obj.location.dot(Field::dstImage),\n                     \"must not be a protected image.\");\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-vkCmdCopyMemoryToImageIndirectNV-dstImage-07665\", \"If dstImage is non-sparse then it must be bound completely and contiguously to a single VkDeviceMemory object\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "const LogObjectList objlist(commandBuffer, dstImage);\nskip |= LogError(\"VUID-vkCmdCopyMemoryToImageIndirectNV-dstImage-07665\", objlist, error_obj.location.dot(Field::dstImage),\n                 \"is non-sparse, but it is not bound completely and contiguously to a single VkDeviceMemory object.\");\n"
        },
        {
            "role": "user",
            "content": "{\"VUID-vkGetBufferDeviceAddress-bufferDeviceAddress-03324\", \"The bufferDeviceAddress or VkPhysicalDeviceBufferDeviceAddressFeaturesEXT::bufferDeviceAddress feature must be enabled\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (!enabled_features.bufferDeviceAddress && !enabled_features.bufferDeviceAddressEXT) {\n    skip |= LogError(\"VUID-vkGetBufferDeviceAddress-bufferDeviceAddress-03324\", pInfo->buffer, error_obj.location,\n                     \"The bufferDeviceAddress feature must be enabled.\");\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-vkGetDeviceMemoryOpaqueCaptureAddress-device-03335\", \"If device was created with multiple physical devices, then the bufferDeviceAddressMultiDevice feature must be enabled\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (physical_device_count > 1 && !enabled_features.bufferDeviceAddressMultiDevice) {\n    skip |= LogError(\"VUID-vkGetDeviceMemoryOpaqueCaptureAddress-device-03335\", objlst, error_obj.location,\n                     \"If device was created with multiple physical devices, then the \"\n                     \"bufferDeviceAddressMultiDevice feature was not enabled.\");\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-vkCmdDrawMultiIndexedEXT-None-04937\", \"The multiDraw feature must be enabled\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (!enabled_features.multiDraw) {\n    skip |= LogError(\"VUID-vkCmdDrawMultiIndexedEXT-None-04937\", cb_state.GetObjectList(VK_PIPELINE_BIND_POINT_GRAPHICS),\n                     error_obj.location, \"multiDraw feature was not enabled.\");\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-vkCmdDrawIndirect-drawCount-02719\", \"drawCount must be less than or equal to VkPhysicalDeviceLimits::maxDrawIndirectCount\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (drawCount > phys_dev_props.limits.maxDrawIndirectCount) {\n    skip |= LogError(\"VUID-vkCmdDrawIndirect-drawCount-02719\", cb_state.GetObjectList(VK_PIPELINE_BIND_POINT_GRAPHICS),\n                     error_obj.location.dot(Field::drawCount),\n                     \"(%\" PRIu32 \") is not less than or equal to the maximum allowed (%\" PRIu32 \").\", drawCount,\n                     phys_dev_props.limits.maxDrawIndirectCount);\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-vkCmdDrawIndexedIndirect-drawCount-02718\", \"If the multiDrawIndirect feature is not enabled, drawCount must be 0 or 1\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (!enabled_features.multiDrawIndirect && ((drawCount > 1))) {\n    skip |= LogError(\"VUID-vkCmdDrawIndexedIndirect-drawCount-02718\", cb_state.GetObjectList(VK_PIPELINE_BIND_POINT_GRAPHICS),\n                     error_obj.location.dot(Field::drawCount),\n                     \"(%\" PRIu32 \") must be 0 or 1 if multiDrawIndirect feature is not enabled.\", drawCount);\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-vkCmdDrawIndexedIndirect-drawCount-00539\", \"If drawCount is equal to 1, (offset + sizeof(VkDrawIndexedIndirectCommand)) must be less than or equal to the size of buffer\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "} else if ((drawCount == 1) && (offset + sizeof(VkDrawIndexedIndirectCommand)) > buffer_state->create_info.size) {\n    LogObjectList objlist = cb_state.GetObjectList(VK_PIPELINE_BIND_POINT_GRAPHICS);\n    objlist.add(buffer);\n    skip |= LogError(\"VUID-vkCmdDrawIndexedIndirect-drawCount-00539\", objlist, error_obj.location.dot(Field::drawCount),\n                     \"is 1 and (offset + sizeof(VkDrawIndexedIndirectCommand)) (%\" PRIu64\n                     \") is not less than \"\n                     \"or equal to the size of buffer (%\" PRIu64 \").\",\n                     (offset + sizeof(VkDrawIndexedIndirectCommand)), buffer_state->create_info.size);\n"
        },
        {
            "role": "user",
            "content": "{\"VUID-vkCmdDispatchBase-baseGroupX-00427\", \"If any of baseGroupX, baseGroupY, or baseGroupZ are not zero, then the bound compute pipeline must have been created with the VK_PIPELINE_CREATE_DISPATCH_BASE flag or the bound compute shader object must have been created with the VK_SHADER_CREATE_DISPATCH_BASE_BIT_EXT flag\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (shader_object && ((shader_object->create_info.flags & VK_SHADER_CREATE_DISPATCH_BASE_BIT_EXT) == 0)) {\n    skip |= LogError(\"VUID-vkCmdDispatchBase-baseGroupX-00427\", cb_state.GetObjectList(VK_SHADER_STAGE_COMPUTE_BIT),\n                     error_obj.location,\n                     \"If any of baseGroupX (%\" PRIu32 \"), baseGroupY (%\" PRIu32 \"), or baseGroupZ (%\" PRIu32\n                     \") are not zero, then the bound compute shader object \"\n                     \"must have been created with the VK_SHADER_CREATE_DISPATCH_BASE_BIT_EXT flag\",\n                     baseGroupX, baseGroupY, baseGroupZ);\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-vkCmdDrawIndirectCount-stride-03110\", \"stride must be a multiple of 4 and must be greater than or equal to sizeof(VkDrawIndirectCommand)\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "skip |= ValidateCmdDrawStrideWithStruct(cb_state, \"VUID-vkCmdDrawIndirectCount-stride-03110\", stride,\n                                        Struct::VkDrawIndirectCommand, sizeof(VkDrawIndirectCommand), error_obj.location);\n"
        },
        {
            "role": "user",
            "content": "{\"VUID-vkCmdDrawIndexedIndirectCount-stride-03142\", \"stride must be a multiple of 4 and must be greater than or equal to sizeof(VkDrawIndexedIndirectCommand)\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "skip |= ValidateCmdDrawStrideWithStruct(cb_state, \"VUID-vkCmdDrawIndexedIndirectCount-stride-03142\", stride,\n                                        Struct::VkDrawIndexedIndirectCommand, sizeof(VkDrawIndexedIndirectCommand),\n                                        error_obj.location);\n"
        },
        {
            "role": "user",
            "content": "{\"VUID-vkCmdDrawIndirectByteCountEXT-counterOffset-09474\", \"counterOffset must be a multiple of 4\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (SafeModulo(counterOffset, 4) != 0) {\n    skip |= LogError(\"VUID-vkCmdDrawIndirectByteCountEXT-counterOffset-09474\",\n                     cb_state.GetObjectList(VK_PIPELINE_BIND_POINT_GRAPHICS), error_obj.location.dot(Field::counterOffset),\n                     \"(%\" PRIu32 \") must be a multiple of 4.\", counterOffset);\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-vkCmdTraceRaysNV-hitShaderBindingOffset-02460\", \"hitShaderBindingOffset must be a multiple of VkPhysicalDeviceRayTracingPropertiesNV::shaderGroupBaseAlignment\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (SafeModulo(hitShaderBindingOffset, phys_dev_ext_props.ray_tracing_props_nv.shaderGroupBaseAlignment) != 0) {\n    skip |= LogError(\"VUID-vkCmdTraceRaysNV-hitShaderBindingOffset-02460\",\n                     cb_state.GetObjectList(VK_PIPELINE_BIND_POINT_RAY_TRACING_KHR),\n                     error_obj.location.dot(Field::hitShaderBindingOffset),\n                     \"must be a multiple of \"\n                     \"VkPhysicalDeviceRayTracingPropertiesNV::shaderGroupBaseAlignment.\");\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-vkCmdTraceRaysNV-missShaderBindingStride-02466\", \"missShaderBindingStride must be less than or equal to VkPhysicalDeviceRayTracingPropertiesNV::maxShaderGroupStride\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (missShaderBindingStride > phys_dev_ext_props.ray_tracing_props_nv.maxShaderGroupStride) {\n    skip |= LogError(\"VUID-vkCmdTraceRaysNV-missShaderBindingStride-02466\",\n                     cb_state.GetObjectList(VK_PIPELINE_BIND_POINT_RAY_TRACING_KHR),\n                     error_obj.location.dot(Field::missShaderBindingStride),\n                     \"must be less than or equal to \"\n                     \"VkPhysicalDeviceRayTracingPropertiesNV::maxShaderGroupStride.\");\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-vkCmdTraceRaysNV-callableShaderBindingOffset-02461\", \"callableShaderBindingOffset must be less than the size of callableShaderBindingTableBuffer\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (callable_shader_buffer_state && callableShaderBindingOffset >= callable_shader_buffer_state->create_info.size) {\n    LogObjectList objlist = cb_state.GetObjectList(VK_PIPELINE_BIND_POINT_RAY_TRACING_KHR);\n    objlist.add(callableShaderBindingTableBuffer);\n    skip |= LogError(\"VUID-vkCmdTraceRaysNV-callableShaderBindingOffset-02461\", objlist,\n                     error_obj.location.dot(Field::callableShaderBindingOffset),\n                     \"%\" PRIu64 \" must be less than the size of callableShaderBindingTableBuffer %\" PRIu64 \" .\",\n                     callableShaderBindingOffset, callable_shader_buffer_state->create_info.size);\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-vkCmdDrawMeshTasksIndirectNV-drawCount-02718\", \"If the multiDrawIndirect feature is not enabled, drawCount must be 0 or 1\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (!enabled_features.multiDrawIndirect) {\n    skip |= LogError(\"VUID-vkCmdDrawMeshTasksIndirectNV-drawCount-02718\",\n                     cb_state.GetObjectList(VK_PIPELINE_BIND_POINT_GRAPHICS), error_obj.location.dot(Field::drawCount),\n                     \"(%\" PRIu32 \") must be 0 or 1 if multiDrawIndirect feature is not enabled.\", drawCount);\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-vkCmdDrawMeshTasksIndirectCountNV-maxDrawCount-02183\", \"If maxDrawCount is greater than or equal to 1, (stride \u00d7 (maxDrawCount - 1) + offset + sizeof(VkDrawMeshTasksIndirectCommandNV)) must be less than or equal to the size of buffer\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (maxDrawCount > 1) {\n    skip |= ValidateCmdDrawStrideWithBuffer(cb_state, \"VUID-vkCmdDrawMeshTasksIndirectCountNV-maxDrawCount-02183\", stride,\n                                            Struct::VkDrawMeshTasksIndirectCommandNV, sizeof(VkDrawMeshTasksIndirectCommandNV),\n                                            maxDrawCount, offset, *buffer_state, error_obj.location);\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-vkCmdDrawMeshTasksIndirectCountEXT-stride-07096\", \"stride must be a multiple of 4 and must be greater than or equal to sizeof(VkDrawMeshTasksIndirectCommandEXT)\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "skip |= ValidateBufferUsageFlags(LogObjectList(commandBuffer, countBuffer), *count_buffer_state,\nskip |= ValidateCmdDrawStrideWithStruct(cb_state, \"VUID-vkCmdDrawMeshTasksIndirectCountEXT-stride-07096\", stride,\n                                        Struct::VkDrawMeshTasksIndirectCommandEXT, sizeof(VkDrawMeshTasksIndirectCommandEXT),\n                                        error_obj.location);\n"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkImportSemaphoreFdInfoKHR-handleType-07307\", \"If handleType refers to a handle type with copy payload transference semantics, flags must contain VK_SEMAPHORE_IMPORT_TEMPORARY_BIT\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (pImportSemaphoreFdInfo->handleType == VK_EXTERNAL_SEMAPHORE_HANDLE_TYPE_SYNC_FD_BIT) {\n    skip |= LogError(\"VUID-VkImportSemaphoreFdInfoKHR-handleType-07307\", sem_state->Handle(), info_loc.dot(Field::flags),\n                     \"is %s and handleType is VK_EXTERNAL_SEMAPHORE_HANDLE_TYPE_SYNC_FD_BIT.\",\n                     string_VkSemaphoreImportFlags(pImportSemaphoreFdInfo->flags).c_str());\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkSemaphoreGetFdInfoKHR-semaphore-01133\", \"semaphore must not currently have its payload replaced by an imported payload as described below in Importing Semaphore Payloads unless that imported payload's handle type was included in VkExternalSemaphoreProperties::exportFromImportedHandleTypes for handleType\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (sem_state->Scope() != vvl::Semaphore::kInternal && sem_state->HasImportedHandleType() &&\n    !CanSemaphoreExportFromImported(physical_device, pGetFdInfo->handleType, sem_state->ImportedHandleType())) {\n    skip |= LogError(\"VUID-VkSemaphoreGetFdInfoKHR-semaphore-01133\", sem_state->Handle(), info_loc.dot(Field::handleType),\n                     \"(%s) cannot be exported from semaphore with imported payload with handle type %s\",\n                     string_VkExternalSemaphoreHandleTypeFlagBits(pGetFdInfo->handleType),\n                     string_VkExternalSemaphoreHandleTypeFlagBits(sem_state->ImportedHandleType()));\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkFenceGetFdInfoKHR-handleType-01454\", \"If handleType refers to a handle type with copy payload transference semantics, fence must be signaled, or have an associated fence signal operation pending execution\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (pGetFdInfo->handleType == VK_EXTERNAL_FENCE_HANDLE_TYPE_SYNC_FD_BIT && fence_state->State() == vvl::Fence::kUnsignaled) {\n    skip |= LogError(\"VUID-VkFenceGetFdInfoKHR-handleType-01454\", fence_state->Handle(), info_loc.dot(Field::handleType),\n                     \"is VK_EXTERNAL_FENCE_HANDLE_TYPE_SYNC_FD_BIT which cannot be exported unless the fence has a pending \"\n                     \"signal operation or is already signaled.\");\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkSemaphoreGetWin32HandleInfoKHR-semaphore-01128\", \"semaphore must not currently have its payload replaced by an imported payload as described below in Importing Semaphore Payloads unless that imported payload's handle type was included in VkExternalSemaphoreProperties::exportFromImportedHandleTypes for handleType\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (sem_state->Scope() != vvl::Semaphore::kInternal && sem_state->HasImportedHandleType() &&\n    !CanSemaphoreExportFromImported(physical_device, pGetWin32HandleInfo->handleType, sem_state->ImportedHandleType())) {\n    skip |= LogError(\"VUID-VkSemaphoreGetWin32HandleInfoKHR-semaphore-01128\", sem_state->Handle(),\n                     error_obj.location.dot(Field::pGetWin32HandleInfo).dot(Field::handleType),\n                     \"(%s) cannot be exported from semaphore with imported payload with handle type %s\",\n                     string_VkExternalSemaphoreHandleTypeFlagBits(pGetWin32HandleInfo->handleType),\n                     string_VkExternalSemaphoreHandleTypeFlagBits(sem_state->ImportedHandleType()));\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkExportMetalObjectsInfoEXT-pNext-06802\", \"If the pNext chain includes a VkExportMetalTextureInfoEXT structure, and if the VkImageView in its imageView member has a multi-planar format with only two planes, then its plane member must not be VK_IMAGE_ASPECT_PLANE_2_BIT\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if ((format_plane_count == 2) && (image_plane == VK_IMAGE_ASPECT_PLANE_2_BIT)) {\n    skip |= LogError(\"VUID-VkExportMetalObjectsInfoEXT-pNext-06802\", device, error_obj.location,\n                     \"pNext chain contains a VkExportMetalTextureInfoEXT structure \"\n                     \"with imageView = \"\n                     \"%s, and plane = %s, but imageView was created with format %s, which has exactly 2 \"\n                     \"planes and plane \"\n                     \"cannot\"\n                     \"be VK_IMAGE_ASPECT_PLANE_2_BIT\",\n                     FormatHandle(metal_texture_ptr->imageView).c_str(),\n                     string_VkImageAspectFlags(image_plane).c_str(),\n                     string_VkFormat(image_view_info->create_info.format));\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkImageCreateInfo-pNext-09653\", \"If the pNext chain contains a VkImageAlignmentControlCreateInfoMESA structure, tiling must be VK_IMAGE_TILING_OPTIMAL\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (create_info.tiling != VK_IMAGE_TILING_OPTIMAL) {\n    skip |= LogError(\"VUID-VkImageCreateInfo-pNext-09653\", device, create_info_loc.dot(Field::tiling),\n                     \"is %s but needs to be VK_IMAGE_TILING_OPTIMAL\", string_VkImageTiling(create_info.tiling));\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkImageCreateInfo-None-01925\", \"If any of the bits VK_IMAGE_CREATE_SPARSE_BINDING_BIT, VK_IMAGE_CREATE_SPARSE_RESIDENCY_BIT, or VK_IMAGE_CREATE_SPARSE_ALIASED_BIT are set, VK_IMAGE_USAGE_TRANSIENT_ATTACHMENT_BIT must not also be set\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if ((pCreateInfo->flags & sparseFlags) && (pCreateInfo->usage & VK_IMAGE_USAGE_TRANSIENT_ATTACHMENT_BIT)) {\n    skip |= LogError(\"VUID-VkImageCreateInfo-None-01925\", device, create_info_loc,\n                     \"images using sparse memory cannot have VK_IMAGE_USAGE_TRANSIENT_ATTACHMENT_BIT set.\");\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkImageCreateInfo-mipLevels-02255\", \"mipLevels must be less than or equal to imageCreateMaxMipLevels (as defined in Image Creation Limits)\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (pCreateInfo->mipLevels > format_limits.maxMipLevels) {\n    skip |= LogError(\"VUID-VkImageCreateInfo-mipLevels-02255\", device, create_info_loc.dot(Field::mipLevels),\n                     \"(%d) exceed image format maxMipLevels (%d) for format %s.\", pCreateInfo->mipLevels,\n                     format_limits.maxMipLevels, string_VkFormat(pCreateInfo->format));\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkImageCreateInfo-extent-02254\", \"extent.depth must be less than or equal to imageCreateMaxExtent.depth (as defined in Image Creation Limits)\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (pCreateInfo->extent.depth > format_limits.maxExtent.depth) {\n    skip |= LogError(\"VUID-VkImageCreateInfo-extent-02254\", device, create_info_loc.dot(Field::extent).dot(Field::depth),\n                     \"(%\" PRIu32 \") exceeds allowable maximum image extent depth %\" PRIu32 \" for format %s.\",\n                     pCreateInfo->extent.depth, format_limits.maxExtent.depth, string_VkFormat(pCreateInfo->format));\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkImageCreateInfo-format-01577\", \"If format is not a multi-planar format, and flags does not include VK_IMAGE_CREATE_ALIAS_BIT, flags must not contain VK_IMAGE_CREATE_DISJOINT_BIT\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (!vkuFormatIsMultiplane(pCreateInfo->format) && !(pCreateInfo->flags & VK_IMAGE_CREATE_ALIAS_BIT) &&\n    skip |= LogError(\"VUID-VkImageCreateInfo-format-01577\", device, create_info_loc,\n                     \"format is %s and flags are %s. The flags should not include VK_IMAGE_CREATE_DISJOINT_BIT.\",\n                     string_VkFormat(pCreateInfo->format), string_VkImageCreateFlags(pCreateInfo->flags).c_str());\n"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkImageCreateInfo-imageView2DOn3DImage-04459\", \"If the VK_KHR_portability_subset extension is enabled, and VkPhysicalDevicePortabilitySubsetFeaturesKHR::imageView2DOn3DImage is VK_FALSE, flags must not contain VK_IMAGE_CREATE_2D_ARRAY_COMPATIBLE_BIT\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (VK_IMAGE_CREATE_2D_ARRAY_COMPATIBLE_BIT & pCreateInfo->flags && VK_FALSE == enabled_features.imageView2DOn3DImage) {\n    skip |= LogError(\"VUID-VkImageCreateInfo-imageView2DOn3DImage-04459\", device, create_info_loc,\n                     \"(portability error) VK_IMAGE_CREATE_2D_ARRAY_COMPATIBLE_BIT is not supported.\");\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkImageCreateInfo-pNext-00991\", \"If the pNext chain includes a VkExternalMemoryImageCreateInfoNV structure, its handleTypes member must only contain bits that are also in VkExternalImageFormatPropertiesNV::externalMemoryProperties.compatibleHandleTypes, as returned by vkGetPhysicalDeviceExternalImageFormatPropertiesNV with format, imageType, tiling, usage, and flags equal to those in this structure, and with externalHandleType equal to any one of the handle types specified in VkExternalMemoryImageCreateInfoNV::handleTypes\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (result != VK_SUCCESS) {\n    skip |= LogError(\"VUID-VkImageCreateInfo-pNext-00991\", device, create_info_loc,\n                     \"The handle type (%s), format (%s), type (%s), tiling (%s), usage (%s), flags (%s) \"\n                     \"is not supported combination of parameters and vkGetPhysicalDeviceExternalImageFormatPropertiesNV \"\n                     \"returned back %s.\",\n                     string_VkExternalMemoryHandleTypeFlagBitsNV(handle_type), string_VkFormat(pCreateInfo->format),\n                     string_VkImageType(pCreateInfo->imageType), string_VkImageTiling(pCreateInfo->tiling),\n                     string_VkImageUsageFlags(pCreateInfo->usage).c_str(),\n                     string_VkImageCreateFlags(pCreateInfo->flags).c_str(), string_VkResult(result));\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkImageCreateInfo-flags-08328\", \"If flags includes VK_IMAGE_CREATE_VIDEO_PROFILE_INDEPENDENT_BIT_KHR, then videoMaintenance1 must be enabled\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (video_profile_independent && !enabled_features.videoMaintenance1) {\n    skip |= LogError(\"VUID-VkImageCreateInfo-flags-08328\", device, create_info_loc.dot(Field::flags),\n                     \"has VK_IMAGE_CREATE_VIDEO_PROFILE_INDEPENDENT_BIT_KHR is set but the videoMaintenance1 \"\n                     \"device feature is not enabled.\");\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkImageCreateInfo-pNext-06744\", \"If the pNext chain includes a VkImageCompressionControlEXT structure, format is not a multi-planar format, and VkImageCompressionControlEXT::flags includes VK_IMAGE_COMPRESSION_FIXED_RATE_EXPLICIT_EXT, then VkImageCompressionControlEXT::compressionControlPlaneCount must be 1\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (image_compression_control->compressionControlPlaneCount != 1) {\n    skip |= LogError(\"VUID-VkImageCreateInfo-pNext-06744\", device, create_info_loc,\n                     \"VkImageCompressionControlEXT::flags contain VK_IMAGE_COMPRESSION_FIXED_RATE_EXPLICIT_EXT and \"\n                     \"VkImageCreateInfo::format is a not a multi-planar format (%s), but \"\n                     \"VkImageCompressionControlEXT::compressionControlPlaneCount is %\" PRIu32,\n                     string_VkFormat(pCreateInfo->format), image_compression_control->compressionControlPlaneCount);\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-vkCmdClearColorImage-commandBuffer-01805\", \"If commandBuffer is an unprotected command buffer and protectedNoFault is not supported, image must not be a protected image\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "skip |= ValidateImageFormatFeatureFlags(commandBuffer, image_state, VK_FORMAT_FEATURE_2_TRANSFER_DST_BIT_KHR, image_loc,\n                                        \"VUID-vkCmdClearColorImage-image-01993\");\nskip |= ValidateProtectedImage(cb_state, image_state, image_loc, \"VUID-vkCmdClearColorImage-commandBuffer-01805\");\n"
        },
        {
            "role": "user",
            "content": "{\"VUID-vkCmdClearColorImage-image-01545\", \"image must not use any of the formats that require a sampler Y'CBCR conversion\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (FormatRequiresYcbcrConversionExplicitly(format)) {\n    skip |= LogError(\"VUID-vkCmdClearColorImage-image-01545\", objlist, image_loc, \"(%s) was created with format %s.\",\n                     FormatHandle(image).c_str(), string_VkFormat(format));\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-vkCmdClearDepthStencilImage-image-02825\", \"If the image's format does not have a stencil component, then the VkImageSubresourceRange::aspectMask member of each element of the pRanges array must not include the VK_IMAGE_ASPECT_STENCIL_BIT bit\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (vkuFormatHasStencil(image_format) == false) {\n    skip |= LogError(\"VUID-vkCmdClearDepthStencilImage-image-02825\", objlist, range_loc.dot(Field::aspectMask),\n                     \"has a VK_IMAGE_ASPECT_STENCIL_BIT but \"\n                     \"%s doesn't have a stencil component.\",\n                     string_VkFormat(image_format));\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-vkCmdClearAttachments-aspectMask-07885\", \"If the current render pass instance does not use dynamic rendering, and the aspectMask member of any element of pAttachments contains VK_IMAGE_ASPECT_STENCIL_BIT, the current subpass instance's depth-stencil attachment must be either VK_ATTACHMENT_UNUSED or the attachment format must contain a stencil component\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if ((aspect_mask & VK_IMAGE_ASPECT_STENCIL_BIT) && !vkuFormatHasStencil(image_view_format)) {\n    const LogObjectList objlist(commandBuffer, cb_state.activeRenderPass->Handle(),\n    skip |= LogError(\"VUID-vkCmdClearAttachments-aspectMask-07885\", objlist, attachment_loc,\n                     \"in pSubpasses[%\" PRIu32\n                     \"] has VK_IMAGE_ASPECT_STENCIL_BIT and is backed by an image view with format (%s).\",\n                     cb_state.GetActiveSubpass(), string_VkFormat(image_view_format));\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-vkCmdClearAttachments-aspectMask-09298\", \"If the subpass this is recorded in performs an external format resolve, the aspectMask member of any element of pAttachments must not include VK_IMAGE_ASPECT_PLANE_i_BIT for any index i\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "attachment_loc.dot(Field::clearValue).dot(Field::depthStencil));\nconst LogObjectList objlist(commandBuffer, cb_state.activeRenderPass->Handle());\nskip |= LogError(\"VUID-vkCmdClearAttachments-aspectMask-09298\", objlist, attachment_loc.dot(Field::aspectMask),\n\"is %s.\", string_VkImageAspectFlags(aspect_mask).c_str());\n"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkImageSubresourceRange-aspectMask-01670\", \"If aspectMask includes VK_IMAGE_ASPECT_COLOR_BIT, then it must not include any of VK_IMAGE_ASPECT_PLANE_0_BIT, VK_IMAGE_ASPECT_PLANE_1_BIT, or VK_IMAGE_ASPECT_PLANE_2_BIT\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (subresourceRange.aspectMask &\n    skip |= LogError(\"VUID-VkImageSubresourceRange-aspectMask-01670\", objlist, subresource_loc.dot(Field::aspectMask),\n                     \"is %s.\", string_VkImageAspectFlags(subresourceRange.aspectMask).c_str());\n"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkImageViewCreateInfo-usage-08931\", \"If usage contains VK_IMAGE_USAGE_COLOR_ATTACHMENT_BIT, then the image view's format features must contain VK_FORMAT_FEATURE_COLOR_ATTACHMENT_BIT or VK_FORMAT_FEATURE_2_LINEAR_COLOR_ATTACHMENT_BIT_NV\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "skip |= LogError(\"VUID-VkImageViewCreateInfo-usage-08931\", image_state.Handle(), create_info_loc.dot(Field::format),\n                 \"%s with tiling %s doesn't support VK_FORMAT_FEATURE_COLOR_ATTACHMENT_BIT.\\n\"\n                 \"(supported features: %s)\",\n                 string_VkFormat(view_format), string_VkImageTiling(image_tiling),\n                 string_VkFormatFeatureFlags2(tiling_features).c_str());\n"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkImageViewCreateInfo-image-08334\", \"If image was created with VK_IMAGE_CREATE_VIDEO_PROFILE_INDEPENDENT_BIT_KHR and usage contains VK_IMAGE_USAGE_VIDEO_DECODE_DPB_BIT_KHR, then the image view's format features must contain VK_FORMAT_FEATURE_VIDEO_DECODE_DPB_BIT_KHR\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "skip |= LogError(\"VUID-VkImageViewCreateInfo-image-08334\", image_state.Handle(), create_info_loc.dot(Field::format),\n                 \"%s and tiling %s doesn't support VK_FORMAT_FEATURE_VIDEO_DECODE_DPB_BIT_KHR.\\n\"\n                 \"(supported features: %s)\",\n                 string_VkFormat(view_format), string_VkImageTiling(image_tiling),\n                 string_VkFormatFeatureFlags2(tiling_features).c_str());\n"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkImageViewCreateInfo-image-04441\", \"image must have been created with a usage value containing at least one of the usages defined in the valid image usage list for image views\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "skip |= ValidateImageUsageFlags(VK_NULL_HANDLE, image_state, valid_usage_flags, false, \"VUID-VkImageViewCreateInfo-image-04441\",\n                                create_info_loc.dot(Field::image));\n"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkImageViewSlicedCreateInfoEXT-sliceCount-07868\", \"If sliceCount is not VK_REMAINING_3D_SLICES_EXT, it must be non-zero and sliceOffset + sliceCount must be less than or equal to the effective view depth as specified in Image Mip Level Sizing\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if ((slice_offset + slice_count) > effective_view_depth) {\n    skip |= LogError(\"VUID-VkImageViewSlicedCreateInfoEXT-sliceCount-07868\", pCreateInfo->image,\n                     create_info_loc.pNext(Struct::VkImageViewSlicedCreateInfoEXT, Field::sliceOffset),\n                     \"(%\" PRIu32 \") + sliceCount (%\" PRIu32 \") greater than effective view depth (%\" PRIu32 \").\",\n                     slice_offset, slice_count, effective_view_depth);\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkImageViewCreateInfo-image-04972\", \"If image was created with a samples value not equal to VK_SAMPLE_COUNT_1_BIT then viewType must be either VK_IMAGE_VIEW_TYPE_2D or VK_IMAGE_VIEW_TYPE_2D_ARRAY\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (image_state.create_info.samples != VK_SAMPLE_COUNT_1_BIT && view_type != VK_IMAGE_VIEW_TYPE_2D &&\n    skip |= LogError(\"VUID-VkImageViewCreateInfo-image-04972\", pCreateInfo->image, create_info_loc.dot(Field::image),\n                     \"was created with sample count %s, but pCreateInfo->viewType is %s.\",\n                     string_VkSampleCountFlagBits(image_state.create_info.samples), string_VkImageViewType(view_type));\n"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkImageViewCreateInfo-subResourceRange-01021\", \"viewType must be compatible with the type of image as shown in the view type compatibility table\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "skip |= LogError(\"VUID-VkImageViewCreateInfo-subResourceRange-01021\", pCreateInfo->image,\n                 create_info_loc.dot(Field::viewType), \"(%s) is not compatible with image type %s.\",\n                 string_VkImageViewType(view_type), string_VkImageType(image_type));\n"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkImageViewCreateInfo-image-02087\", \"If the shadingRateImage feature is enabled, and If image was created with usage containing VK_IMAGE_USAGE_SHADING_RATE_IMAGE_BIT_NV, format must be VK_FORMAT_R8_UINT\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (view_format != VK_FORMAT_R8_UINT) {\n    skip |= LogError(\"VUID-VkImageViewCreateInfo-image-02087\", pCreateInfo->image, create_info_loc.dot(Field::image),\n                     \"was created with usage containing \"\n                     \"VK_IMAGE_USAGE_SHADING_RATE_IMAGE_BIT_NV, format must be VK_FORMAT_R8_UINT.\");\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkImageViewCreateInfo-imageViewType-04973\", \"If viewType is VK_IMAGE_VIEW_TYPE_1D, VK_IMAGE_VIEW_TYPE_2D, or VK_IMAGE_VIEW_TYPE_3D; and subresourceRange.layerCount is not VK_REMAINING_ARRAY_LAYERS, then subresourceRange.layerCount must be 1\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if ((pCreateInfo->subresourceRange.layerCount != 1) &&\n    skip |= LogError(\"VUID-VkImageViewCreateInfo-imageViewType-04973\", pCreateInfo->image,\n                     create_info_loc.dot(Field::subresourceRange).dot(Field::layerCount),\n                     \"(%\" PRIu32 \") must be 1 when using viewType %s (try looking into VK_IMAGE_VIEW_TYPE_*_ARRAY).\",\n                     pCreateInfo->subresourceRange.layerCount, string_VkImageViewType(view_type));\n"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkImageViewCreateInfo-image-09487\", \"If image was created with the VK_IMAGE_CREATE_BLOCK_TEXEL_VIEW_COMPATIBLE_BIT flag, the VkPhysicalDeviceMaintenance6PropertiesKHR::blockTexelViewCompatibleMultipleLayers property is not set to VK_TRUE, and format is a non-compressed format, then the layerCount member of subresourceRange must be 1\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (normalized_subresource_range.layerCount != 1 &&\n    skip |= LogError(\"VUID-VkImageViewCreateInfo-image-09487\", pCreateInfo->image, create_info_loc.dot(Field::image),\n                     \"was created with VK_IMAGE_CREATE_BLOCK_TEXEL_VIEW_COMPATIBLE_BIT bit, \"\n                     \"and format (%s) is not compressed, but subresourcesRange.layerCount is %s (instead of 1).\",\n                     string_VkFormat(view_format),\n                     string_LayerCount(image_state.create_info, pCreateInfo->subresourceRange).c_str());\n"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkImageViewASTCDecodeModeEXT-decodeMode-02231\", \"If the decodeModeSharedExponent feature is not enabled, decodeMode must not be VK_FORMAT_E5B9G9R9_UFLOAT_PACK32\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if ((enabled_features.decodeModeSharedExponent == VK_FALSE) &&\n    (astc_decode_mode->decodeMode == VK_FORMAT_E5B9G9R9_UFLOAT_PACK32)) {\n    skip |= LogError(\"VUID-VkImageViewASTCDecodeModeEXT-decodeMode-02231\", pCreateInfo->image,\n                     create_info_loc.pNext(Struct::VkImageViewASTCDecodeModeEXT, Field::decodeMode),\n                     \"is VK_FORMAT_E5B9G9R9_UFLOAT_PACK32 but decodeModeSharedExponent feature is not enabled.\");\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkImageViewCreateInfo-format-06415\", \"If the image view requires a sampler Y'CBCR conversion and usage contains VK_IMAGE_USAGE_SAMPLED_BIT, then the pNext chain must include a VkSamplerYcbcrConversionInfo structure with a conversion value other than VK_NULL_HANDLE\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "string_VkFormat(ycbcr_state->format), string_VkFormat(view_format));\nskip |= LogError(\"VUID-VkImageViewCreateInfo-format-06415\", pCreateInfo->image, create_info_loc.dot(Field::image),\n\"was created with VK_IMAGE_USAGE_SAMPLED_BIT, but pCreateInfo->format %s requires a \"\n\"VkSamplerYcbcrConversion but one was not passed in the pNext chain.\",\nstring_VkFormat(view_format));\n"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkImageViewCreateInfo-format-04714\", \"If format has a _422 or _420 suffix then image must have been created with a width that is a multiple of 2\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (vkuFormatIsXChromaSubsampled(view_format) && (SafeModulo(image_state.create_info.extent.width, 2) != 0)) {\n    skip |= LogError(\"VUID-VkImageViewCreateInfo-format-04714\", device, create_info_loc.dot(Field::format),\n                     \"(%s) is X Chroma Subsampled (has _422 or _420 suffix) so the image width (%\" PRIu32\n                     \") must be a multiple of 2.\",\n                     string_VkFormat(view_format), image_state.create_info.extent.width);\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkHostImageLayoutTransitionInfoEXT-image-09241\", \"If image has a color format that is single-plane, then the aspectMask member of subresourceRange must be VK_IMAGE_ASPECT_COLOR_BIT\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (!vkuFormatIsMultiplane(image_format)) {\n    const LogObjectList objlist(device, image_state->Handle());\n    skip |= LogError(\"VUID-VkHostImageLayoutTransitionInfoEXT-image-09241\", objlist,\n                     transition_loc.dot(Field::subresourceRange).dot(Field::aspectMask),\n                     \"is %s (not VK_IMAGE_ASPECT_COLOR_BIT) and image was created with format %s.\",\n                     string_VkImageAspectFlags(aspect_mask).c_str(), string_VkFormat(image_format));\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkHostImageLayoutTransitionInfoEXT-aspectMask-08702\", \"If the aspectMask member of subresourceRange includes VK_IMAGE_ASPECT_DEPTH_BIT, oldLayout and newLayout must not be one of VK_IMAGE_LAYOUT_STENCIL_ATTACHMENT_OPTIMAL or VK_IMAGE_LAYOUT_STENCIL_READ_ONLY_OPTIMAL\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "const LogObjectList objlist(device, image_state->Handle());\nskip |= LogError(\"VUID-VkHostImageLayoutTransitionInfoEXT-aspectMask-08702\", objlist,\n                 transition_loc.dot(Field::subresourceRange).dot(Field::aspectMask),\n                 \"is %s meaning that neither oldLayout nor newLayout can be \"\n                 \"VK_IMAGE_LAYOUT_STENCIL_ATTACHMENT_OPTIMAL or VK_IMAGE_LAYOUT_STENCIL_READ_ONLY_OPTIMAL\"\n                 \" (oldLayout = %s and newLayout = %s).\",\n                 string_VkImageAspectFlags(aspect_mask).c_str(), string_VkImageLayout(transition.oldLayout),\n                 string_VkImageLayout(transition.oldLayout));\n"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkImageViewCreateInfo-pNext-06948\", \"If the pNext chain includes VkImageViewSampleWeightCreateInfoQCOM structure, then subresourceRange.levelCount must be 1\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (normalized_subresource_range.levelCount != 1) {\n    skip |= LogError(\"VUID-VkImageViewCreateInfo-pNext-06948\", create_info.image, loc,\n                     \"pNext chain includes VkImageViewSampleWeightCreateInfoQCOM \"\n                     \"so subresourcesRange.levelCount must be 1, but it is %s.\",\n                     string_LevelCount(image_state.create_info, create_info.subresourceRange).c_str());\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkImageViewCreateInfo-pNext-06954\", \"If the pNext chain includes VkImageViewSampleWeightCreateInfoQCOM structure and viewType is VK_IMAGE_VIEW_TYPE_2D_ARRAY, then subresourceRange.layerCount must be equal or greater than numPhases\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if ((create_info.viewType == VK_IMAGE_VIEW_TYPE_2D_ARRAY) &&\n    skip |= LogError(\"VUID-VkImageViewCreateInfo-pNext-06954\", create_info.image, loc,\n                     \"pNext chain includes VkImageViewSampleWeightCreateInfoQCOM \"\n                     \"and the view type is VK_IMAGE_VIEW_TYPE_1D_ARRAY but the subresourceRange.layerCount (%s) is not greater \"\n                     \"than or equal to \"\n                     \"VkImageViewSampleWeightCreateInfoQCOM::numPhases (%\" PRIu32 \").\",\n                     string_LayerCount(image_state.create_info, create_info.subresourceRange).c_str(),\n                     sample_weight_info->numPhases);\n"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkImageViewSampleWeightCreateInfoQCOM-filterSize-06959\", \"filterSize.height must be less than or equal to VkPhysicalDeviceImageProcessingPropertiesQCOM::maxWeightFilterDimension.height\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if ((sample_weight_info->filterSize.height > phys_dev_ext_props.image_processing_props.maxWeightFilterDimension.height)) {\n    skip |= LogError(\"VUID-VkImageViewSampleWeightCreateInfoQCOM-filterSize-06959\", create_info.image, loc,\n                     \"VkImageViewSampleWeightCreateInfoQCOM::filterSize.height (%\" PRIu32\n                     \") is not less than or equal to \"\n                     \"VkPhysicalDeviceImageProcessingPropertiesQCOM::maxWeightFilterDimension.height (%\" PRIu32 \").\",\n                     sample_weight_info->filterSize.width,\n                     phys_dev_ext_props.image_processing_props.maxWeightFilterDimension.width);\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkRenderPassCreateInfo2-pAttachments-02522\", \"For any member of pAttachments with a loadOp equal to VK_ATTACHMENT_LOAD_OP_CLEAR, the first use of that attachment must not specify a layout equal to VK_IMAGE_LAYOUT_SHADER_READ_ONLY_OPTIMAL, VK_IMAGE_LAYOUT_DEPTH_STENCIL_READ_ONLY_OPTIMAL, or VK_IMAGE_LAYOUT_DEPTH_READ_ONLY_STENCIL_ATTACHMENT_OPTIMAL\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (use_rp2 && ((first_layout == VK_IMAGE_LAYOUT_DEPTH_STENCIL_READ_ONLY_OPTIMAL) ||\n    skip |= LogError(\"VUID-VkRenderPassCreateInfo2-pAttachments-02522\", device, layout_loc,\n                     \"(%s) is an invalid for pAttachments[%d] (first attachment to have LOAD_OP_CLEAR).\",\n                     string_VkImageLayout(first_layout), attachment);\n"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkRenderPassCreateInfo-pAttachments-02511\", \"For any member of pAttachments with a stencilLoadOp equal to VK_ATTACHMENT_LOAD_OP_CLEAR, the first use of that attachment must not specify a layout equal to VK_IMAGE_LAYOUT_SHADER_READ_ONLY_OPTIMAL or VK_IMAGE_LAYOUT_DEPTH_STENCIL_READ_ONLY_OPTIMAL\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "skip |= LogError(\"VUID-VkRenderPassCreateInfo-pAttachments-02511\", device, layout_loc,\n                 \"(%s) is an invalid for pAttachments[%d] (first attachment to have LOAD_OP_CLEAR).\",\n                 string_VkImageLayout(first_layout), attachment);\n"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkRenderPassBeginInfo-framebuffer-parameter\", \"framebuffer must be a valid VkFramebuffer handle\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (image_state->IsSwapchainImage() && image_state->owned_by_swapchain && !image_state->bind_swapchain) {\n    const LogObjectList objlist(render_pass, framebuffer_state.Handle(), image_view, image);\n    skip |= LogError(\"VUID-VkRenderPassBeginInfo-framebuffer-parameter\", objlist, attachment_loc,\n                     \"%s references a swapchain image (%s) from a swapchain that has been destroyed.\",\n                     FormatHandle(image_view).c_str(), FormatHandle(image).c_str());\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkPipelineCacheCreateInfo-pipelineCreationCacheControl-02892\", \"If the pipelineCreationCacheControl feature is not enabled, flags must not include VK_PIPELINE_CACHE_CREATE_EXTERNALLY_SYNCHRONIZED_BIT\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if ((pCreateInfo->flags & VK_PIPELINE_CACHE_CREATE_EXTERNALLY_SYNCHRONIZED_BIT_EXT) != 0) {\n    skip |= LogError(\"VUID-VkPipelineCacheCreateInfo-pipelineCreationCacheControl-02892\", device,\n                     error_obj.location.dot(Field::pCreateInfo).dot(Field::flags),\n                     \"includes VK_PIPELINE_CACHE_CREATE_EXTERNALLY_SYNCHRONIZED_BIT_EXT, but pipelineCreationCacheControl \"\n                     \"feature was not enabled\");\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkPipelineRobustnessCreateInfoEXT-robustImageAccess-06930\", \"If the robustImageAccess feature is not supported, images must not be VK_PIPELINE_ROBUSTNESS_IMAGE_BEHAVIOR_ROBUST_IMAGE_ACCESS_EXT\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (!has_robust_image_access &&\n    skip |= LogError(\"VUID-VkPipelineRobustnessCreateInfoEXT-robustImageAccess-06930\", device,\n                     loc.pNext(Struct::VkPipelineRobustnessCreateInfoEXT, Field::images),\n                     \"is VK_PIPELINE_ROBUSTNESS_IMAGE_BEHAVIOR_ROBUST_IMAGE_ACCESS_EXT \"\n                     \"but robustImageAccess2 is not supported.\");\n"
        },
        {
            "role": "user",
            "content": "{\"VUID-vkCmdBindPipeline-pipelineBindPoint-00779\", \"If pipelineBindPoint is VK_PIPELINE_BIND_POINT_COMPUTE, pipeline must be a compute pipeline\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (pipelineBindPoint == VK_PIPELINE_BIND_POINT_GRAPHICS) {\n    const LogObjectList objlist(cb_state->Handle(), pipeline);\n    skip |= LogError(\"VUID-vkCmdBindPipeline-pipelineBindPoint-00779\", objlist, error_obj.location,\n                     \"Cannot bind a pipeline of type %s to the graphics pipeline bind point\",\n                     string_VkPipelineBindPoint(pipeline_state.pipeline_type));\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-vkCmdBindPipeline-variableSampleLocations-01525\", \"If VkPhysicalDeviceSampleLocationsPropertiesEXT::variableSampleLocations is VK_FALSE, and pipeline is a graphics pipeline created with a VkPipelineSampleLocationsStateCreateInfoEXT structure having its sampleLocationsEnable member set to VK_TRUE but without VK_DYNAMIC_STATE_SAMPLE_LOCATIONS_EXT enabled then the current render pass instance must have been begun by specifying a VkRenderPassSampleLocationsBeginInfoEXT structure whose pPostSubpassSampleLocations member contains an element with a subpassIndex matching the current subpass index and the sampleLocationsInfo member of that element must match the sampleLocationsInfo specified in VkPipelineSampleLocationsStateCreateInfoEXT when the pipeline was created\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (!found) {\n    const LogObjectList objlist(cb_state->Handle(), pipeline, cb_state->activeRenderPass->Handle());\n    skip |= LogError(\"VUID-vkCmdBindPipeline-variableSampleLocations-01525\", objlist, error_obj.location,\n                     \"the current render pass was not begun with any element of \"\n                     \"pPostSubpassSampleLocations subpassIndex \"\n                     \"matching the current subpass index (%\" PRIu32\n                     \") and sampleLocationsInfo from VkPipelineMultisampleStateCreateInfo of the pipeline.\",\n                     cb_state->GetActiveSubpass());\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-vkCmdBindPipeline-pipelineProtectedAccess-07408\", \"If the pipelineProtectedAccess feature is enabled, and commandBuffer is a protected command buffer, pipeline must have been created without VK_PIPELINE_CREATE_NO_PROTECTED_ACCESS_BIT_EXT\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (pipeline_state.create_flags & VK_PIPELINE_CREATE_NO_PROTECTED_ACCESS_BIT_EXT) {\n    skip |= LogError(\"VUID-vkCmdBindPipeline-pipelineProtectedAccess-07408\", objlist, error_obj.location,\n                     \"Binding pipeline created with \"\n                     \"VK_PIPELINE_CREATE_NO_PROTECTED_ACCESS_BIT_EXT in a protected command buffer.\");\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkSpecializationInfo-offset-00773\", \"The offset member of each element of pMapEntries must be less than dataSize\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (map_entry.offset >= spec->dataSize) {\n    skip |= LogError(\"VUID-VkSpecializationInfo-offset-00773\", device, map_loc.dot(Field::offset),\n                     \"is %\" PRIu32 \" but dataSize is %zu (for constantID %\" PRIu32 \").\", map_entry.offset, spec->dataSize,\n                     map_entry.constantID);\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkPipelineShaderStageCreateInfo-stage-06848\", \"If a shader module identifier is specified for this stage, module must be VK_NULL_HANDLE\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (stage_ci.module != VK_NULL_HANDLE) {\n    skip |= LogError(\"VUID-VkPipelineShaderStageCreateInfo-stage-06848\", device, loc.dot(Field::pNext),\n                     \"has a VkPipelineShaderStageModuleIdentifierCreateInfoEXT \"\n                     \"struct in the pNext chain, but module is not VK_NULL_HANDLE. (stage %s).\",\n                     string_VkShaderStageFlagBits(stage_ci.stage));\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkVertexInputAttributeDescription-vertexAttributeAccessBeyondStride-04457\", \"If the VK_KHR_portability_subset extension is enabled, and VkPhysicalDevicePortabilitySubsetFeaturesKHR::vertexAttributeAccessBeyondStride is VK_FALSE, the sum of offset plus the size of the vertex attribute data described by format must not be greater than stride in the VkVertexInputBindingDescription referenced in binding\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if ((attrib.offset + vkuFormatElementSize(attrib.format)) > desc.stride) {\n    skip |= LogError(\"VUID-VkVertexInputAttributeDescription-vertexAttributeAccessBeyondStride-04457\", device,\n                     create_info_loc,\n                     \"(portability error): attribute.offset (%\" PRIu32\n                     \") + \"\n                     \"sizeof(vertex_description.format) (%\" PRIu32\n                     \") is larger than the vertex stride (%\" PRIu32 \").\",\n                     attrib.offset, vkuFormatElementSize(attrib.format), desc.stride);\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkGraphicsPipelineCreateInfo-flags-06609\", \"If flags includes VK_PIPELINE_CREATE_LINK_TIME_OPTIMIZATION_BIT_EXT, pipeline libraries included via VkPipelineLibraryCreateInfoKHR must have been created with VK_PIPELINE_CREATE_RETAIN_LINK_TIME_OPTIMIZATION_INFO_BIT_EXT\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (has_link_time_opt && !lib_has_retain_link_time_opt) {\n    const LogObjectList objlist(device, lib->Handle());\n    skip |= LogError(\"VUID-VkGraphicsPipelineCreateInfo-flags-06609\", objlist, library_loc,\n                     \"(%s) was created with %s, which is missing \"\n                     \"VK_PIPELINE_CREATE_RETAIN_LINK_TIME_OPTIMIZATION_INFO_BIT_EXT, %s is %s.\",\n                     string_VkGraphicsPipelineLibraryFlagsEXT(lib->graphics_lib_type).c_str(),\n                     string_VkPipelineCreateFlags2KHR(lib_pipeline_flags).c_str(),\n                     create_info_loc.dot(Field::flags).Fields().c_str(),\n                     string_VkPipelineCreateFlags2KHR(pipeline_flags).c_str());\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkPipelineLibraryCreateInfoKHR-pLibraries-08096\", \"If any element of pLibraries was created with VK_PIPELINE_CREATE_DESCRIPTOR_BUFFER_BIT_EXT, all elements must have been created with VK_PIPELINE_CREATE_DESCRIPTOR_BUFFER_BIT_EXT\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (i == 0) {\n    skip |= LogError(\"VUID-VkPipelineLibraryCreateInfoKHR-pLibraries-08096\", device, library_loc,\n                     \"%s created with VK_PIPELINE_CREATE_DESCRIPTOR_BUFFER_BIT_EXT which is opposite of pLibraries[0].\",\n                     lib->descriptor_buffer_mode ? \"was\" : \"was not\");\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkGraphicsPipelineCreateInfo-dynamicRendering-06576\", \"If the dynamicRendering feature is not enabled and the pipeline requires pre-rasterization shader state, fragment shader state, or fragment output interface state, renderPass must not be VK_NULL_HANDLE\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (!enabled_features.dynamicRendering) {\n    skip |= LogError(\"VUID-VkGraphicsPipelineCreateInfo-dynamicRendering-06576\", device,\n                     create_info_loc.dot(Field::renderPass), \"is NULL, but the dynamicRendering feature was not enabled\");\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkGraphicsPipelineCreateInfo-flags-08901\", \"If flags does not include VK_PIPELINE_CREATE_LIBRARY_BIT_KHR, the pipeline must either define pre-rasterization shader state or include that state in a linked pipeline library\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (!pipeline.pre_raster_state) {\n    skip |= LogError(\"VUID-VkGraphicsPipelineCreateInfo-flags-08901\", device, create_info_loc,\n                     \"Attempting to link pipeline libraries without a pre-rasterization shader state (did you forget to \"\n                     \"add VK_PIPELINE_CREATE_LIBRARY_BIT_KHR to your intermediate pipeline?).\");\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkGraphicsPipelineCreateInfo-None-07826\", \"If the pipeline includes a complete set of state, and there are no libraries included in VkPipelineLibraryCreateInfoKHR::pLibraries, then VkPipelineLayout must be a valid pipeline layout\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (!pipeline_layout_state && (!pipeline.library_create_info || pipeline.library_create_info->libraryCount == 0)) {\n    skip |= LogError(\"VUID-VkGraphicsPipelineCreateInfo-None-07826\", device, create_info_loc.dot(Field::layout),\n                     \"is not a valid VkPipelineLayout, but defines a complete set of state.\");\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkGraphicsPipelineCreateInfo-renderPass-06041\", \"If renderPass is not VK_NULL_HANDLE, and the pipeline is being created with fragment output interface state, then for each color attachment in the subpass, if the potential format features of the format of the corresponding attachment description do not contain VK_FORMAT_FEATURE_COLOR_ATTACHMENT_BLEND_BIT, then the blendEnable member of the corresponding element of the pAttachments member of pColorBlendState must be VK_FALSE\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (!pipeline.RasterizationDisabled() && pipeline.AttachmentStates()[i].blendEnable &&\n    skip |= LogError(\"VUID-VkGraphicsPipelineCreateInfo-renderPass-06041\", device,\n                     color_loc.dot(Field::pAttachments, i).dot(Field::blendEnable),\n                     \"is VK_TRUE but format %s of the corresponding attachment description (subpass %\" PRIu32\n                     \", attachment %\" PRIu32 \") does not support VK_FORMAT_FEATURE_COLOR_ATTACHMENT_BLEND_BIT.\",\n                     string_VkFormat(attachment_desc.format), subpass, attachment);\n"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkGraphicsPipelineCreateInfo-externalFormatResolve-09316\", \"If the externalFormatResolve feature is enabled, the pipeline requires fragment output interface state, renderPass is not VK_NULL_HANDLE, subpass includes an external format resolve attachment, and pDynamicState->pDynamicStates does not include VK_DYNAMIC_STATE_FRAGMENT_SHADING_RATE_KHR, VkPipelineFragmentShadingRateStateCreateInfoKHR::height must be 1\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (fragment_shading_rate->fragmentSize.height != 1) {\n    skip |= LogError(\"VUID-VkGraphicsPipelineCreateInfo-externalFormatResolve-09316\", device,\n                     create_info_loc.pNext(Struct::VkPipelineFragmentShadingRateStateCreateInfoKHR, Field::fragmentSize)\n                         .dot(Field::height),\n                     \"is %\" PRIu32 \", but externalFormat is %\" PRIu64 \" for subpass %\" PRIu32 \".\",\n                     fragment_shading_rate->fragmentSize.height, external_format, pipeline.Subpass());\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkGraphicsPipelineCreateInfo-externalFormatResolve-09305\", \"If the externalFormatResolve feature is enabled, the pipeline requires fragment output interface state, renderPass is VK_NULL_HANDLE, and VkExternalFormatANDROID::externalFormat is not 0, and blendEnable is not dynamic, the blendEnable member of each element of pColorBlendState->pAttachments must be VK_FALSE\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (color_blend_state->pAttachments[i].blendEnable) {\n    skip |= LogError(\"VUID-VkGraphicsPipelineCreateInfo-externalFormatResolve-09305\", device,\n                     create_info_loc.dot(Field::pColorBlendState).dot(Field::pAttachments, i).dot(Field::blendEnable),\n                     \"is VK_TRUE, but externalFormat is %\" PRIu64 \".\", external_format);\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkPipelineInputAssemblyStateCreateInfo-topology-00430\", \"If the tessellationShader feature is not enabled, topology must not be VK_PRIMITIVE_TOPOLOGY_PATCH_LIST\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if ((enabled_features.tessellationShader == VK_FALSE) && (topology == VK_PRIMITIVE_TOPOLOGY_PATCH_LIST)) {\n    skip |= LogError( \"VUID-VkPipelineInputAssemblyStateCreateInfo-topology-00430\", device, ia_loc,\n                     \"topology is %s and tessellationShader feature was not enabled.\",\n                     string_VkPrimitiveTopology(topology));\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkPipelineShaderStageCreateInfo-stage-00704\", \"If the geometryShader feature is not enabled, stage must not be VK_SHADER_STAGE_GEOMETRY_BIT\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (!enabled_features.geometryShader && (stages & VK_SHADER_STAGE_GEOMETRY_BIT)) {\n    skip |= LogError(\"VUID-VkPipelineShaderStageCreateInfo-stage-00704\", device, create_info_loc,\n                     \"pStages include Geometry Shader but geometryShader feature was not enabled.\");\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkPipelineShaderStageCreateInfo-stage-02092\", \"If the taskShaders feature is not enabled, stage must not be VK_SHADER_STAGE_TASK_BIT_EXT\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (!(enabled_features.taskShader) && (stages & VK_SHADER_STAGE_TASK_BIT_EXT)) {\n    skip |= LogError(\"VUID-VkPipelineShaderStageCreateInfo-stage-02092\", device, create_info_loc,\n                     \"pStages include Task Shader but taskShader feature was not enabled.\");\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkPipelineColorBlendAttachmentState-dstColorBlendFactor-00609\", \"If the dualSrcBlend feature is not enabled, dstColorBlendFactor must not be VK_BLEND_FACTOR_SRC1_COLOR, VK_BLEND_FACTOR_ONE_MINUS_SRC1_COLOR, VK_BLEND_FACTOR_SRC1_ALPHA, or VK_BLEND_FACTOR_ONE_MINUS_SRC1_ALPHA\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (!enabled_features.dualSrcBlend) {\n    skip |= LogError(\"VUID-VkPipelineColorBlendAttachmentState-dstColorBlendFactor-00609\", device,\n                     attachment_loc.dot(Field::dstColorBlendFactor),\n                     \"(%s) is a dual-source blend factor, but dualSrcBlend feature was not enabled.\",\n                     string_VkBlendFactor(attachment_state.dstColorBlendFactor));\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkPipelineColorBlendAttachmentState-advancedBlendIndependentBlend-01408\", \"If VkPhysicalDeviceBlendOperationAdvancedPropertiesEXT::advancedBlendIndependentBlend is VK_FALSE and alphaBlendOp is an advanced blend operation, then alphaBlendOp must be the same for all attachments\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (phys_dev_ext_props.blend_operation_advanced_props.advancedBlendIndependentBlend == VK_FALSE &&\n    skip |= LogError(\"VUID-VkPipelineColorBlendAttachmentState-advancedBlendIndependentBlend-01408\", device,\n                     attachment_loc.dot(Field::alphaBlendOp), \"(%s) is not same the other attachments (%s).\",\n                     string_VkBlendOp(attachment_state.alphaBlendOp), string_VkBlendOp(first_alpha_blend_op));\n"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkGraphicsPipelineCreateInfo-renderPass-06063\", \"If the pipeline requires fragment output interface state and renderPass is VK_NULL_HANDLE, if the pNext chain includes VkAttachmentSampleCountInfoAMD or VkAttachmentSampleCountInfoNV, the colorAttachmentCount member of that structure must be equal to the value of VkPipelineRenderingCreateInfo::colorAttachmentCount\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (null_rp && rendering_struct && attachment_sample_count_info &&\n    skip |= LogError(\"VUID-VkGraphicsPipelineCreateInfo-renderPass-06063\", device,\n                     create_info_loc.pNext(Struct::VkAttachmentSampleCountInfoAMD, Field::attachmentCount),\n                     \"(%\" PRIu32 \") is different then %s (%\" PRIu32 \").\", attachment_sample_count_info->colorAttachmentCount,\n                     create_info_loc.pNext(Struct::VkPipelineRenderingCreateInfo, Field::colorAttachmentCount).Fields().c_str(),\n                     rendering_struct->colorAttachmentCount);\n"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkPipelineRasterizationStateStreamCreateInfoEXT-geometryStreams-02324\", \"VkPhysicalDeviceTransformFeedbackFeaturesEXT::geometryStreams must be enabled\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (!enabled_features.geometryStreams) {\n    skip |= LogError(\"VUID-VkPipelineRasterizationStateStreamCreateInfoEXT-geometryStreams-02324\", device, raster_loc,\n                     \"pNext chain includes VkPipelineRasterizationStateStreamCreateInfoEXT, but \"\n                     \"geometryStreams feature was not enabled.\");\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkPipelineRasterizationStateCreateInfo-depthClampEnable-00782\", \"If the depthClamp feature is not enabled, depthClampEnable must be VK_FALSE\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if ((raster_state->depthClampEnable == VK_TRUE) && !enabled_features.depthClamp &&\n    skip |= LogError(\"VUID-VkPipelineRasterizationStateCreateInfo-depthClampEnable-00782\", device,\n                     raster_loc.dot(Field::depthClampEnable), \"is VK_TRUE, but the depthClamp feature was not enabled.\");\n"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkGraphicsPipelineCreateInfo-pDynamicStates-02510\", \"If the pipeline requires fragment shader state, the VK_EXT_depth_range_unrestricted extension is not enabled and no element of the pDynamicStates member of pDynamicState is VK_DYNAMIC_STATE_DEPTH_BOUNDS, and the depthBoundsTestEnable member of pDepthStencilState is VK_TRUE, the minDepthBounds and maxDepthBounds members of pDepthStencilState must be between 0.0 and 1.0, inclusive\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (!(minDepthBounds >= 0.0) || !(minDepthBounds <= 1.0)) {\n    skip |= LogError(\"VUID-VkGraphicsPipelineCreateInfo-pDynamicStates-02510\", device,\n                     ds_loc.dot(Field::minDepthBounds),\n                     \"is %f, depthBoundsTestEnable is VK_TRUE, but VK_EXT_depth_range_unrestricted extension \"\n                     \"is not enabled (and not using VK_DYNAMIC_STATE_DEPTH_BOUNDS).\",\n                     minDepthBounds);\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkGraphicsPipelineCreateInfo-subpass-01505\", \"If the pipeline requires fragment output interface state, and the VK_AMD_mixed_attachment_samples extension is enabled, rasterizationSamples is not dynamic, and if subpass uses color and/or depth/stencil attachments, then the rasterizationSamples member of pMultisampleState must equal the maximum of the sample counts of those subpass attachments\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (!pipeline.RasterizationDisabled() && (max_sample_count != static_cast<VkSampleCountFlagBits>(0)) &&\n    (multisample_state->rasterizationSamples != max_sample_count)) {\n    skip |= LogError(\"VUID-VkGraphicsPipelineCreateInfo-subpass-01505\", device, ms_loc.dot(Field::rasterizationSamples),\n                     \"(%s) is different from the max attachment samples (%s) used in pSubpasses[%\" PRIu32 \"].\",\n                     string_VkSampleCountFlagBits(multisample_state->rasterizationSamples),\n                     string_VkSampleCountFlagBits(max_sample_count), pipeline.Subpass());\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkGraphicsPipelineCreateInfo-pDynamicStates-07612\", \"If the pipeline requires fragment shader state or fragment output interface state, and rasterizationSamples and sampleLocationsInfo are not dynamic, and VkPipelineSampleLocationsStateCreateInfoEXT::sampleLocationsEnable included in the pNext chain of pMultisampleState is VK_TRUE or VK_DYNAMIC_STATE_SAMPLE_LOCATIONS_ENABLE_EXT is used, sampleLocationsInfo.sampleLocationsPerPixel must equal rasterizationSamples\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (sample_location_info.sampleLocationsPerPixel != multisample_state->rasterizationSamples) {\n    skip |= LogError(\"VUID-VkGraphicsPipelineCreateInfo-pDynamicStates-07612\", device,\n                     sample_info_loc.dot(Field::sampleLocationsPerPixel), \"(%s) is different from %s (%s).\",\n                     string_VkSampleCountFlagBits(sample_location_info.sampleLocationsPerPixel),\n                     ms_loc.dot(Field::rasterizationSamples).Fields().c_str(),\n                     string_VkSampleCountFlagBits(multisample_state->rasterizationSamples));\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkGraphicsPipelineCreateInfo-pMultisampleState-09026\", \"If the pipeline requires fragment output interface state, and the VK_EXT_extended_dynamic_state3 extension is not enabled or any of the VK_DYNAMIC_STATE_RASTERIZATION_SAMPLES_EXT, VK_DYNAMIC_STATE_SAMPLE_MASK_EXT, or VK_DYNAMIC_STATE_ALPHA_TO_COVERAGE_ENABLE_EXT dynamic states is not set, or alphaToOne is enabled on the device and VK_DYNAMIC_STATE_ALPHA_TO_ONE_ENABLE_EXT is not set, pMultisampleState must be a valid pointer to a valid VkPipelineMultisampleStateCreateInfo structure\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (!pipeline.IsDynamic(CB_DYNAMIC_STATE_RASTERIZATION_SAMPLES_EXT) ||\n    skip |= LogError(\"VUID-VkGraphicsPipelineCreateInfo-pMultisampleState-09026\", device,\n                     create_info_loc.dot(Field::pMultisampleState), \"is NULL.\");\n"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkGraphicsPipelineCreateInfo-flags-06482\", \"If the dynamicRenderingLocalRead feature is not enabled, the pipeline requires fragment output interface state, and the flags member of VkPipelineColorBlendStateCreateInfo includes VK_PIPELINE_COLOR_BLEND_STATE_CREATE_RASTERIZATION_ORDER_ATTACHMENT_ACCESS_BIT_EXT, renderPass must not be VK_NULL_HANDLE\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (!enabled_features.dynamicRenderingLocalRead && null_rp) {\n    skip |= LogError(\"VUID-VkGraphicsPipelineCreateInfo-flags-06482\", device, color_loc.dot(Field::flags),\n                     \"includes \"\n                     \"VK_PIPELINE_COLOR_BLEND_STATE_CREATE_RASTERIZATION_ORDER_ATTACHMENT_ACCESS_BIT_EXT, but \"\n                     \"renderpass is VK_NULL_HANDLE.\");\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkGraphicsPipelineCreateInfo-pDynamicStates-07066\", \"If the pipeline requires pre-rasterization shader state, and includes a mesh shader, there must be no element of the pDynamicStates member of pDynamicState set to VK_DYNAMIC_STATE_PRIMITIVE_RESTART_ENABLE, or VK_DYNAMIC_STATE_PATCH_CONTROL_POINTS_EXT\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": ".dot(Field::pDynamicStates, get_state_index(VK_DYNAMIC_STATE_PRIMITIVE_RESTART_ENABLE)),\nskip |= LogError(\"VUID-VkGraphicsPipelineCreateInfo-pDynamicStates-07066\", device,\ncreate_info_loc.dot(Field::pDynamicState)\n.dot(Field::pDynamicStates, get_state_index(VK_DYNAMIC_STATE_PATCH_CONTROL_POINTS_EXT)),\n\"is VK_DYNAMIC_STATE_PATCH_CONTROL_POINTS_EXT, but the pipeline contains a mesh shader.\");\n"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkGraphicsPipelineCreateInfo-extendedDynamicState3PolygonMode-07372\", \"If the extendedDynamicState3PolygonMode feature is not enabled, there must be no element of the pDynamicStates member of pDynamicState set to VK_DYNAMIC_STATE_POLYGON_MODE_EXT\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (!enabled_features.extendedDynamicState3PolygonMode && pipeline.IsDynamic(CB_DYNAMIC_STATE_POLYGON_MODE_EXT)) {\n    skip |= LogError(\"VUID-VkGraphicsPipelineCreateInfo-extendedDynamicState3PolygonMode-07372\", device,\n                     create_info_loc.dot(Field::pDynamicState)\n                         .dot(Field::pDynamicStates, get_state_index(VK_DYNAMIC_STATE_POLYGON_MODE_EXT)),\n                     \"is VK_DYNAMIC_STATE_POLYGON_MODE_EXT, but the extendedDynamicState3PolygonMode feature was not enabled.\");\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkGraphicsPipelineCreateInfo-extendedDynamicState3ExtraPrimitiveOverestimationSize-07383\", \"If the extendedDynamicState3ExtraPrimitiveOverestimationSize feature is not enabled, there must be no element of the pDynamicStates member of pDynamicState set to VK_DYNAMIC_STATE_EXTRA_PRIMITIVE_OVERESTIMATION_SIZE_EXT\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (!enabled_features.extendedDynamicState3ExtraPrimitiveOverestimationSize &&\n    skip |= LogError(\"VUID-VkGraphicsPipelineCreateInfo-extendedDynamicState3ExtraPrimitiveOverestimationSize-07383\", device,\n                     create_info_loc.dot(Field::pDynamicState)\n                         .dot(Field::pDynamicStates, get_state_index(VK_DYNAMIC_STATE_EXTRA_PRIMITIVE_OVERESTIMATION_SIZE_EXT)),\n                     \"is VK_DYNAMIC_STATE_EXTRA_PRIMITIVE_OVERESTIMATION_SIZE_EXT but the \"\n                     \"extendedDynamicState3ExtraPrimitiveOverestimationSize feature is not enabled.\");\n"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkGraphicsPipelineCreateInfo-extendedDynamicState3ViewportWScalingEnable-07391\", \"If the extendedDynamicState3ViewportWScalingEnable feature is not enabled, there must be no element of the pDynamicStates member of pDynamicState set to VK_DYNAMIC_STATE_VIEWPORT_W_SCALING_ENABLE_NV\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (!enabled_features.extendedDynamicState3ViewportWScalingEnable &&\n    skip |= LogError(\"VUID-VkGraphicsPipelineCreateInfo-extendedDynamicState3ViewportWScalingEnable-07391\", device,\n                     create_info_loc.dot(Field::pDynamicState)\n                         .dot(Field::pDynamicStates, get_state_index(VK_DYNAMIC_STATE_VIEWPORT_W_SCALING_ENABLE_NV)),\n                     \"is VK_DYNAMIC_STATE_VIEWPORT_W_SCALING_ENABLE_NV but the extendedDynamicState3ViewportWScalingEnable \"\n                     \"feature is not enabled.\");\n"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkGraphicsPipelineCreateInfo-extendedDynamicState3CoverageModulationTable-07397\", \"If the extendedDynamicState3CoverageModulationTable feature is not enabled, there must be no element of the pDynamicStates member of pDynamicState set to VK_DYNAMIC_STATE_COVERAGE_MODULATION_TABLE_NV\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (!enabled_features.extendedDynamicState3CoverageModulationTable &&\n    skip |= LogError(\"VUID-VkGraphicsPipelineCreateInfo-extendedDynamicState3CoverageModulationTable-07397\", device,\n                     create_info_loc.dot(Field::pDynamicState)\n                         .dot(Field::pDynamicStates, get_state_index(VK_DYNAMIC_STATE_COVERAGE_MODULATION_TABLE_NV)),\n                     \"is VK_DYNAMIC_STATE_COVERAGE_MODULATION_TABLE_NV but the extendedDynamicState3CoverageModulationTable \"\n                     \"feature is not enabled.\");\n"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkGraphicsPipelineCreateInfo-pDynamicStates-04800\", \"If the colorWriteEnable feature is not enabled, there must be no element of the pDynamicStates member of pDynamicState set to VK_DYNAMIC_STATE_COLOR_WRITE_ENABLE_EXT\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (!enabled_features.colorWriteEnable && pipeline.IsDynamic(CB_DYNAMIC_STATE_COLOR_WRITE_ENABLE_EXT)) {\n    skip |= LogError(\"VUID-VkGraphicsPipelineCreateInfo-pDynamicStates-04800\", device,\n                     create_info_loc.dot(Field::pDynamicState)\n                         .dot(Field::pDynamicStates, get_state_index(VK_DYNAMIC_STATE_COLOR_WRITE_ENABLE_EXT)),\n                     \"is VK_DYNAMIC_STATE_VERTEX_INPUT_EXT but the colorWriteEnable feature is not enabled.\");\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkGraphicsPipelineCreateInfo-pDynamicState-04500\", \"If the pipeline requires pre-rasterization shader state or fragment shader state and VK_DYNAMIC_STATE_FRAGMENT_SHADING_RATE_KHR is not included in pDynamicState->pDynamicStates, and the pipelineFragmentShadingRate feature is not enabled, VkPipelineFragmentShadingRateStateCreateInfoKHR::fragmentSize.width and VkPipelineFragmentShadingRateStateCreateInfoKHR::fragmentSize.height must both be equal to 1\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (!enabled_features.pipelineFragmentShadingRate && fragment_shading_rate_state.fragmentSize.width != 1) {\n    skip |= LogError(\"VUID-VkGraphicsPipelineCreateInfo-pDynamicState-04500\", device, fragment_loc.dot(Field::width),\n                     \"is %\" PRIu32 \", but the pipelineFragmentShadingRate feature was not enabled.\",\n                     fragment_shading_rate_state.fragmentSize.width);\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkGraphicsPipelineCreateInfo-fragmentShadingRateNonTrivialCombinerOps-04506\", \"If the pipeline requires pre-rasterization shader state or fragment shader state, the fragmentShadingRateNonTrivialCombinerOps limit is not supported, and VK_DYNAMIC_STATE_FRAGMENT_SHADING_RATE_KHR is not included in pDynamicState->pDynamicStates, elements of VkPipelineFragmentShadingRateStateCreateInfoKHR::combinerOps must be VK_FRAGMENT_SHADING_RATE_COMBINER_OP_KEEP_KHR or VK_FRAGMENT_SHADING_RATE_COMBINER_OP_REPLACE_KHR\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (!phys_dev_ext_props.fragment_shading_rate_props.fragmentShadingRateNonTrivialCombinerOps &&\n    skip |= LogError(\"VUID-VkGraphicsPipelineCreateInfo-fragmentShadingRateNonTrivialCombinerOps-04506\", device,\n                     create_info_loc.pNext(Struct::VkPipelineFragmentShadingRateStateCreateInfoKHR, Field::combinerOps, 1),\n                     \"is %s, but the fragmentShadingRateNonTrivialCombinerOps feature is not enabled.\",\n                     string_VkFragmentShadingRateCombinerOpKHR(fragment_shading_rate_state.combinerOps[1]));\n"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkGraphicsPipelineCreateInfo-renderPass-06055\", \"If renderPass is VK_NULL_HANDLE, pColorBlendState is not dynamic, and the pipeline is being created with fragment output interface state, pColorBlendState->attachmentCount must be equal to VkPipelineRenderingCreateInfo::colorAttachmentCount\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (color_blend_state && rendering_struct->colorAttachmentCount != color_blend_state->attachmentCount &&\n    skip |= LogError(\"VUID-VkGraphicsPipelineCreateInfo-renderPass-06055\", device,\n                     create_info_loc.pNext(Struct::VkPipelineRenderingCreateInfo, Field::colorAttachmentCount),\n                     \"(%\" PRIu32 \") is different from %s (%\" PRIu32 \").\", rendering_struct->colorAttachmentCount,\n                     create_info_loc.dot(Field::pColorBlendState).dot(Field::attachmentCount).Fields().c_str(),\n                     color_blend_state->attachmentCount);\n"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkVertexInputBindingDivisorDescriptionKHR-divisor-01870\", \"divisor must be a value between 0 and VkPhysicalDeviceVertexAttributeDivisorPropertiesKHR::maxVertexAttribDivisor, inclusive\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (vibdd->divisor > phys_dev_ext_props.vtx_attrib_divisor_props.maxVertexAttribDivisor) {\n    skip |= LogError(\"VUID-VkVertexInputBindingDivisorDescriptionKHR-divisor-01870\", device,\n                     divisor_loc.dot(Field::divisor), \"(%\" PRIu32 \") exceeds device maxVertexAttribDivisor (%\" PRIu32 \").\",\n                     vibdd->divisor, phys_dev_ext_props.vtx_attrib_divisor_props.maxVertexAttribDivisor);\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-vkCmdBindVertexBuffers2-pStrides-06209\", \"If pStrides is not NULL each element of pStrides must be either 0 or greater than or equal to the maximum extent of all vertex input attributes fetched from the corresponding binding, where the extent is calculated as the VkVertexInputAttributeDescription::offset plus VkVertexInputAttributeDescription::format size\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (vertex_buffer_stride != 0 && vertex_buffer_stride < attribute_binding_extent) {\n    const LogObjectList objlist(cb_state.Handle(), pipeline.Handle());\n    skip |= LogError(\"VUID-vkCmdBindVertexBuffers2-pStrides-06209\", objlist, vuid.loc(),\n                     \"(binding %\" PRIu32 \"location %\" PRIu32 \") The pStrides value (%\" PRIu64\n                     \") parameter in the last call to %s is not 0 \"\n                     \"and less than the extent of the binding for the attribute (%\" PRIu64 \").\",\n                     attr_desc.binding, attr_desc.location, vertex_buffer_stride, String(vuid.function),\n                     attribute_binding_extent);\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkRayTracingPipelineCreateInfoNV-maxRecursionDepth-03457\", \"maxRecursionDepth must be less than or equal to VkPhysicalDeviceRayTracingPropertiesNV::maxRecursionDepth\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (create_info.maxRecursionDepth > phys_dev_ext_props.ray_tracing_props_nv.maxRecursionDepth) {\n    skip |= LogError(\"VUID-VkRayTracingPipelineCreateInfoNV-maxRecursionDepth-03457\", device,\n                     create_info_loc.dot(Field::maxRecursionDepth),\n                     \"(%\" PRIu32\n                     \") must be less than or equal to \"\n                     \"maxRecursionDepth (%\" PRIu32 \")\",\n                     create_info.maxRecursionDepth, phys_dev_ext_props.ray_tracing_props_nv.maxRecursionDepth);\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkRayTracingShaderGroupCreateInfoKHR-type-03477\", \"If type is VK_RAY_TRACING_SHADER_GROUP_TYPE_TRIANGLES_HIT_GROUP_KHR then intersectionShader must be VK_SHADER_UNUSED_KHR\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (group.intersectionShader != VK_SHADER_UNUSED_NV) {\n    skip |= LogError(isKHR ? \"VUID-VkRayTracingShaderGroupCreateInfoKHR-type-03477\"\n                           : \"VUID-VkRayTracingShaderGroupCreateInfoNV-type-02416\",\n                     device, group_loc.dot(Field::intersectionShader), \"is %\" PRIu32 \".\", group.intersectionShader);\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-vkGetQueryPoolResults-queryCount-09438\", \"If queryCount is greater than 1, stride must not be zero\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (queryCount > 1 && stride == 0) {\n    skip |= LogError(\"VUID-vkGetQueryPoolResults-queryCount-09438\", queryPool, error_obj.location.dot(Field::queryCount),\n                     \"is %\" PRIu32 \" but stride is zero.\", queryCount);\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-vkGetQueryPoolResults-queryType-04519\", \"If the queryType used to create queryPool was VK_QUERY_TYPE_PERFORMANCE_QUERY_KHR, then stride must be large enough to contain the VkQueryPoolPerformanceCreateInfoKHR::counterIndexCount used to create queryPool times the size of VkPerformanceCounterResultKHR\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (query_size > stride) {\n    skip |= LogError(\"VUID-vkGetQueryPoolResults-queryType-04519\", queryPool, error_obj.location.dot(Field::queryPool),\n                     \"(%s) specified stride %\" PRIu64\n                     \" which must be at least counterIndexCount (%d) \"\n                     \"multiplied by sizeof(VkPerformanceCounterResultKHR) (%zu).\",\n                     FormatHandle(queryPool).c_str(), stride, query_items, sizeof(VkPerformanceCounterResultKHR));\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkQueryPoolCreateInfo-queryType-07133\", \"If queryType is VK_QUERY_TYPE_VIDEO_ENCODE_FEEDBACK_KHR, then the pNext chain must include a VkVideoProfileInfoKHR structure with videoCodecOperation specifying an encode operation\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (!profile_desc.IsEncode()) {\n    skip |= LogError(\"VUID-VkQueryPoolCreateInfo-queryType-07133\", device, create_info_loc.dot(Field::queryType),\n                     \"is VK_QUERY_TYPE_VIDEO_ENCODE_FEEDBACK_KHR but \"\n                     \"VkVideoProfileInfoKHR::videoCodecOperation (%s) is not an encode operation.\",\n                     string_VkVideoCodecOperationFlagBitsKHR(video_profile->videoCodecOperation));\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkPerformanceQuerySubmitInfoKHR-counterPassIndex-03221\", \"counterPassIndex must be less than the number of counter passes required by any queries within the batch. The required number of counter passes for a performance query is obtained by calling vkGetPhysicalDeviceQueueFamilyPerformanceQueryPassesKHR\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (perfPass >= query_pool_state->n_performance_passes) {\n    const LogObjectList objlist(cb_state.Handle(), query_obj.pool);\n    skip |= state_data.LogError(\"VUID-VkPerformanceQuerySubmitInfoKHR-counterPassIndex-03221\", objlist, loc,\n                                \"Invalid counterPassIndex (%u, maximum allowed %u) value for query pool %s.\", perfPass,\n                                query_pool_state->n_performance_passes, state_data.FormatHandle(query_obj.pool).c_str());\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-vkCmdResetQueryPool-firstQuery-02862\", \"If queryPool was created with VK_QUERY_TYPE_PERFORMANCE_QUERY_KHR, this command must not be recorded in a command buffer that, either directly or through secondary command buffers, also contains begin commands for a query from the set of queries [firstQuery, firstQuery + queryCount - 1]\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (state == QUERYSTATE_ENDED) {\n    const LogObjectList objlist(cb_state_arg.Handle(), queryPool);\n    skip |= state_data.LogError(\"VUID-vkCmdResetQueryPool-firstQuery-02862\", objlist, record_obj.location,\n                                \"Query index %\" PRIu32 \" was begun and reset in the same command buffer.\",\n                                firstQuery + i);\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-vkCmdCopyQueryPoolResults-queryType-03232\", \"If the queryType used to create queryPool was VK_QUERY_TYPE_PERFORMANCE_QUERY_KHR, VkPhysicalDevicePerformanceQueryPropertiesKHR::allowCommandBufferQueryCopies must be VK_TRUE\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (!phys_dev_ext_props.performance_query_props.allowCommandBufferQueryCopies) {\n    const LogObjectList objlist(commandBuffer, queryPool);\n    skip |= LogError(\"VUID-vkCmdCopyQueryPoolResults-queryType-03232\", objlist, error_obj.location.dot(Field::queryPool),\n                     \"(%s) was created with VK_QUERY_TYPE_PERFORMANCE_QUERY_KHR but \"\n                     \"VkPhysicalDevicePerformanceQueryPropertiesKHR::allowCommandBufferQueryCopies is not supported.\",\n                     FormatHandle(queryPool).c_str());\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-vkCmdWriteTimestamp2-synchronization2-03858\", \"The synchronization2 feature must be enabled\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (!enabled_features.synchronization2) {\n    skip |= LogError(\"VUID-vkCmdWriteTimestamp2-synchronization2-03858\", commandBuffer, error_obj.location,\n                     \"Synchronization2 feature is not enabled.\");\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-vkCmdBeginQueryIndexedEXT-queryType-06692\", \"If the queryType used to create queryPool was not VK_QUERY_TYPE_TRANSFORM_FEEDBACK_STREAM_EXT and not VK_QUERY_TYPE_PRIMITIVES_GENERATED_EXT, the index must be zero\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "} else if (index != 0) {\n    const LogObjectList objlist(commandBuffer, query_pool_state->Handle());\n    skip |= LogError(\"VUID-vkCmdBeginQueryIndexedEXT-queryType-06692\", objlist, error_obj.location.dot(Field::index),\n                     \"(%\" PRIu32\n                     \") must be zero if %s was not created with type VK_QUERY_TYPE_TRANSFORM_FEEDBACK_STREAM_EXT or \"\n                     \"VK_QUERY_TYPE_PRIMITIVES_GENERATED_EXT\",\n                     index, FormatHandle(queryPool).c_str());\n"
        },
        {
            "role": "user",
            "content": "{\"VUID-vkResetQueryPool-None-02665\", \"The hostQueryReset feature must be enabled\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (!enabled_features.hostQueryReset) {\n    skip |= LogError(\"VUID-vkResetQueryPool-None-02665\", device, error_obj.location, \"hostQueryReset feature was not enabled.\");\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-vkQueueSubmit-fence-00063\", \"If fence is not VK_NULL_HANDLE, fence must be unsignaled\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (auto fence_state = Get<vvl::Fence>(fence)) {\n    const LogObjectList objlist(queue, fence);\n    skip |= ValidateFenceForSubmit(*fence_state, \"VUID-vkQueueSubmit-fence-00064\", \"VUID-vkQueueSubmit-fence-00063\", objlist,\n                                   error_obj.location);\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkDeviceGroupSubmitInfo-waitSemaphoreCount-00082\", \"waitSemaphoreCount must equal VkSubmitInfo::waitSemaphoreCount\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (chained_device_group_struct->waitSemaphoreCount != submit.waitSemaphoreCount) {\n    skip |= LogError(\"VUID-VkDeviceGroupSubmitInfo-waitSemaphoreCount-00082\", queue,\n                     submit_loc.pNext(Struct::VkDeviceGroupSubmitInfo, Field::waitSemaphoreCount),\n                     \"(%\" PRIu32 \") is different than waitSemaphoreCount (%\" PRIu32 \").\",\n                     chained_device_group_struct->waitSemaphoreCount, submit.waitSemaphoreCount);\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkCommandBufferSubmitInfo-commandBuffer-09445\", \"If any render pass instance in commandBuffer was recorded with a VkRenderPassStripeBeginInfoARM structure in its pNext chain and did not specify the VK_RENDERING_RESUMING_BIT flag, a VkRenderPassStripeSubmitInfoARM must be included in the pNext chain\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (cb_state.has_render_pass_striped && !cb_state.resumesRenderPassInstance) {\n    skip |= LogError(\"VUID-VkCommandBufferSubmitInfo-commandBuffer-09445\", objlist, loc.dot(Field::pNext),\n                     \"missing VkRenderPassStripeSubmitInfoARM struct because command buffer contain begin info \"\n                     \"with renderpass striped struct\");\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-vkQueueSubmit2-synchronization2-03866\", \"The synchronization2 feature must be enabled\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (!enabled_features.synchronization2) {\n    skip |= LogError(\"VUID-vkQueueSubmit2-synchronization2-03866\", queue, error_obj.location,\n                     \"synchronization2 feature is not enabled\");\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkSubmitInfo2KHR-commandBuffer-06192\", \"If any commandBuffer member of an element of pCommandBufferInfos contains any resumed render pass instances, they must be suspended by a render pass instance earlier in submission order within pCommandBufferInfos\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (!suspended_render_pass_instance) {\n    skip |= LogError(\"VUID-VkSubmitInfo2KHR-commandBuffer-06192\", queue, info_loc.dot(Field::commandBuffer),\n                     \"resumes a render pass instance, but there is no suspended render pass instance.\");\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-vkQueueBindSparse-queuetype\", \"The queue must support sparse binding operations\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (!(queue_flags & VK_QUEUE_SPARSE_BINDING_BIT)) {\n    skip |= LogError(\"VUID-vkQueueBindSparse-queuetype\", queue, error_obj.location,\n                     \"queueFamilyIndex %\" PRIu32 \" queueFlags are %s.\", queue_state->queue_family_index,\n                     string_VkQueueFlags(queue_flags).c_str());\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkBindAccelerationStructureMemoryInfoNV-memoryOffset-03623\", \"memoryOffset must be an integer multiple of the alignment member of the VkMemoryRequirements structure returned from a call to vkGetAccelerationStructureMemoryRequirementsNV with accelerationStructure and type of VK_ACCELERATION_STRUCTURE_MEMORY_REQUIREMENTS_TYPE_OBJECT_NV\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (SafeModulo(info.memoryOffset, as_state->memory_requirements.alignment) != 0) {\n    skip |= LogError(\"VUID-VkBindAccelerationStructureMemoryInfoNV-memoryOffset-03623\", info.accelerationStructure,\n                     bind_info_loc.dot(Field::memoryOffset),\n                     \"(%\" PRIu64 \") must be a multiple of the alignment (%\" PRIu64\n                     \") member of the VkMemoryRequirements structure returned from \"\n                     \"a call to vkGetAccelerationStructureMemoryRequirementsNV with accelerationStructure %s and type of \"\n                     \"VK_ACCELERATION_STRUCTURE_MEMORY_REQUIREMENTS_TYPE_OBJECT_NV\",\n                     info.memoryOffset, as_state->memory_requirements.alignment,\n                     FormatHandle(info.accelerationStructure).c_str());\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-vkCmdBuildAccelerationStructuresKHR-pInfos-03804\", \"For any element of pInfos[i].pGeometries or pInfos[i].ppGeometries with a geometryType of VK_GEOMETRY_TYPE_TRIANGLES_KHR, geometry.triangles.vertexData.deviceAddress must be a valid device address obtained from vkGetBufferDeviceAddress\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (vertex_buffer_states.empty() && geometry_build_ranges[geom_i].primitiveCount > 0) {\n    skip |= LogError(pick_vuid(\"VUID-vkCmdBuildAccelerationStructuresKHR-pInfos-03804\",\n                               \"VUID-vkCmdBuildAccelerationStructuresIndirectKHR-pInfos-03804\"),\n                     cmd_buffer, p_geom_geom_triangles_loc.dot(Field::vertexData).dot(Field::deviceAddress),\n                     \"(0x%\" PRIx64 \") is not an address belonging to an existing buffer.\",\n                     geom_data.geometry.triangles.vertexData.deviceAddress);\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-vkCmdBuildAccelerationStructuresKHR-pInfos-03711\", \"For any element of pInfos[i].pGeometries or pInfos[i].ppGeometries with a geometryType of VK_GEOMETRY_TYPE_TRIANGLES_KHR, geometry.triangles.vertexData.deviceAddress must be aligned to the size in bytes of the smallest component of the format in vertexFormat\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (SafeModulo(geom_data.geometry.triangles.vertexData.deviceAddress, min_component_byte_size) != 0) {\n    skip |= LogError(pick_vuid(\"VUID-vkCmdBuildAccelerationStructuresKHR-pInfos-03711\",\n                               \"VUID-vkCmdBuildAccelerationStructuresIndirectKHR-pInfos-03711\"),\n                     cmd_buffer, p_geom_geom_triangles_loc.dot(Field::vertexData).dot(Field::deviceAddress),\n                     \"is 0x%\" PRIx64 \" and is not aligned to the minimum component byte size (%\" PRIu32\n                     \") of its corresponding vertex \"\n                     \"format (%s).\",\n                     geom_data.geometry.triangles.vertexData.deviceAddress, min_component_byte_size,\n                     string_VkFormat(geom_data.geometry.triangles.vertexFormat));\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-vkCmdBuildAccelerationStructuresKHR-pInfos-03802\", \"For each element of pInfos, its scratchData.deviceAddress member must be a valid device address obtained from vkGetBufferDeviceAddress\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (buffer_states.empty()) {\n    skip |= LogError(pick_vuid(\"VUID-vkCmdBuildAccelerationStructuresKHR-pInfos-03802\",\n                               \"VUID-vkCmdBuildAccelerationStructuresIndirectKHR-pInfos-03802\"),\n                     device, info_loc.dot(Field::scratchData).dot(Field::deviceAddress),\n                     \"(0x%\" PRIx64 \") has no buffer is associated with it.\", info.scratchData.deviceAddress);\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-vkCmdBuildAccelerationStructureNV-geometryCount-02241\", \"geometryCount must be less than or equal to VkPhysicalDeviceRayTracingPropertiesNV::maxGeometryCount\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (pInfo != nullptr && pInfo->geometryCount > phys_dev_ext_props.ray_tracing_props_nv.maxGeometryCount) {\n    skip |= LogError(\"VUID-vkCmdBuildAccelerationStructureNV-geometryCount-02241\", commandBuffer, error_obj.location,\n                     \"geometryCount [%\" PRIu32\n                     \"] must be less than or equal to \"\n                     \"VkPhysicalDeviceRayTracingPropertiesNV::maxGeometryCount.\",\n                     pInfo->geometryCount);\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-vkCmdBuildAccelerationStructureNV-dst-02488\", \"dst must have been created with compatible VkAccelerationStructureInfoNV where VkAccelerationStructureInfoNV::type and VkAccelerationStructureInfoNV::flags are identical, VkAccelerationStructureInfoNV::instanceCount and VkAccelerationStructureInfoNV::geometryCount for dst are greater than or equal to the build size and each geometry in VkAccelerationStructureInfoNV::pGeometries for dst has greater than or equal to the number of vertices, indices, and AABBs\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (dst_as_state->create_info.info.geometryCount < pInfo->geometryCount) {\n    skip |= LogError(\"VUID-vkCmdBuildAccelerationStructureNV-dst-02488\", commandBuffer, error_obj.location,\n                     \"create info VkAccelerationStructureInfoNV::geometryCount\"\n                     \"[%\" PRIu32\n                     \"] must be greater than or equal to build info VkAccelerationStructureInfoNV::geometryCount [%\" PRIu32\n                     \"].\",\n                     dst_as_state->create_info.info.geometryCount, pInfo->geometryCount);\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-vkCmdBuildAccelerationStructureNV-update-02490\", \"If update is VK_TRUE, src must have previously been constructed with VK_BUILD_ACCELERATION_STRUCTURE_ALLOW_UPDATE_BIT_NV set in VkAccelerationStructureInfoNV::flags in the original build\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (!src_as_state || !src_as_state->built ||\n    skip |= LogError(\"VUID-vkCmdBuildAccelerationStructureNV-update-02490\", commandBuffer, error_obj.location,\n                     \"If update is VK_TRUE, src must have been built before \"\n                     \"with VK_BUILD_ACCELERATION_STRUCTURE_ALLOW_UPDATE_BIT_NV set in \"\n                     \"VkAccelerationStructureInfoNV::flags.\");\n"
        },
        {
            "role": "user",
            "content": "{\"VUID-vkCmdCopyAccelerationStructureNV-mode-03410\", \"mode must be VK_COPY_ACCELERATION_STRUCTURE_MODE_COMPACT_KHR or VK_COPY_ACCELERATION_STRUCTURE_MODE_CLONE_KHR\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (!(mode == VK_COPY_ACCELERATION_STRUCTURE_MODE_COMPACT_NV || mode == VK_COPY_ACCELERATION_STRUCTURE_MODE_CLONE_KHR)) {\n    skip |= LogError(\"VUID-vkCmdCopyAccelerationStructureNV-mode-03410\", commandBuffer, error_obj.location,\n                     \"mode must be VK_COPY_ACCELERATION_STRUCTURE_MODE_COMPACT_KHR\"\n                     \"or VK_COPY_ACCELERATION_STRUCTURE_MODE_CLONE_KHR.\");\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-vkCmdWriteAccelerationStructuresPropertiesKHR-accelerationStructures-03431\", \"All acceleration structures in pAccelerationStructures must have been built with VK_BUILD_ACCELERATION_STRUCTURE_ALLOW_COMPACTION_BIT_KHR if queryType is VK_QUERY_TYPE_ACCELERATION_STRUCTURE_COMPACTED_SIZE_KHR\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (!(as_state->build_info_khr.flags & VK_BUILD_ACCELERATION_STRUCTURE_ALLOW_COMPACTION_BIT_KHR)) {\n    skip |= LogError(\"VUID-vkCmdWriteAccelerationStructuresPropertiesKHR-accelerationStructures-03431\",\n                     commandBuffer, as_loc,\n                     \"was built with %s, but queryType is VK_QUERY_TYPE_ACCELERATION_STRUCTURE_COMPACTED_SIZE_KHR.\",\n                     string_VkBuildAccelerationStructureFlagsKHR(as_state->build_info_khr.flags).c_str());\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkCopyAccelerationStructureToMemoryInfoKHR-src-04959\", \"The source acceleration structure src must have been constructed prior to the execution of this command\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (!src_accel_struct.built) {\n    objlist.add(src_accel_struct.Handle());\n    skip |= LogError(\"VUID-VkCopyAccelerationStructureToMemoryInfoKHR-src-04959\", objlist, loc.dot(Field::src),\n                     \"has not been built.\");\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-vkGetRayTracingShaderGroupHandlesKHR-firstGroup-02419\", \"The sum of firstGroup and groupCount must be less than or equal to the number of shader groups in pipeline\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if ((firstGroup + groupCount) > total_group_count) {\n    skip |= LogError(\"VUID-vkGetRayTracingShaderGroupHandlesKHR-firstGroup-02419\", device,\n                     error_obj.location.dot(Field::firstGroup),\n                     \"(%\" PRIu32 \") plus groupCount (%\" PRIu32\n                     \") must be less than or equal to the number \"\n                     \"of shader groups in pipeline (%\" PRIu32 \").\",\n                     firstGroup, groupCount, total_group_count);\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-vkGetRayTracingCaptureReplayShaderGroupHandlesKHR-firstGroup-03483\", \"The sum of firstGroup and groupCount must be less than or equal to the number of shader groups in pipeline\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if ((firstGroup + groupCount) > total_group_count) {\n    skip |= LogError(\"VUID-vkGetRayTracingCaptureReplayShaderGroupHandlesKHR-firstGroup-03483\", device,\n                     error_obj.location.dot(Field::firstGroup),\n                     \"(%\" PRIu32 \") plus groupCount (%\" PRIu32\n                     \") must be less than or equal to the number of shader groups in pipeline (%\" PRIu32 \").\",\n                     firstGroup, groupCount, total_group_count);\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkGeometryTrianglesNV-indexOffset-02431\", \"indexOffset must be less than the size of indexData\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (ib_state && ib_state->create_info.size <= triangles.indexOffset) {\n    skip |= LogError(\"VUID-VkGeometryTrianglesNV-indexOffset-02431\", device, loc, \"is invalid.\");\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkRenderPassBeginInfo-clearValueCount-00902\", \"clearValueCount must be greater than the largest attachment index in renderPass specifying a loadOp (or stencilLoadOp, if the attachment has a depth/stencil format) of VK_ATTACHMENT_LOAD_OP_CLEAR\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (clear_op_size > pRenderPassBegin->clearValueCount) {\n    const LogObjectList objlist(commandBuffer, pRenderPassBegin->renderPass);\n    skip |= LogError(\"VUID-VkRenderPassBeginInfo-clearValueCount-00902\", objlist, rp_begin_loc.dot(Field::clearValueCount),\n                     \"is %\" PRIu32 \" but there must be at least %\" PRIu32\n                     \" entries in pClearValues array to account for the highest index attachment in %s that uses \"\n                     \"VK_ATTACHMENT_LOAD_OP_CLEAR is %\" PRIu32\n                     \". Note that the pClearValues array is indexed by \"\n                     \"attachment number so even if some pClearValues entries between 0 and %\" PRIu32\n                     \" correspond to attachments \"\n                     \"that aren't cleared they will be ignored.\",\n                     pRenderPassBegin->clearValueCount, clear_op_size, FormatHandle(rp_state->Handle()).c_str(), clear_op_size,\n                     clear_op_size - 1);\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkFramebufferCreateInfo-renderPass-06502\", \"If renderPass was created with fragment density map offsets other than (0,0), each element of pAttachments must have been created with a flags value including VK_IMAGE_CREATE_FRAGMENT_DENSITY_MAP_OFFSET_BIT_QCOM\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if ((fdm_non_zero_offsets == true) && ((ici.flags & VK_IMAGE_CREATE_FRAGMENT_DENSITY_MAP_OFFSET_BIT_QCOM) == 0)) {\n    const LogObjectList objlist(commandBuffer, rp_state.Handle(), view_state->Handle());\n    skip |= LogError(\"VUID-VkFramebufferCreateInfo-renderPass-06502\", objlist, error_obj.location,\n                     \"pAttachments[%\" PRIu32\n                     \"] is not created with flag value\"\n                     \" VK_IMAGE_CREATE_FRAGMENT_DENSITY_MAP_OFFSET_BIT_QCOM and renderPass\"\n                     \" uses non-zero fdm offsets.\",\n                     i);\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkSubpassFragmentDensityMapOffsetEndInfoQCOM-pInputAttachments-06506\", \"If any element of VkSubpassDescription::pInputAttachments is not is not VK_ATTACHMENT_UNUSED and was not created with VK_IMAGE_CREATE_FRAGMENT_DENSITY_MAP_OFFSET_BIT_QCOM, fragmentDensityOffsetCount must equal 0\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if ((attachment != VK_ATTACHMENT_UNUSED) && (attachment == i) &&\n    const LogObjectList objlist(commandBuffer, rp_state.Handle(), view_state->Handle());\n    skip |= LogError(\"VUID-VkSubpassFragmentDensityMapOffsetEndInfoQCOM-pInputAttachments-06506\", objlist,\n                     error_obj.location,\n                     \"pInputAttachments[%\" PRIu32\n                     \"] is not created with\"\n                     \" VK_IMAGE_CREATE_FRAGMENT_DENSITY_MAP_OFFSET_BIT_QCOM and fragmentDensityOffsetCount\"\n                     \" is %\" PRIu32 \" but must be 0 due to missing fragmentDensityOffset feature bit.\",\n                     i, fdm_offset_info->fragmentDensityOffsetCount);\n"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkDeviceGroupRenderPassBeginInfo-offset-06166\", \"The offset.x member of any element of pDeviceRenderAreas must be greater than or equal to 0\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (offset_x < 0) {\n    skip |= LogError(\"VUID-VkDeviceGroupRenderPassBeginInfo-offset-06166\", commandBuffer,\n                     group_loc.dot(Field::offset).dot(Field::x), \"is %\" PRId32 \" (offset can't be negative).\", offset_x);\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkRenderPassBeginInfo-pNext-02851\", \"If the pNext chain does not contain VkDeviceGroupRenderPassBeginInfo or its deviceRenderAreaCount member is equal to 0, renderArea.offset.y must be greater than or equal to 0\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (begin_info.renderArea.offset.y < 0) {\n    skip |= LogError(\"VUID-VkRenderPassBeginInfo-pNext-02851\", begin_info.renderPass,\n                     render_area_loc.dot(Field::offset).dot(Field::y), \"is %\" PRId32 \" (offset can't be negative).\",\n                     begin_info.renderArea.offset.y);\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkRenderPassBeginInfo-framebuffer-04627\", \"If framebuffer was created with a VkFramebufferCreateInfo::flags value that included VK_FRAMEBUFFER_CREATE_IMAGELESS_BIT, each element of the pAttachments member of a VkRenderPassAttachmentBeginInfo structure included in the pNext chain must be a VkImageView with an inherited usage equal to the usage member of the corresponding element of VkFramebufferAttachmentsCreateInfo::pAttachmentImageInfos used to create framebuffer\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "string_VkImageUsageFlags(image_create_info->usage).c_str(), i,\nstring_VkImageUsageFlags(framebuffer_attachment_image_info->usage).c_str());\nskip |= LogError(\"VUID-VkRenderPassBeginInfo-framebuffer-04627\", objlist, attachment_loc.dot(Field::usage),\n\"is (%s), which has an inherited usage subset from VkImageViewUsageCreateInfo of (%s), but the \"\n\"VkFramebuffer was created with vkFramebufferAttachmentsCreateInfo::pAttachmentImageInfos[%\" PRIu32\n\"].usage = %s.\",\nstring_VkImageUsageFlags(image_create_info->usage).c_str(),\nstring_VkImageUsageFlags(image_view_state->inherited_usage).c_str(), i,\nstring_VkImageUsageFlags(framebuffer_attachment_image_info->usage).c_str());\n"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkRenderPassBeginInfo-framebuffer-03216\", \"If framebuffer was created with a VkFramebufferCreateInfo::flags value that included VK_FRAMEBUFFER_CREATE_IMAGELESS_BIT, each element of the pAttachments member of a VkRenderPassAttachmentBeginInfo structure included in the pNext chain must be a VkImageView of an image created with a value of VkImageViewCreateInfo::format equal to the corresponding value of VkAttachmentDescription::format in renderPass\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (render_pass_create_info->pAttachments[i].format != image_view_create_info->format) {\n    skip |= LogError(\"VUID-VkRenderPassBeginInfo-framebuffer-03216\", objlist, attachment_loc.dot(Field::format),\n                     \"is %s, but the VkRenderPass was created with a pAttachments[%\" PRIu32 \"].format of %s.\",\n                     string_VkFormat(image_view_create_info->format), i,\n                     string_VkFormat(render_pass_create_info->pAttachments[i].format));\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkRenderPassAttachmentBeginInfo-pAttachments-04114\", \"Each element of pAttachments must have been created with VkImageViewCreateInfo::viewType not equal to VK_IMAGE_VIEW_TYPE_3D\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (image_view_create_info->viewType == VK_IMAGE_VIEW_TYPE_3D) {\n    skip |= LogError(\"VUID-VkRenderPassAttachmentBeginInfo-pAttachments-04114\", objlist, attachment_loc,\n                     \"was created with viewType of VK_IMAGE_VIEW_TYPE_3D.\");\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkRenderPassFragmentDensityMapCreateInfoEXT-fragmentDensityMapAttachment-02548\", \"If fragmentDensityMapAttachment is not VK_ATTACHMENT_UNUSED, fragmentDensityMapAttachment must not be an element of VkSubpassDescription::pInputAttachments, VkSubpassDescription::pColorAttachments, VkSubpassDescription::pResolveAttachments, VkSubpassDescription::pDepthStencilAttachment, or VkSubpassDescription::pPreserveAttachments for any subpass\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if ((fdm_attachment_index != VK_ATTACHMENT_UNUSED) && (attachment == fdm_attachment_index)) {\n    skip |= LogError(\"VUID-VkRenderPassFragmentDensityMapCreateInfoEXT-fragmentDensityMapAttachment-02548\", device,\n                     ds_loc,\n                     \"is also referenced by \"\n                     \"VkRenderPassFragmentDensityMapCreateInfoEXT::fragmentDensityMapAttachment\");\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkRenderPassCreateInfo2-attachment-06246\", \"If the attachment member of the pDepthStencilAttachment member of an element of pSubpasses is not VK_ATTACHMENT_UNUSED and the layout member of that same structure is either VK_IMAGE_LAYOUT_DEPTH_ATTACHMENT_OPTIMAL or VK_IMAGE_LAYOUT_DEPTH_READ_ONLY_OPTIMAL, then the element of pAttachments with an index equal to attachment must not have a format that includes only a stencil component\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (vkuFormatIsStencilOnly(attachment_format)) {\n    skip |= LogError(\"VUID-VkRenderPassCreateInfo2-attachment-06246\", device, attachment_loc.dot(Field::format),\n                     \"(%s) only has a stencil component (referenced by %s).\",\n                     string_VkFormat(attachment_format), ds_loc.Fields().c_str());\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkSubpassDescription2-externalFormatResolve-09345\", \"If externalFormatResolve is enabled, pResolveAttachments is not NULL, any element of pResolveAttachments is not VK_ATTACHMENT_UNUSED and has a format of VK_FORMAT_UNDEFINED, and the corresponding element of pColorAttachments is not VK_ATTACHMENT_UNUSED, the color attachment must have a samples value of 1\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (color_desc.samples != VK_SAMPLE_COUNT_1_BIT) {\n    skip |= LogError(\"VUID-VkSubpassDescription2-externalFormatResolve-09345\", device,\n                     create_info_loc.dot(Field::pAttachments, attachment_index).dot(Field::samples),\n                     \"is %s (referenced by %s).\", string_VkSampleCountFlagBits(color_desc.samples),\n                     color_loc.Fields().c_str());\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkSubpassDependency2-dependencyFlags-03092\", \"If dependencyFlags does not include VK_DEPENDENCY_VIEW_LOCAL_BIT, viewOffset must be 0\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "skip |= LogError(\"VUID-VkRenderPassCreateInfo2-viewMask-03059\", device, dependencies_loc,\n} else if (use_rp2 && !(dependency.dependencyFlags & VK_DEPENDENCY_VIEW_LOCAL_BIT) && dependency.viewOffset != 0) {\nskip |= LogError(\"VUID-VkSubpassDependency2-dependencyFlags-03092\", device, dependencies_loc,\n                 \"specifies the VK_DEPENDENCY_VIEW_LOCAL_BIT, but also specifies a view offset of %\" PRIu32 \".\",\n                 dependency.viewOffset);\n"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkRenderPassFragmentDensityMapCreateInfoEXT-fragmentDensityMapAttachment-02549\", \"If fragmentDensityMapAttachment is not VK_ATTACHMENT_UNUSED, layout must be equal to VK_IMAGE_LAYOUT_FRAGMENT_DENSITY_MAP_OPTIMAL_EXT, or VK_IMAGE_LAYOUT_GENERAL\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (!(fragment_density_map_info->fragmentDensityMapAttachment.layout ==\n      fragment_density_map_info->fragmentDensityMapAttachment.layout == VK_IMAGE_LAYOUT_GENERAL)) {\n    skip |= LogError(\"VUID-VkRenderPassFragmentDensityMapCreateInfoEXT-fragmentDensityMapAttachment-02549\", device,\n                     attchment_loc,\n                     \"(%\" PRIu32\n                     \") layout must be equal to \"\n                     \"VK_IMAGE_LAYOUT_FRAGMENT_DENSITY_MAP_OPTIMAL_EXT or VK_IMAGE_LAYOUT_GENERAL.\",\n                     fragment_density_map_info->fragmentDensityMapAttachment.attachment);\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkRenderPassMultiviewCreateInfo-multiview-06555\", \"If the multiview feature is not enabled, each element of pViewMasks must be 0\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (!enabled_features.multiview && multiview_info->pViewMasks[i] != 0) {\n    skip |= LogError(\"VUID-VkRenderPassMultiviewCreateInfo-multiview-06555\", device, error_obj.location,\n                     \"multiview feature is not enabled, but \"\n                     \"VkRenderPassMultiviewCreateInfo->pViewMask[%\" PRIu32 \"] is 0x%\" PRIx32 \".\",\n                     i, multiview_info->pViewMasks[i]);\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkRenderPassCreateInfo-pNext-02514\", \"If the pNext chain includes a VkRenderPassMultiviewCreateInfo structure, and each element of its pViewMasks member is 0, the dependencyFlags member of each element of pDependencies must not include VK_DEPENDENCY_VIEW_LOCAL_BIT\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "skip |= LogError(\"VUID-VkRenderPassCreateInfo-pNext-02514\", device,\n                 error_obj.location.dot(Field::pDependencies, i).dot(Field::dependencyFlags),\n                 \"contains VK_DEPENDENCY_VIEW_LOCAL_BIT bit, but all elements of pViewMasks are 0.\");\n"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkSubpassDescriptionDepthStencilResolve-pDepthStencilResolveAttachment-03178\", \"If pDepthStencilResolveAttachment is not NULL and does not have the value VK_ATTACHMENT_UNUSED, depthResolveMode and stencilResolveMode must not both be VK_RESOLVE_MODE_NONE\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (resolve_has_depth && !resolve_has_stencil && resolve->depthResolveMode == VK_RESOLVE_MODE_NONE) {\n    skip |= LogError(\"VUID-VkSubpassDescriptionDepthStencilResolve-pDepthStencilResolveAttachment-03178\", device,\n                     ds_resolve_loc,\n                     \"is not NULL, but the depth resolve mode is VK_RESOLVE_MODE_NONE (stencil resolve mode is \"\n                     \"ignored due to format not having stencil component).\");\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkRenderPassCreateInfo2-flags-04908\", \"If flags includes VK_SUBPASS_DESCRIPTION_SHADER_RESOLVE_BIT_QCOM, and if pDepthStencilResolveAttachment is not NULL, then the depth/stencil resolve attachment must be VK_ATTACHMENT_UNUSED\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if ((subpass.flags & VK_SUBPASS_DESCRIPTION_SHADER_RESOLVE_BIT_QCOM) != 0) {\n    skip |= LogError(\"VUID-VkRenderPassCreateInfo2-flags-04908\", device, subpass_loc,\n                     \"enables shader resolve, which requires the depth/stencil resolve attachment\"\n                     \" must be VK_ATTACHMENT_UNUSED, but a reference to attachment %\" PRIu32 \" was found instead.\",\n                     resolve_attachment);\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkRenderPassCreateInfo2-pAttachments-04585\", \"If any element of pAttachments is used as a fragment shading rate attachment in any subpass, it must not be used as any other attachment in the render pass\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (subpass_info.pColorAttachments[attachment].attachment == attachment_description) {\n    skip |= LogError(\"VUID-VkRenderPassCreateInfo2-pAttachments-04585\", device,\n                     subpass_loc.dot(Field::pColorAttachments, attachment).dot(Field::attachment),\n                     \"is also used in pAttachments[%\" PRIu32\n                     \"] as a fragment shading rate attachment in subpass(es) %s\",\n                     attachment_description, fsr_attachment_subpasses_string.c_str());\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkRenderingInfo-pNext-06080\", \"If the pNext chain does not contain VkDeviceGroupRenderPassBeginInfo or its deviceRenderAreaCount member is equal to 0, the height of the imageView member of any element of pColorAttachments, pDepthAttachment, or pStencilAttachment that is not VK_NULL_HANDLE must be greater than or equal to renderArea.offset.y + renderArea.extent.height\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (!y_extent_valid) {\n    skip |= LogError(\"VUID-VkRenderingInfo-pNext-06080\", objlist, loc,\n                     \"height (%\" PRIu32 \") is less than pRenderingInfo->renderArea.offset.y (%\" PRId32\n                     \") + pRenderingInfo->renderArea.extent.height (%\" PRIu32 \").\",\n                     image_view->image_state->create_info.extent.height, pRenderingInfo->renderArea.offset.y,\n                     pRenderingInfo->renderArea.extent.height);\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkRenderingAttachmentInfo-imageView-06861\", \"imageView must not have a sample count of VK_SAMPLE_COUNT_1_BIT if all of the following hold: imageView is not VK_NULL_HANDLE resolveMode is not VK_RESOLVE_MODE_NONE the pNext chain of VkRenderingInfo does not include a VkMultisampledRenderToSingleSampledInfoEXT structure with the multisampledRenderToSingleSampledEnable field equal to VK_TRUE\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (!msrtss_info || !msrtss_info->multisampledRenderToSingleSampledEnable) {\n    const LogObjectList objlist(commandBuffer, attachment_info.imageView);\n    skip |= LogError(\"VUID-VkRenderingAttachmentInfo-imageView-06861\", objlist, attachment_loc.dot(Field::imageView),\n                     \"must not have a VK_SAMPLE_COUNT_1_BIT when resolveMode is %s\",\n                     string_VkResolveModeFlags(attachment_info.resolveMode).c_str());\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkRenderingAttachmentInfo-imageView-06136\", \"If imageView is not VK_NULL_HANDLE and resolveMode is not VK_RESOLVE_MODE_NONE, resolveImageLayout must not be VK_IMAGE_LAYOUT_UNDEFINED, VK_IMAGE_LAYOUT_DEPTH_STENCIL_READ_ONLY_OPTIMAL, VK_IMAGE_LAYOUT_SHADER_READ_ONLY_OPTIMAL, VK_IMAGE_LAYOUT_TRANSFER_SRC_OPTIMAL, VK_IMAGE_LAYOUT_TRANSFER_DST_OPTIMAL, or VK_IMAGE_LAYOUT_PREINITIALIZED\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "skip |= LogError(\"VUID-VkRenderingAttachmentInfo-imageView-06136\", commandBuffer,\n                 attachment_loc.dot(Field::resolveImageLayout), \"is %s.\",\n                 string_VkImageLayout(attachment_info.resolveImageLayout));\n"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkRenderingInfo-imageView-06107\", \"If the imageView member of a VkRenderingFragmentDensityMapAttachmentInfoEXT structure included in the pNext chain is not VK_NULL_HANDLE, and the fragmentDensityMapNonSubsampledImages feature is not enabled, valid imageView and resolveImageView members of pDepthAttachment, pStencilAttachment, and each element of pColorAttachments must be a VkImageView created with VK_IMAGE_CREATE_SUBSAMPLED_BIT_EXT\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (stencil_view_state && !(stencil_view_state->image_state->create_info.flags & VK_IMAGE_CREATE_SUBSAMPLED_BIT_EXT)) {\n    const LogObjectList objlist(commandBuffer, rendering_info.pStencilAttachment->imageView);\n    skip |= LogError(\"VUID-VkRenderingInfo-imageView-06107\", objlist,\n                     rendering_info_loc.dot(Field::pStencilAttachment).dot(Field::imageView),\n                     \"must be created with VK_IMAGE_CREATE_SUBSAMPLED_BIT_EXT.\");\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkRenderingInfo-imageView-06108\", \"If the imageView member of a VkRenderingFragmentDensityMapAttachmentInfoEXT structure included in the pNext chain is not VK_NULL_HANDLE, and viewMask is not 0, imageView must have a layerCount greater than or equal to the index of the most significant bit in viewMask\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if ((rendering_info.viewMask != 0) && (layer_count < MostSignificantBit(rendering_info.viewMask))) {\n    const LogObjectList objlist(commandBuffer, fragment_density_map_attachment_info->imageView);\n    skip |= LogError(\"VUID-VkRenderingInfo-imageView-06108\", objlist, view_loc,\n                     \"must have a layer count (%\" PRId32\n                     \") greater than or equal to the most significant bit in viewMask (%\" PRIu32 \")\",\n                     layer_count, rendering_info.viewMask);\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkRenderingInfo-imageView-09485\", \"If the imageView member of a VkRenderingFragmentShadingRateAttachmentInfoKHR structure included in the pNext chain is not VK_NULL_HANDLE, it must have been created with the identity swizzle\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (!IsIdentitySwizzle(components)) {\n    skip |= LogError(\"VUID-VkRenderingInfo-imageView-09485\", objlist,\n                     rendering_info_loc.pNext(Struct::VkRenderingFragmentShadingRateAttachmentInfoKHR, Field::imageView),\n                     \"has a non-identiy swizzle component, here are the actual swizzle values:\\n\"\n                     \"r swizzle = %s\\n\"\n                     \"g swizzle = %s\\n\"\n                     \"b swizzle = %s\\n\"\n                     \"a swizzle = %s\\n\",\n                     string_VkComponentSwizzle(components.r), string_VkComponentSwizzle(components.g),\n                     string_VkComponentSwizzle(components.b), string_VkComponentSwizzle(components.a));\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkDeviceGroupRenderPassBeginInfo-offset-06168\", \"The sum of the offset.x and extent.width members of any element of pDeviceRenderAreas must be less than or equal to maxFramebufferWidth\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if ((offset_x + width) > phys_dev_props.limits.maxFramebufferWidth) {\n    skip |= LogError(\"VUID-VkDeviceGroupRenderPassBeginInfo-offset-06168\", commandBuffer, group_loc,\n                     \"sum of offset.x (%\" PRId32 \") and extent.width (%\" PRIu32\n                     \") is greater than maxFramebufferWidth (%\" PRIu32 \").\",\n                     offset_x, width, phys_dev_props.limits.maxFramebufferWidth);\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkRenderingInfo-pNext-06084\", \"If the pNext chain contains VkDeviceGroupRenderPassBeginInfo, the height of the imageView member of any element of pColorAttachments, pDepthAttachment, or pStencilAttachment that is not VK_NULL_HANDLE must be greater than or equal to the sum of the offset.y and extent.height members of each element of pDeviceRenderAreas\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (image_state->create_info.extent.height < offset_y + height) {\n    const LogObjectList objlist(commandBuffer, image_view_state->Handle(), image_state->Handle());\n    skip |= LogError(\"VUID-VkRenderingInfo-pNext-06084\", objlist,\n                     rendering_info_loc.dot(Field::pColorAttachments, j).dot(Field::imageView),\n                     \"height (%\" PRIu32\n                     \") must be greater than or equal to\"\n                     \"renderArea.offset.y (%\" PRId32 \") + renderArea.extent.height (%\" PRIu32 \").\",\n                     image_state->create_info.extent.height, offset_y, height);\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkRenderingInfo-multisampledRenderToSingleSampled-06857\", \"imageView members of pDepthAttachment, pStencilAttachment, and elements of pColorAttachments that are not VK_NULL_HANDLE must have been created with the same sampleCount , if none of the following are enabled: The VK_AMD_mixed_attachment_samples extension The VK_NV_framebuffer_mixed_samples extension The multisampledRenderToSingleSampled feature,\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (first_sample_count_attachment != image_view->samples) {\n    skip |= LogError(\"VUID-VkRenderingInfo-multisampledRenderToSingleSampled-06857\", objlist,\n                     rendering_info_loc.dot(Field::pColorAttachments, j).dot(Field::imageView),\n                     \"has sample count %s, whereas first used color \"\n                     \"attachment ref has sample count %\" PRIu32 \".\",\n                     string_VkSampleCountFlagBits(image_view->samples), first_sample_count_attachment);\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkRenderingInfo-None-08994\", \"If VkDeviceGroupRenderPassBeginInfo::deviceRenderAreaCount is 0, renderArea.extent.width must be greater than 0\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "skip |= LogError(\"VUID-VkRenderingInfo-None-08994\", commandBuffer,\n                 rendering_info_loc.dot(Field::renderArea).dot(Field::extent).dot(Field::width), \"is zero.\");\n"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkRenderingInfo-pDepthAttachment-06105\", \"If pDepthAttachment or pStencilAttachment are both not NULL, pDepthAttachment->imageView and pStencilAttachment->imageView are both not VK_NULL_HANDLE, VkPhysicalDeviceDepthStencilResolveProperties::independentResolve is VK_FALSE, and the resolveMode of neither structure is VK_RESOLVE_MODE_NONE, the resolveMode of both structures must be the same value\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "(pRenderingInfo->pDepthAttachment->resolveMode != VK_RESOLVE_MODE_NONE) &&\n(pRenderingInfo->pStencilAttachment->resolveMode != pRenderingInfo->pDepthAttachment->resolveMode)) {\nskip |= LogError(\"VUID-VkRenderingInfo-pDepthAttachment-06105\", commandBuffer, rendering_info_loc,\n                 \"values of pDepthAttachment->resolveMode (%s) and pStencilAttachment->resolveMode (%s) must \"\n                 \"be identical, or one of them must be VK_RESOLVE_MODE_NONE.\",\n                 string_VkResolveModeFlagBits(pRenderingInfo->pDepthAttachment->resolveMode),\n                 string_VkResolveModeFlagBits(pRenderingInfo->pStencilAttachment->resolveMode));\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkRenderingInfo-resolveMode-09321\", \"If the resolveMode of any element of pColorAttachments is VK_RESOLVE_MODE_EXTERNAL_FORMAT_DOWNSAMPLE_ANDROID, VkRenderingFragmentDensityMapAttachmentInfoEXT::imageView must be VK_NULL_HANDLE\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (fragment_density_info_ext && fragment_density_info_ext->imageView != VK_NULL_HANDLE) {\n    skip |= LogError(\"VUID-VkRenderingInfo-resolveMode-09321\", commandBuffer,\n                     rendering_info_loc.pNext(Struct::VkRenderingFragmentDensityMapAttachmentInfoEXT, Field::imageView),\n                     \"is not null (%s).\", FormatHandle(fragment_density_info_ext->imageView).c_str());\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkRenderingAttachmentInfo-resolveMode-09328\", \"If resolveMode is VK_RESOLVE_MODE_EXTERNAL_FORMAT_DOWNSAMPLE_ANDROID and nullColorAttachmentWithExternalFormatResolve is VK_TRUE, imageView must be VK_NULL_HANDLE\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (android_external_format_resolve_null_color_attachment_prop) {\n    skip |= LogError(\"VUID-VkRenderingAttachmentInfo-resolveMode-09328\", commandBuffer,\n                     color_loc.dot(Field::imageView), \"is not null (%s).\",\n                     FormatHandle(attachment_info.imageView).c_str());\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkRenderingInfo-pDepthAttachment-09318\", \"pDepthAttachment->resolveMode must not be VK_RESOLVE_MODE_EXTERNAL_FORMAT_DOWNSAMPLE_ANDROID\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (depth_attachment_info.resolveMode == VK_RESOLVE_MODE_EXTERNAL_FORMAT_DOWNSAMPLE_ANDROID) {\n    skip |= LogError(\"VUID-VkRenderingInfo-pDepthAttachment-09318\", commandBuffer,\n                     rendering_info_loc.dot(Field::pDepthAttachment).dot(Field::resolveMode),\n                     \"is VK_RESOLVE_MODE_EXTERNAL_FORMAT_DOWNSAMPLE_ANDROID.\");\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkRenderingInfo-pStencilAttachment-09483\", \"If pStencilAttachment is not NULL and pStencilAttachment->imageView is not VK_NULL_HANDLE, pStencilAttachment->imageView must have been created with the identity swizzle\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (!IsIdentitySwizzle(components)) {\n    const LogObjectList objlist(commandBuffer, stencil_view_state->Handle());\n    skip |= LogError(\"VUID-VkRenderingInfo-pStencilAttachment-09483\", objlist,\n                     rendering_info_loc.dot(Field::pStencilAttachment).dot(Field::imageView),\n                     \"has a non-identiy swizzle component, here are the actual swizzle values:\\n\"\n                     \"r swizzle = %s\\n\"\n                     \"g swizzle = %s\\n\"\n                     \"b swizzle = %s\\n\"\n                     \"a swizzle = %s\\n\",\n                     string_VkComponentSwizzle(components.r), string_VkComponentSwizzle(components.g),\n                     string_VkComponentSwizzle(components.b), string_VkComponentSwizzle(components.a));\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-vkCmdEndRendering-None-06161\", \"The current render pass instance must have been begun with vkCmdBeginRendering\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (!cb_state->activeRenderPass->UsesDynamicRendering()) {\n    skip |= LogError(\"VUID-vkCmdEndRendering-None-06161\", commandBuffer, error_obj.location,\n                     \"in a render pass instance that was not begun with vkCmdBeginRendering().\");\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkFramebufferCreateInfo-samples-06881\", \"If multisampled-render-to-single-sampled is enabled for any subpass, all color, depth/stencil and input attachments used in that subpass which have VkAttachmentDescription::samples or VkAttachmentDescription2::samples equal to VK_SAMPLE_COUNT_1_BIT must have been created with VK_IMAGE_CREATE_MULTISAMPLED_RENDER_TO_SINGLE_SAMPLED_BIT_EXT in their VkImageCreateInfo::flags\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (!(image_state->create_info.flags & VK_IMAGE_CREATE_MULTISAMPLED_RENDER_TO_SINGLE_SAMPLED_BIT_EXT)) {\n    skip |= LogError(\"VUID-VkFramebufferCreateInfo-samples-06881\", device, create_info_loc,\n                     \"Renderpass subpass %\" PRIu32\n                     \" enables \"\n                     \"multisampled-render-to-single-sampled and attachment %\" PRIu32\n                     \", is specified from with \"\n                     \"VK_SAMPLE_COUNT_1_BIT samples, but image (%s) was created without \"\n                     \"VK_IMAGE_CREATE_MULTISAMPLED_RENDER_TO_SINGLE_SAMPLED_BIT_EXT in its pCreateInfo->flags.\",\n                     subpass, fb_attachment, FormatHandle(*image_state).c_str());\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkFramebufferCreateInfo-pAttachments-00880\", \"If flags does not include VK_FRAMEBUFFER_CREATE_IMAGELESS_BIT, each element of pAttachments must have been created with a VkFormat value that matches the VkFormat specified by the corresponding VkAttachmentDescription in renderPass\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (ivci.format != rpci.pAttachments[i].format) {\n    LogObjectList objlist(create_info.renderPass, image_views[i]);\n    skip |= LogError(\"VUID-VkFramebufferCreateInfo-pAttachments-00880\", objlist, attachment_loc,\n                     \"has format of %s that does not match the format of %s used by the corresponding attachment for %s.\",\n                     string_VkFormat(ivci.format), string_VkFormat(rpci.pAttachments[i].format),\n                     FormatHandle(create_info.renderPass).c_str());\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkFramebufferCreateInfo-flags-04539\", \"If maintenance7 is not enabled or the robustFragmentShadingRateAttachmentAccess limit is VK_FALSE or the imageView member of a VkRenderingFragmentShadingRateAttachmentInfoKHR structure was created with VkImageSubresourceRange::baseMipLevel greater than 0, flags does not include VK_FRAMEBUFFER_CREATE_IMAGELESS_BIT, an element of pAttachments that is used as a fragment shading rate attachment must have a width at least as large as \u2308width / texelWidth\u2309, where texelWidth is the largest value of shadingRateAttachmentTexelSize.width in a VkFragmentShadingRateAttachmentInfoKHR which references that attachment\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (validate_render_area &&\n    LogObjectList objlist(create_info.renderPass, image_views[i], ivci.image);\n    skip |= LogError(\"VUID-VkFramebufferCreateInfo-flags-04539\", objlist, attachment_loc,\n                     \"mip level %\" PRIu32\n                     \" is used as a \"\n                     \"fragment shading rate attachment in subpass %\" PRIu32\n                     \", but the product of its \"\n                     \"width (%\" PRIu32\n                     \") and the \"\n                     \"specified shading rate texel width (%\" PRIu32\n                     \") are smaller than the \"\n                     \"corresponding framebuffer width (%\" PRIu32 \").\",\n                     subresource_range.baseMipLevel, j, mip_width,\n                     fsr_attachment->shadingRateAttachmentTexelSize.width, create_info.width);\n"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkFramebufferCreateInfo-renderPass-02746\", \"Each element of pAttachments that is referenced by fragmentDensityMapAttachment must have a layerCount equal to 1 or if renderPass was specified with non-zero view masks, greater than the index of the most significant bit set in any of those view masks\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (view_state->normalized_subresource_range.layerCount != 1 &&\n    LogObjectList objlist(create_info.renderPass, image_views[i], ivci.image);\n    skip |= LogError(\"VUID-VkFramebufferCreateInfo-renderPass-02746\", objlist, attachment_loc,\n                     \"is referenced by \"\n                     \"VkRenderPassFragmentDensityMapCreateInfoEXT::fragmentDensityMapAttachment in \"\n                     \"the pNext chain, but it was create with subresourceRange.layerCount (%\" PRIu32\n                     \") different from 1.\",\n                     view_state->normalized_subresource_range.layerCount);\n"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkFramebufferCreateInfo-flags-04533\", \"If flags does not include VK_FRAMEBUFFER_CREATE_IMAGELESS_BIT, each element of pAttachments that is used as an input, color, resolve, or depth/stencil attachment by renderPass must have been created with a VkImageCreateInfo::extent.width greater than or equal to width\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (mip_width < create_info.width) {\n    LogObjectList objlist(create_info.renderPass, image_views[i], ivci.image);\n    skip |= LogError(\"VUID-VkFramebufferCreateInfo-flags-04533\", objlist, attachment_loc,\n                     \"mip level %\" PRIu32 \" has width (%\" PRIu32\n                     \") smaller than the corresponding framebuffer width (%\" PRIu32 \").\",\n                     mip_level, mip_width, create_info.width);\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkFramebufferCreateInfo-pAttachments-00891\", \"If flags does not include VK_FRAMEBUFFER_CREATE_IMAGELESS_BIT, each element of pAttachments that is a 2D or 2D array image view taken from a 3D image must not be a depth/stencil format\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (vkuFormatIsDepthOrStencil(ivci.format)) {\n    LogObjectList objlist(create_info.renderPass, image_views[i], ivci.image);\n    skip |= LogError(\"VUID-VkFramebufferCreateInfo-pAttachments-00891\", objlist, attachment_loc,\n                     \"has an image view type of %s which was taken from image %s of type \"\n                     \"VK_IMAGE_TYPE_3D, but the image view format is a \"\n                     \"depth/stencil format %s.\",\n                     string_VkImageViewType(ivci.viewType), FormatHandle(ivci.image).c_str(),\n                     string_VkFormat(ivci.format));\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkFramebufferCreateInfo-flags-04587\", \"If flags includes VK_FRAMEBUFFER_CREATE_IMAGELESS_BIT and renderPass was specified with non-zero view masks, the layerCount member of any element of the pAttachmentImageInfos member of a VkFramebufferAttachmentsCreateInfo structure in the pNext chain that is used as a fragment shading rate attachment must be either 1, or greater than the index of the most significant bit set in any of those view masks\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (aii.layerCount != 1 && static_cast<int32_t>(aii.layerCount) <= highest_view_bit) {\n    skip |= LogError(\"VUID-VkFramebufferCreateInfo-flags-04587\", create_info.renderPass, attachment_loc,\n                     \"has a layer count (%\" PRIu32\n                     \") \"\n                     \"less than or equal to the highest bit in the view mask (%i) of subpass %\" PRIu32 \".\",\n                     aii.layerCount, highest_view_bit, j);\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkFramebufferCreateInfo-renderPass-04546\", \"If multiview is not enabled for renderPass and flags includes VK_FRAMEBUFFER_CREATE_IMAGELESS_BIT, the layerCount member of any element of the pAttachmentImageInfos member of a VkFramebufferAttachmentsCreateInfo structure included in the pNext chain used as an input, color, resolve, or depth/stencil attachment in renderPass must be greater than or equal to layers\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (aii.layerCount < create_info.layers) {\n    skip |= LogError(\"VUID-VkFramebufferCreateInfo-renderPass-04546\", create_info.renderPass, attachment_loc,\n                     \"has only %\" PRIu32 \" layers, but framebuffer has %\" PRIu32 \" layers.\", aii.layerCount,\n                     create_info.layers);\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkRenderingAttachmentLocationInfoKHR-dynamicRenderingLocalRead-09512\", \"If the dynamicRenderingLocalRead feature is not enabled, and pColorAttachmentLocations is not NULL, each element must be set to the value of its index within the array\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (!enabled_features.dynamicRenderingLocalRead && location != i) {\n    skip |= LogError(\"VUID-VkRenderingAttachmentLocationInfoKHR-dynamicRenderingLocalRead-09512\", objlist, loc,\n                     \"= %\" PRIu32 \" while expected to be %\" PRIu32, location, i);\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-vkCmdSetRenderingAttachmentLocationsKHR-commandBuffer-09511\", \"The current render pass instance must have been started or resumed by vkCmdBeginRendering in this commandBuffer\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (!rp_state.UsesDynamicRendering()) {\n    const LogObjectList objlist(commandBuffer, rp_state.VkHandle());\n    skip |= LogError(\"VUID-vkCmdSetRenderingAttachmentLocationsKHR-commandBuffer-09511\", objlist, loc_info,\n                     \"vkCmdBeginRendering was not called.\");\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkRenderingInputAttachmentIndexInfoKHR-colorAttachmentCount-09525\", \"colorAttachmentCount must be less than or equal to maxColorAttachments\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (index_info.colorAttachmentCount > phys_dev_props.limits.maxColorAttachments) {\n    const Location loc = loc_info.dot(Struct::VkRenderingInputAttachmentIndexInfoKHR, Field::colorAttachmentCount);\n    skip |= LogError(\"VUID-VkRenderingInputAttachmentIndexInfoKHR-colorAttachmentCount-09525\", objlist, loc,\n                     \"= %\" PRIu32 \" must be less than or equal to maxColorAttachments = %\" PRIu32 \".\",\n                     index_info.colorAttachmentCount, phys_dev_props.limits.maxColorAttachments);\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkGraphicsPipelineCreateInfo-alphaToCoverageEnable-08891\", \"If the pipeline is being created with fragment shader state, the VkPipelineMultisampleStateCreateInfo::alphaToCoverageEnable is not ignored and is VK_TRUE, then the Fragment Output Interface must contain a variable for the alpha Component word in Location 0 at Index 0\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (!entrypoint.has_alpha_to_coverage_variable) {\n    skip |= LogError(\"VUID-VkGraphicsPipelineCreateInfo-alphaToCoverageEnable-08891\", module_state.handle(),\n                     create_info_loc.dot(Field::pMultisampleState).dot(Field::alphaToCoverageEnable),\n                     \"is VK_TRUE, but the fragment shader doesn't declare a variable that covers \"\n                     \"Location 0, Component 3 (alpha channel).\");\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-RuntimeSpirv-Location-06272\", \"The sum of Location and the number of locations the variable it decorates consumes must be less than or equal to the value for the matching Execution Model defined in Shader Input and Output Locations\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (entrypoint.max_input_slot_variable->is_patch &&\n    skip |= LogError(\"VUID-RuntimeSpirv-Location-06272\", module_state.handle(), loc,\n                     \"SPIR-V (Tessellation control stage) output interface variable (%s) \"\n                     \"exceeds component limit maxTessellationControlPerPatchOutputComponents (%\" PRIu32 \").\",\n                     max_output_slot.Describe().c_str(), limits.maxTessellationControlPerPatchOutputComponents);\n"
        },
        {
            "role": "user",
            "content": "{\"VUID-RuntimeSpirv-Location-06272\", \"The sum of Location and the number of locations the variable it decorates consumes must be less than or equal to the value for the matching Execution Model defined in Shader Input and Output Locations\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (total_output_components >= limits.maxGeometryOutputComponents) {\n    skip |= LogError(\"VUID-RuntimeSpirv-Location-06272\", module_state.handle(), loc,\n                     \"SPIR-V (Geometry stage) output interface variable (%s) along with %\" PRIu32\n                     \" built-in components,  \"\n                     \"exceeds component limit maxGeometryOutputComponents (%\" PRIu32 \").\",\n                     max_output_slot.Describe().c_str(), entrypoint.builtin_output_components,\n                     limits.maxGeometryOutputComponents);\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-RuntimeSpirv-MeshNV-07114\", \"For mesh shaders using the MeshNV Execution Model the OutputPrimitivesNV OpExecutionMode must be less than or equal to VkPhysicalDeviceMeshShaderPropertiesNV::maxMeshOutputPrimitives\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (num_primitives > phys_dev_ext_props.mesh_shader_props_nv.maxMeshOutputPrimitives) {\n    skip |= LogError(\"VUID-RuntimeSpirv-MeshNV-07114\", module_state.handle(), loc,\n                     \"SPIR-V (Mesh stage) output primitives count exceeds the \"\n                     \"maxMeshOutputPrimitives of %\" PRIu32 \" by %\" PRIu32 \".\",\n                     phys_dev_ext_props.mesh_shader_props_nv.maxMeshOutputPrimitives,\n                     num_primitives - phys_dev_ext_props.mesh_shader_props_nv.maxMeshOutputPrimitives);\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-RuntimeSpirv-maintenance4-06817\", \"If maintenance4 is not enabled, any OpTypeVector output interface variables must not have a higher Component Count than a matching OpTypeVector input interface variable\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (output_vec_size > input_vec_size) {\n    const LogObjectList objlist(producer.handle(), consumer.handle());\n    skip |= LogError(\"VUID-RuntimeSpirv-maintenance4-06817\", objlist, create_info_loc,\n                     \"(SPIR-V Interface) starting at Location %\" PRIu32 \" Component %\" PRIu32\n                     \" the Output (%s) has a Vec%\" PRIu32 \" while Input (%s) as a Vec%\" PRIu32\n                     \". Enable VK_KHR_maintenance4 device extension to allow relaxed interface matching \"\n                     \"between input and output vectors.\",\n                     location, component, string_VkShaderStageFlagBits(producer_stage), output_vec_size,\n                     string_VkShaderStageFlagBits(consumer_stage), input_vec_size);\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkGraphicsPipelineCreateInfo-pStages-00734\", \"If the pipeline requires pre-rasterization shader state and pStages includes tessellation shader stages, the shader code of at least one stage must contain an OpExecutionMode instruction specifying the output patch size in the pipeline\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (tesc_patch_size == vvl::kU32Max && tese_patch_size == vvl::kU32Max) {\n    const LogObjectList objlist(tesc_module_state.handle(), tese_module_state.handle());\n    skip |= LogError(\"VUID-VkGraphicsPipelineCreateInfo-pStages-00734\", objlist, create_info_loc,\n                     \"Output patch size is not specified in either of tessellation stages\");\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkShaderCreateInfoEXT-stage-08422\", \"If the meshShader feature is not enabled, stage must not be VK_SHADER_STAGE_MESH_BIT_EXT\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (enabled_features.meshShader == VK_FALSE) {\n    skip |= LogError(\"VUID-VkShaderCreateInfoEXT-stage-08422\", device, create_info_loc.dot(Field::stage),\n                     \"is VK_SHADER_STAGE_MESH_BIT_EXT, but the meshShader feature was not enabled.\");\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkShaderCreateInfoEXT-nextStage-08428\", \"If the tessellationShader feature is not enabled, nextStage must not include VK_SHADER_STAGE_TESSELLATION_CONTROL_BIT or VK_SHADER_STAGE_TESSELLATION_EVALUATION_BIT\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (enabled_features.tessellationShader == VK_FALSE &&\n    (create_info.nextStage == VK_SHADER_STAGE_TESSELLATION_CONTROL_BIT ||\n     create_info.nextStage == VK_SHADER_STAGE_TESSELLATION_EVALUATION_BIT)) {\n    skip |= LogError(\"VUID-VkShaderCreateInfoEXT-nextStage-08428\", device, create_info_loc.dot(Field::nextStage),\n                     \"is %s, but tessellationShader feature was not enabled.\",\n                     string_VkShaderStageFlags(create_info.nextStage).c_str());\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkShaderCreateInfoEXT-nextStage-08431\", \"If stage is VK_SHADER_STAGE_TESSELLATION_EVALUATION_BIT, nextStage must not include any bits other than VK_SHADER_STAGE_GEOMETRY_BIT and VK_SHADER_STAGE_FRAGMENT_BIT\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if ((createInfo.nextStage & ~(VK_SHADER_STAGE_GEOMETRY_BIT | VK_SHADER_STAGE_FRAGMENT_BIT)) != 0) {\n    skip |= LogError(\"VUID-VkShaderCreateInfoEXT-nextStage-08431\", device, create_info_loc.dot(Field::stage),\n                     \"is VK_SHADER_STAGE_TESSELLATION_EVALUATION_BIT, but nextStage is %s.\",\n                     string_VkShaderStageFlags(createInfo.nextStage).c_str());\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkShaderCreateInfoEXT-nextStage-08435\", \"If stage is VK_SHADER_STAGE_TASK_BIT_EXT, nextStage must not include any bits other than VK_SHADER_STAGE_MESH_BIT_EXT\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (create_info.stage == VK_SHADER_STAGE_TASK_BIT_EXT && (create_info.nextStage & ~VK_SHADER_STAGE_MESH_BIT_EXT) > 0) {\n    skip |= LogError(\"VUID-VkShaderCreateInfoEXT-nextStage-08435\", device, create_info_loc.dot(Field::stage),\n                     \"is VK_SHADER_STAGE_TASK_BIT_EXT, but nextStage is %s.\",\n                     string_VkShaderStageFlags(create_info.nextStage).c_str());\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-vkCreateShadersEXT-pCreateInfos-08403\", \"If the flags member of any element of pCreateInfos includes VK_SHADER_CREATE_LINK_STAGE_BIT_EXT, the flags member of all other elements of pCreateInfos whose stage is VK_SHADER_STAGE_TASK_BIT_EXT or VK_SHADER_STAGE_MESH_BIT_EXT must also include VK_SHADER_CREATE_LINK_STAGE_BIT_EXT\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (linked_stage != invalid && non_linked_task_mesh_stage != invalid) {\n    skip |= LogError(\"VUID-vkCreateShadersEXT-pCreateInfos-08403\", device,\n                     loc.dot(Field::pCreateInfos, linked_stage).dot(Field::flags),\n                     \"contains VK_SHADER_CREATE_LINK_STAGE_BIT_EXT, but pCreateInfos[%\" PRIu32\n                     \"] stage is %s and does not have VK_SHADER_CREATE_LINK_STAGE_BIT_EXT.\",\n                     non_linked_task_mesh_stage, string_VkShaderStageFlagBits(pCreateInfos[non_linked_task_mesh_stage].stage));\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkShaderCreateInfoEXT-codeType-08873\", \"If codeType is VK_SHADER_CODE_TYPE_SPIRV_EXT, and stage is VK_SHADER_STAGE_TESSELLATION_EVALUATION_BIT, pCode must contain an OpExecutionMode instruction specifying the orientation of triangles generated by the tessellator\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (stage_state.entrypoint->execution_mode.tessellation_orientation == 0) {\n    skip |= LogError(\"VUID-VkShaderCreateInfoEXT-codeType-08873\", device, create_info_loc.dot(Field::stage),\n                     \"is VK_SHADER_STAGE_TESSELLATION_EVALUATION_BIT, but orientation is not specified.\");\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-vkCreateShadersEXT-pCreateInfos-08870\", \"If pCreateInfos contains elements with both VK_SHADER_STAGE_TESSELLATION_CONTROL_BIT and VK_SHADER_STAGE_TESSELLATION_EVALUATION_BIT, both elements' flags include VK_SHADER_CREATE_LINK_STAGE_BIT_EXT, both elements' codeType is VK_SHADER_CODE_TYPE_SPIRV_EXT, and the VK_SHADER_STAGE_TESSELLATION_CONTROL_BIT stage's pCode contains an OpExecutionMode instruction specifying the spacing of segments on the edges of tessellated primitives, it must match the segment spacing specified in the VK_SHADER_STAGE_TESSELLATION_EVALUATION_BIT stage\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (tesc_linked_spacing != 0 && tese_linked_spacing != 0 && tesc_linked_spacing != tese_linked_spacing) {\n    skip |= LogError(\"VUID-vkCreateShadersEXT-pCreateInfos-08870\", device, error_obj.location,\n                     \"The spacing specified in tessellation control shader (%s) does not match the spacing in \"\n                     \"tessellation evaluation shader (%s).\",\n                     string_SpvExecutionMode(tesc_linked_spacing), string_SpvExecutionMode(tese_linked_spacing));\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-vkCmdBindShadersEXT-pShaders-08478\", \"If pStages contains VK_SHADER_STAGE_MESH_BIT_EXT or VK_SHADER_STAGE_TASK_BIT_EXT, the VkCommandPool that commandBuffer was allocated from must support graphics operations\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if ((cb_state->command_pool->queue_flags & VK_QUEUE_GRAPHICS_BIT) == 0) {\n    const LogObjectList objlist(commandBuffer, cb_state->command_pool->Handle());\n    skip |= LogError(\"VUID-vkCmdBindShadersEXT-pShaders-08478\", objlist, stage_loc,\n                     \"is %s, but the command pool the command buffer %s was allocated from \"\n                     \"does not support graphics operations (%s).\",\n                     string_VkShaderStageFlagBits(stage), FormatHandle(commandBuffer).c_str(),\n                     string_VkQueueFlags(cb_state->command_pool->queue_flags).c_str());\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-vkCmdBindShadersEXT-pStages-08467\", \"pStages must not contain VK_SHADER_STAGE_SUBPASS_SHADING_BIT_HUAWEI\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (stage == VK_SHADER_STAGE_SUBPASS_SHADING_BIT_HUAWEI) {\n    skip |= LogError(\"VUID-vkCmdBindShadersEXT-pStages-08467\", commandBuffer, stage_loc, \"is %s.\",\n                     string_VkShaderStageFlagBits(stage));\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkGraphicsPipelineCreateInfo-renderPass-06038\", \"If renderPass is not VK_NULL_HANDLE and the pipeline is being created with fragment shader state the fragment shader must not read from any input attachment that is defined as VK_ATTACHMENT_UNUSED in subpass\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (!input_attachments) {\n    const LogObjectList objlist(module_state.handle(), rp_state->Handle());\n    skip |= LogError(\"VUID-VkGraphicsPipelineCreateInfo-renderPass-06038\", objlist, loc,\n                     \"SPIR-V consumes input attachment index %\" PRIu32 \" but pSubpasses[%\" PRIu32\n                     \"].pInputAttachments is NULL.\",\n                     input_attachment_index, subpass);\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-RuntimeSpirv-None-06343\", \"Group operations with subgroup scope must not be used if the shader stage is not in subgroupSupportedStages\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if ((supported_stages & stage) == 0) {\n    skip |= LogError(\"VUID-RuntimeSpirv-None-06343\", module_state.handle(), loc,\n                     \"%s is not supported in subgroupSupportedStages (%s).\", string_VkShaderStageFlagBits(stage),\n                     string_VkShaderStageFlags(supported_stages).c_str());\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-RuntimeSpirv-OpCooperativeMatrixMulAddKHR-10060\", \"For OpCooperativeMatrixMulAddKHR, the operands must match a supported VkCooperativeMatrixPropertiesKHR\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (r.scope != VK_SCOPE_SUBGROUP_KHR || a.scope != VK_SCOPE_SUBGROUP_KHR || b.scope != VK_SCOPE_SUBGROUP_KHR ||\n    skip |= LogError(\"VUID-RuntimeSpirv-OpCooperativeMatrixMulAddKHR-10060\", module_state.handle(), loc,\n                     \"SPIR-V (%s) has a scopes mismatch for OpCooperativeMatrixMulAddKHR (all need to be \"\n                     \"VK_SCOPE_SUBGROUP_KHR)\\n\"\n                     \"A: %s\\n\"\n                     \"B: %s\\n\"\n                     \"C: %s\\n\"\n                     \"Result: %s\\n\",\n                     string_VkShaderStageFlagBits(entrypoint.stage), string_VkScopeKHR(a.scope),\n                     string_VkScopeKHR(b.scope), string_VkScopeKHR(c.scope), string_VkScopeKHR(r.scope));\n"
        },
        {
            "role": "user",
            "content": "{\"VUID-RuntimeSpirv-OpCooperativeMatrixMulAddKHR-10060\", \"For OpCooperativeMatrixMulAddKHR, the operands must match a supported VkCooperativeMatrixPropertiesKHR\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "skip |= LogError(\"VUID-RuntimeSpirv-OpCooperativeMatrixMulAddKHR-10060\", module_state.handle(), loc,\n                 \"SPIR-V (%s) instruction\\n%s (%s)\\ndoesn't match a supported matrix \"\n                 \"VkCooperativeMatrixPropertiesKHR for C type\\n%s\",\n                 string_VkShaderStageFlagBits(entrypoint.stage), insn.Describe().c_str(),\n                 c.Describe().c_str(), print_properties().c_str());\n"
        },
        {
            "role": "user",
            "content": "{\"VUID-RuntimeSpirv-shaderFloat16VectorAtomics-09581\", \"shaderFloat16VectorAtomics, must be enabled for 16-bit floating-point, 2- and 4-component vector atomic operations to be supported\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (!valid_16_float_vector) {\n    skip |= LogError(\"VUID-RuntimeSpirv-shaderFloat16VectorAtomics-09581\", module_state.handle(), loc,\n                     \"SPIR-V is using 16-bit float vector atomics operations\\n%s\\nwith %s storage class, but \"\n                     \"shaderFloat16VectorAtomics was not enabled.\",\n                     atomic_def->Describe().c_str(), string_SpvStorageClass(atomic.storage_class));\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-RuntimeSpirv-None-06337\", \"shaderBufferFloat16Atomics, or shaderBufferFloat16AtomicAdd, or shaderBufferFloat16AtomicMinMax, or shaderSharedFloat16Atomics, or shaderSharedFloat16AtomicAdd, or shaderSharedFloat16AtomicMinMax must be enabled for 16-bit floating-point atomic operations\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if ((atomic.bit_width == 16) && (enabled_features.shaderBufferFloat16AtomicAdd == VK_FALSE)) {\n    skip |= LogError(\"VUID-RuntimeSpirv-None-06337\", module_state.handle(), loc,\n                     \"SPIR-V is using 16-bit float atomics for add operations\\n%s\\nwith \"\n                     \"StorageBuffer storage class, but shaderBufferFloat16AtomicAdd was not enabled.\",\n                     atomic_def->Describe().c_str());\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-RuntimeSpirv-None-06338\", \"shaderBufferFloat32Atomics, or shaderBufferFloat32AtomicAdd, or shaderSharedFloat32Atomics, or shaderSharedFloat32AtomicAdd, or shaderImageFloat32Atomics, or shaderImageFloat32AtomicAdd or shaderBufferFloat32AtomicMinMax, or shaderSharedFloat32AtomicMinMax, or shaderImageFloat32AtomicMinMax must be enabled for 32-bit floating-point atomic operations\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "skip |= LogError(\"VUID-RuntimeSpirv-None-06338\", module_state.handle(), loc,\n                 \"SPIR-V is using 32-bit float atomics for min/max operations\\n%s\\nwith \"\n                 \"StorageBuffer storage class, but shaderBufferFloat32AtomicMinMax was not enabled.\",\n                 atomic_def->Describe().c_str());\n"
        },
        {
            "role": "user",
            "content": "{\"VUID-RuntimeSpirv-None-06339\", \"shaderBufferFloat64Atomics, or shaderBufferFloat64AtomicAdd, or shaderSharedFloat64Atomics, or shaderSharedFloat64AtomicAdd, or shaderBufferFloat64AtomicMinMax, or shaderSharedFloat64AtomicMinMax, must be enabled for 64-bit floating-point atomic operations\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "skip |= LogError(\"VUID-RuntimeSpirv-None-06339\", module_state.handle(), loc,\n                 \"SPIR-V is using 64-bit float atomics for add operations\\n%s\\nwith \"\n                 \"StorageBuffer storage class, but shaderBufferFloat64AtomicAdd was not enabled.\",\n                 atomic_def->Describe().c_str());\n"
        },
        {
            "role": "user",
            "content": "{\"VUID-RuntimeSpirv-None-06285\", \"shaderSharedFloat32Atomics, or shaderSharedFloat32AtomicAdd, or shaderSharedFloat64Atomics, or shaderSharedFloat64AtomicAdd, or shaderSharedFloat16Atomics, or shaderSharedFloat16AtomicAdd, or shaderSharedFloat16AtomicMinMax, or shaderSharedFloat32AtomicMinMax, or shaderSharedFloat64AtomicMinMax, or shaderFloat16VectorAtomics, must be enabled for floating-point atomic operations to be supported on a Pointer with a Storage Class of Workgroup\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (valid_workgroup_float == false) {\n    skip |= LogError(\"VUID-RuntimeSpirv-None-06285\", module_state.handle(), loc,\n                     \"SPIR-V is using float atomics operations\\n%s\\nwith Workgroup storage class, but none of the \"\n                     \"required features were enabled.\",\n                     atomic_def->Describe().c_str());\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-RuntimeSpirv-shaderDenormPreserveFloat16-06296\", \"If shaderDenormPreserveFloat16 is VK_FALSE, then DenormPreserve for 16-bit floating-point type must not be used\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (has_denorm_preserve_width_16 && !phys_dev_props_core12.shaderDenormPreserveFloat16) {\n    skip |= LogError(\"VUID-RuntimeSpirv-shaderDenormPreserveFloat16-06296\", module_state.handle(), loc,\n                     \"SPIR-V requires DenormPreserve for bit width 16 but it is not enabled on the device.\");\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-RuntimeSpirv-shaderDenormFlushToZeroFloat64-06301\", \"If shaderDenormFlushToZeroFloat64 is VK_FALSE, then DenormFlushToZero for 64-bit floating-point type must not be used\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "skip |= LogError(\"VUID-RuntimeSpirv-shaderDenormFlushToZeroFloat32-06300\", module_state.handle(), loc,\n} else if (has_denorm_flush_to_zero_width_64 && !phys_dev_props_core12.shaderDenormFlushToZeroFloat64) {\nskip |= LogError(\"VUID-RuntimeSpirv-shaderDenormFlushToZeroFloat64-06301\", module_state.handle(), loc,\n                 \"SPIR-V requires DenormFlushToZero for bit width 64 but it is not enabled on the device.\");\n"
        },
        {
            "role": "user",
            "content": "{\"VUID-RuntimeSpirv-shaderRoundingModeRTZFloat32-06306\", \"If shaderRoundingModeRTZFloat32 is VK_FALSE, then RoundingModeRTZ for 32-bit floating-point type must not be used\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "skip |= LogError(\"VUID-RuntimeSpirv-shaderRoundingModeRTZFloat16-06305\", module_state.handle(), loc,\n} else if (has_rounding_mode_rtz_width_32 && !phys_dev_props_core12.shaderRoundingModeRTZFloat32) {\nskip |= LogError(\"VUID-RuntimeSpirv-shaderRoundingModeRTZFloat32-06306\", module_state.handle(), loc,\n                 \"SPIR-V requires RoundingModeRTZ for bit width 32 but it is not enabled on the device.\");\n"
        },
        {
            "role": "user",
            "content": "{\"VUID-RuntimeSpirv-shaderSignedZeroInfNanPreserveFloat16-09560\", \"If shaderSignedZeroInfNanPreserveFloat16 is VK_FALSE then any FPFastMathMode decoration on an instruction with result type or any operand type that includes a 16-bit float must include the NSZ, NotInf, and NotNaN flags\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (float_16 && !phys_dev_props_core12.shaderSignedZeroInfNanPreserveFloat16) {\n    skip |= LogError(\"VUID-RuntimeSpirv-shaderSignedZeroInfNanPreserveFloat16-09560\", module_state.handle(), loc,\n                     \"shaderSignedZeroInfNanPreserveFloat16 is false, FPFastMathMode has modes 0x%\" PRIx32\n                     \" but the target instruction\\n%s\\n is using 16-bit floats.\",\n                     modes, target_insn->Describe().c_str());\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-RuntimeSpirv-SubgroupUniformControlFlowKHR-06379\", \"The Execution Mode SubgroupUniformControlFlowKHR must not be applied to an entry point unless shaderSubgroupUniformControlFlow is enabled, the corresponding shader stage bit is set in subgroupSupportedStages, and the entry point does not execute any invocation repack instructions\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "skip |= LogError(\"VUID-RuntimeSpirv-SubgroupUniformControlFlowKHR-06379\", module_state.handle(), loc,\n                 \"SPIR-V uses ExecutionModeSubgroupUniformControlFlowKHR, but %s.\", msg.str().c_str());\n"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkGraphicsPipelineCreateInfo-primitiveFragmentShadingRateWithMultipleViewports-04505\", \"If the pipeline requires pre-rasterization shader state and the primitiveFragmentShadingRateWithMultipleViewports limit is not supported, and entry points specified in pStages write to the ViewportMaskNV built-in, they must not also write to the PrimitiveShadingRateKHR built-in\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (entrypoint.written_builtin_primitive_shading_rate_khr && entrypoint.written_builtin_viewport_mask_nv) {\n    skip |= LogError(\"VUID-VkGraphicsPipelineCreateInfo-primitiveFragmentShadingRateWithMultipleViewports-04505\",\n                     module_state.handle(), loc,\n                     \"SPIR-V (%s) statically writes to both PrimitiveShadingRateKHR and \"\n                     \"ViewportMaskNV built-ins, \"\n                     \"but the primitiveFragmentShadingRateWithMultipleViewports limit is not supported.\",\n                     string_VkShaderStageFlagBits(stage));\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-RuntimeSpirv-maxTaskSharedMemorySize-08759\", \"The sum of size in bytes for variables and padding in the Workgroup Storage Class in the TaskEXT Execution Model must be less than or equal to maxTaskSharedMemorySize\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (total_workgroup_shared_memory > phys_dev_ext_props.mesh_shader_props_ext.maxTaskSharedMemorySize) {\n    skip |= LogError(\"VUID-RuntimeSpirv-maxTaskSharedMemorySize-08759\", module_state.handle(), loc,\n                     \"SPIR-V uses %\" PRIu32\n                     \" bytes of shared memory, which is more than maxTaskSharedMemorySize (%\" PRIu32 \").\",\n                     total_workgroup_shared_memory, phys_dev_ext_props.mesh_shader_props_ext.maxTaskSharedMemorySize);\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-RuntimeSpirv-storagePushConstant16-06333\", \"If storagePushConstant16 is VK_FALSE, then objects containing 16-bit integer or 16-bit floating-point elements must not have Storage Class of PushConstant\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (!enabled_features.storagePushConstant16 && storage_class == spv::StorageClassPushConstant) {\n    skip |= LogError(\"VUID-RuntimeSpirv-storagePushConstant16-06333\", module_state.handle(), loc,\n                     \"SPIR-V contains an 16-bit \"\n                     \"OpVariable with PushConstant Storage Class, but storagePushConstant16 was not enabled.\\n%s\\n\",\n                     insn->Describe().c_str());\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkGraphicsPipelineCreateInfo-pStages-02318\", \"If the pipeline requires pre-rasterization shader state, and any shader stage in pStages specifies Xfb execution mode it must be the last pre-rasterization shader stage\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (pipeline.pre_raster_state && (entrypoint.stage != pipeline.pre_raster_state->last_stage)) {\n    skip |= LogError(\"VUID-VkGraphicsPipelineCreateInfo-pStages-02318\", module_state.handle(), loc,\n                     \"SPIR-V has OpExecutionMode of Xfb in %s, but %s is the last last pre-rasterization shader stage.\",\n                     string_VkShaderStageFlagBits(entrypoint.stage),\n                     string_VkShaderStageFlagBits(pipeline.pre_raster_state->last_stage));\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-RuntimeSpirv-OpImage-06377\", \"If an OpImage*Gather operation has an image operand of Offset, ConstOffset, or ConstOffsets the offset value must be less than or equal to maxTexelGatherOffset\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "skip |= LogError(\"VUID-RuntimeSpirv-OpImage-06377\", module_state.handle(), loc,\n                 \"SPIR-V uses\\n%s\\nwith offset (%\" PRIu32\n                 \") greater than VkPhysicalDeviceLimits::maxTexelGatherOffset (%\" PRIu32 \").\",\n                 insn.Describe().c_str(), offset, phys_dev_props.limits.maxTexelGatherOffset);\n"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkGraphicsPipelineCreateInfo-renderPass-08710\", \"If the pipeline requires fragment shader state and renderPass is not VK_NULL_HANDLE, fragment shaders in pStages must not include any of the TileImageColorReadAccessEXT, TileImageDepthReadAccessEXT, or TileImageStencilReadAccessEXT capabilities\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (rp != VK_NULL_HANDLE) {\n    skip |= LogError(\"VUID-VkGraphicsPipelineCreateInfo-renderPass-08710\", module_state.handle(), loc,\n                     \"SPIR-V (Fragment stage) is using capabilities (%s), but renderpass (%s) is not VK_NULL_HANDLE.\",\n                     GetShaderTileImageCapabilitiesString(module_state).c_str(), FormatHandle(rp).c_str());\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-RuntimeSpirv-shaderTileImageColorReadAccess-08728\", \"If shaderTileImageColorReadAccess is not enabled, OpColorAttachmentReadEXT operation must not be used\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (module_state.static_data_.has_shader_tile_image_color_read && !enabled_features.shaderTileImageColorReadAccess) {\n    skip |= LogError(\"VUID-RuntimeSpirv-shaderTileImageColorReadAccess-08728\", module_state.handle(), loc,\n                     \"shaderTileImageColorReadAccess was not enabled\");\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkShaderModuleCreateInfo-pCode-07912\", \"If the VK_NV_glsl_shader extension is not enabled, pCode must be a pointer to SPIR-V code\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (!IsExtEnabled(device_extensions.vk_nv_glsl_shader)) {\n    skip |= LogError(\"VUID-VkShaderModuleCreateInfo-pCode-07912\", device, create_info_loc.dot(Field::pCode),\n                     \"doesn't point to a SPIR-V module (The first dword is not the SPIR-V MagicNumber 0x07230203).\");\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkPipelineShaderStageCreateInfo-pNext-02756\", \"If a VkPipelineShaderStageRequiredSubgroupSizeCreateInfo structure is included in the pNext chain and stage is VK_SHADER_STAGE_COMPUTE_BIT, VK_SHADER_STAGE_MESH_BIT_EXT, or VK_SHADER_STAGE_TASK_BIT_EXT, the local workgroup size of the shader must be less than or equal to the product of VkPipelineShaderStageRequiredSubgroupSizeCreateInfo::requiredSubgroupSize and maxComputeWorkgroupSubgroups\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if ((invocations > required_subgroup_size * phys_dev_ext_props.subgroup_size_control_props.maxComputeWorkgroupSubgroups)) {\n    skip |= LogError(\"VUID-VkPipelineShaderStageCreateInfo-pNext-02756\", module_state.handle(), loc,\n                     \"SPIR-V Local workgroup size (%\" PRIu32 \", %\" PRIu32 \", %\" PRIu32\n                     \") is greater than requiredSubgroupSize (%\" PRIu32 \") * maxComputeWorkgroupSubgroups (%\" PRIu32 \").\",\n                     local_size_x, local_size_y, local_size_z, required_subgroup_size,\n                     phys_dev_ext_props.subgroup_size_control_props.maxComputeWorkgroupSubgroups);\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-RuntimeSpirv-y-06430\", \"In compute shaders using the GLCompute Execution Model the y size in LocalSize or LocalSizeId must be less than or equal to VkPhysicalDeviceLimits::maxComputeWorkGroupSize[1]\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (local_size_y > phys_dev_props.limits.maxComputeWorkGroupSize[1]) {\n    skip |= LogError(\"VUID-RuntimeSpirv-y-06430\", module_state.handle(), loc,\n                     \"SPIR-V LocalSize Y (%\" PRIu32 \") exceeds device limit maxComputeWorkGroupSize[1] (%\" PRIu32 \").\",\n                     local_size_y, phys_dev_props.limits.maxComputeWorkGroupSize[1]);\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkSubmitInfo-pWaitSemaphores-03239\", \"If any element of pWaitSemaphores or pSignalSemaphores was created with a VkSemaphoreType of VK_SEMAPHORE_TYPE_TIMELINE, then the pNext chain must include a VkTimelineSemaphoreSubmitInfo structure\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (timeline_semaphore_submit_info == nullptr) {\n    skip |= LogError(\"VUID-VkSubmitInfo-pWaitSemaphores-03239\", semaphore, wait_semaphore_loc,\n                     \"(%s) is a timeline semaphore, but VkSubmitInfo does \"\n                     \"not include an instance of VkTimelineSemaphoreSubmitInfo.\",\n                     FormatHandle(semaphore).c_str());\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkExportFenceCreateInfo-handleTypes-01446\", \"The bits in handleTypes must be supported and compatible, as reported by VkExternalFenceProperties\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if ((external_properties.externalFenceFeatures & VK_EXTERNAL_FENCE_FEATURE_EXPORTABLE_BIT) == 0) {\n    skip |= LogError(\"VUID-VkExportFenceCreateInfo-handleTypes-01446\", device,\n                     create_info_loc.pNext(Struct::VkExportFenceCreateInfo, Field::handleTypes),\n                     \"(%s) does not support VK_EXTERNAL_FENCE_FEATURE_EXPORTABLE_BIT.\",\n                     string_VkExternalFenceHandleTypeFlagBits(flag));\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkSemaphoreWaitInfo-pSemaphores-03256\", \"All of the elements of pSemaphores must reference a semaphore that was created with a VkSemaphoreType of VK_SEMAPHORE_TYPE_TIMELINE\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (semaphore_state->type != VK_SEMAPHORE_TYPE_TIMELINE) {\n    skip |= LogError(\"VUID-VkSemaphoreWaitInfo-pSemaphores-03256\", pWaitInfo->pSemaphores[i],\n                     error_obj.location.dot(Field::pWaitInfo).dot(Field::pSemaphores, i), \"%s was created with %s\",\n                     FormatHandle(pWaitInfo->pSemaphores[i]).c_str(), string_VkSemaphoreType(semaphore_state->type));\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-vkCmdResetEvent2-synchronization2-03829\", \"The synchronization2 feature must be enabled\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (!enabled_features.synchronization2) {\n    skip |= LogError(\"VUID-vkCmdResetEvent2-synchronization2-03829\", commandBuffer, error_obj.location,\n                     \"the synchronization2 feature was not enabled.\");\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-vkCmdPipelineBarrier2-bufferMemoryBarrierCount-01178\", \"If vkCmdPipelineBarrier2 is called within a render pass instance using a VkRenderPass object, it must not include any buffer memory barriers\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (0 != dep_info.bufferMemoryBarrierCount) {\n    skip |= LogError(\"VUID-vkCmdPipelineBarrier2-bufferMemoryBarrierCount-01178\", state.rp_handle,\n                     outer_loc.dot(Field::bufferMemoryBarrierCount), \"is non-zero (%\" PRIu32 \") for subpass %\" PRIu32 \" of %s.\",\n                     dep_info.bufferMemoryBarrierCount, state.active_subpass, FormatHandle(state.rp_handle).c_str());\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-vkCmdWaitEvents-srcStageMask-07308\", \"If vkCmdWaitEvents is being called inside a render pass instance, srcStageMask must not include VK_PIPELINE_STAGE_HOST_BIT\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (cb_state->activeRenderPass && ((srcStageMask & VK_PIPELINE_STAGE_HOST_BIT) != 0)) {\n    skip |= LogError(\"VUID-vkCmdWaitEvents-srcStageMask-07308\", commandBuffer, error_obj.location.dot(Field::srcStageMask),\n                     \"is %s.\", sync_utils::StringPipelineStageFlags(srcStageMask).c_str());\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-vkSetEvent-event-09543\", \"event must not be waited on by a command buffer in the pending state\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (event_state->write_in_use) {\n    skip |= LogError(\"VUID-vkSetEvent-event-09543\", event, error_obj.location.dot(Field::event),\n                     \"(%s) that is already in use by a command buffer.\", FormatHandle(event).c_str());\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkSemaphoreSignalInfo-value-03258\", \"value must have a value greater than the current value of the semaphore\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (current_payload >= pSignalInfo->value) {\n    skip |= LogError(\"VUID-VkSemaphoreSignalInfo-value-03258\", pSignalInfo->semaphore, signal_loc.dot(Field::value),\n                     \"(%\" PRIu64 \") must be greater than current semaphore %s value (%\" PRIu64 \").\", pSignalInfo->value,\n                     FormatHandle(pSignalInfo->semaphore).c_str(), current_payload);\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkVideoInlineQueryInfoKHR-queryPool-08372\", \"If queryPool is not VK_NULL_HANDLE, then firstQuery must be less than the number of queries in queryPool\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (query_info.firstQuery >= query_pool_state.create_info.queryCount) {\n    skip |= LogError(\"VUID-VkVideoInlineQueryInfoKHR-queryPool-08372\", query_pool_state.Handle(), loc.dot(Field::firstQuery),\n                     \"(%u) is greater than or equal to the number of queries (%u) in %s.\", query_info.firstQuery,\n                     query_pool_state.create_info.queryCount, FormatHandle(query_pool_state).c_str());\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkVideoEncodeRateControlInfoKHR-layerCount-08358\", \"If layerCount is not zero, then initialVirtualBufferSizeInMs must be less than virtualBufferSizeInMs\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (rc_info.initialVirtualBufferSizeInMs >= rc_info.virtualBufferSizeInMs) {\n    skip |= LogError(\"VUID-VkVideoEncodeRateControlInfoKHR-layerCount-08358\", cmdbuf,\n                     rc_info_loc.dot(Field::initialVirtualBufferSizeInMs),\n                     \"(%u) must be less than virtualBufferSizeInMs (%u) if %s (%u) is not zero.\",\n                     rc_info.initialVirtualBufferSizeInMs, rc_info.virtualBufferSizeInMs,\n                     rc_info_loc.dot(Field::layerCount).Fields().c_str(), rc_info.layerCount);\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkVideoEncodeH264RateControlInfoKHR-idrPeriod-08284\", \"If idrPeriod is not 0, then it must be greater than or equal to gopFrameCount\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (rc_info_h264->idrPeriod != 0 && rc_info_h264->idrPeriod < rc_info_h264->gopFrameCount) {\n    skip |= LogError(\"VUID-VkVideoEncodeH264RateControlInfoKHR-idrPeriod-08284\", cmdbuf, rc_info_h264_loc.dot(Field::idrPeriod),\n                     \"(%u) is not zero and the specified IDR period smaller than the GOP size specified in %s (%u).\",\n                     rc_info_h264->idrPeriod, rc_info_h264_loc.dot(Field::gopFrameCount).Fields().c_str(),\n                     rc_info_h264->gopFrameCount);\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkVideoEncodeH265RateControlInfoKHR-idrPeriod-08295\", \"If idrPeriod is not 0, then it must be greater than or equal to gopFrameCount\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (rc_info_h265->idrPeriod != 0 && rc_info_h265->idrPeriod < rc_info_h265->gopFrameCount) {\n    skip |= LogError(\"VUID-VkVideoEncodeH265RateControlInfoKHR-idrPeriod-08295\", cmdbuf, rc_info_h265_loc.dot(Field::idrPeriod),\n                     \"(%u) is not zero and the specified IDR period smaller than the GOP size specified in %s (%u).\",\n                     rc_info_h265->idrPeriod, rc_info_h265_loc.dot(Field::gopFrameCount).Fields().c_str(),\n                     rc_info_h265->gopFrameCount);\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkVideoProfileInfoKHR-lumaBitDepth-07014\", \"lumaBitDepth must have a single bit set\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (GetBitSetCount(profile->lumaBitDepth) != 1) {\n    skip |= LogError(\"VUID-VkVideoProfileInfoKHR-lumaBitDepth-07014\", object, loc.dot(Field::lumaBitDepth),\n                     \"must have a single bit set.\");\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkVideoProfileInfoKHR-videoCodecOperation-07181\", \"If videoCodecOperation is VK_VIDEO_CODEC_OPERATION_ENCODE_H264_BIT_KHR, then the pNext chain must include a VkVideoEncodeH264ProfileInfoKHR structure\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (encode_h264 == nullptr) {\n    skip |= LogError(\"VUID-VkVideoProfileInfoKHR-videoCodecOperation-07181\", object, loc.dot(Field::pNext),\n                     profile_pnext_msg, \"VkVideoEncodeH264ProfileInfoKHR\");\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkVideoDecodeH264SessionParametersAddInfoKHR-None-04826\", \"The pair constructed from the seq_parameter_set_id and pic_parameter_set_id members of each StdVideoH264PictureParameterSet structure specified in the elements of pStdPPSs must be unique within pStdPPSs\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (!keys.emplace(key).second) {\n    skip |= LogError(\"VUID-VkVideoDecodeH264SessionParametersAddInfoKHR-None-04826\", device, loc.dot(Field::pStdPPSs),\n                     \"keys are not unique.\");\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkVideoSessionParametersCreateInfoKHR-videoSession-07208\", \"If videoSession was created with the video codec operation VK_VIDEO_CODEC_OPERATION_DECODE_H265_BIT_KHR, then the number of elements of spsAddList must be less than or equal to the maxStdSPSCount specified in the VkVideoDecodeH265SessionParametersCreateInfoKHR structure included in the pNext chain\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (keys.size() > create_info->maxStdSPSCount) {\n    skip |= LogError(\"VUID-VkVideoSessionParametersCreateInfoKHR-videoSession-07208\", device, loc.function,\n                     \"number of H.265 SPS entries to add (%zu) is larger than \"\n                     \"VkVideoDecodeH265SessionParametersCreateInfoKHR::maxStdSPSCount (%u).\",\n                     keys.size(), create_info->maxStdSPSCount);\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkVideoEncodeH264SessionParametersAddInfoKHR-None-04838\", \"The pair constructed from the seq_parameter_set_id and pic_parameter_set_id members of each StdVideoH264PictureParameterSet structure specified in the elements of pStdPPSs must be unique within pStdPPSs\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (!keys.emplace(key).second) {\n    skip |= LogError(\"VUID-VkVideoEncodeH264SessionParametersAddInfoKHR-None-04838\", device, loc.dot(Field::pStdPPSs),\n                     \"keys are not unique.\");\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkVideoSessionParametersCreateInfoKHR-videoSession-04842\", \"If videoSession was created with the video codec operation VK_VIDEO_CODEC_OPERATION_ENCODE_H265_BIT_KHR, then the number of elements of spsAddList must be less than or equal to the maxStdSPSCount specified in the VkVideoEncodeH265SessionParametersCreateInfoKHR structure included in the pNext chain\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (keys.size() > create_info->maxStdSPSCount) {\n    skip |= LogError(\"VUID-VkVideoSessionParametersCreateInfoKHR-videoSession-04842\", device, loc.function,\n                     \"number of H.265 SPS entries to add (%zu) is larger than \"\n                     \"VkVideoEncodeH265SessionParametersCreateInfoKHR::maxStdSPSCount (%u).\",\n                     keys.size(), create_info->maxStdSPSCount);\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-vkCmdDecodeVideoKHR-pDecodeInfo-07141\", \"If pDecodeInfo->pSetupReferenceSlot is not NULL and none of the following is true: VkVideoDecodeCapabilitiesKHR::flags includes VK_VIDEO_DECODE_CAPABILITY_DPB_AND_OUTPUT_DISTINCT_BIT_KHR, as returned by vkGetPhysicalDeviceVideoCapabilitiesKHR for the video profile the bound video session was created with the bound video session was created with the video codec operation VK_VIDEO_CODEC_OPERATION_DECODE_AV1_BIT_KHR and VkVideoDecodeAV1ProfileInfoKHR::filmGrainSupport set to VK_TRUE, and film grain is enabled for the decoded picture then the video picture resources specified by pDecodeInfo->dstPictureResource and pDecodeInfo->pSetupReferenceSlot->pPictureResource must match\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "skip |= LogError(\"VUID-vkCmdDecodeVideoKHR-pDecodeInfo-07141\", objlist, cmd_loc,\n                 \"the video profile %s was created with does not support \"\n                 \"VK_VIDEO_DECODE_CAPABILITY_DPB_AND_OUTPUT_DISTINCT_BIT_KHR but \"\n                 \"pDecodeInfo->dstPictureResource and pSetupReferenceSlot->pPictureResource \"\n                 \"do not match.\",\n                 FormatHandle(vs_state).c_str());\n"
        },
        {
            "role": "user",
            "content": "{\"VUID-vkCmdDecodeVideoKHR-pNext-07152\", \"If the bound video session was created with the video codec operation VK_VIDEO_CODEC_OPERATION_DECODE_H264_BIT_KHR, then the pNext chain of pDecodeInfo must include a VkVideoDecodeH264PictureInfoKHR structure\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "skip |= LogError(\"VUID-vkCmdDecodeVideoKHR-pNext-07152\", cb_state.Handle(), loc.dot(Field::pNext), pnext_msg,\n                 \"VkVideoDecodeH264PictureInfoKHR\");\n"
        },
        {
            "role": "user",
            "content": "{\"VUID-vkCmdDecodeVideoKHR-pDecodeInfo-07156\", \"If the bound video session was created with the video codec operation VK_VIDEO_CODEC_OPERATION_DECODE_H264_BIT_KHR and pDecodeInfo->pSetupReferenceSlot is not NULL, then the pNext chain of pDecodeInfo->pSetupReferenceSlot must include a VkVideoDecodeH264DpbSlotInfoKHR structure\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "skip |= LogError(\"VUID-vkCmdDecodeVideoKHR-pDecodeInfo-07156\", cb_state.Handle(),\n                 loc.dot(Field::pSetupReferenceSlot).dot(Field::pNext), pnext_msg, \"VkVideoDecodeH264DpbSlotInfoKHR\");\n"
        },
        {
            "role": "user",
            "content": "{\"VUID-vkCmdDecodeVideoKHR-StdVideoH265SequenceParameterSet-07161\", \"If the bound video session was created with the video codec operation VK_VIDEO_CODEC_OPERATION_DECODE_H265_BIT_KHR, then the bound video session parameters object must contain a StdVideoH265SequenceParameterSet entry with sps_video_parameter_set_id and sps_seq_parameter_set_id matching StdVideoDecodeH265PictureInfo::sps_video_parameter_set_id and StdVideoDecodeH265PictureInfo::pps_seq_parameter_set_id, respectively, that are provided in the pStdPictureInfo member of the VkVideoDecodeH265PictureInfoKHR structure included in the pNext chain of pDecodeInfo\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (session_params.GetH265SPS(std_picture_info->sps_video_parameter_set_id, std_picture_info->pps_seq_parameter_set_id) ==\n    const LogObjectList objlist(cb_state.Handle(), vsp_state.Handle());\n    skip |= LogError(\"VUID-vkCmdDecodeVideoKHR-StdVideoH265SequenceParameterSet-07161\", objlist, loc.function,\n                     \"no H.265 SPS with sps_video_parameter_set_id = %u \"\n                     \"and pps_seq_parameter_set_id = %u exists in the bound video session \"\n                     \"parameters object %s.\",\n                     std_picture_info->sps_video_parameter_set_id, std_picture_info->pps_seq_parameter_set_id,\n                     FormatHandle(vsp_state).c_str());\n"
        },
        {
            "role": "user",
            "content": "{\"VUID-vkCmdDecodeVideoKHR-pDecodeInfo-09254\", \"If the bound video session was created with the video codec operation VK_VIDEO_CODEC_OPERATION_DECODE_AV1_BIT_KHR and pDecodeInfo->pSetupReferenceSlot is not NULL, then the pNext chain of pDecodeInfo->pSetupReferenceSlot must include a VkVideoDecodeAV1DpbSlotInfoKHR structure\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (!dpb_slot_info) {\n    skip |= LogError(\"VUID-vkCmdDecodeVideoKHR-pDecodeInfo-09254\", cb_state.Handle(),\n                     loc.dot(Field::pSetupReferenceSlot).dot(Field::pNext), pnext_msg, \"VkVideoDecodeAV1DpbSlotInfoKHR\");\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-vkCmdDecodeVideoKHR-slotIndex-09263\", \"If the bound video session was created with the video codec operation VK_VIDEO_CODEC_OPERATION_DECODE_AV1_BIT_KHR, then the slotIndex member of each element of pDecodeInfo->pReferenceSlots must equal one of the elements of the referenceNameSlotIndices array member of the VkVideoDecodeAV1PictureInfoKHR structure included in the pNext chain of pDecodeInfo\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (reference_name_slot_indices.find(decode_info.pReferenceSlots[i].slotIndex) == reference_name_slot_indices.end()) {\n    skip |= LogError(\"VUID-vkCmdDecodeVideoKHR-slotIndex-09263\", cb_state.Handle(),\n                     loc.dot(Field::pReferenceSlots, i),\n                     \"(%d) does not match any of the elements of \"\n                     \"VkVideoDecodeAV1PictureInfoKHR::referenceNameSlotIndices.\",\n                     decode_info.pReferenceSlots[i].slotIndex);\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-vkCmdEncodeVideoKHR-maxPPictureL0ReferenceCount-08340\", \"If the bound video session was created with the video codec operation VK_VIDEO_CODEC_OPERATION_ENCODE_H264_BIT_KHR and VkVideoEncodeH264CapabilitiesKHR::maxPPictureL0ReferenceCount is zero, as returned by vkGetPhysicalDeviceVideoCapabilitiesKHR for the video profile the bound video session was created with, then h264PictureType and each element of h264L0PictureTypes and h264L1PictureTypes must not be STD_VIDEO_H264_PICTURE_TYPE_P\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (profile_caps.encode_h264.maxPPictureL0ReferenceCount == 0 && pic_type == STD_VIDEO_H264_PICTURE_TYPE_P) {\n    skip |= LogError(\"VUID-vkCmdEncodeVideoKHR-maxPPictureL0ReferenceCount-08340\", vs_state.Handle(), loc,\n                     \"%s is STD_VIDEO_H264_PICTURE_TYPE_P but P pictures \"\n                     \"are not supported by the H.264 encode profile %s was created with.\",\n                     where, FormatHandle(vs_state).c_str());\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-vkCmdEncodeVideoKHR-StdVideoH264PictureParameterSet-08227\", \"If the bound video session was created with the video codec operation VK_VIDEO_CODEC_OPERATION_ENCODE_H264_BIT_KHR, then the bound video session parameters object must contain a StdVideoH264PictureParameterSet entry with seq_parameter_set_id and pic_parameter_set_id matching StdVideoEncodeH264PictureInfo::seq_parameter_set_id and StdVideoEncodeH264PictureInfo::pic_parameter_set_id, respectively, that are provided in the pStdPictureInfo member of the VkVideoEncodeH264PictureInfoKHR structure included in the pNext chain of pEncodeInfo\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (std_pps == nullptr) {\n    const LogObjectList objlist(cb_state.Handle(), vsp_state.Handle());\n    skip |= LogError(\"VUID-vkCmdEncodeVideoKHR-StdVideoH264PictureParameterSet-08227\", objlist, loc.function,\n                     \"no H.264 PPS with seq_parameter_set_id = %u \"\n                     \"and pic_parameter_set_id = %u exists in the bound video session parameters object %s.\",\n                     std_picture_info->seq_parameter_set_id, std_picture_info->pic_parameter_set_id,\n                     FormatHandle(vsp_state).c_str());\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkVideoEncodeH264PictureInfoKHR-flags-08314\", \"If VkVideoEncodeH264CapabilitiesKHR::flags, as returned by vkGetPhysicalDeviceVideoCapabilitiesKHR for the used video profile, does not include VK_VIDEO_ENCODE_H264_CAPABILITY_PREDICTION_WEIGHT_TABLE_GENERATED_BIT_KHR and the slice corresponding to any element of pNaluSliceEntries uses explicit weighted sample prediction, then VkVideoEncodeH264NaluSliceInfoKHR::pStdSliceHeader->pWeightTable must not be NULL for that element of pNaluSliceEntries\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (std_slice_header->pWeightTable == nullptr && weighted_pred_error_msg != nullptr) {\n    const LogObjectList objlist(cb_state.Handle(), vs_state.Handle());\n    skip |= LogError(\"VUID-VkVideoEncodeH264PictureInfoKHR-flags-08314\", objlist, loc.function,\n                     \"%s, and pWeightTable is NULL in %s but \"\n                     \"VK_VIDEO_ENCODE_H264_CAPABILITY_PREDICTION_WEIGHT_TABLE_GENERATED_BIT_KHR \"\n                     \"is not supported by the H.264 encode profile %s was created with.\",\n                     weighted_pred_error_msg, slice_info_loc.dot(Field::pStdSliceHeader).Fields().c_str(),\n                     FormatHandle(vs_state).c_str());\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-vkCmdEncodeVideoKHR-pNext-08339\", \"If the bound video session was created with the video codec operation VK_VIDEO_CODEC_OPERATION_ENCODE_H264_BIT_KHR, the pNext chain of pEncodeInfo includes a VkVideoEncodeH264PictureInfoKHR structure, and VkVideoEncodeH264PictureInfoKHR::pStdPictureInfo->pRefLists is not NULL, then each element of the RefPicList0 and RefPicList1 array members of the StdVideoEncodeH264ReferenceListsInfo structure pointed to by VkVideoEncodeH264PictureInfoKHR::pStdPictureInfo->pRefLists must either be STD_VIDEO_H264_NO_REFERENCE_PICTURE or must equal the slotIndex member of one of the elements of pEncodeInfo->pReferenceSlots\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "skip |= LogError(\"VUID-vkCmdEncodeVideoKHR-pNext-08339\", cb_state.Handle(), loc.function,\n                 \"%s->pRefLists->RefPicList1[%u] (%u) does not match \"\n                 \"the slotIndex member of any element of pEncodeInfo->pReferenceSlots.\",\n                 loc.pNext(Struct::VkVideoEncodeH264PictureInfoKHR, Field::pStdPictureInfo).Fields().c_str(), i,\n                 ref_list_entry);\n"
        },
        {
            "role": "user",
            "content": "{\"VUID-vkCmdEncodeVideoKHR-pNext-08225\", \"If the bound video session was created with the video codec operation VK_VIDEO_CODEC_OPERATION_ENCODE_H264_BIT_KHR, then the pNext chain of pEncodeInfo must include a VkVideoEncodeH264PictureInfoKHR structure\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "skip |= LogError(\"VUID-vkCmdEncodeVideoKHR-pNext-08225\", cb_state.Handle(), loc.dot(Field::pNext), pnext_msg,\n                 \"VkVideoEncodeH264PictureInfoKHR\");\n"
        },
        {
            "role": "user",
            "content": "{\"VUID-vkCmdEncodeVideoKHR-StdVideoH265VideoParameterSet-08231\", \"If the bound video session was created with the video codec operation VK_VIDEO_CODEC_OPERATION_ENCODE_H265_BIT_KHR, then the bound video session parameters object must contain a StdVideoH265VideoParameterSet entry with vps_video_parameter_set_id matching StdVideoEncodeH265PictureInfo::sps_video_parameter_set_id that is provided in the pStdPictureInfo member of the VkVideoEncodeH265PictureInfoKHR structure included in the pNext chain of pEncodeInfo\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (std_vps == nullptr) {\n    const LogObjectList objlist(cb_state.Handle(), vsp_state.Handle());\n    skip |= LogError(\"VUID-vkCmdEncodeVideoKHR-StdVideoH265VideoParameterSet-08231\", objlist, loc.function,\n                     \"no H.265 VPS with sps_video_parameter_set_id = %u \"\n                     \"exists in the bound video session parameters object %s.\",\n                     std_picture_info->sps_video_parameter_set_id, FormatHandle(vsp_state).c_str());\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-vkCmdEncodeVideoKHR-naluSliceSegmentEntryCount-08313\", \"If the bound video session was created with the video codec operation VK_VIDEO_CODEC_OPERATION_ENCODE_H265_BIT_KHR and VkVideoEncodeH265CapabilitiesKHR::flags does not include VK_VIDEO_ENCODE_H265_CAPABILITY_ROW_UNALIGNED_SLICE_SEGMENT_BIT_KHR, as returned by vkGetPhysicalDeviceVideoCapabilitiesKHR for the video profile the bound video session was created with, then the naluSliceSegmentEntryCount member of the VkVideoEncodeH265PictureInfoKHR structure included in the pNext chain of pEncodeInfo must be less than or equal to minCodingBlockExtent.height\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (picture_info->naluSliceSegmentEntryCount > min_coding_block_extent.height) {\n    const LogObjectList objlist(cb_state.Handle(), vs_state.Handle());\n    skip |= LogError(\"VUID-vkCmdEncodeVideoKHR-naluSliceSegmentEntryCount-08313\", objlist, slice_seg_count_loc,\n                     \"(%u) is greater than the number of CTB rows (minCodingBlockExtent.height = %u) that can \"\n                     \"be coded for the encode input picture specified in pEncodeInfo->srcPictureResource \"\n                     \"(codedExtent = {%s}) assuming the maximum CTB size (%s) supported by the \"\n                     \"H.265 encode profile %s was created with.\",\n                     picture_info->naluSliceSegmentEntryCount, min_coding_block_extent.height,\n                     string_VkExtent2D(encode_info.srcPictureResource.codedExtent).c_str(),\n                     string_VkExtent2D(max_coding_block_size).c_str(), FormatHandle(vs_state).c_str());\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-vkCmdEncodeVideoKHR-flags-08347\", \"If the bound video session was created with the video codec operation VK_VIDEO_CODEC_OPERATION_ENCODE_H265_BIT_KHR and VkVideoEncodeH265CapabilitiesKHR::flags does not include VK_VIDEO_ENCODE_H265_CAPABILITY_B_FRAME_IN_L0_LIST_BIT_KHR, as returned by vkGetPhysicalDeviceVideoCapabilitiesKHR for the video profile the bound video session was created with, then each element of h265L0PictureTypes must not be STD_VIDEO_H264_PICTURE_TYPE_B\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (std_reference_info->pic_type == STD_VIDEO_H265_PICTURE_TYPE_B &&\n    (profile_caps.encode_h265.flags & VK_VIDEO_ENCODE_H265_CAPABILITY_B_FRAME_IN_L0_LIST_BIT_KHR) == 0) {\n    const LogObjectList objlist(cb_state.Handle(), vs_state.Handle());\n    skip |= LogError(\"VUID-vkCmdEncodeVideoKHR-flags-08347\", objlist, loc.function,\n                     \"pic_type for L0 reference is \"\n                     \"STD_VIDEO_H265_PICTURE_TYPE_B but B pictures are not supported in the \"\n                     \"L0 reference list by the H.265 encode profile %s was created with.\",\n                     FormatHandle(vs_state).c_str());\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-vkCmdEncodeVideoKHR-pNext-08354\", \"If the bound video session was created with the video codec operation VK_VIDEO_CODEC_OPERATION_ENCODE_H265_BIT_KHR, the pNext chain of pEncodeInfo includes a VkVideoEncodeH265PictureInfoKHR structure, and pEncodeInfo->referenceSlotCount is greater than zero, then VkVideoEncodeH265PictureInfoKHR::pStdPictureInfo->pRefLists must not be NULL\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "skip |= LogError(\"VUID-vkCmdEncodeVideoKHR-pNext-08354\", cb_state.Handle(), loc.function,\n                 \"%s->pRefLists is NULL but pEncodeInfo->referenceSlotCount (%u) is not zero.\",\n                 loc.pNext(Struct::VkVideoEncodeH265PictureInfoKHR, Field::pStdPictureInfo).Fields().c_str(),\n                 encode_info.referenceSlotCount);\n"
        },
        {
            "role": "user",
            "content": "{\"VUID-vkCmdDecodeVideoKHR-dpbTopFieldUseCount-07177\", \"All elements of dpbTopFieldUseCount must be less than or equal to 1\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (dpb_top_field_use_count[i] > 1) {\n    skip |= LogError(\"VUID-vkCmdDecodeVideoKHR-dpbTopFieldUseCount-07177\", cb_state.Handle(), loc,\n                     \"top field in DPB slot %u is referred to multiple \"\n                     \"times across pDecodeInfo->pSetupReferenceSlot and the elements of \"\n                     \"pDecodeInfo->pReferenceSlots.\",\n                     i);\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-vkGetPhysicalDeviceVideoCapabilitiesKHR-pVideoProfile-09257\", \"If pVideoProfile->videoCodecOperation is VK_VIDEO_CODEC_OPERATION_DECODE_AV1_BIT_KHR, then the pNext chain of pCapabilities must include a VkVideoDecodeAV1CapabilitiesKHR structure\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (!vku::FindStructInPNextChain<VkVideoDecodeAV1CapabilitiesKHR>(pCapabilities->pNext)) {\n    skip |= LogError(\"VUID-vkGetPhysicalDeviceVideoCapabilitiesKHR-pVideoProfile-09257\", physicalDevice, caps_loc,\n                     caps_pnext_msg, \"VkVideoDecodeAV1CapabilitiesKHR\");\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkPhysicalDeviceVideoEncodeQualityLevelInfoKHR-pVideoProfile-08260\", \"pVideoProfile->videoCodecOperation must specify an encode operation\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (!profile_desc.IsEncode()) {\n    skip |= LogError(\"VUID-VkPhysicalDeviceVideoEncodeQualityLevelInfoKHR-pVideoProfile-08260\", physicalDevice,\n                     quality_level_info_loc.dot(Field::pVideoProfile), \"does not specify an encode profile.\");\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkVideoSessionCreateInfoKHR-maxActiveReferencePictures-04849\", \"maxActiveReferencePictures must be less than or equal to VkVideoCapabilitiesKHR::maxActiveReferencePictures, as returned by vkGetPhysicalDeviceVideoCapabilitiesKHR for the video profile specified by pVideoProfile\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (pCreateInfo->maxActiveReferencePictures > profile_caps.base.maxActiveReferencePictures) {\n    skip |= LogError(\"VUID-VkVideoSessionCreateInfoKHR-maxActiveReferencePictures-04849\", device, error_obj.location,\n                     \"pCreateInfo->maxActiveReferencePictures (%u) is greater \"\n                     \"than the maxActiveReferencePictures (%u) supported by the video profile.\",\n                     pCreateInfo->maxActiveReferencePictures, profile_caps.base.maxActiveReferencePictures);\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkVideoSessionCreateInfoKHR-pStdHeaderVersion-07191\", \"pStdHeaderVersion->specVersion must be less than or equal to VkVideoCapabilitiesKHR::stdHeaderVersion.specVersion, as returned by vkGetPhysicalDeviceVideoCapabilitiesKHR for the video profile specified by pVideoProfile\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (pCreateInfo->pStdHeaderVersion->specVersion > profile_caps.base.stdHeaderVersion.specVersion) {\n    skip |= LogError(\"VUID-VkVideoSessionCreateInfoKHR-pStdHeaderVersion-07191\", device,\n                     create_info_loc.dot(Field::pStdHeaderVersion).dot(Field::specVersion),\n                     \"(0x%08x) is larger than the supported version (0x%08x).\", pCreateInfo->pStdHeaderVersion->specVersion,\n                     profile_caps.base.stdHeaderVersion.specVersion);\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkBindVideoSessionMemoryInfoKHR-memoryOffset-07201\", \"memoryOffset must be less than the size of memory\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (bind_info.memoryOffset >= mem_state->allocate_info.allocationSize) {\n    const LogObjectList objlist(videoSession, mem_state->Handle());\n    skip |= LogError(\"VUID-VkBindVideoSessionMemoryInfoKHR-memoryOffset-07201\", objlist,\n                     error_obj.location.dot(Field::pBindSessionMemoryInfos, i).dot(Field::memoryOffset),\n                     \"(%\" PRIuLEAST64 \") must be less than the size (%\" PRIuLEAST64 \") of %s.\",\n                     bind_info.memoryOffset, mem_state->allocate_info.allocationSize,\n                     FormatHandle(*mem_state).c_str());\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-vkBindVideoSessionMemoryKHR-pBindSessionMemoryInfos-07197\", \"Each element of pBindSessionMemoryInfos must have a corresponding VkMemoryRequirements structure\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "bind_info.memoryBindIndex, FormatHandle(videoSession).c_str(), i);\nskip |= LogError(\"VUID-vkBindVideoSessionMemoryKHR-pBindSessionMemoryInfos-07197\", videoSession, error_obj.location,\n\"%s does not have a memory binding corresponding \"\n\"to the memoryBindIndex specified in pBindSessionMemoryInfos[%u].\",\nFormatHandle(videoSession).c_str(), i);\n"
        },
        {
            "role": "user",
            "content": "{\"VUID-vkUpdateVideoSessionParametersKHR-pUpdateInfo-07215\", \"pUpdateInfo->updateSequenceCount must equal the current update sequence counter of videoSessionParameters plus one\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (pUpdateInfo->updateSequenceCount != vsp_data->update_sequence_counter + 1) {\n    skip |= LogError(\"VUID-vkUpdateVideoSessionParametersKHR-pUpdateInfo-07215\", device,\n                     update_info_loc.dot(Field::updateSequenceCount), \"(%\" PRIu32 \") should be %\" PRIu32 \".\",\n                     pUpdateInfo->updateSequenceCount, vsp_data->update_sequence_counter + 1);\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-vkUpdateVideoSessionParametersKHR-videoSessionParameters-07220\", \"If videoSessionParameters was created with the video codec operation VK_VIDEO_CODEC_OPERATION_DECODE_H265_BIT_KHR and the pNext chain of pUpdateInfo includes a VkVideoDecodeH265SessionParametersAddInfoKHR structure, then videoSessionParameters must not already contain a StdVideoH265VideoParameterSet entry with vps_video_parameter_set_id matching any of the elements of VkVideoDecodeH265SessionParametersAddInfoKHR::pStdVPSs\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (vsp_data.GetH265VPS(add_info->pStdVPSs[i].vps_video_parameter_set_id)) {\n    skip |= LogError(\"VUID-vkUpdateVideoSessionParametersKHR-videoSessionParameters-07220\",\n                     videoSessionParameters, error_obj.location,\n                     \"H.265 VPS with key \"\n                     \"(VPS ID = %u) already exists in %s.\",\n                     add_info->pStdVPSs[i].vps_video_parameter_set_id,\n                     FormatHandle(videoSessionParameters).c_str());\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-vkUpdateVideoSessionParametersKHR-videoSessionParameters-07226\", \"If videoSessionParameters was created with the video codec operation VK_VIDEO_CODEC_OPERATION_ENCODE_H264_BIT_KHR and the pNext chain of pUpdateInfo includes a VkVideoEncodeH264SessionParametersAddInfoKHR structure, then videoSessionParameters must not already contain a StdVideoH264SequenceParameterSet entry with seq_parameter_set_id matching any of the elements of VkVideoEncodeH264SessionParametersAddInfoKHR::pStdSPSs\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (vsp_data.GetH264SPS(add_info->pStdSPSs[i].seq_parameter_set_id)) {\n    skip |= LogError(\"VUID-vkUpdateVideoSessionParametersKHR-videoSessionParameters-07226\",\n                     videoSessionParameters, error_obj.location,\n                     \"H.264 SPS with key \"\n                     \"(SPS ID = %u) already exists in %s.\",\n                     add_info->pStdSPSs[i].seq_parameter_set_id, FormatHandle(videoSessionParameters).c_str());\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-vkUpdateVideoSessionParametersKHR-videoSessionParameters-06443\", \"If videoSessionParameters was created with the video codec operation VK_VIDEO_CODEC_OPERATION_ENCODE_H265_BIT_KHR, then the number of StdVideoH265VideoParameterSet entries already stored in it plus the value of the stdVPSCount member of the VkVideoEncodeH265SessionParametersAddInfoKHR structure included in the pUpdateInfo->pNext chain must be less than or equal to the VkVideoEncodeH265SessionParametersCreateInfoKHR::maxStdVPSCount videoSessionParameters was created with\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (add_info->stdVPSCount + vsp_data->h265.vps.size() > vsp_data->h265.vps_capacity) {\n    skip |= LogError(\"VUID-vkUpdateVideoSessionParametersKHR-videoSessionParameters-06443\", videoSessionParameters,\n                     error_obj.location,\n                     \"number of H.265 VPS entries to add \"\n                     \"(%u) plus the already used capacity (%zu) is greater than the maximum H.265 \"\n                     \"VPS capacity (%u) the %s was created with.\",\n                     add_info->stdVPSCount, vsp_data->h265.vps.size(), vsp_data->h265.vps_capacity,\n                     FormatHandle(videoSessionParameters).c_str());\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-vkGetEncodedVideoSessionParametersKHR-pVideoSessionParametersInfo-08264\", \"If pVideoSessionParametersInfo->videoSessionParameters was created with the video codec operation VK_VIDEO_CODEC_OPERATION_ENCODE_H264_BIT_KHR, then for the VkVideoEncodeH264SessionParametersGetInfoKHR structure included in the pNext chain of pVideoSessionParametersInfo, if its writeStdPPS member is VK_TRUE, then pVideoSessionParametersInfo->videoSessionParameters must contain a StdVideoH264PictureParameterSet entry with seq_parameter_set_id and pic_parameter_set_id matching VkVideoEncodeH264SessionParametersGetInfoKHR::stdSPSId and VkVideoEncodeH264SessionParametersGetInfoKHR::stdPPSId, respectively\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (h264_info->writeStdPPS && vsp_data.GetH264PPS(h264_info->stdSPSId, h264_info->stdPPSId) == nullptr) {\n    skip |= LogError(\"VUID-vkGetEncodedVideoSessionParametersKHR-pVideoSessionParametersInfo-08264\",\n                     pVideoSessionParametersInfo->videoSessionParameters, error_obj.location,\n                     \"%s does not contain an H.264 PPS \"\n                     \"matching the stdSPSId (%u) and stdPPSId (%u) specified in %s.\",\n                     FormatHandle(*vsp_state).c_str(), h264_info->stdSPSId, h264_info->stdPPSId,\n                     h264_info_loc.Fields().c_str());\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-vkGetEncodedVideoSessionParametersKHR-pVideoSessionParametersInfo-08268\", \"If pVideoSessionParametersInfo->videoSessionParameters was created with the video codec operation VK_VIDEO_CODEC_OPERATION_ENCODE_H265_BIT_KHR, then for the VkVideoEncodeH265SessionParametersGetInfoKHR structure included in the pNext chain of pVideoSessionParametersInfo, if its writeStdPPS member is VK_TRUE, then pVideoSessionParametersInfo->videoSessionParameters must contain a StdVideoH265PictureParameterSet entry with sps_video_parameter_set_id, pps_seq_parameter_set_id, and pps_pic_parameter_set_id matching VkVideoEncodeH265SessionParametersGetInfoKHR::stdVPSId, VkVideoEncodeH265SessionParametersGetInfoKHR::stdSPSId, and VkVideoEncodeH265SessionParametersGetInfoKHR::stdPPSId, respectively\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (h265_info->writeStdPPS &&\n    skip |= LogError(\"VUID-vkGetEncodedVideoSessionParametersKHR-pVideoSessionParametersInfo-08268\",\n                     pVideoSessionParametersInfo->videoSessionParameters, error_obj.location,\n                     \"%s does not contain an H.265 PPS \"\n                     \"matching the stdVPSId(%u), stdSPSId (%u), and stdPPSId (%u) specified in %s.\",\n                     FormatHandle(*vsp_state).c_str(), h265_info->stdVPSId, h265_info->stdSPSId,\n                     h265_info->stdPPSId, h265_info_loc.Fields().c_str());\n"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkVideoBeginCodingInfoKHR-videoSession-07237\", \"videoSession must have memory bound to all of its memory bindings returned by vkGetVideoSessionMemoryRequirementsKHR for videoSession\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (vs_state->GetUnboundMemoryBindingCount() > 0) {\n    const LogObjectList objlist(commandBuffer, pBeginInfo->videoSession);\n    skip |= LogError(\"VUID-VkVideoBeginCodingInfoKHR-videoSession-07237\", objlist, begin_info_loc.dot(Field::videoSession),\n                     \"%s has %u unbound memory binding indices.\", FormatHandle(pBeginInfo->videoSession).c_str(),\n                     vs_state->GetUnboundMemoryBindingCount());\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkVideoBeginCodingInfoKHR-flags-07244\", \"If VkVideoCapabilitiesKHR::flags does not include VK_VIDEO_CAPABILITY_SEPARATE_REFERENCE_IMAGES_BIT_KHR, as returned by vkGetPhysicalDeviceVideoCapabilitiesKHR for the video profile videoSession was created with, then pPictureResource->imageViewBinding of all elements of pReferenceSlots with a non-NULL pPictureResource member must specify image views created from the same image\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if ((supported_cap_flags & VK_VIDEO_CAPABILITY_SEPARATE_REFERENCE_IMAGES_BIT_KHR) == 0 && has_separate_images) {\n    const LogObjectList objlist(commandBuffer, pBeginInfo->videoSession);\n    skip |= LogError(\"VUID-VkVideoBeginCodingInfoKHR-flags-07244\", objlist, error_obj.location,\n                     \"not all elements of pBeginInfo->pReferenceSlots refer \"\n                     \"to the same image and the video profile %s was created with does not support \"\n                     \"VK_VIDEO_CAPABILITY_SEPARATE_REFERENCE_IMAGES_BIT_KHR.\",\n                     FormatHandle(pBeginInfo->videoSession).c_str());\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-vkCmdBeginVideoCodingKHR-pPictureResource-07265\", \"Each video picture resource specified by any non-NULL pPictureResource member specified in the elements of pBeginInfo->pReferenceSlots for which slotIndex is not negative must match one of the video picture resources currently associated with the DPB slot index of pBeginInfo->videoSession specified by slotIndex at the time the command is executed on the device\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "dev_data.FormatHandle(*vs_state).c_str());\nskip |= dev_data.LogError(\"VUID-vkCmdBeginVideoCodingKHR-pPictureResource-07265\", vs_state->Handle(), loc,\n\"DPB slot index %d of %s is not currently associated with the specified \"\n\"video picture resource: %s, layer %u, offset (%s), extent (%s).\",\nslot.index, dev_data.FormatHandle(*vs_state).c_str(),\ndev_data.FormatHandle(slot.resource.image_state->Handle()).c_str(),\nslot.resource.range.baseArrayLayer,\nstring_VkOffset2D(slot.resource.coded_offset).c_str(),\nstring_VkExtent2D(slot.resource.coded_extent).c_str());\n"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkVideoCodingControlInfoKHR-flags-08349\", \"If flags includes VK_VIDEO_CODING_CONTROL_ENCODE_QUALITY_LEVEL_BIT_KHR, then the pNext chain must include a VkVideoEncodeQualityLevelInfoKHR structure\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "skip |= LogError(\"VUID-VkVideoCodingControlInfoKHR-flags-08349\", commandBuffer, control_info_loc.dot(Field::flags),\n                 flags_pnext_msg, \"VK_VIDEO_CODING_CONTROL_ENCODE_QUALITY_LEVEL_BIT_KHR\",\n                 \"VkVideoEncodeQualityLevelInfoKHR\");\n"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkVideoDecodeInfoKHR-srcBufferRange-07167\", \"srcBufferRange must be less than or equal to the size of srcBuffer minus srcBufferOffset\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (pDecodeInfo->srcBufferOffset + pDecodeInfo->srcBufferRange > buffer_state->create_info.size) {\n    const LogObjectList objlist(commandBuffer, vs_state->Handle(), pDecodeInfo->srcBuffer);\n    skip |= LogError(\"VUID-VkVideoDecodeInfoKHR-srcBufferRange-07167\", objlist, decode_info_loc.dot(Field::srcBufferOffset),\n                     \"(%\" PRIu64 \") plus pDecodeInfo->srcBufferRange (%\" PRIu64\n                     \") must be less than or equal to the size (%\" PRIu64 \") of pDecodeInfo->srcBuffer (%s).\",\n                     pDecodeInfo->srcBufferOffset, pDecodeInfo->srcBufferRange, buffer_state->create_info.size,\n                     FormatHandle(pDecodeInfo->srcBuffer).c_str());\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-vkCmdDecodeVideoKHR-pDecodeInfo-07149\", \"If pDecodeInfo->pSetupReferenceSlot is not NULL, then pDecodeInfo->pSetupReferenceSlot->pPictureResource must match one of the bound reference picture resource\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (bound_resources.find(setup_resource) == bound_resources.end()) {\n    skip |= LogError(\"VUID-vkCmdDecodeVideoKHR-pDecodeInfo-07149\", commandBuffer,\n                     decode_info_loc.dot(Field::pSetupReferenceSlot).dot(Field::pPictureResource),\n                     \"is not one of the bound video picture resources.\");\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-vkCmdDecodeVideoKHR-pDecodeInfo-07140\", \"If pDecodeInfo->pSetupReferenceSlot is not NULL and VkVideoDecodeCapabilitiesKHR::flags does not include VK_VIDEO_DECODE_CAPABILITY_DPB_AND_OUTPUT_COINCIDE_BIT_KHR, as returned by vkGetPhysicalDeviceVideoCapabilitiesKHR for the video profile the bound video session was created with, then the video picture resources specified by pDecodeInfo->dstPictureResource and pDecodeInfo->pSetupReferenceSlot->pPictureResource must not match\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if ((profile_caps.decode.flags & VK_VIDEO_DECODE_CAPABILITY_DPB_AND_OUTPUT_COINCIDE_BIT_KHR) == 0 &&\n    const LogObjectList objlist(commandBuffer, vs_state->Handle());\n    skip |= LogError(\"VUID-vkCmdDecodeVideoKHR-pDecodeInfo-07140\", objlist, error_obj.location,\n                     \"the video profile %s was created with does not support \"\n                     \"VK_VIDEO_DECODE_CAPABILITY_DPB_AND_OUTPUT_COINCIDE_BIT_KHR but \"\n                     \"pDecodeInfo->dstPictureResource and \"\n                     \"pDecodeInfo->pSetupReferenceSlot->pPictureResource match.\",\n                     FormatHandle(*vs_state).c_str());\n"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkVideoDecodeInfoKHR-pPictureResource-07172\", \"The pPictureResource member of each element of pReferenceSlots must not be NULL\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "\"VUID-vkCmdDecodeVideoKHR-pPictureResource-07255\", &hit_error);\nskip |= LogError(\"VUID-VkVideoDecodeInfoKHR-pPictureResource-07172\", commandBuffer,\ndecode_info_loc.dot(Field::pReferenceSlots, i).dot(Field::pPictureResource), \"is NULL.\");\n"
        },
        {
            "role": "user",
            "content": "{\"VUID-vkCmdDecodeVideoKHR-queryPool-08368\", \"If the bound video session was created with VK_VIDEO_SESSION_CREATE_INLINE_QUERIES_BIT_KHR, then the queryPool specified in the VkVideoInlineQueryInfoKHR structure included in the pNext chain of pDecodeInfo must have been created with a VkVideoProfileInfoKHR structure included in the pNext chain of VkQueryPoolCreateInfo identical to the one specified in VkVideoSessionCreateInfoKHR::pVideoProfile the bound video session was created with\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (vs_state->profile != query_pool_state->supported_video_profile) {\n    const LogObjectList objlist(commandBuffer, inline_query_info->queryPool, vs_state->Handle());\n    skip |= LogError(\"VUID-vkCmdDecodeVideoKHR-queryPool-08368\", objlist,\n                     decode_info_loc.pNext(Struct::VkVideoInlineQueryInfoKHR, Field::queryPool),\n                     \"video profile %s that was created with does not \"\n                     \"match the video profile of the bound video session %s.\",\n                     FormatHandle(*query_pool_state).c_str(), FormatHandle(*vs_state).c_str());\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-vkCmdEncodeVideoKHR-None-08250\", \"The bound video session must have been created with an encode operation\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (!vs_state->IsEncode()) {\n    const LogObjectList objlist(commandBuffer, vs_state->Handle());\n    skip |= LogError(\"VUID-vkCmdEncodeVideoKHR-None-08250\", objlist, error_obj.location,\n                     \"the video codec operation (%s) the bound video session %s \"\n                     \"was created with is not an encode operation.\",\n                     string_VkVideoCodecOperationFlagBitsKHR(vs_state->GetCodecOp()), FormatHandle(*vs_state).c_str());\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-vkCmdEncodeVideoKHR-pEncodeInfo-08204\", \"pEncodeInfo->dstBufferOffset must be an integer multiple of VkVideoCapabilitiesKHR::minBitstreamBufferOffsetAlignment, as returned by vkGetPhysicalDeviceVideoCapabilitiesKHR for the video profile the bound video session was created with\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (!IsIntegerMultipleOf(pEncodeInfo->dstBufferOffset, profile_caps.base.minBitstreamBufferOffsetAlignment)) {\n    const LogObjectList objlist(commandBuffer, vs_state->Handle());\n    skip |= LogError(\"VUID-vkCmdEncodeVideoKHR-pEncodeInfo-08204\", objlist, encode_info_loc.dot(Field::dstBufferOffset),\n                     \"(%\" PRIu64 \") is not an integer multiple of the minBitstreamBufferOffsetAlignment (%\" PRIu64\n                     \") required by the video profile %s was created with.\",\n                     pEncodeInfo->dstBufferOffset, profile_caps.base.minBitstreamBufferOffsetAlignment,\n                     FormatHandle(*vs_state).c_str());\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-vkCmdEncodeVideoKHR-pEncodeInfo-08213\", \"If pEncodeInfo->pSetupReferenceSlot is not NULL, then pEncodeInfo->pSetupReferenceSlot->slotIndex must be less than the VkVideoSessionCreateInfoKHR::maxDpbSlots specified when the bound video session was created\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "pEncodeInfo->pSetupReferenceSlot->slotIndex);\n} else if ((uint32_t)pEncodeInfo->pSetupReferenceSlot->slotIndex >= vs_state->create_info.maxDpbSlots) {\nskip |= LogError(\"VUID-vkCmdEncodeVideoKHR-pEncodeInfo-08213\", commandBuffer,\nencode_info_loc.dot(Field::pSetupReferenceSlot).dot(Field::slotIndex),\n\"(%d) must be smaller than the maxDpbSlots (%u) the bound video session %s \"\n\"was created with.\",\npEncodeInfo->pSetupReferenceSlot->slotIndex, vs_state->create_info.maxDpbSlots,\nFormatHandle(*vs_state).c_str());\n"
        },
        {
            "role": "user",
            "content": "{\"VUID-vkCmdEncodeVideoKHR-pEncodeInfo-08210\", \"pEncodeInfo->srcPictureResource.imageViewBinding must have been created with VK_IMAGE_USAGE_VIDEO_ENCODE_SRC_BIT_KHR\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if ((supported_usage & VK_IMAGE_USAGE_VIDEO_ENCODE_SRC_BIT_KHR) == 0) {\n    const LogObjectList objlist(commandBuffer, vs_state->Handle(), src_resource.image_view_state->Handle(),\n    skip |= LogError(\"VUID-vkCmdEncodeVideoKHR-pEncodeInfo-08210\", objlist,\n                     encode_info_loc.dot(Field::srcPictureResource).dot(Field::imageViewBinding),\n                     \"(%s created from %s) was not created with VK_IMAGE_USAGE_VIDEO_ENCODE_SRC_BIT_KHR \"\n                     \"thus it cannot be used as an encode input picture with the bound video session %s \"\n                     \"that was created with an encode operation.\",\n                     FormatHandle(src_resource.image_view_state->Handle()).c_str(),\n                     FormatHandle(src_resource.image_state->Handle()).c_str(), FormatHandle(*vs_state).c_str());\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkVideoEncodeInfoKHR-pPictureResource-08242\", \"The pPictureResource member of each element of pReferenceSlots must not be NULL\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "\"VUID-vkCmdEncodeVideoKHR-pPictureResource-08224\", &hit_error);\nskip |= LogError(\"VUID-VkVideoEncodeInfoKHR-pPictureResource-08242\", commandBuffer,\nencode_info_loc.dot(Field::pReferenceSlots, i).dot(Field::pPictureResource), \"is NULL.\");\n"
        },
        {
            "role": "user",
            "content": "{\"VUID-vkCmdEncodeVideoKHR-queryPool-08363\", \"If the bound video session was created with VK_VIDEO_SESSION_CREATE_INLINE_QUERIES_BIT_KHR, then the queryPool specified in the VkVideoInlineQueryInfoKHR structure included in the pNext chain of pEncodeInfo must have been created with a VkVideoProfileInfoKHR structure included in the pNext chain of VkQueryPoolCreateInfo identical to the one specified in VkVideoSessionCreateInfoKHR::pVideoProfile the bound video session was created with\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (vs_state->profile != query_pool_state->supported_video_profile) {\n    const LogObjectList objlist(commandBuffer, inline_query_info->queryPool, vs_state->Handle());\n    skip |= LogError(\"VUID-vkCmdEncodeVideoKHR-queryPool-08363\", objlist,\n                     encode_info_loc.pNext(Struct::VkVideoInlineQueryInfoKHR, Field::queryPool),\n                     \"video profile %s that was created with does not \"\n                     \"match the video profile of the bound video session %s.\",\n                     FormatHandle(*query_pool_state).c_str(), FormatHandle(*vs_state).c_str());\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkPresentInfoKHR-pImageIndices-01430\", \"Each element of pImageIndices must be the index of a presentable image acquired from the swapchain specified by the corresponding element of the pSwapchains array, and the presented image subresource must be in the VK_IMAGE_LAYOUT_PRESENT_SRC_KHR or VK_IMAGE_LAYOUT_SHARED_PRESENT_KHR layout at the time the operation is executed on a VkDevice\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (pPresentInfo->pImageIndices[i] >= swapchain_data->images.size()) {\n    skip |= LogError(\"VUID-VkPresentInfoKHR-pImageIndices-01430\", pPresentInfo->pSwapchains[i], swapchain_loc,\n                     \"image index is too large (%\" PRIu32 \"), There are only %\" PRIu32 \" images in this swapchain.\",\n                     pPresentInfo->pImageIndices[i], static_cast<uint32_t>(swapchain_data->images.size()));\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkRectLayerKHR-offset-04864\", \"The sum of offset and extent, after being transformed according to the preTransform member of the VkSwapchainCreateInfoKHR structure, must be no greater than the imageExtent member of the VkSwapchainCreateInfoKHR structure passed to vkCreateSwapchainKHR\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if ((rect.offset.x + rect.extent.width) > swapchain_data->create_info.imageExtent.width) {\n    skip |= LogError(\"VUID-VkRectLayerKHR-offset-04864\", pPresentInfo->pSwapchains[i], rect_loc,\n                     \"sum of offset.x (%\" PRId32 \") and extent.width (%\" PRIu32\n                     \") after applying preTransform (%s) is greater \"\n                     \"than the corresponding swapchain's imageExtent.width (%\" PRIu32 \").\",\n                     rect.offset.x, rect.extent.width,\n                     string_VkSurfaceTransformFlagBitsKHR(swapchain_data->create_info.preTransform),\n                     swapchain_data->create_info.imageExtent.width);\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkPresentIdKHR-presentIds-04999\", \"Each presentIds entry must be greater than any previous presentIds entry passed for the associated pSwapchains entry\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if ((present_id_info->pPresentIds[i] != 0) &&\n    (present_id_info->pPresentIds[i] <= swapchain_state->max_present_id)) {\n    skip |= LogError(\"VUID-VkPresentIdKHR-presentIds-04999\", pPresentInfo->pSwapchains[i],\n                     present_info_loc.pNext(Struct::VkPresentIdKHR, Field::pPresentIds, i),\n                     \"%\" PRIu64 \" and the largest presentId sent for this swapchain is %\" PRIu64\n                     \". Each presentIds entry must be greater than any previous presentIds entry passed for the \"\n                     \"associated pSwapchains entry\",\n                     present_id_info->pPresentIds[i], swapchain_state->max_present_id);\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkReleaseSwapchainImagesInfoEXT-pImageIndices-07785\", \"Each element of pImageIndices must be the index of a presentable image acquired from the swapchain specified by swapchain\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (pReleaseInfo->pImageIndices[i] >= swapchain_state->images.size()) {\n    skip |= LogError(\"VUID-VkReleaseSwapchainImagesInfoEXT-pImageIndices-07785\", pReleaseInfo->swapchain,\n                     release_info_loc.dot(Field::pImageIndices, i),\n                     \"%\" PRIu32 \" is too large, there are only %\" PRIu32 \" images in this swapchain.\",\n                     pReleaseInfo->pImageIndices[i], static_cast<uint32_t>(swapchain_state->images.size()));\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-vkWaitForPresentKHR-swapchain-04997\", \"swapchain must not be in the retired state\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (swapchain_state->retired) {\n    skip |= LogError(\"VUID-vkWaitForPresentKHR-swapchain-04997\", swapchain, error_obj.location,\n                     \"called with a retired swapchain.\");\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkDisplaySurfaceCreateInfoKHR-planeIndex-01252\", \"planeIndex must be less than the number of display planes supported by the device as determined by calling vkGetPhysicalDeviceDisplayPlanePropertiesKHR\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (plane_index >= pd_state->display_plane_property_count) {\n    skip |= LogError(\"VUID-VkDisplaySurfaceCreateInfoKHR-planeIndex-01252\", display_mode,\n                     create_info_loc.dot(Field::planeIndex),\n                     \"(%\" PRIu32 \") must be in the range [0, %\" PRIu32\n                     \"] that was returned by \"\n                     \"vkGetPhysicalDeviceDisplayPlanePropertiesKHR \"\n                     \"or vkGetPhysicalDeviceDisplayPlaneProperties2KHR. Do you have the plane index hardcoded?\",\n                     plane_index, pd_state->display_plane_property_count - 1);\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-vkReleaseFullScreenExclusiveModeEXT-swapchain-02677\", \"swapchain must not be in the retired state\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (swapchain_state->retired) {\n    skip |= LogError(\"VUID-vkReleaseFullScreenExclusiveModeEXT-swapchain-02677\", device, error_obj.location,\n                     \"swapchain %s is retired.\", FormatHandle(swapchain).c_str());\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkSamplerYcbcrConversionCreateInfo-format-04061\", \"If an external format conversion is not being created, format must represent unsigned normalized values (i.e. the format must be a UNORM format)\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "skip |= LogError(\"VUID-VkSamplerYcbcrConversionCreateInfo-format-04061\", device, create_info_loc.dot(Field::format),\n                 \"(%s) is not an UNORM format and there is no external format conversion being created.\",\n                 string_VkFormat(conversion_format));\n"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkDispatchIndirectCommand-y-00418\", \"y must be less than or equal to VkPhysicalDeviceLimits::maxComputeWorkGroupCount[1]\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "skip |= gpuav.LogError(\"VUID-VkDispatchIndirectCommand-y-00418\", objlist, loc,\n                       \"Indirect dispatch VkDispatchIndirectCommand::y of %\" PRIu32\n                       \" would exceed maxComputeWorkGroupCount[1] limit of %\" PRIu32 \".\",\n                       count, gpuav.phys_dev_props.limits.maxComputeWorkGroupCount[1]);\n"
        },
        {
            "role": "user",
            "content": "{\"VUID-vkFreeCommandBuffers-pCommandBuffers-parent\", \"Each element of pCommandBuffers that is a valid handle must have been created, allocated, or retrieved from commandPool\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "// We know that the parent *must* be a command pool\nconst LogObjectList objlist(command_buffer, parent_pool, command_pool);\nskip |= LogError(\"VUID-vkFreeCommandBuffers-pCommandBuffers-parent\", objlist, loc,\n                 \"attempting to free %s belonging to %s from %s.\", FormatHandle(command_buffer).c_str(),\n                 FormatHandle(parent_pool).c_str(), FormatHandle(command_pool).c_str());\n"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkWriteDescriptorSet-descriptorType-02995\", \"If descriptorType is VK_DESCRIPTOR_TYPE_UNIFORM_TEXEL_BUFFER or VK_DESCRIPTOR_TYPE_STORAGE_TEXEL_BUFFER and the nullDescriptor feature is not enabled, each element of pTexelBufferView must not be VK_NULL_HANDLE\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (!null_descriptor_enabled && desc->pTexelBufferView[i] == VK_NULL_HANDLE) {\n    skip |= LogError(\"VUID-VkWriteDescriptorSet-descriptorType-02995\", desc->dstSet,\n                     loc.dot(Field::pTexelBufferView, i), \"is VK_NULL_HANDLE.\");\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-vkDestroyInstance-instance-00630\", \"If VkAllocationCallbacks were provided when instance was created, a compatible set of callbacks must be provided here\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "\"VUID-vkDestroyInstance-instance-00631\", error_obj.location);\nskip |= ValidateDestroyObject(instance, kVulkanObjectTypeInstance, pAllocator, \"VUID-vkDestroyInstance-instance-00630\",\n\"VUID-vkDestroyInstance-instance-00631\", error_obj.location);\n"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkDebugMarkerObjectTagInfoEXT-object-01495\", \"object must be a Vulkan object of the type associated with objectType as defined in VkDebugReportObjectTypeEXT and Vulkan Handle Relationship\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (object_type != kVulkanObjectTypeImage || !swapchain_image_map.contains(pTagInfo->object)) {\n    skip |= LogError(\"VUID-VkDebugMarkerObjectTagInfoEXT-object-01495\", device,\n                     error_obj.location.dot(Field::pTagInfo).dot(Field::objectType),\n                     \"(%s) doesn't match the object (0x%\" PRIx64 \").\",\n                     string_VkDebugReportObjectTypeEXT(pTagInfo->objectType), pTagInfo->object);\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkDebugUtilsObjectNameInfoEXT-objectType-02590\", \"If objectType is not VK_OBJECT_TYPE_UNKNOWN, objectHandle must be VK_NULL_HANDLE or a valid Vulkan handle of the type associated with objectType as defined in the VkObjectType and Vulkan Handle Relationship table\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "skip |= ValidateAnonymousObject(object_handle, object_type, \"VUID-VkDebugUtilsObjectNameInfoEXT-objectType-02590\",\n                                \"VUID-vkSetDebugUtilsObjectNameEXT-pNameInfo-07874\",\n                                error_obj.location.dot(Field::pNameInfo).dot(Field::objectHandle));\n"
        },
        {
            "role": "user",
            "content": "{\"VUID-vkBuildAccelerationStructuresKHR-srcAccelerationStructure-04629\", \"If the srcAccelerationStructure member of any element of pInfos is not VK_NULL_HANDLE, the srcAccelerationStructure member must be a valid VkAccelerationStructureKHR handle\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "\"VUID-vkBuildAccelerationStructuresKHR-deferredOperation-parameter\",\n\"VUID-vkBuildAccelerationStructuresKHR-deferredOperation-parent\",\nskip |= ValidateAccelerationStructures(\"VUID-vkBuildAccelerationStructuresKHR-srcAccelerationStructure-04629\",\n                \"VUID-vkBuildAccelerationStructuresKHR-dstAccelerationStructure-03800\", infoCount,\n                pInfos, error_obj.location);\n"
        },
        {
            "role": "user",
            "content": "{\"VUID-vkGetPrivateData-objectType-04018\", \"objectHandle must be device or a child of device\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (HandleToUint64(device) != objectHandle) {\n    skip |= LogError(\"VUID-vkGetPrivateData-objectType-04018\", device, error_obj.location.dot(Field::objectType),\n                     \"is VK_OBJECT_TYPE_DEVICE but objectHandle (0x%\" PRIx64 \") != device (%s).\", objectHandle,\n                     FormatHandle(device).c_str());\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkBufferCreateInfo-flags-00915\", \"If the sparseBinding feature is not enabled, flags must not contain VK_BUFFER_CREATE_SPARSE_BINDING_BIT\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if ((pCreateInfo->flags & VK_BUFFER_CREATE_SPARSE_BINDING_BIT) && (!enabled_features.sparseBinding)) {\n    skip |= LogError(\"VUID-VkBufferCreateInfo-flags-00915\", device, create_info_loc.dot(Field::flags),\n                     \"includes VK_BUFFER_CREATE_SPARSE_BINDING_BIT, but the sparseBinding feature is not enabled.\");\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkBufferCreateInfo-flags-09641\", \"If flags includes VK_BUFFER_CREATE_PROTECTED_BIT, then usage must not contain any of the following bits VK_BUFFER_USAGE_TRANSFORM_FEEDBACK_BUFFER_BIT_EXT VK_BUFFER_USAGE_TRANSFORM_FEEDBACK_COUNTER_BUFFER_BIT_EXT VK_BUFFER_USAGE_CONDITIONAL_RENDERING_BIT_EXT VK_BUFFER_USAGE_ACCELERATION_STRUCTURE_BUILD_INPUT_READ_ONLY_BIT_KHR VK_BUFFER_USAGE_ACCELERATION_STRUCTURE_STORAGE_BIT_KHR VK_BUFFER_USAGE_SHADER_BINDING_TABLE_BIT_KHR VK_BUFFER_USAGE_SAMPLER_DESCRIPTOR_BUFFER_BIT_EXT VK_BUFFER_USAGE_RESOURCE_DESCRIPTOR_BUFFER_BIT_EXT VK_BUFFER_USAGE_PUSH_DESCRIPTORS_DESCRIPTOR_BUFFER_BIT_EXT VK_BUFFER_USAGE_MICROMAP_BUILD_INPUT_READ_ONLY_BIT_EXT VK_BUFFER_USAGE_MICROMAP_STORAGE_BIT_EXT\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (pCreateInfo->usage & invalid) {\n    skip |= LogError(\"VUID-VkBufferCreateInfo-flags-09641\", device, create_info_loc.dot(Field::flags),\n                     \"includes VK_BUFFER_CREATE_PROTECTED_BIT, but the usage is %s.\",\n                     string_VkBufferUsageFlags(pCreateInfo->usage).c_str());\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-vkCmdBindVertexBuffers-pBuffers-04002\", \"If an element of pBuffers is VK_NULL_HANDLE, then the corresponding element of pOffsets must be zero\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (pOffsets[i] != 0) {\n    skip |= LogError(\"VUID-vkCmdBindVertexBuffers-pBuffers-04002\", commandBuffer, buffer_loc,\n                     \"is VK_NULL_HANDLE, but pOffsets[%\" PRIu32 \"] is not 0.\", i);\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-vkCmdBindTransformFeedbackBuffersEXT-pSize-02361\", \"If the optional pSize array is specified, each element of pSizes must either be VK_WHOLE_SIZE, or be less than or equal to VkPhysicalDeviceTransformFeedbackPropertiesEXT::maxTransformFeedbackBufferSize\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (pSizes[i] != VK_WHOLE_SIZE &&\n    skip |= LogError(\"VUID-vkCmdBindTransformFeedbackBuffersEXT-pSize-02361\", commandBuffer,\n                     error_obj.location.dot(Field::pSizes, i),\n                     \"(%\" PRIu64\n                     \") is not VK_WHOLE_SIZE and is greater than \"\n                     \"maxTransformFeedbackBufferSize.\",\n                     pSizes[i]);\n"
        },
        {
            "role": "user",
            "content": "{\"VUID-vkCmdEndTransformFeedbackEXT-pCounterBuffer-02379\", \"If pCounterBuffer is NULL, then pCounterBufferOffsets must also be NULL\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (pCounterBuffers == nullptr && pCounterBufferOffsets != nullptr) {\n    skip |= LogError(\"VUID-vkCmdEndTransformFeedbackEXT-pCounterBuffer-02379\", commandBuffer, error_obj.location,\n                     \"pCounterBuffers is NULL and pCounterBufferOffsets is not NULL.\");\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-vkCmdBindVertexBuffers2-pBuffers-parameter\", \"pBuffers must be a valid pointer to an array of bindingCount valid or VK_NULL_HANDLE VkBuffer handles\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (pBuffers == nullptr) {\n    skip |= LogError(\"VUID-vkCmdBindVertexBuffers2-pBuffers-parameter\", commandBuffer,\n                     error_obj.location.dot(Field::pBuffers), \"is NULL.\");\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkPushConstantsInfoKHR-layout-09496\", \"If layout is VK_NULL_HANDLE, the pNext chain must include a valid VkPipelineLayoutCreateInfo structure\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "skip |= LogError(\"VUID-VkPushConstantsInfoKHR-None-09495\", commandBuffer,\n                 error_obj.location.dot(Field::pPushConstantsInfo).dot(Field::layout), \"is VK_NULL_HANDLE.\");\nskip |= LogError(\"VUID-VkPushConstantsInfoKHR-layout-09496\", commandBuffer,\n                 error_obj.location.dot(Field::pPushConstantsInfo).dot(Field::layout),\n                 \"is VK_NULL_HANDLE and pNext is missing VkPipelineLayoutCreateInfo.\");\n"
        },
        {
            "role": "user",
            "content": "{\"VUID-vkCmdClearAttachments-rect-02683\", \"The rect member of each element of pRects must have an extent.height greater than 0\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (pRects[rect].rect.extent.height == 0) {\n    skip |= LogError(\"VUID-vkCmdClearAttachments-rect-02683\", commandBuffer,\n                     rect_loc.dot(Field::rect).dot(Field::extent).dot(Field::height), \"is zero.\");\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-vkCmdFillBuffer-dstOffset-00025\", \"dstOffset must be a multiple of 4\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (dstOffset & 3) {\n    const LogObjectList objlist(commandBuffer, dstBuffer);\n    skip |= LogError(\"VUID-vkCmdFillBuffer-dstOffset-00025\", objlist, error_obj.location.dot(Field::dstOffset),\n                     \"(%\" PRIu64 \") is not a multiple of 4.\", dstOffset);\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkPushDescriptorSetInfoKHR-layout-09496\", \"If layout is VK_NULL_HANDLE, the pNext chain must include a valid VkPipelineLayoutCreateInfo structure\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "skip |= LogError(\"VUID-VkPushDescriptorSetInfoKHR-None-09495\", commandBuffer,\n                 error_obj.location.dot(Field::pPushDescriptorSetInfo).dot(Field::layout), \"is VK_NULL_HANDLE.\");\nskip |= LogError(\"VUID-VkPushDescriptorSetInfoKHR-layout-09496\", commandBuffer,\n                 error_obj.location.dot(Field::pPushDescriptorSetInfo).dot(Field::layout),\n                 \"is VK_NULL_HANDLE and pNext is missing VkPipelineLayoutCreateInfo.\");\n"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkViewport-x-01232\", \"(x + width) must be less than or equal to viewportBoundsRange[1]\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (right_bound > device_limits.viewportBoundsRange[1]) {\n    skip |= LogError(\"VUID-VkViewport-x-01232\", object, loc,\n                     \"x (%f) + width (%f) is %f which is greater than VkPhysicalDeviceLimits::viewportBoundsRange[1] (%f).\",\n                     viewport.x, viewport.width, right_bound, device_limits.viewportBoundsRange[1]);\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkViewport-minDepth-01234\", \"If the VK_EXT_depth_range_unrestricted extension is not enabled, minDepth must be between 0.0 and 1.0, inclusive\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (!(viewport.minDepth >= 0.0) || !(viewport.minDepth <= 1.0)) {\n    skip |= LogError(\"VUID-VkViewport-minDepth-01234\", object, loc.dot(Field::minDepth), \"is %f.\", viewport.minDepth);\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-vkCmdSetScissorWithCount-scissorCount-03398\", \"If the multiViewport feature is not enabled, scissorCount must be 1\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (scissorCount != 1) {\n    skip |= LogError(\"VUID-vkCmdSetScissorWithCount-scissorCount-03398\", commandBuffer,\n                     error_obj.location.dot(Field::scissorCount),\n                     \"(%\" PRIu32\n                     \") must \"\n                     \"be 1 when the multiViewport feature is disabled.\",\n                     scissorCount);\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-vkCmdSetScissorWithCount-offset-03400\", \"Evaluation of (offset.x + extent.width) must not cause a signed integer addition overflow for any element of pScissors\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (x_sum > vvl::kI32Max) {\n    skip |= LogError(\"VUID-vkCmdSetScissorWithCount-offset-03400\", commandBuffer, scissor_loc,\n                     \"offset.x (%\" PRId32 \") + extent.width (%\" PRIu32 \") is %\" PRIi64 \" which will overflow int32_t.\",\n                     scissor.offset.x, scissor.extent.width, x_sum);\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-vkCmdSetVertexInputEXT-pVertexBindingDescriptions-04794\", \"All elements of pVertexBindingDescriptions must describe distinct binding numbers\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (binding_it != vertex_bindings.cend()) {\n    skip |= LogError(\"VUID-vkCmdSetVertexInputEXT-pVertexBindingDescriptions-04794\", commandBuffer,\n                     error_obj.location.dot(Field::pVertexBindingDescriptions, binding),\n                     \"is already in pVertexBindingDescriptions[%\" PRIu32 \"].\", *binding_it);\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkVertexInputBindingDescription2EXT-divisor-06226\", \"divisor must be a value between 0 and VkPhysicalDeviceVertexAttributeDivisorPropertiesEXT::maxVertexAttribDivisor, inclusive\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (pVertexBindingDescriptions[binding].divisor >\n    skip |= LogError(\"VUID-VkVertexInputBindingDescription2EXT-divisor-06226\", commandBuffer,\n                     binding_loc.dot(Field::divisor),\n                     \"(%\" PRIu32 \") is greater than maxVertexAttribDivisor (%\" PRIu32 \")\",\n                     pVertexBindingDescriptions[binding].divisor,\n                     phys_dev_ext_props.vertex_attribute_divisor_props.maxVertexAttribDivisor);\n"
        },
        {
            "role": "user",
            "content": "{\"VUID-vkCmdSetDiscardRectangleEnableEXT-specVersion-07851\", \"The VK_EXT_discard_rectangles extension must be enabled, and the implementation must support at least specVersion 2 of this extension\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (discard_rectangles_extension_version < 2) {\n    skip |= LogError(\"VUID-vkCmdSetDiscardRectangleEnableEXT-specVersion-07851\", commandBuffer, error_obj.location,\n                     \"Requires support for version 2 of VK_EXT_discard_rectangles.\");\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-vkCmdSetExclusiveScissorNV-firstExclusiveScissor-02034\", \"The sum of firstExclusiveScissor and exclusiveScissorCount must be between 1 and VkPhysicalDeviceLimits::maxViewports, inclusive\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (sum > device_limits.maxViewports) {\n    skip |= LogError(\"VUID-vkCmdSetExclusiveScissorNV-firstExclusiveScissor-02034\", commandBuffer, error_obj.location,\n                     \"firstExclusiveScissor + exclusiveScissorCount (=%\" PRIu32 \" + %\" PRIu32 \" = %\" PRIu64\n                     \") is greater than VkPhysicalDeviceLimits::maxViewports (=%\" PRIu32 \").\",\n                     firstExclusiveScissor, exclusiveScissorCount, sum, device_limits.maxViewports);\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-vkCmdSetViewportWScalingNV-firstViewport-01324\", \"The sum of firstViewport and viewportCount must be between 1 and VkPhysicalDeviceLimits::maxViewports, inclusive\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if ((sum < 1) || (sum > device_limits.maxViewports)) {\n    skip |= LogError(\"VUID-vkCmdSetViewportWScalingNV-firstViewport-01324\", commandBuffer, error_obj.location,\n                     \"firstViewport + viewportCount (=%\" PRIu32 \" + %\" PRIu32 \" = %\" PRIu64\n                     \") must be between 1 and VkPhysicalDeviceLimits::maxViewports (=%\" PRIu32 \"), inculsive.\",\n                     firstViewport, viewportCount, sum, device_limits.maxViewports);\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-vkCmdSetViewport-firstViewport-01223\", \"The sum of firstViewport and viewportCount must be between 1 and VkPhysicalDeviceLimits::maxViewports, inclusive\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (sum > device_limits.maxViewports) {\n    skip |= LogError(\"VUID-vkCmdSetViewport-firstViewport-01223\", commandBuffer, error_obj.location,\n                     \"firstViewport (%\" PRIu32 \") + viewportCount (%\" PRIu32 \") is %\" PRIu64\n                     \" which is greater than maxViewports (%\" PRIu32 \").\",\n                     firstViewport, viewportCount, sum, device_limits.maxViewports);\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-vkCmdSetScissor-x-00595\", \"The x and y members of offset member of any element of pScissors must be greater than or equal to 0\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (scissor.offset.y < 0) {\n    skip |= LogError(\"VUID-vkCmdSetScissor-x-00595\", commandBuffer, scissor_loc.dot(Field::offset).dot(Field::y),\n                     \"(%\" PRId32 \") is negative.\", scissor.offset.y);\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkCoarseSampleOrderCustomNV-shadingRate-02073\", \"shadingRate must be a shading rate that generates fragments with more than one pixel\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (sample_order_info == nullptr) {\n    skip |= LogError(\"VUID-VkCoarseSampleOrderCustomNV-shadingRate-02073\", device, order_loc,\n                     \"shadingRate must be a shading rate \"\n                     \"that generates fragments with more than one pixel.\");\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkCoarseSampleLocationNV-sample-02080\", \"sample must be less than the number of coverage samples in each pixel belonging to the fragment\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (sample_loc->sample >= order.sampleCount) {\n    skip |= LogError(\"VUID-VkCoarseSampleLocationNV-sample-02080\", device, order_loc,\n                     \"sample must be less than the number of coverage samples in each pixel belonging to the fragment.\");\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkSamplerCustomBorderColorCreateInfoEXT-format-07605\", \"If format is not VK_FORMAT_UNDEFINED and format is not a depth/stencil format then the VkSamplerCreateInfo::borderColor type must match the sampled type of the provided format, as shown in the SPIR-V Type column of the Interpretation of Numeric Format table\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "!vkuFormatIsSampledInt(custom_create_info->format)) ||\n!vkuFormatIsSampledFloat(custom_create_info->format)))) {\nskip |= LogError(\"VUID-VkSamplerCustomBorderColorCreateInfoEXT-format-07605\", device,\n               create_info_loc.pNext(Struct::VkSamplerCustomBorderColorCreateInfoEXT, Field::format),\n               \"%s does not match borderColor (%s).\", string_VkFormat(custom_create_info->format),\n               string_VkBorderColor(create_info.borderColor));\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkSamplerCreateInfo-flags-02578\", \"If flags includes VK_SAMPLER_CREATE_SUBSAMPLED_BIT_EXT, then anisotropyEnable must be VK_FALSE\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (create_info.anisotropyEnable) {\n    skip |= LogError(\"VUID-VkSamplerCreateInfo-flags-02578\", device, create_info_loc.dot(Field::flags),\n                     \"includes VK_SAMPLER_CREATE_SUBSAMPLED_BIT_EXT, \"\n                     \"but anisotropyEnable is VK_TRUE.\");\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkSamplerCreateInfo-flags-06966\", \"[If flags includes VK_SAMPLER_CREATE_IMAGE_PROCESSING_BIT_QCOM, then minLod and maxLod must be zero\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if ((create_info.minLod != 0) || (create_info.maxLod != 0)) {\n    skip |= LogError(\"VUID-VkSamplerCreateInfo-flags-06966\", device, create_info_loc.dot(Field::flags),\n                     \"includes VK_SAMPLER_CREATE_IMAGE_PROCESSING_BIT_QCOM, so \"\n                     \"minLod (%f) and maxLod (%f) must be 0.\",\n                     create_info.minLod, create_info.maxLod);\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkSamplerCreateInfo-unnormalizedCoordinates-01072\", \"If unnormalizedCoordinates is VK_TRUE, minFilter and magFilter must be equal\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (pCreateInfo->minFilter != pCreateInfo->magFilter) {\n    skip |= LogError(\"VUID-VkSamplerCreateInfo-unnormalizedCoordinates-01072\", device,\n                     create_info_loc.dot(Field::unnormalizedCoordinates),\n                     \"is VK_TRUE, but minFilter (%s) is different then magFilter (%s).\",\n                     string_VkFilter(pCreateInfo->minFilter), string_VkFilter(pCreateInfo->magFilter));\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkSamplerCreateInfo-unnormalizedCoordinates-01077\", \"If unnormalizedCoordinates is VK_TRUE, compareEnable must be VK_FALSE\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (pCreateInfo->compareEnable == VK_TRUE) {\n    skip |= LogError(\"VUID-VkSamplerCreateInfo-unnormalizedCoordinates-01077\", device, create_info_loc,\n                     \"compareEnable and unnormalizedCoordinates are both VK_TRUE.\");\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkSamplerCreateInfo-maxLod-01973\", \"maxLod must be greater than or equal to minLod\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (pCreateInfo->minLod > pCreateInfo->maxLod) {\n    skip |= LogError(\"VUID-VkSamplerCreateInfo-maxLod-01973\", device, create_info_loc,\n                     \"minLod (%f) is greater than maxLod (%f)\", pCreateInfo->minLod, pCreateInfo->maxLod);\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkMutableDescriptorTypeListEXT-pDescriptorTypes-04600\", \"pDescriptorTypes must not contain VK_DESCRIPTOR_TYPE_MUTABLE_EXT\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "const Location type_loc = mutable_loc.dot(Field::pDescriptorTypes, k);\nswitch (mutable_create_info.pMutableDescriptorTypeLists[j].pDescriptorTypes[k]) {\n        skip |= LogError(\"VUID-VkMutableDescriptorTypeListEXT-pDescriptorTypes-04600\", device, type_loc,\n                         \"is VK_DESCRIPTOR_TYPE_MUTABLE_EXT.\");\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkDescriptorSetLayoutBinding-descriptorType-01510\", \"If descriptorType is VK_DESCRIPTOR_TYPE_INPUT_ATTACHMENT and descriptorCount is not 0, then stageFlags must be 0 or VK_SHADER_STAGE_FRAGMENT_BIT\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if ((create_info.pBindings[i].descriptorType == VK_DESCRIPTOR_TYPE_INPUT_ATTACHMENT) &&\n    skip |= LogError(\"VUID-VkDescriptorSetLayoutBinding-descriptorType-01510\", device,\n                     binding_loc.dot(Field::stageFlags),\n                     \"is %s but descriptorType is VK_DESCRIPTOR_TYPE_INPUT_ATTACHMENT.\",\n                     string_VkShaderStageFlags(stage_flags).c_str());\n"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkDescriptorSetLayoutCreateInfo-flags-08000\", \"If flags contains VK_DESCRIPTOR_SET_LAYOUT_CREATE_DESCRIPTOR_BUFFER_BIT_EXT, then all elements of pBindings must not have a descriptorType of VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER_DYNAMIC or VK_DESCRIPTOR_TYPE_STORAGE_BUFFER_DYNAMIC\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (create_info.flags & VK_DESCRIPTOR_SET_LAYOUT_CREATE_DESCRIPTOR_BUFFER_BIT_EXT &&\n    ((create_info.pBindings[i].descriptorType == VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER_DYNAMIC) ||\n     (create_info.pBindings[i].descriptorType == VK_DESCRIPTOR_TYPE_STORAGE_BUFFER_DYNAMIC))) {\n    skip |= LogError(\"VUID-VkDescriptorSetLayoutCreateInfo-flags-08000\", device, binding_loc.dot(Field::descriptorType),\n                     \"is %s, but flags includes VK_DESCRIPTOR_SET_LAYOUT_CREATE_PUSH_DESCRIPTOR_BIT_KHR.\",\n                     string_VkDescriptorType(create_info.pBindings[i].descriptorType));\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkDescriptorSetLayoutCreateInfo-flags-08002\", \"If flags contains VK_DESCRIPTOR_SET_LAYOUT_CREATE_DESCRIPTOR_BUFFER_BIT_EXT, then flags must not contain VK_DESCRIPTOR_SET_LAYOUT_CREATE_UPDATE_AFTER_BIND_POOL_BIT\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if ((create_info.flags & VK_DESCRIPTOR_SET_LAYOUT_CREATE_DESCRIPTOR_BUFFER_BIT_EXT) &&\n    (create_info.flags & VK_DESCRIPTOR_SET_LAYOUT_CREATE_UPDATE_AFTER_BIND_POOL_BIT)) {\n    skip |= LogError(\"VUID-VkDescriptorSetLayoutCreateInfo-flags-08002\", device, create_info_loc.dot(Field::flags), \"is %s.\",\n                     string_VkDescriptorSetLayoutCreateFlags(create_info.flags).c_str());\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkWriteDescriptorSet-descriptorType-00327\", \"If descriptorType is VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER or VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER_DYNAMIC, the offset member of each element of pBufferInfo must be a multiple of VkPhysicalDeviceLimits::minUniformBufferOffsetAlignment\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (SafeModulo(descriptor_writes.pBufferInfo[j].offset, uniform_alignment) != 0) {\n    skip |= LogError(\"VUID-VkWriteDescriptorSet-descriptorType-00327\", device,\n                     writes_loc.dot(Field::pBufferInfo, j).dot(Field::offset),\n                     \"(%\" PRIu64 \") must be a multiple of device limit minUniformBufferOffsetAlignment %\" PRIu64\n                     \" when descriptor type is %s.\",\n                     descriptor_writes.pBufferInfo[j].offset, uniform_alignment,\n                     string_VkDescriptorType(descriptor_type));\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkWriteDescriptorSetAccelerationStructureNV-pAccelerationStructures-03749\", \"If the nullDescriptor feature is not enabled, each member of pAccelerationStructures must not be VK_NULL_HANDLE\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (pnext_struct->pAccelerationStructures[j] == VK_NULL_HANDLE) {\n    skip |= LogError(\"VUID-VkWriteDescriptorSetAccelerationStructureNV-pAccelerationStructures-03749\",\n                     device, loc,\n                     \"If the nullDescriptor feature is not enabled, each member of \"\n                     \"pAccelerationStructures must not be VK_NULL_HANDLE.\");\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkDescriptorPoolCreateInfo-flags-04609\", \"If flags has the VK_DESCRIPTOR_POOL_CREATE_HOST_ONLY_BIT_EXT bit set, VkPhysicalDeviceMutableDescriptorTypeFeaturesEXT::mutableDescriptorType must be enabled\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (pCreateInfo->flags & VK_DESCRIPTOR_POOL_CREATE_HOST_ONLY_BIT_EXT && !enabled_features.mutableDescriptorType) {\n    skip |= LogError(\"VUID-VkDescriptorPoolCreateInfo-flags-04609\", device, create_info_loc.dot(Field::flags),\n                     \"includes VK_DESCRIPTOR_POOL_CREATE_HOST_ONLY_BIT_EXT, \"\n                     \"but mutableDescriptorType feature was not enabled.\");\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkQueryPoolCreateInfo-queryType-00792\", \"If queryType is VK_QUERY_TYPE_PIPELINE_STATISTICS, pipelineStatistics must be a valid combination of VkQueryPipelineStatisticFlagBits values\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "skip |= LogError(\"VUID-VkQueryPoolCreateInfo-queryType-09534\", device, create_info_loc.dot(Field::queryType),\nskip |= LogError(\"VUID-VkQueryPoolCreateInfo-queryType-00792\", device, create_info_loc.dot(Field::queryType),\n                 \"is VK_QUERY_TYPE_PIPELINE_STATISTICS, but \"\n                 \"pCreateInfo->pipelineStatistics must be a valid combination of VkQueryPipelineStatisticFlagBits \"\n                 \"values.\");\n"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkSamplerYcbcrConversionCreateInfo-components-02582\", \"If the format has a _422 or _420 suffix, then components.a must be the identity swizzle, VK_COMPONENT_SWIZZLE_ONE, or VK_COMPONENT_SWIZZLE_ZERO\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if ((components.a != VK_COMPONENT_SWIZZLE_A) && (components.a != VK_COMPONENT_SWIZZLE_IDENTITY) &&\n    (components.a != VK_COMPONENT_SWIZZLE_ONE) && (components.a != VK_COMPONENT_SWIZZLE_ZERO)) {\n    skip |= LogError(\"VUID-VkSamplerYcbcrConversionCreateInfo-components-02582\", device, create_info_loc,\n                     \" When using a XChroma subsampled format (%s) the components.a needs to be VK_COMPONENT_SWIZZLE_A or \"\n                     \"VK_COMPONENT_SWIZZLE_IDENTITY or VK_COMPONENT_SWIZZLE_ONE or VK_COMPONENT_SWIZZLE_ZERO, but is %s.\",\n                     string_VkFormat(format), string_VkComponentSwizzle(components.a));\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkDescriptorGetInfoEXT-pInputAttachmentImage-parameter\", \"If type is VK_DESCRIPTOR_TYPE_INPUT_ATTACHMENT, the pInputAttachmentImage member of data must be a valid pointer to a valid VkDescriptorImageInfo structure\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (!pDescriptorInfo->data.pInputAttachmentImage) {\n    skip |= LogError(\"VUID-VkDescriptorGetInfoEXT-pInputAttachmentImage-parameter\", device,\n                     descriptor_info_loc.dot(Field::type),\n                     \"is VK_DESCRIPTOR_TYPE_INPUT_ATTACHMENT, but pInputAttachmentImage is null.\");\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkPushDescriptorSetWithTemplateInfoKHR-None-09495\", \"If the dynamicPipelineLayout feature is not enabled, layout must be a valid VkPipelineLayout handle\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (!enabled_features.dynamicPipelineLayout) {\n    skip |= LogError(\"VUID-VkPushDescriptorSetWithTemplateInfoKHR-None-09495\", commandBuffer,\n                     error_obj.location.dot(Field::pPushDescriptorSetWithTemplateInfo).dot(Field::layout),\n                     \"is VK_NULL_HANDLE.\");\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkMemoryAllocateInfo-flags-03330\", \"If VkMemoryAllocateFlagsInfo::flags includes VK_MEMORY_ALLOCATE_DEVICE_ADDRESS_CAPTURE_REPLAY_BIT, the bufferDeviceAddressCaptureReplay feature must be enabled\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if ((flags & VK_MEMORY_ALLOCATE_DEVICE_ADDRESS_CAPTURE_REPLAY_BIT) && !enabled_features.bufferDeviceAddressCaptureReplay) {\n    skip |= LogError(\"VUID-VkMemoryAllocateInfo-flags-03330\", device, flags_loc,\n                     \"has VK_MEMORY_ALLOCATE_DEVICE_ADDRESS_CAPTURE_REPLAY_BIT set, but\"\n                     \"bufferDeviceAddressCaptureReplay feature is not enabled.\");\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkDeviceImageMemoryRequirements-pCreateInfo-06419\", \"If pCreateInfo->flags has VK_IMAGE_CREATE_DISJOINT_BIT set and if the pCreateInfo->tiling is VK_IMAGE_TILING_LINEAR or VK_IMAGE_TILING_OPTIMAL, then planeAspect must be a single valid multi-planar aspect mask bit\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "!IsOnlyOneValidPlaneAspect(create_info.format, memory_requirements.planeAspect)) {\nskip |= LogError(\"VUID-VkDeviceImageMemoryRequirements-pCreateInfo-06419\", device, loc.dot(Field::planeAspect),\n          \"is %s but is invalid for %s.\", string_VkImageAspectFlags(memory_requirements.planeAspect).c_str(),\n          string_VkFormat(create_info.format));\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-vkSetDeviceMemoryPriorityEXT-priority-06258\", \"priority must be between 0 and 1, inclusive\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (!IsBetweenInclusive(priority, 0.0F, 1.0F)) {\n    skip |= LogError(\"VUID-vkSetDeviceMemoryPriorityEXT-priority-06258\", device, error_obj.location.dot(Field::priority),\n                     \"is %f.\", priority);\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkImportFenceFdInfoKHR-handleType-07306\", \"If handleType refers to a handle type with copy payload transference semantics, flags must contain VK_FENCE_IMPORT_TEMPORARY_BIT\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (pImportFenceFdInfo->handleType == VK_EXTERNAL_FENCE_HANDLE_TYPE_SYNC_FD_BIT &&\n    (pImportFenceFdInfo->flags & VK_FENCE_IMPORT_TEMPORARY_BIT) == 0) {\n    skip |= LogError(\"VUID-VkImportFenceFdInfoKHR-handleType-07306\", pImportFenceFdInfo->fence, info_loc.dot(Field::handleType),\n                     \"is VK_EXTERNAL_FENCE_HANDLE_TYPE_SYNC_FD_BIT so\"\n                     \" VK_FENCE_IMPORT_TEMPORARY_BIT must be set, but flags is 0x%x\",\n                     pImportFenceFdInfo->flags);\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkImportSemaphoreWin32HandleInfoKHR-handle-01469\", \"If handle is not NULL, name must be NULL\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (info->handle && info->name) {\n    skip |= LogError(\"VUID-VkImportSemaphoreWin32HandleInfoKHR-handle-01469\", info->semaphore,\n                     error_obj.location.dot(Field::pImportSemaphoreWin32HandleInfo),\n                     \"both handle (%p) and name (%p) are non-NULL\", info->handle, reinterpret_cast<const void *>(info->name));\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkMemoryAllocateInfo-opaqueCaptureAddress-03329\", \"If VkMemoryOpaqueCaptureAddressAllocateInfo::opaqueCaptureAddress is not zero, VkMemoryAllocateFlagsInfo::flags must include VK_MEMORY_ALLOCATE_DEVICE_ADDRESS_CAPTURE_REPLAY_BIT\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (!(flags & VK_MEMORY_ALLOCATE_DEVICE_ADDRESS_CAPTURE_REPLAY_BIT)) {\n    skip |= LogError(\"VUID-VkMemoryAllocateInfo-opaqueCaptureAddress-03329\", device, address_loc,\n                     \"is non-zero (%\" PRIu64\n                     \") so VkMemoryAllocateFlagsInfo::flags must include \"\n                     \"VK_MEMORY_ALLOCATE_DEVICE_ADDRESS_CAPTURE_REPLAY_BIT.\",\n                     opaque_alloc_info->opaqueCaptureAddress);\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkMemoryAllocateInfo-pNext-00641\", \"If the pNext chain includes a VkImportMemoryWin32HandleInfoKHR structure, it must not include a VkImportMemoryWin32HandleInfoNV structure\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (ext.import_info_win32 && ext.import_info_win32_nv) {\n    skip |= LogError(\"VUID-VkMemoryAllocateInfo-pNext-00641\", device, allocate_info_loc,\n                     \"pNext chain includes both VkImportMemoryWin32HandleInfoKHR and \"\n                     \"VkImportMemoryWin32HandleInfoNV\");\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkMemoryAllocateInfo-allocationSize-01745\", \"If the parameters define an import operation and the external handle is a host pointer, allocationSize must be an integer multiple of VkPhysicalDeviceExternalMemoryHostPropertiesEXT::minImportedHostPointerAlignment\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (SafeModulo(allocate_info.allocationSize,\n    skip |= LogError(\"VUID-VkMemoryAllocateInfo-allocationSize-01745\", device, allocate_info_loc.dot(Field::allocationSize),\n                     \"(%\" PRIuLEAST64 \") is not a multiple of minImportedHostPointerAlignment (%\" PRIuLEAST64 \")\",\n                     allocate_info.allocationSize,\n                     phys_dev_ext_props.external_memory_host_props.minImportedHostPointerAlignment);\n"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkFramebufferCreateInfo-flags-03190\", \"If flags includes VK_FRAMEBUFFER_CREATE_IMAGELESS_BIT, the pNext chain must include a VkFramebufferAttachmentsCreateInfo structure\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (framebuffer_attachments_create_info == nullptr) {\n    skip |= LogError(\"VUID-VkFramebufferCreateInfo-flags-03190\", device, create_info_loc.dot(Field::flags),\n                     \"includes VK_FRAMEBUFFER_CREATE_IMAGELESS_BIT, but no instance of VkFramebufferAttachmentsCreateInfo \"\n                     \"is present in the pNext chain.\");\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkFramebufferCreateInfo-width-00886\", \"width must be less than or equal to maxFramebufferWidth\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (pCreateInfo->width > device_limits.maxFramebufferWidth) {\n    skip |= LogError(\"VUID-VkFramebufferCreateInfo-width-00886\", device, create_info_loc.dot(Field::width),\n                     \"(%\" PRIu32 \") exceeds physical device limits (%\" PRIu32 \").\", pCreateInfo->width,\n                     device_limits.maxFramebufferWidth);\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkImageCreateInfo-extent-00944\", \"extent.width must be greater than 0\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "skip |= ValidateNotZero(pCreateInfo->extent.width == 0, \"VUID-VkImageCreateInfo-extent-00944\",\n                        create_info_loc.dot(Field::extent).dot(Field::width));\n"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkImageCreateInfo-initialLayout-00993\", \"initialLayout must be VK_IMAGE_LAYOUT_UNDEFINED or VK_IMAGE_LAYOUT_PREINITIALIZED\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if ((pCreateInfo->initialLayout != VK_IMAGE_LAYOUT_UNDEFINED) &&\n    (pCreateInfo->initialLayout != VK_IMAGE_LAYOUT_PREINITIALIZED)) {\n    skip |= LogError(\"VUID-VkImageCreateInfo-initialLayout-00993\", device, create_info_loc.dot(Field::initialLayout),\n                     \"is %s, but must be UNDEFINED or PREINITIALIZED.\", string_VkImageLayout(pCreateInfo->initialLayout));\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkImageCreateInfo-imageType-00957\", \"If imageType is VK_IMAGE_TYPE_2D, extent.depth must be 1\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (pCreateInfo->extent.depth != 1) {\n    skip |= LogError(\"VUID-VkImageCreateInfo-imageType-00957\", device, create_info_loc,\n                     \"if pCreateInfo->imageType is VK_IMAGE_TYPE_2D, pCreateInfo->extent.depth must be 1.\");\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkImageCreateInfo-flags-00950\", \"If flags contains VK_IMAGE_CREATE_2D_ARRAY_COMPATIBLE_BIT, imageType must be VK_IMAGE_TYPE_3D\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if ((image_flags & VK_IMAGE_CREATE_2D_ARRAY_COMPATIBLE_BIT) && (pCreateInfo->imageType != VK_IMAGE_TYPE_3D)) {\n    skip |= LogError(\"VUID-VkImageCreateInfo-flags-00950\", device, create_info_loc.dot(Field::flags),\n                     \"includes VK_IMAGE_CREATE_2D_ARRAY_COMPATIBLE_BIT but \"\n                     \"imageType is %s.\",\n                     string_VkImageType(pCreateInfo->imageType));\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkImageCreateInfo-tiling-02261\", \"If tiling is VK_IMAGE_TILING_DRM_FORMAT_MODIFIER_EXT, then the pNext chain must include exactly one of VkImageDrmFormatModifierListCreateInfoEXT or VkImageDrmFormatModifierExplicitCreateInfoEXT structures\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "skip |= LogError(\"VUID-VkImageCreateInfo-tiling-02261\", device, create_info_loc.dot(Field::tiling),\n                 \"is VK_IMAGE_TILING_DRM_FORMAT_MODIFIER_EXT but pNext has both \"\n                 \"VkImageDrmFormatModifierListCreateInfoEXT and \"\n                 \"VkImageDrmFormatModifierExplicitCreateInfoEXT.\");\n"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkImageDrmFormatModifierExplicitCreateInfoEXT-arrayPitch-02268\", \"For each element of pPlaneLayouts, arrayPitch must be 0 if VkImageCreateInfo::arrayLayers is 1\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (pCreateInfo->arrayLayers == 1 && drm_format_mod_explict->pPlaneLayouts[i].arrayPitch != 0) {\n    skip |= LogError(\"VUID-VkImageDrmFormatModifierExplicitCreateInfoEXT-arrayPitch-02268\", device,\n                     drm_loc.dot(Field::arrayPitch), \"is %\" PRIu64 \" and arrayLayers is 1.\",\n                     drm_format_mod_explict->pPlaneLayouts[i].arrayPitch);\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkImageCreateInfo-flags-02557\", \"If flags contains VK_IMAGE_USAGE_FRAGMENT_DENSITY_MAP_BIT_EXT, imageType must be VK_IMAGE_TYPE_2D\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (pCreateInfo->imageType != VK_IMAGE_TYPE_2D) {\n    skip |= LogError(\"VUID-VkImageCreateInfo-flags-02557\", device, create_info_loc.dot(Field::usage),\n                     \"includes VK_IMAGE_USAGE_FRAGMENT_DENSITY_MAP_BIT_EXT, but imageType is %s.\",\n                     string_VkImageType(pCreateInfo->imageType));\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkImageCreateInfo-flags-02568\", \"If flags contains VK_IMAGE_CREATE_SUBSAMPLED_BIT_EXT, mipLevels must be 1\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (pCreateInfo->mipLevels != 1) {\n    skip |= LogError(\"VUID-VkImageCreateInfo-flags-02568\", device, create_info_loc.dot(Field::flags),\n                     \"includes VK_IMAGE_CREATE_SUBSAMPLED_BIT_EXT, but mipLevels is %\" PRIu32 \".\", pCreateInfo->mipLevels);\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkImageCreateInfo-pNext-06722\", \"If a VkImageFormatListCreateInfo structure was included in the pNext chain and format is not a multi-planar format and VkImageFormatListCreateInfo::viewFormatCount is not zero, then each format in VkImageFormatListCreateInfo::pViewFormats must either be compatible with the format as described in the compatibility table or, if flags contains VK_IMAGE_CREATE_BLOCK_TEXEL_VIEW_COMPATIBLE_BIT, be an uncompressed format that is size-compatible with format\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "skip |= LogError(\"VUID-VkImageCreateInfo-pNext-06722\", device, format_loc,\n                 \"(%s) and VkImageCreateInfo::format (%s) are not compatible.\", string_VkFormat(view_format),\n                 string_VkFormat(image_format));\n"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkImageCreateInfo-flags-00987\", \"If flags contains VK_IMAGE_CREATE_SPARSE_RESIDENCY_BIT or VK_IMAGE_CREATE_SPARSE_ALIASED_BIT, it must also contain VK_IMAGE_CREATE_SPARSE_BINDING_BIT\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (((image_flags & (VK_IMAGE_CREATE_SPARSE_RESIDENCY_BIT | VK_IMAGE_CREATE_SPARSE_ALIASED_BIT)) != 0) &&\n    skip |= LogError(\"VUID-VkImageCreateInfo-flags-00987\", device, create_info_loc.dot(Field::flags), \"is %s.\",\n                     string_VkImageCreateFlags(image_flags).c_str());\n"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkImageCreateInfo-imageType-00973\", \"If the sparseResidency2Samples feature is not enabled, imageType is VK_IMAGE_TYPE_2D, and samples is VK_SAMPLE_COUNT_2_BIT, flags must not contain VK_IMAGE_CREATE_SPARSE_RESIDENCY_BIT\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if ((!enabled_features.sparseResidency2Samples) && (VK_SAMPLE_COUNT_2_BIT == create_info.samples)) {\n    skip |= LogError(\"VUID-VkImageCreateInfo-imageType-00973\", device, create_info_loc.dot(Field::flags),\n                     \"includes VK_IMAGE_CREATE_SPARSE_BINDING_BIT and imageType is VK_IMAGE_TYPE_2D and samples is \"\n                     \"VK_SAMPLE_COUNT_2_BIT, but sparseResidency2Samples feature was not enabled.\");\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkImageCreateInfo-samples-02083\", \"If usage includes VK_IMAGE_USAGE_FRAGMENT_SHADING_RATE_ATTACHMENT_BIT_KHR, samples must be VK_SAMPLE_COUNT_1_BIT\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (create_info.samples != VK_SAMPLE_COUNT_1_BIT) {\n    skip |= LogError(\"VUID-VkImageCreateInfo-samples-02083\", device, create_info_loc.dot(Field::usage),\n                     \"includes VK_IMAGE_USAGE_FRAGMENT_SHADING_RATE_ATTACHMENT_BIT_KHR (or the \"\n                     \"alias VK_IMAGE_USAGE_SHADING_RATE_IMAGE_BIT_NV), but samples is %s.\",\n                     string_VkSampleCountFlagBits(create_info.samples));\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkImageCreateInfo-flags-02053\", \"If flags contains VK_IMAGE_CREATE_CORNER_SAMPLED_BIT_NV and imageType is VK_IMAGE_TYPE_3D, extent.width, extent.height, and extent.depth must be greater than 1\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "skip |= LogError(\"VUID-VkImageCreateInfo-flags-02053\", device, create_info_loc.dot(Field::flags),\n                 \"includes VK_IMAGE_CREATE_CORNER_SAMPLED_BIT_NV and \"\n                 \"imageType is VK_IMAGE_TYPE_3D, extent.width, extent.height, and extent.depth \"\n                 \"must be greater than 1.\");\n"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkImageCreateInfo-format-02538\", \"If the shaderStorageImageMultisample feature is not enabled, format is a depth-stencil format and the pNext chain includes a VkImageStencilUsageCreateInfo structure with its stencilUsage including VK_IMAGE_USAGE_STORAGE_BIT, samples must be VK_SAMPLE_COUNT_1_BIT\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (!enabled_features.shaderStorageImageMultisample &&\n    skip |= LogError(\"VUID-VkImageCreateInfo-format-02538\", device,\n                     create_info_loc.pNext(Struct::VkImageStencilUsageCreateInfo, Field::stencilUsage),\n                     \"includes VK_IMAGE_USAGE_STORAGE_BIT and format is %s and samples is %s, but \"\n                     \"shaderStorageImageMultisample feature was not enabled.\",\n                     string_VkFormat(create_info.format), string_VkSampleCountFlagBits(create_info.samples));\n"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkImageCreateInfo-pNext-06783\", \"If the pNext chain includes a VkExportMetalObjectCreateInfoEXT structure, its exportObjectType member must be either VK_EXPORT_METAL_OBJECT_TYPE_METAL_TEXTURE_BIT_EXT or VK_EXPORT_METAL_OBJECT_TYPE_METAL_IOSURFACE_BIT_EXT\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if ((export_metal_object_info->exportObjectType != VK_EXPORT_METAL_OBJECT_TYPE_METAL_TEXTURE_BIT_EXT) &&\n    skip |= LogError(\"VUID-VkImageCreateInfo-pNext-06783\", device,\n                     create_info_loc.pNext(Struct::VkExportMetalObjectCreateInfoEXT, Field::exportObjectType),\n                     \"is %s, but only VkExportMetalObjectCreateInfoEXT structs with exportObjectType of \"\n                     \"VK_EXPORT_METAL_OBJECT_TYPE_METAL_TEXTURE_BIT_EXT or \"\n                     \"VK_EXPORT_METAL_OBJECT_TYPE_METAL_IOSURFACE_BIT_EXT are allowed\",\n                     string_VkExportMetalObjectTypeFlagBitsEXT(export_metal_object_info->exportObjectType));\n"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkImageViewCreateInfo-viewType-02961\", \"If viewType is VK_IMAGE_VIEW_TYPE_CUBE_ARRAY and subresourceRange.layerCount is not VK_REMAINING_ARRAY_LAYERS, subresourceRange.layerCount must be a multiple of 6\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (pCreateInfo->viewType == VK_IMAGE_VIEW_TYPE_CUBE_ARRAY && (pCreateInfo->subresourceRange.layerCount % 6) != 0) {\n    skip |= LogError(\"VUID-VkImageViewCreateInfo-viewType-02961\", pCreateInfo->image,\n                     create_info_loc.dot(Field::subresourceRange).dot(Field::layerCount),\n                     \"(%\" PRIu32 \") must be a multiple of 6 or VK_REMAINING_ARRAY_LAYERS.\",\n                     pCreateInfo->subresourceRange.layerCount);\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkDeviceImageSubresourceInfoKHR-format-08886\", \"If format of the image is a color format that is not a multi-planar image format, and tiling of the pCreateInfo is VK_IMAGE_TILING_LINEAR or VK_IMAGE_TILING_OPTIMAL, the aspectMask member of pSubresource must be VK_IMAGE_ASPECT_COLOR_BIT\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (vkuFormatIsColor(image_format) && !vkuFormatIsMultiplane(image_format) && (aspect_mask != VK_IMAGE_ASPECT_COLOR_BIT) &&\n    skip |= LogError(\"VUID-VkDeviceImageSubresourceInfoKHR-format-08886\", device, subresource_loc.dot(Field::aspectMask),\n                     \"(%s) is invalid with %s (%s).\", string_VkImageAspectFlags(aspect_mask).c_str(),\n                     create_info_loc.dot(Field::format).Fields().c_str(), string_VkFormat(image_format));\n"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkApplicationInfo-apiVersion-04010\", \"If apiVersion is not 0, then it must be greater than or equal to VK_API_VERSION_1_0\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if ((api_version_nopatch < VK_API_VERSION_1_0) && (local_api_version != 0)) {\n    skip |= LogError(\"VUID-VkApplicationInfo-apiVersion-04010\", instance,\n                     create_info_loc.dot(Field::pApplicationInfo).dot(Field::apiVersion),\n                     \"is (0x%08x). \"\n                     \"Using VK_API_VERSION_%\" PRIu32 \"_%\" PRIu32 \".\",\n                     local_api_version, api_version.Major(), api_version.Minor());\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkInstanceCreateInfo-pNext-04926\", \"If the pNext chain of VkInstanceCreateInfo includes a VkDebugUtilsMessengerCreateInfoEXT structure, the list of enabled extensions in ppEnabledExtensionNames must contain VK_EXT_debug_utils\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (debug_utils_messenger && !local_instance_extensions.vk_ext_debug_utils) {\n    skip |= LogError(\"VUID-VkInstanceCreateInfo-pNext-04926\", instance, create_info_loc.dot(Field::ppEnabledExtensionNames),\n                     \"does not include VK_EXT_debug_utils, but the pNext chain includes VkDebugUtilsMessengerCreateInfoEXT.\");\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkDeviceCreateInfo-None-08095\", \"If descriptorBuffer is enabled, ppEnabledExtensionNames must not contain VK_AMD_shader_fragment_mask\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (descriptor_buffer_features && descriptor_buffer_features->descriptorBuffer && fragmentmask_requested) {\n    skip |= LogError(\"VUID-VkDeviceCreateInfo-None-08095\", physicalDevice, error_obj.location,\n                     \"If the descriptorBuffer feature is enabled, ppEnabledExtensionNames must not \"\n                     \"contain VK_AMD_shader_fragment_mask.\");\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkDeviceCreateInfo-pNext-02830\", \"If the pNext chain includes a VkPhysicalDeviceVulkan12Features structure, then it must not include a VkPhysicalDevice8BitStorageFeatures, VkPhysicalDeviceShaderAtomicInt64Features, VkPhysicalDeviceShaderFloat16Int8Features, VkPhysicalDeviceDescriptorIndexingFeatures, VkPhysicalDeviceScalarBlockLayoutFeatures, VkPhysicalDeviceImagelessFramebufferFeatures, VkPhysicalDeviceUniformBufferStandardLayoutFeatures, VkPhysicalDeviceShaderSubgroupExtendedTypesFeatures, VkPhysicalDeviceSeparateDepthStencilLayoutsFeatures, VkPhysicalDeviceHostQueryResetFeatures, VkPhysicalDeviceTimelineSemaphoreFeatures, VkPhysicalDeviceBufferDeviceAddressFeatures, or VkPhysicalDeviceVulkanMemoryModelFeatures structure\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "skip |= LogError(\"VUID-VkDeviceCreateInfo-pNext-02830\", physicalDevice, error_obj.location,\n                 \"If the pNext chain includes a VkPhysicalDeviceVulkan12Features structure, then it must not \"\n                 \"include a %s structure\",\n                 string_VkStructureType(current->sType));\n"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkPhysicalDeviceVariablePointersFeatures-variablePointers-01431\", \"If variablePointers is enabled then variablePointersStorageBuffer must also be enabled\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if ((variable_pointers == VK_TRUE) && (variable_pointers_storage_buffer == VK_FALSE)) {\n    skip |= LogError(\"VUID-VkPhysicalDeviceVariablePointersFeatures-variablePointers-01431\", physicalDevice, error_obj.location,\n                     \"If variablePointers is VK_TRUE then variablePointersStorageBuffer also needs to be VK_TRUE\");\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkPhysicalDeviceImageFormatInfo2-tiling-02249\", \"tiling must be VK_IMAGE_TILING_DRM_FORMAT_MODIFIER_EXT if and only if the pNext chain includes VkPhysicalDeviceImageDrmFormatModifierInfoEXT\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (pImageFormatInfo->tiling == VK_IMAGE_TILING_DRM_FORMAT_MODIFIER_EXT) {\n    skip |= LogError(\"VUID-VkPhysicalDeviceImageFormatInfo2-tiling-02249\", physicalDevice,\n                     format_info_loc.dot(Field::tiling),\n                     \"is VK_IMAGE_TILING_DRM_FORMAT_MODIFIER_EXT, but pNext chain not include \"\n                     \"VkPhysicalDeviceImageDrmFormatModifierInfoEXT.\");\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkDebugUtilsObjectNameInfoEXT-objectType-02589\", \"If objectType is VK_OBJECT_TYPE_UNKNOWN, objectHandle must not be VK_NULL_HANDLE\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if ((pNameInfo->objectType == VK_OBJECT_TYPE_UNKNOWN) && (pNameInfo->objectHandle == HandleToUint64(VK_NULL_HANDLE))) {\n    skip |= LogError(\"VUID-VkDebugUtilsObjectNameInfoEXT-objectType-02589\", device, name_info_loc.dot(Field::objectType),\n                     \"is VK_OBJECT_TYPE_UNKNOWN but objectHandle is VK_NULL_HANDLE\");\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkPushConstantRange-size-00298\", \"size must be less than or equal to VkPhysicalDeviceLimits::maxPushConstantsSize minus offset\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (size > max_push_constants_size - offset) {\n    skip |= LogError(\"VUID-VkPushConstantRange-size-00298\", device, pc_loc.dot(Field::offset),\n                     \"(%\" PRIu32 \") and size (%\" PRIu32\n                     \") \"\n                     \"together exceeds this device's maxPushConstantSize of %\" PRIu32 \".\",\n                     offset, size, max_push_constants_size);\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkPipelineShaderStageCreateInfo-pName-parameter\", \"pName must be a null-terminated UTF-8 string\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (create_info.pName) {\n    skip |= ValidateString(loc.dot(Field::pName), \"VUID-VkPipelineShaderStageCreateInfo-pName-parameter\", create_info.pName);\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkPipelineRenderingCreateInfo-colorAttachmentCount-09533\", \"colorAttachmentCount must be less than or equal to maxColorAttachments\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (rendering_struct.colorAttachmentCount > device_limits.maxColorAttachments) {\n    skip |= LogError(\"VUID-VkPipelineRenderingCreateInfo-colorAttachmentCount-09533\", device,\n                     loc.pNext(Struct::VkPipelineRenderingCreateInfo, Field::colorAttachmentCount),\n                     \"(%\" PRIu32 \") is larger than maxColorAttachments (%\" PRIu32 \").\",\n                     rendering_struct.colorAttachmentCount, device_limits.maxColorAttachments);\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkGraphicsPipelineCreateInfo-flags-03374\", \"flags must not include VK_PIPELINE_CREATE_RAY_TRACING_NO_NULL_MISS_SHADERS_BIT_KHR\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if ((flags & VK_PIPELINE_CREATE_RAY_TRACING_NO_NULL_MISS_SHADERS_BIT_KHR) != 0) {\n    skip |= LogError(\"VUID-VkGraphicsPipelineCreateInfo-flags-03374\", device, flags_loc,\n                     \"(%s) must not include VK_PIPELINE_CREATE_RAY_TRACING_NO_NULL_MISS_SHADERS_BIT_KHR.\",\n                     string_VkPipelineCreateFlags2KHR(flags).c_str());\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkGraphicsPipelineCreateInfo-flags-04947\", \"flags must not include VK_PIPELINE_CREATE_RAY_TRACING_ALLOW_MOTION_BIT_NV\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if ((flags & VK_PIPELINE_CREATE_RAY_TRACING_ALLOW_MOTION_BIT_NV) != 0) {\n    skip |= LogError(\"VUID-VkGraphicsPipelineCreateInfo-flags-04947\", device, flags_loc,\n                     \"(%s) must not include VK_PIPELINE_CREATE_RAY_TRACING_ALLOW_MOTION_BIT_NV.\",\n                     string_VkPipelineCreateFlags2KHR(flags).c_str());\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkGraphicsPipelineCreateInfo-pDynamicStates-04133\", \"If the pipeline requires pre-rasterization shader state, and VK_DYNAMIC_STATE_SCISSOR_WITH_COUNT is included in the pDynamicStates array then VK_DYNAMIC_STATE_SCISSOR must not be present\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (has_pre_raster_state && vvl::Contains(dynamic_state_map, VK_DYNAMIC_STATE_SCISSOR_WITH_COUNT) &&\n    skip |= LogError(\"VUID-VkGraphicsPipelineCreateInfo-pDynamicStates-04133\", device,\n                     create_info_loc.dot(Field::pDynamicState),\n                     \"pDynamicStates[%\" PRIu32 \"] is VK_DYNAMIC_STATE_SCISSOR_WITH_COUNT and pDynamicStates[%\" PRIu32\n                     \"] is VK_DYNAMIC_STATE_SCISSOR.\",\n                     dynamic_state_map[VK_DYNAMIC_STATE_SCISSOR_WITH_COUNT], dynamic_state_map[VK_DYNAMIC_STATE_SCISSOR]);\n"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkPipelineVertexInputStateCreateInfo-pVertexBindingDescriptions-00616\", \"All elements of pVertexBindingDescriptions must describe distinct binding numbers\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (binding_it != vertex_bindings.cend()) {\n    skip |= LogError(\"VUID-VkPipelineVertexInputStateCreateInfo-pVertexBindingDescriptions-00616\", device,\n                     binding_loc.dot(Field::binding),\n                     \"(%\" PRIu32 \") is already in pVertexBindingDescription[%\" PRIu32 \"].\",\n                     vertex_bind_desc.binding, *binding_it);\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkVertexInputAttributeDescription-location-00620\", \"location must be less than VkPhysicalDeviceLimits::maxVertexInputAttributes\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (vertex_attrib_desc.location >= device_limits.maxVertexInputAttributes) {\n    skip |= LogError(\"VUID-VkVertexInputAttributeDescription-location-00620\", device,\n                     attribute_loc.dot(Field::location),\n                     \"(%\" PRIu32 \") is larger than or equal to maxVertexInputAttributes (%\" PRIu32 \").\",\n                     vertex_attrib_desc.location, device_limits.maxVertexInputAttributes);\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkPipelineViewportStateCreateInfo-scissorCount-04136\", \"If the graphics pipeline is being created with VK_DYNAMIC_STATE_SCISSOR_WITH_COUNT set then scissorCount must be 0, otherwise scissorCount must be greater than 0\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (viewport_state.scissorCount == 0) {\n    skip |= LogError(\"VUID-VkPipelineViewportStateCreateInfo-scissorCount-04136\", device,\n                     viewport_loc.dot(Field::scissorCount),\n                     \"can't be 0 unless VK_DYNAMIC_STATE_SCISSOR_WITH_COUNT is used.\");\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkPipelineViewportStateCreateInfo-offset-02823\", \"Evaluation of (offset.y + extent.height) must not cause a signed integer addition overflow for any element of pScissors\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (y_sum > std::numeric_limits<int32_t>::max()) {\n    skip |= LogError(\"VUID-VkPipelineViewportStateCreateInfo-offset-02823\", device, scissor_loc,\n                     \"offset.y (%\" PRId32 \") + extent.height (%\" PRId32 \") is %\" PRIi64\n                     \" which will overflow int32_t.\",\n                     scissor.offset.y, scissor.extent.height, y_sum);\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkGraphicsPipelineCreateInfo-pDynamicStates-04131\", \"If the pipeline requires pre-rasterization shader state, and pViewportState->pScissors is not dynamic, then pViewportState->pScissors must be a valid pointer to an array of pViewportState->scissorCount VkRect2D structures\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (!has_dynamic_scissor && !has_dynamic_scissor_with_count && viewport_state.scissorCount > 0 &&\n    skip |= LogError(\"VUID-VkGraphicsPipelineCreateInfo-pDynamicStates-04131\", device,\n                     viewport_loc.dot(Field::pScissors), \"is NULL, but the scissor state is not dynamic.\");\n"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkPipelineMultisampleStateCreateInfo-minSampleShading-00786\", \"minSampleShading must be in the range [0,1]\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (!IsBetweenInclusive(create_info.pMultisampleState->minSampleShading, 0.F, 1.0F)) {\n    skip |= LogError(\"VUID-VkPipelineMultisampleStateCreateInfo-minSampleShading-00786\", device,\n                     ms_loc.dot(Field::minSampleShading), \"is %f.\",\n                     create_info.pMultisampleState->minSampleShading);\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkGraphicsPipelineCreateInfo-stippledLineEnable-02767\", \"If the pipeline requires pre-rasterization shader state, the stippledLineEnable member of VkPipelineRasterizationLineStateCreateInfoKHR is VK_TRUE, and no element of the pDynamicStates member of pDynamicState is VK_DYNAMIC_STATE_LINE_STIPPLE_EXT, then the lineStippleFactor member of VkPipelineRasterizationLineStateCreateInfoKHR must be in the range [1,256]\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (line_state->lineStippleFactor < 1 || line_state->lineStippleFactor > 256) {\n    skip |= LogError(\"VUID-VkGraphicsPipelineCreateInfo-stippledLineEnable-02767\", device,\n                     rasterization_loc.pNext(Struct::VkPipelineRasterizationLineStateCreateInfoKHR,\n                                             Field::lineStippleFactor),\n                     \"is %\" PRIu32 \".\", line_state->lineStippleFactor);\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkPipelineRasterizationLineStateCreateInfoKHR-stippledLineEnable-02772\", \"If stippledLineEnable is VK_TRUE and lineRasterizationMode is VK_LINE_RASTERIZATION_MODE_BRESENHAM_KHR, then the stippledBresenhamLines feature must be enabled\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (line_state->lineRasterizationMode == VK_LINE_RASTERIZATION_MODE_BRESENHAM_KHR &&\n    skip |= LogError(\"VUID-VkPipelineRasterizationLineStateCreateInfoKHR-stippledLineEnable-02772\", device,\n                     rasterization_loc.pNext(Struct::VkPhysicalDeviceLineRasterizationFeaturesKHR,\n                                             Field::lineRasterizationMode),\n                     \"is VK_LINE_RASTERIZATION_MODE_BRESENHAM_KHR and stippledLineEnable was VK_TRUE, but \"\n                     \"the stippledBresenhamLines feature was not enabled.\");\n"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkComputePipelineCreateInfo-flags-03365\", \"flags must not include VK_PIPELINE_CREATE_RAY_TRACING_NO_NULL_ANY_HIT_SHADERS_BIT_KHR\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if ((flags & VK_PIPELINE_CREATE_RAY_TRACING_NO_NULL_ANY_HIT_SHADERS_BIT_KHR) != 0) {\n    skip |= LogError(\"VUID-VkComputePipelineCreateInfo-flags-03365\", device, flags_loc,\n                     \"(%s) must not include VK_PIPELINE_CREATE_RAY_TRACING_NO_NULL_ANY_HIT_SHADERS_BIT_KHR.\",\n                     string_VkPipelineCreateFlags2KHR(flags).c_str());\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkComputePipelineCreateInfo-flags-03370\", \"flags must not include VK_PIPELINE_CREATE_RAY_TRACING_SKIP_AABBS_BIT_KHR\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if ((flags & VK_PIPELINE_CREATE_RAY_TRACING_SKIP_AABBS_BIT_KHR) != 0) {\n    skip |= LogError(\"VUID-VkComputePipelineCreateInfo-flags-03370\", device, flags_loc,\n                     \"(%s) must not include VK_PIPELINE_CREATE_RAY_TRACING_SKIP_AABBS_BIT_KHR.\",\n                     string_VkPipelineCreateFlags2KHR(flags).c_str());\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkComputePipelineCreateInfo-stage-00701\", \"The stage member of stage must be VK_SHADER_STAGE_COMPUTE_BIT\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (create_info.stage.stage != VK_SHADER_STAGE_COMPUTE_BIT) {\n    skip |= LogError(\"VUID-VkComputePipelineCreateInfo-stage-00701\", device,\n                     create_info_loc.dot(Field::stage).dot(Field::stage), \"is %s.\",\n                     string_VkShaderStageFlagBits(create_info.stage.stage));\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkGeometryTrianglesNV-vertexFormat-02430\", \"vertexFormat must be one of VK_FORMAT_R32G32B32_SFLOAT, VK_FORMAT_R32G32_SFLOAT, VK_FORMAT_R16G16B16_SFLOAT, VK_FORMAT_R16G16_SFLOAT, VK_FORMAT_R16G16_SNORM, or VK_FORMAT_R16G16B16_SNORM\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (triangles.vertexFormat != VK_FORMAT_R32G32B32_SFLOAT && triangles.vertexFormat != VK_FORMAT_R16G16B16_SFLOAT &&\n    triangles.vertexFormat != VK_FORMAT_R16G16B16_SNORM && triangles.vertexFormat != VK_FORMAT_R32G32_SFLOAT &&\n    triangles.vertexFormat != VK_FORMAT_R16G16_SFLOAT && triangles.vertexFormat != VK_FORMAT_R16G16_SNORM) {\n    skip |= LogError(\"VUID-VkGeometryTrianglesNV-vertexFormat-02430\", object_handle, loc, \"is invalid.\");\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkGeometryTrianglesNV-indexData-02434\", \"indexData must be VK_NULL_HANDLE if indexType is VK_INDEX_TYPE_NONE_NV\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (triangles.indexData != VK_NULL_HANDLE) {\n    skip |= LogError(\"VUID-VkGeometryTrianglesNV-indexData-02434\", object_handle, loc, \"is invalid.\");\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkAccelerationStructureInfoNV-type-02426\", \"If type is VK_ACCELERATION_STRUCTURE_TYPE_BOTTOM_LEVEL_NV then instanceCount must be 0\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (info.type == VK_ACCELERATION_STRUCTURE_TYPE_BOTTOM_LEVEL_NV && info.instanceCount != 0) {\n    skip |= LogError(\"VUID-VkAccelerationStructureInfoNV-type-02426\", object_handle, loc,\n                     \"If type is VK_ACCELERATION_STRUCTURE_TYPE_BOTTOM_LEVEL_NV then \"\n                     \"instanceCount must be 0.\");\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkAccelerationStructureInfoNV-type-02786\", \"If type is VK_ACCELERATION_STRUCTURE_TYPE_BOTTOM_LEVEL_NV then the geometryType member of each geometry in pGeometries must be the same\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (geometry.geometryType != first_geometry_type) {\n    skip |= LogError(\"VUID-VkAccelerationStructureInfoNV-type-02786\", object_handle, loc,\n                     \"info.pGeometries[%\" PRIu32\n                     \"].geometryType does not match \"\n                     \"info.pGeometries[0].geometryType.\",\n                     i);\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkAccelerationStructureCreateInfoKHR-deviceAddress-03612\", \"If deviceAddress is not zero, createFlags must include VK_ACCELERATION_STRUCTURE_CREATE_DEVICE_ADDRESS_CAPTURE_REPLAY_BIT_KHR\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (pCreateInfo->deviceAddress &&\n    skip |= LogError(\"VUID-VkAccelerationStructureCreateInfoKHR-deviceAddress-03612\", device,\n                     create_info_loc.dot(Field::createFlags), \"is %s, but deviceAddress (%\" PRIu64 \") is not zero.\",\n                     string_VkAccelerationStructureCreateFlagsKHR(pCreateInfo->createFlags).c_str(),\n                     pCreateInfo->deviceAddress);\n"
        },
        {
            "role": "user",
            "content": "{\"VUID-vkCmdWriteAccelerationStructuresPropertiesNV-queryType-06216\", \"queryType must be VK_QUERY_TYPE_ACCELERATION_STRUCTURE_COMPACTED_SIZE_NV\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (queryType != VK_QUERY_TYPE_ACCELERATION_STRUCTURE_COMPACTED_SIZE_NV) {\n    skip |= LogError(\"VUID-vkCmdWriteAccelerationStructuresPropertiesNV-queryType-06216\", device, error_obj.location,\n                     \"queryType must be \"\n                     \"VK_QUERY_TYPE_ACCELERATION_STRUCTURE_COMPACTED_SIZE_NV.\");\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkRayTracingPipelineCreateInfoNV-flags-03459\", \"flags must not include VK_PIPELINE_CREATE_RAY_TRACING_NO_NULL_CLOSEST_HIT_SHADERS_BIT_KHR\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (flags & VK_PIPELINE_CREATE_RAY_TRACING_NO_NULL_CLOSEST_HIT_SHADERS_BIT_KHR) {\n    skip |= LogError(\"VUID-VkRayTracingPipelineCreateInfoNV-flags-03459\", device, flags_loc, \"is %s.\",\n                     string_VkPipelineCreateFlags2KHR(flags).c_str());\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkRayTracingPipelineCreateInfoNV-flags-03588\", \"flags must not include VK_PIPELINE_CREATE_RAY_TRACING_SHADER_GROUP_HANDLE_CAPTURE_REPLAY_BIT_KHR\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (flags & VK_PIPELINE_CREATE_RAY_TRACING_SHADER_GROUP_HANDLE_CAPTURE_REPLAY_BIT_KHR) {\n    skip |= LogError(\"VUID-VkRayTracingPipelineCreateInfoNV-flags-03588\", device, flags_loc, \"is %s\",\n                     string_VkPipelineCreateFlags2KHR(flags).c_str());\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkRayTracingPipelineCreateInfoNV-flags-07986\", \"If flags contains the VK_PIPELINE_CREATE_DERIVATIVE_BIT flag, basePipelineIndex must be -1 or basePipelineHandle must be VK_NULL_HANDLE\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (create_info.basePipelineHandle != VK_NULL_HANDLE) {\n    skip |= LogError(\"VUID-VkRayTracingPipelineCreateInfoNV-flags-07986\", device, flags_loc,\n                     \"is %s, %s is %\" PRId32 \", but %s is %s.\", string_VkPipelineCreateFlags2KHR(flags).c_str(),\n                     create_info_loc.dot(Field::basePipelineIndex).Fields().c_str(), create_info.basePipelineIndex,\n                     create_info_loc.dot(Field::basePipelineHandle).Fields().c_str(),\n                     FormatHandle(create_info.basePipelineHandle).c_str());\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-vkCreateRayTracingPipelinesKHR-flags-03816\", \"flags must not contain the VK_PIPELINE_CREATE_DISPATCH_BASE flag\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (flags & VK_PIPELINE_CREATE_DISPATCH_BASE) {\n    skip |= LogError(\"VUID-vkCreateRayTracingPipelinesKHR-flags-03816\", device, flags_loc, \"is %s.\",\n                     string_VkPipelineCreateFlags2KHR(flags).c_str());\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkRayTracingPipelineCreateInfoKHR-stage-06899\", \"The stage value in all pStages elements must be one of VK_SHADER_STAGE_RAYGEN_BIT_KHR, VK_SHADER_STAGE_ANY_HIT_BIT_KHR, VK_SHADER_STAGE_CLOSEST_HIT_BIT_KHR, VK_SHADER_STAGE_MISS_BIT_KHR, VK_SHADER_STAGE_INTERSECTION_BIT_KHR, or VK_SHADER_STAGE_CALLABLE_BIT_KHR\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if ((stage & kShaderStageAllRayTracing) == 0) {\n    skip |= LogError(\"VUID-VkRayTracingPipelineCreateInfoKHR-stage-06899\", device, stage_loc.dot(Field::stage),\n                     \"is %s.\", string_VkShaderStageFlagBits(stage));\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkRayTracingPipelineCreateInfoKHR-flags-07985\", \"If flags contains the VK_PIPELINE_CREATE_DERIVATIVE_BIT flag, and basePipelineHandle is VK_NULL_HANDLE, basePipelineIndex must be a valid index into the calling command's pCreateInfos parameter\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (create_info.basePipelineIndex < 0 || static_cast<uint32_t>(create_info.basePipelineIndex) >= createInfoCount) {\n    skip |= LogError(\"VUID-VkRayTracingPipelineCreateInfoKHR-flags-07985\", device, flags_loc,\n                     \"is %s but basePipelineIndex has invalid index value %\" PRId32 \".\",\n                     string_VkPipelineCreateFlags2KHR(flags).c_str(), create_info.basePipelineIndex);\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkRayTracingPipelineCreateInfoKHR-pLibraryInfo-07999\", \"If pLibraryInfo is NULL or its libraryCount is 0, stageCount must not be 0\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (create_info.stageCount == 0) {\n    skip |= LogError(\"VUID-VkRayTracingPipelineCreateInfoKHR-pLibraryInfo-07999\", device,\n                     create_info_loc.dot(Field::pLibraryInfo), \"is NULL and stageCount is zero.\");\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-vkCopyAccelerationStructureToMemoryKHR-accelerationStructureHostCommands-03584\", \"The VkPhysicalDeviceAccelerationStructureFeaturesKHR::accelerationStructureHostCommands feature must be enabled\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (!enabled_features.accelerationStructureHostCommands) {\n    skip |= LogError(\"VUID-vkCopyAccelerationStructureToMemoryKHR-accelerationStructureHostCommands-03584\", device,\n                     error_obj.location, \"accelerationStructureHostCommands feature was not enabled.\");\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-vkCopyAccelerationStructureKHR-accelerationStructureHostCommands-03582\", \"The VkPhysicalDeviceAccelerationStructureFeaturesKHR::accelerationStructureHostCommands feature must be enabled\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (!enabled_features.accelerationStructureHostCommands) {\n    skip |= LogError(\"VUID-vkCopyAccelerationStructureKHR-accelerationStructureHostCommands-03582\", device, error_obj.location,\n                     \"feature was not enabled.\");\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-vkCmdCopyMemoryToAccelerationStructureKHR-accelerationStructure-08927\", \"The VkPhysicalDeviceAccelerationStructureFeaturesKHR::accelerationStructure feature must be enabled\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (!enabled_features.accelerationStructure) {\n    skip |= LogError(\"VUID-vkCmdCopyMemoryToAccelerationStructureKHR-accelerationStructure-08927\", device, error_obj.location,\n                     \"accelerationStructure feature was not enabled.\");\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-vkWriteAccelerationStructuresPropertiesKHR-dataSize-03452\", \"dataSize must be greater than or equal to accelerationStructureCount*stride\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (dataSize < accelerationStructureCount * stride) {\n    skip |= LogError(\"VUID-vkWriteAccelerationStructuresPropertiesKHR-dataSize-03452\", device,\n                     error_obj.location.dot(Field::dataSize),\n                     \"(%zu) is less than \"\n                     \"accelerationStructureCount (%\" PRIu32 \") x stride (%zu).\",\n                     dataSize, accelerationStructureCount, stride);\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-vkWriteAccelerationStructuresPropertiesKHR-queryType-06742\", \"queryType must be VK_QUERY_TYPE_ACCELERATION_STRUCTURE_SIZE_KHR, VK_QUERY_TYPE_ACCELERATION_STRUCTURE_SERIALIZATION_BOTTOM_LEVEL_POINTERS_KHR, VK_QUERY_TYPE_ACCELERATION_STRUCTURE_COMPACTED_SIZE_KHR, or VK_QUERY_TYPE_ACCELERATION_STRUCTURE_SERIALIZATION_SIZE_KHR\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "queryType == VK_QUERY_TYPE_ACCELERATION_STRUCTURE_SERIALIZATION_SIZE_KHR ||\nqueryType == VK_QUERY_TYPE_ACCELERATION_STRUCTURE_SIZE_KHR ||\nqueryType == VK_QUERY_TYPE_ACCELERATION_STRUCTURE_SERIALIZATION_BOTTOM_LEVEL_POINTERS_KHR)) {\nskip |= LogError(\"VUID-vkWriteAccelerationStructuresPropertiesKHR-queryType-06742\", device,\n               error_obj.location.dot(Field::queryType), \"is %s.\", string_VkQueryType(queryType));\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-vkGetDeviceAccelerationStructureCompatibilityKHR-accelerationStructure-08928\", \"The VkPhysicalDeviceAccelerationStructureFeaturesKHR::accelerationStructure feature must be enabled\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (!enabled_features.accelerationStructure) {\n    skip |= LogError(\"VUID-vkGetDeviceAccelerationStructureCompatibilityKHR-accelerationStructure-08928\", device,\n                     error_obj.location, \"accelerationStructure feature was not enabled.\");\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkAccelerationStructureBuildGeometryInfoKHR-pGeometries-03788\", \"If geometryCount is not 0, exactly one of pGeometries or ppGeometries must be a valid pointer, the other must be NULL\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (info.pGeometries && info.ppGeometries) {\n    skip |= LogError(\"VUID-VkAccelerationStructureBuildGeometryInfoKHR-pGeometries-03788\", handle, info_loc,\n                     \"both pGeometries and ppGeometries are not NULL.\");\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkAccelerationStructureGeometryTrianglesDataKHR-indexType-03798\", \"indexType must be VK_INDEX_TYPE_UINT16, VK_INDEX_TYPE_UINT32, or VK_INDEX_TYPE_NONE_KHR\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (geom.geometry.triangles.indexType != VK_INDEX_TYPE_UINT16 &&\n    geom.geometry.triangles.indexType != VK_INDEX_TYPE_UINT32 &&\n    geom.geometry.triangles.indexType != VK_INDEX_TYPE_NONE_KHR) {\n    skip |= LogError(\"VUID-VkAccelerationStructureGeometryTrianglesDataKHR-indexType-03798\", handle,\n                     geometry_loc.dot(Field::geometry).dot(Field::triangles).dot(Field::indexType), \"is %s.\",\n                     string_VkIndexType(geom.geometry.triangles.indexType));\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkAccelerationStructureBuildGeometryInfoKHR-type-03792\", \"If type is VK_ACCELERATION_STRUCTURE_TYPE_BOTTOM_LEVEL_KHR then the geometryType member of each geometry in either pGeometries or ppGeometries must be the same\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (geom.geometryType != rt::GetGeometry(info, 0).geometryType) {\n    skip |= LogError(\"VUID-VkAccelerationStructureBuildGeometryInfoKHR-type-03792\", handle,\n                     geometry_loc.dot(Field::geometryType), \"(%s) is different than pGeometries[0].geometryType (%s)\",\n                     string_VkGeometryTypeKHR(geom.geometryType),\n                     string_VkGeometryTypeKHR(rt::GetGeometry(info, 0).geometryType));\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-vkCmdBuildAccelerationStructuresKHR-pInfos-03403\", \"The srcAccelerationStructure member of any element of pInfos must not be the same acceleration structure as the dstAccelerationStructure member of any other element of pInfos\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (info->srcAccelerationStructure == other_info->dstAccelerationStructure) {\n    const LogObjectList objlist(commandBuffer, info->srcAccelerationStructure);\n    skip |= LogError(\"VUID-vkCmdBuildAccelerationStructuresKHR-pInfos-03403\", objlist,\n                     info_loc.dot(Field::srcAccelerationStructure),\n                     \"and pInfos[%\" PRIu32 \"].dstAccelerationStructure are both %s.\", other_info_j,\n                     FormatHandle(info->srcAccelerationStructure).c_str());\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-vkCmdBuildAccelerationStructuresIndirectKHR-dstAccelerationStructure-03698\", \"The dstAccelerationStructure member of any element of pInfos must not be the same acceleration structure as the dstAccelerationStructure member of any other element of pInfos\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (info->dstAccelerationStructure == pInfos[info_k].dstAccelerationStructure) {\n    const LogObjectList objlist(commandBuffer, info->dstAccelerationStructure);\n    skip |= LogError(\"VUID-vkCmdBuildAccelerationStructuresIndirectKHR-dstAccelerationStructure-03698\", objlist,\n                     info_loc.dot(Field::dstAccelerationStructure),\n                     \"and pInfos[%\" PRIu32 \"].dstAccelerationStructure are both %s.\", info_k,\n                     FormatHandle(info->dstAccelerationStructure).c_str());\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-vkCmdBuildAccelerationStructuresIndirectKHR-pIndirectStrides-03787\", \"Each element of pIndirectStrides must be a multiple of 4\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (SafeModulo(pIndirectStrides[info_i], 4) != 0) {\n    skip |= LogError(\"VUID-vkCmdBuildAccelerationStructuresIndirectKHR-pIndirectStrides-03787\", commandBuffer,\n                     error_obj.location.dot(Field::pIndirectStrides, info_i), \"is %\" PRIu32 \".\", pIndirectStrides[info_i]);\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-vkBuildAccelerationStructuresKHR-pInfos-03771\", \"For any element of pInfos[i].pGeometries or pInfos[i].ppGeometries with a geometryType of VK_GEOMETRY_TYPE_TRIANGLES_KHR, geometry.triangles.vertexData.hostAddress must be a valid host address\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (geom.geometry.triangles.vertexData.hostAddress == nullptr) {\n    skip |= LogError(\"VUID-vkBuildAccelerationStructuresKHR-pInfos-03771\", device,\n                     info_loc.dot(Field::triangles).dot(Field::vertexData).dot(Field::hostAddress), \"is NULL.\");\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-vkGetAccelerationStructureBuildSizesKHR-accelerationStructure-08933\", \"The VkPhysicalDeviceAccelerationStructureFeaturesKHR::accelerationStructure feature must be enabled\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (!enabled_features.accelerationStructure) {\n    skip |= LogError(\"VUID-vkGetAccelerationStructureBuildSizesKHR-accelerationStructure-08933\", device, error_obj.location,\n                     \"accelerationStructure feature was not enabled.\");\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-vkCmdTraceRaysKHR-depth-03640\", \"depth must be less than or equal to VkPhysicalDeviceLimits::maxComputeWorkGroupCount[2] \u00d7 VkPhysicalDeviceLimits::maxComputeWorkGroupSize[2]\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (depth > device_limits.maxComputeWorkGroupCount[2] * device_limits.maxComputeWorkGroupSize[2]) {\n    skip |= LogError(\"VUID-vkCmdTraceRaysKHR-depth-03640\", commandBuffer, error_obj.location.dot(Field::depth),\n                     \"(%\" PRIu32\n                     \") must be less than or equal to VkPhysicalDeviceLimits::maxComputeWorkGroupCount[2] \"\n                     \"x VkPhysicalDeviceLimits::maxComputeWorkGroupSize[2] (%\" PRIu32 \" x %\" PRIu32 \").\",\n                     depth, device_limits.maxComputeWorkGroupCount[2], device_limits.maxComputeWorkGroupSize[2]);\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkAttachmentDescription2-format-09334\", \"If format is VK_FORMAT_UNDEFINED, there must be a VkExternalFormatANDROID structure in the pNext chain with a externalFormat that is not equal to 0\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (GetExternalFormat(pNext) == 0) {\n    skip |= LogError(\"VUID-VkAttachmentDescription2-format-09334\", device, attachment_loc.dot(Field::format),\n                     \"is VK_FORMAT_UNDEFINED.\");\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkRenderPassStripeBeginInfoARM-stripeArea-09451\", \"The stripeArea defined by each element of pStripeInfos must not overlap the stripeArea of any other element\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (has_overlapping_stripes) {\n    skip |= LogError(\"VUID-VkRenderPassStripeBeginInfoARM-stripeArea-09451\", commandBuffer, stripe_info_loc,\n                     \"(offset{%s} extent{%s}) is overlapping with pStripeInfos[%\" PRIu32 \"] (offset{%s} extent {%s}).\",\n                     string_VkOffset2D(stripe_area.offset).c_str(), string_VkExtent2D(stripe_area.extent).c_str(),\n                     index, string_VkOffset2D(rect.offset).c_str(), string_VkExtent2D(rect.extent).c_str());\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkRenderPassBeginInfo-clearValueCount-04962\", \"If clearValueCount is not 0, pClearValues must be a valid pointer to an array of clearValueCount VkClearValue unions\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if ((rp_begin->clearValueCount != 0) && !rp_begin->pClearValues) {\n    const LogObjectList objlist(commandBuffer, rp_begin->renderPass);\n    skip |= LogError(\"VUID-VkRenderPassBeginInfo-clearValueCount-04962\", objlist,\n                     error_obj.location.dot(Field::pRenderPassBegin).dot(Field::clearValueCount),\n                     \"(%\" PRIu32 \") is not zero, but pRenderPassBegin->pClearValues is NULL.\", rp_begin->clearValueCount);\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkRenderingInfo-layerCount-07817\", \"layerCount must be less than or equal to maxFramebufferLayers\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (pRenderingInfo->layerCount > device_limits.maxFramebufferLayers) {\n    skip |= LogError(\"VUID-VkRenderingInfo-layerCount-07817\", commandBuffer, rendering_info_loc.dot(Field::layerCount),\n                     \"(%\" PRIu32 \") is greater than maxFramebufferLayers (%\" PRIu32 \").\", pRenderingInfo->layerCount,\n                     device_limits.maxFramebufferLayers);\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkRenderingInfo-colorAttachmentCount-06090\", \"If colorAttachmentCount is not 0 and the imageView member of an element of pColorAttachments is not VK_NULL_HANDLE, the layout member of that element of pColorAttachments must not be VK_IMAGE_LAYOUT_DEPTH_STENCIL_ATTACHMENT_OPTIMAL or VK_IMAGE_LAYOUT_DEPTH_STENCIL_READ_ONLY_OPTIMAL\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (image_layout == VK_IMAGE_LAYOUT_DEPTH_STENCIL_ATTACHMENT_OPTIMAL ||\n    skip |= LogError(\"VUID-VkRenderingInfo-colorAttachmentCount-06090\", commandBuffer,\n                     attachment_loc.dot(Field::imageLayout), \"is %s.\", string_VkImageLayout(image_layout));\n"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkRenderingInfo-colorAttachmentCount-06101\", \"If colorAttachmentCount is not 0 and the imageView member of an element of pColorAttachments is not VK_NULL_HANDLE, if the resolveMode member of that element of pColorAttachments is not VK_RESOLVE_MODE_NONE, its resolveImageLayout member must not be VK_IMAGE_LAYOUT_DEPTH_ATTACHMENT_OPTIMAL, VK_IMAGE_LAYOUT_DEPTH_READ_ONLY_OPTIMAL, VK_IMAGE_LAYOUT_STENCIL_ATTACHMENT_OPTIMAL, or VK_IMAGE_LAYOUT_STENCIL_READ_ONLY_OPTIMAL\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (resolve_image_layout == VK_IMAGE_LAYOUT_DEPTH_ATTACHMENT_OPTIMAL ||\n    skip |= LogError(\"VUID-VkRenderingInfo-colorAttachmentCount-06101\", commandBuffer,\n                     attachment_loc.dot(Field::resolveImageLayout), \"is %s and resolve_mode is %s.\",\n                     string_VkImageLayout(resolve_image_layout), string_VkResolveModeFlagBits(resolve_mode));\n"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkRenderingInfo-pDepthAttachment-06098\", \"If pDepthAttachment is not NULL, pDepthAttachment->imageView is not VK_NULL_HANDLE, and pDepthAttachment->resolveMode is not VK_RESOLVE_MODE_NONE, pDepthAttachment->resolveImageLayout must not be VK_IMAGE_LAYOUT_DEPTH_READ_ONLY_STENCIL_ATTACHMENT_OPTIMAL\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (IsExtEnabled(device_extensions.vk_khr_maintenance2) &&\n    skip |= LogError(\"VUID-VkRenderingInfo-pDepthAttachment-06098\", commandBuffer,\n                     attachment_loc.dot(Field::resolveImageLayout),\n                     \"is VK_IMAGE_LAYOUT_DEPTH_READ_ONLY_STENCIL_ATTACHMENT_OPTIMAL.\");\n"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkRenderingInfo-pStencilAttachment-06099\", \"If pStencilAttachment is not NULL, pStencilAttachment->imageView is not VK_NULL_HANDLE, and pStencilAttachment->resolveMode is not VK_RESOLVE_MODE_NONE, pStencilAttachment->resolveImageLayout must not be VK_IMAGE_LAYOUT_DEPTH_ATTACHMENT_STENCIL_READ_ONLY_OPTIMAL\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (IsExtEnabled(device_extensions.vk_khr_maintenance2) &&\n    skip |= LogError(\"VUID-VkRenderingInfo-pStencilAttachment-06099\", commandBuffer,\n                     attachment_loc.dot(Field::resolveImageLayout),\n                     \"is VK_IMAGE_LAYOUT_DEPTH_READ_ONLY_STENCIL_ATTACHMENT_OPTIMAL.\");\n"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkShaderCreateInfoEXT-codeSize-08735\", \"If codeType is VK_SHADER_CODE_TYPE_SPIRV_EXT, codeSize must be a multiple of 4\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (createInfo.codeType == VK_SHADER_CODE_TYPE_SPIRV_EXT && SafeModulo(createInfo.codeSize, 4) != 0) {\n    skip |= LogError(\"VUID-VkShaderCreateInfoEXT-codeSize-08735\", device, create_info_loc.dot(Field::codeSize),\n                     \"(%\" PRIu64 \") is not a multiple of 4.\", static_cast<uint64_t>(createInfo.codeSize));\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkShaderCreateInfoEXT-flags-08486\", \"If stage is not VK_SHADER_STAGE_FRAGMENT_BIT, flags must not include VK_SHADER_CREATE_FRAGMENT_SHADING_RATE_ATTACHMENT_BIT_EXT\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if ((createInfo.flags & VK_SHADER_CREATE_FRAGMENT_SHADING_RATE_ATTACHMENT_BIT_EXT) != 0) {\n    skip |= LogError(\"VUID-VkShaderCreateInfoEXT-flags-08486\", device, create_info_loc.dot(Field::flags),\n                     \"is %s and stage is %s.\", string_VkShaderCreateFlagsEXT(createInfo.flags).c_str(),\n                     string_VkShaderStageFlagBits(createInfo.stage));\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkShaderCreateInfoEXT-stage-08418\", \"stage must not be VK_SHADER_STAGE_ALL_GRAPHICS or VK_SHADER_STAGE_ALL\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "} else if (createInfo.stage == VK_SHADER_STAGE_ALL) {\n    skip |= LogError(\"VUID-VkShaderCreateInfoEXT-stage-08418\", device, create_info_loc.dot(Field::stage),\n                     \"is VK_SHADER_STAGE_ALL.\");\n"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkAcquireNextImageInfoKHR-semaphore-01782\", \"semaphore and fence must not both be equal to VK_NULL_HANDLE\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (pAcquireInfo->semaphore == VK_NULL_HANDLE && pAcquireInfo->fence == VK_NULL_HANDLE) {\n    skip |= LogError(\"VUID-VkAcquireNextImageInfoKHR-semaphore-01782\", pAcquireInfo->swapchain,\n                     error_obj.location.dot(Field::pAcquireInfo), \"semaphore and fence are both VK_NULL_HANDLE.\");\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkSwapchainCreateInfoKHR-pNext-04099\", \"If a VkImageFormatListCreateInfo structure was included in the pNext chain and VkImageFormatListCreateInfo::viewFormatCount is not zero then all of the formats in VkImageFormatListCreateInfo::pViewFormats must be compatible with the format as described in the compatibility table\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (vkuFormatCompatibilityClass(format_list_info->pViewFormats[0]) !=\n    skip |= LogError(\"VUID-VkSwapchainCreateInfoKHR-pNext-04099\", device,\n                     loc.pNext(Struct::VkImageFormatListCreateInfo, Field::pViewFormats, i),\n                     \"(%s) and pViewFormats[0] (%s) are not compatible in the pNext chain.\",\n                     string_VkFormat(format_list_info->pViewFormats[i]),\n                     string_VkFormat(format_list_info->pViewFormats[0]));\n"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkPresentInfoKHR-pSwapchain-09231\", \"Elements of pSwapchain must be unique\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (pPresentInfo->pSwapchains[i] == pPresentInfo->pSwapchains[j]) {\n    skip |= LogError(\"VUID-VkPresentInfoKHR-pSwapchain-09231\", device, error_obj.location.dot(Field::pSwapchain),\n                     \"at index %\" PRIu32 \" and index %\" PRIu32 \" are both %s.\", i, j,\n                     FormatHandle(pPresentInfo->pSwapchains[i]).c_str());\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-vkGetPhysicalDeviceSurfaceCapabilities2KHR-pNext-02671\", \"If a VkSurfaceCapabilitiesFullScreenExclusiveEXT structure is included in the pNext chain of pSurfaceCapabilities, a VkSurfaceFullScreenExclusiveWin32InfoEXT structure must be included in the pNext chain of pSurfaceInfo\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (!full_screen_exclusive_win32_info) {\n    skip |= LogError(\"VUID-vkGetPhysicalDeviceSurfaceCapabilities2KHR-pNext-02671\", physicalDevice, error_obj.location,\n                     \"pSurfaceCapabilities->pNext contains \"\n                     \"VkSurfaceCapabilitiesFullScreenExclusiveEXT, but pSurfaceInfo->pNext does not contain \"\n                     \"VkSurfaceFullScreenExclusiveWin32InfoEXT\");\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-vkGetPhysicalDeviceSurfaceFormats2KHR-pSurfaceInfo-06521\", \"If the VK_GOOGLE_surfaceless_query extension is not enabled, pSurfaceInfo->surface must be a valid VkSurfaceKHR handle\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (pSurfaceInfo && pSurfaceInfo->surface == VK_NULL_HANDLE && !IsExtEnabled(instance_extensions.vk_google_surfaceless_query)) {\n    skip |= LogError(\"VUID-vkGetPhysicalDeviceSurfaceFormats2KHR-pSurfaceInfo-06521\", physicalDevice,\n                     error_obj.location.dot(Field::pSurfaceInfo).dot(Field::surface),\n                     \"is VK_NULL_HANDLE and VK_GOOGLE_surfaceless_query is not enabled.\");\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkWaylandSurfaceCreateInfoKHR-display-01304\", \"display must point to a valid Wayland wl_display\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (display == nullptr) {\n    skip |= LogError(\"VUID-VkWaylandSurfaceCreateInfoKHR-display-01304\", instance,\n                     error_obj.location.dot(Field::pCreateInfo).dot(Field::display), \"is NULL!\");\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkXlibSurfaceCreateInfoKHR-window-01314\", \"window must be a valid Xlib Window\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "skip |= ValidateNotZero(window == 0, \"VUID-VkXlibSurfaceCreateInfoKHR-window-01314\",\n                        error_obj.location.dot(Field::pCreateInfo).dot(Field::window));\n"
        },
        {
            "role": "user",
            "content": "{\"VUID-vkFreeMemory-memory-parameter\", \"If memory is not VK_NULL_HANDLE, memory must be a valid VkDeviceMemory handle\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "bool skip = false;\n// Checked by chassis: device: \"VUID-vkFreeMemory-device-parameter\"\nskip |= ValidateObject(memory, kVulkanObjectTypeDeviceMemory, true, \"VUID-vkFreeMemory-memory-parameter\",\n                       \"VUID-vkFreeMemory-memory-parent\", error_obj.location.dot(Field::memory));\n"
        },
        {
            "role": "user",
            "content": "{\"VUID-vkBindBufferMemory-memory-parameter\", \"memory must be a valid VkDeviceMemory handle\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "// Checked by chassis: device: \"VUID-vkBindBufferMemory-device-parameter\"\nskip |= ValidateObject(buffer, kVulkanObjectTypeBuffer, false, \"VUID-vkBindBufferMemory-buffer-parameter\",\n                       \"VUID-vkBindBufferMemory-buffer-parent\", error_obj.location.dot(Field::buffer));\nskip |= ValidateObject(memory, kVulkanObjectTypeDeviceMemory, false, \"VUID-vkBindBufferMemory-memory-parameter\",\n                       \"VUID-vkBindBufferMemory-memory-parent\", error_obj.location.dot(Field::memory));\n"
        },
        {
            "role": "user",
            "content": "{\"VUID-vkGetImageSparseMemoryRequirements-image-parameter\", \"image must be a valid VkImage handle\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "bool skip = false;\n// Checked by chassis: device: \"VUID-vkGetImageSparseMemoryRequirements-device-parameter\"\nskip |= ValidateObject(image, kVulkanObjectTypeImage, false, \"VUID-vkGetImageSparseMemoryRequirements-image-parameter\",\n                       \"VUID-vkGetImageSparseMemoryRequirements-image-parent\", error_obj.location.dot(Field::image));\n"
        },
        {
            "role": "user",
            "content": "{\"VUID-vkGetFenceStatus-fence-parameter\", \"fence must be a valid VkFence handle\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "bool ObjectLifetimes::PreCallValidateGetFenceStatus(VkDevice device, VkFence fence, const ErrorObject& error_obj) const {\n    bool skip = false;\n    // Checked by chassis: device: \"VUID-vkGetFenceStatus-device-parameter\"\n    skip |= ValidateObject(fence, kVulkanObjectTypeFence, false, \"VUID-vkGetFenceStatus-fence-parameter\",\n                           \"VUID-vkGetFenceStatus-fence-parent\", error_obj.location.dot(Field::fence));\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-vkDestroyEvent-event-01146\", \"If VkAllocationCallbacks were provided when event was created, a compatible set of callbacks must be provided here\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "// Checked by chassis: device: \"VUID-vkDestroyEvent-device-parameter\"\nskip |= ValidateObject(event, kVulkanObjectTypeEvent, true, \"VUID-vkDestroyEvent-event-parameter\",\n                       \"VUID-vkDestroyEvent-event-parent\", error_obj.location.dot(Field::event));\nskip |= ValidateDestroyObject(event, kVulkanObjectTypeEvent, pAllocator, \"VUID-vkDestroyEvent-event-01146\",\n                              \"VUID-vkDestroyEvent-event-01147\", error_obj.location);\n"
        },
        {
            "role": "user",
            "content": "{\"VUID-vkDestroyQueryPool-queryPool-parameter\", \"If queryPool is not VK_NULL_HANDLE, queryPool must be a valid VkQueryPool handle\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "bool skip = false;\n// Checked by chassis: device: \"VUID-vkDestroyQueryPool-device-parameter\"\nskip |= ValidateObject(queryPool, kVulkanObjectTypeQueryPool, true, \"VUID-vkDestroyQueryPool-queryPool-parameter\",\n                       \"VUID-vkDestroyQueryPool-queryPool-parent\", error_obj.location.dot(Field::queryPool));\n"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkBufferViewCreateInfo-buffer-parameter\", \"buffer must be a valid VkBuffer handle\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (pCreateInfo) {\n    [[maybe_unused]] const Location pCreateInfo_loc = error_obj.location.dot(Field::pCreateInfo);\n    skip |= ValidateObject(pCreateInfo->buffer, kVulkanObjectTypeBuffer, false, \"VUID-VkBufferViewCreateInfo-buffer-parameter\",\n                           \"UNASSIGNED-VkBufferViewCreateInfo-buffer-parent\", pCreateInfo_loc.dot(Field::buffer));\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-vkGetImageSubresourceLayout-image-parameter\", \"image must be a valid VkImage handle\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "bool skip = false;\n// Checked by chassis: device: \"VUID-vkGetImageSubresourceLayout-device-parameter\"\nskip |= ValidateObject(image, kVulkanObjectTypeImage, false, \"VUID-vkGetImageSubresourceLayout-image-parameter\",\n                       \"VUID-vkGetImageSubresourceLayout-image-parent\", error_obj.location.dot(Field::image));\n"
        },
        {
            "role": "user",
            "content": "{\"VUID-vkMergePipelineCaches-dstCache-parameter\", \"dstCache must be a valid VkPipelineCache handle\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "bool skip = false;\n// Checked by chassis: device: \"VUID-vkMergePipelineCaches-device-parameter\"\nskip |= ValidateObject(dstCache, kVulkanObjectTypePipelineCache, false, \"VUID-vkMergePipelineCaches-dstCache-parameter\",\n                       \"VUID-vkMergePipelineCaches-dstCache-parent\", error_obj.location.dot(Field::dstCache));\n"
        },
        {
            "role": "user",
            "content": "{\"VUID-vkDestroyFramebuffer-framebuffer-parameter\", \"If framebuffer is not VK_NULL_HANDLE, framebuffer must be a valid VkFramebuffer handle\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "bool skip = false;\n// Checked by chassis: device: \"VUID-vkDestroyFramebuffer-device-parameter\"\nskip |= ValidateObject(framebuffer, kVulkanObjectTypeFramebuffer, true, \"VUID-vkDestroyFramebuffer-framebuffer-parameter\",\n                       \"VUID-vkDestroyFramebuffer-framebuffer-parent\", error_obj.location.dot(Field::framebuffer));\n"
        },
        {
            "role": "user",
            "content": "{\"VUID-vkCmdBindPipeline-pipeline-parameter\", \"pipeline must be a valid VkPipeline handle\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "bool skip = false;\n// Checked by chassis: commandBuffer: \"VUID-vkCmdBindPipeline-commandBuffer-parameter\"\n// Checked by chassis: commandBuffer: \"VUID-vkCmdBindPipeline-commonparent\"\nskip |= ValidateObject(pipeline, kVulkanObjectTypePipeline, false, \"VUID-vkCmdBindPipeline-pipeline-parameter\",\n                       \"VUID-vkCmdBindPipeline-commonparent\", error_obj.location.dot(Field::pipeline));\n"
        },
        {
            "role": "user",
            "content": "{\"VUID-vkCmdDispatchIndirect-buffer-parameter\", \"buffer must be a valid VkBuffer handle\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "bool skip = false;\n// Checked by chassis: commandBuffer: \"VUID-vkCmdDispatchIndirect-commandBuffer-parameter\"\n// Checked by chassis: commandBuffer: \"VUID-vkCmdDispatchIndirect-commonparent\"\nskip |= ValidateObject(buffer, kVulkanObjectTypeBuffer, false, \"VUID-vkCmdDispatchIndirect-buffer-parameter\",\n                       \"VUID-vkCmdDispatchIndirect-commonparent\", error_obj.location.dot(Field::buffer));\n"
        },
        {
            "role": "user",
            "content": "{\"VUID-vkCmdBlitImage-srcImage-parameter\", \"srcImage must be a valid VkImage handle\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "bool skip = false;\n// Checked by chassis: commandBuffer: \"VUID-vkCmdBlitImage-commandBuffer-parameter\"\n// Checked by chassis: commandBuffer: \"VUID-vkCmdBlitImage-commonparent\"\nskip |= ValidateObject(srcImage, kVulkanObjectTypeImage, false, \"VUID-vkCmdBlitImage-srcImage-parameter\",\n                       \"VUID-vkCmdBlitImage-commonparent\", error_obj.location.dot(Field::srcImage));\n"
        },
        {
            "role": "user",
            "content": "{\"VUID-vkCmdCopyImageToBuffer-dstBuffer-parameter\", \"dstBuffer must be a valid VkBuffer handle\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "// Checked by chassis: commandBuffer: \"VUID-vkCmdCopyImageToBuffer-commonparent\"\nskip |= ValidateObject(srcImage, kVulkanObjectTypeImage, false, \"VUID-vkCmdCopyImageToBuffer-srcImage-parameter\",\n                       \"VUID-vkCmdCopyImageToBuffer-commonparent\", error_obj.location.dot(Field::srcImage));\nskip |= ValidateObject(dstBuffer, kVulkanObjectTypeBuffer, false, \"VUID-vkCmdCopyImageToBuffer-dstBuffer-parameter\",\n                       \"VUID-vkCmdCopyImageToBuffer-commonparent\", error_obj.location.dot(Field::dstBuffer));\n"
        },
        {
            "role": "user",
            "content": "{\"VUID-vkCmdResolveImage-srcImage-parameter\", \"srcImage must be a valid VkImage handle\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "bool skip = false;\n// Checked by chassis: commandBuffer: \"VUID-vkCmdResolveImage-commandBuffer-parameter\"\n// Checked by chassis: commandBuffer: \"VUID-vkCmdResolveImage-commonparent\"\nskip |= ValidateObject(srcImage, kVulkanObjectTypeImage, false, \"VUID-vkCmdResolveImage-srcImage-parameter\",\n                       \"VUID-vkCmdResolveImage-commonparent\", error_obj.location.dot(Field::srcImage));\n"
        },
        {
            "role": "user",
            "content": "{\"VUID-vkCmdBeginQuery-queryPool-parameter\", \"queryPool must be a valid VkQueryPool handle\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "bool skip = false;\n// Checked by chassis: commandBuffer: \"VUID-vkCmdBeginQuery-commandBuffer-parameter\"\n// Checked by chassis: commandBuffer: \"VUID-vkCmdBeginQuery-commonparent\"\nskip |= ValidateObject(queryPool, kVulkanObjectTypeQueryPool, false, \"VUID-vkCmdBeginQuery-queryPool-parameter\",\n                       \"VUID-vkCmdBeginQuery-commonparent\", error_obj.location.dot(Field::queryPool));\n"
        },
        {
            "role": "user",
            "content": "{\"VUID-vkCmdCopyQueryPoolResults-dstBuffer-parameter\", \"dstBuffer must be a valid VkBuffer handle\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "// Checked by chassis: commandBuffer: \"VUID-vkCmdCopyQueryPoolResults-commonparent\"\nskip |= ValidateObject(queryPool, kVulkanObjectTypeQueryPool, false, \"VUID-vkCmdCopyQueryPoolResults-queryPool-parameter\",\n                       \"VUID-vkCmdCopyQueryPoolResults-commonparent\", error_obj.location.dot(Field::queryPool));\nskip |= ValidateObject(dstBuffer, kVulkanObjectTypeBuffer, false, \"VUID-vkCmdCopyQueryPoolResults-dstBuffer-parameter\",\n                       \"VUID-vkCmdCopyQueryPoolResults-commonparent\", error_obj.location.dot(Field::dstBuffer));\n"
        },
        {
            "role": "user",
            "content": "{\"VUID-vkCmdDrawIndirectCount-countBuffer-parameter\", \"countBuffer must be a valid VkBuffer handle\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "// Checked by chassis: commandBuffer: \"VUID-vkCmdDrawIndirectCount-commonparent\"\nskip |= ValidateObject(buffer, kVulkanObjectTypeBuffer, false, \"VUID-vkCmdDrawIndirectCount-buffer-parameter\",\n                       \"VUID-vkCmdDrawIndirectCount-commonparent\", error_obj.location.dot(Field::buffer));\nskip |= ValidateObject(countBuffer, kVulkanObjectTypeBuffer, false, \"VUID-vkCmdDrawIndirectCount-countBuffer-parameter\",\n                       \"VUID-vkCmdDrawIndirectCount-commonparent\", error_obj.location.dot(Field::countBuffer));\n"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkBufferDeviceAddressInfo-buffer-parameter\", \"buffer must be a valid VkBuffer handle\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (pInfo) {\n    [[maybe_unused]] const Location pInfo_loc = error_obj.location.dot(Field::pInfo);\n    skip |= ValidateObject(pInfo->buffer, kVulkanObjectTypeBuffer, false, \"VUID-VkBufferDeviceAddressInfo-buffer-parameter\",\n                           \"UNASSIGNED-VkBufferDeviceAddressInfo-buffer-parent\", pInfo_loc.dot(Field::buffer));\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-vkCmdWriteTimestamp2-queryPool-parameter\", \"queryPool must be a valid VkQueryPool handle\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "bool skip = false;\n// Checked by chassis: commandBuffer: \"VUID-vkCmdWriteTimestamp2-commandBuffer-parameter\"\n// Checked by chassis: commandBuffer: \"VUID-vkCmdWriteTimestamp2-commonparent\"\nskip |= ValidateObject(queryPool, kVulkanObjectTypeQueryPool, false, \"VUID-vkCmdWriteTimestamp2-queryPool-parameter\",\n                       \"VUID-vkCmdWriteTimestamp2-commonparent\", error_obj.location.dot(Field::queryPool));\n"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkBlitImageInfo2-dstImage-parameter\", \"dstImage must be a valid VkImage handle\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "[[maybe_unused]] const Location pBlitImageInfo_loc = error_obj.location.dot(Field::pBlitImageInfo);\nskip |= ValidateObject(pBlitImageInfo->srcImage, kVulkanObjectTypeImage, false, \"VUID-VkBlitImageInfo2-srcImage-parameter\",\n                       \"VUID-VkBlitImageInfo2-commonparent\", pBlitImageInfo_loc.dot(Field::srcImage));\nskip |= ValidateObject(pBlitImageInfo->dstImage, kVulkanObjectTypeImage, false, \"VUID-VkBlitImageInfo2-dstImage-parameter\",\n                       \"VUID-VkBlitImageInfo2-commonparent\", pBlitImageInfo_loc.dot(Field::dstImage));\n"
        },
        {
            "role": "user",
            "content": "{\"VUID-vkAcquireNextImageKHR-swapchain-parameter\", \"swapchain must be a valid VkSwapchainKHR handle\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "bool skip = false;\n// Checked by chassis: device: \"VUID-vkAcquireNextImageKHR-device-parameter\"\nskip |= ValidateObject(swapchain, kVulkanObjectTypeSwapchainKHR, false, \"VUID-vkAcquireNextImageKHR-swapchain-parameter\",\n                       \"VUID-vkAcquireNextImageKHR-swapchain-parent\", error_obj.location.dot(Field::swapchain));\n"
        },
        {
            "role": "user",
            "content": "{\"VUID-vkCreateDisplayModeKHR-display-parameter\", \"display must be a valid VkDisplayKHR handle\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "bool skip = false;\n// Checked by chassis: physicalDevice: \"VUID-vkCreateDisplayModeKHR-physicalDevice-parameter\"\nskip |= ValidateObject(display, kVulkanObjectTypeDisplayKHR, false, \"VUID-vkCreateDisplayModeKHR-display-parameter\",\n                       \"VUID-vkCreateDisplayModeKHR-display-parent\", error_obj.location.dot(Field::display),\n                       kVulkanObjectTypePhysicalDevice);\n"
        },
        {
            "role": "user",
            "content": "{\"VUID-vkWaitForPresentKHR-swapchain-parameter\", \"swapchain must be a valid VkSwapchainKHR handle\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "bool skip = false;\n// Checked by chassis: device: \"VUID-vkWaitForPresentKHR-device-parameter\"\nskip |= ValidateObject(swapchain, kVulkanObjectTypeSwapchainKHR, false, \"VUID-vkWaitForPresentKHR-swapchain-parameter\",\n                       \"VUID-vkWaitForPresentKHR-swapchain-parent\", error_obj.location.dot(Field::swapchain));\n"
        },
        {
            "role": "user",
            "content": "{\"VUID-vkCmdBeginQueryIndexedEXT-queryPool-parameter\", \"queryPool must be a valid VkQueryPool handle\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "bool skip = false;\n// Checked by chassis: commandBuffer: \"VUID-vkCmdBeginQueryIndexedEXT-commandBuffer-parameter\"\n// Checked by chassis: commandBuffer: \"VUID-vkCmdBeginQueryIndexedEXT-commonparent\"\nskip |= ValidateObject(queryPool, kVulkanObjectTypeQueryPool, false, \"VUID-vkCmdBeginQueryIndexedEXT-queryPool-parameter\",\n                       \"VUID-vkCmdBeginQueryIndexedEXT-commonparent\", error_obj.location.dot(Field::queryPool));\n"
        },
        {
            "role": "user",
            "content": "{\"VUID-vkGetImageViewAddressNVX-imageView-parameter\", \"imageView must be a valid VkImageView handle\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "bool skip = false;\n// Checked by chassis: device: \"VUID-vkGetImageViewAddressNVX-device-parameter\"\nskip |= ValidateObject(imageView, kVulkanObjectTypeImageView, false, \"VUID-vkGetImageViewAddressNVX-imageView-parameter\",\n                       \"VUID-vkGetImageViewAddressNVX-imageView-parent\", error_obj.location.dot(Field::imageView));\n"
        },
        {
            "role": "user",
            "content": "{\"VUID-vkGetSwapchainCounterEXT-swapchain-parameter\", \"swapchain must be a valid VkSwapchainKHR handle\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "bool skip = false;\n// Checked by chassis: device: \"VUID-vkGetSwapchainCounterEXT-device-parameter\"\nskip |= ValidateObject(swapchain, kVulkanObjectTypeSwapchainKHR, false, \"VUID-vkGetSwapchainCounterEXT-swapchain-parameter\",\n                       \"VUID-vkGetSwapchainCounterEXT-swapchain-parent\", error_obj.location.dot(Field::swapchain));\n"
        },
        {
            "role": "user",
            "content": "{\"VUID-vkCmdWriteBufferMarkerAMD-dstBuffer-parameter\", \"dstBuffer must be a valid VkBuffer handle\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "bool skip = false;\n// Checked by chassis: commandBuffer: \"VUID-vkCmdWriteBufferMarkerAMD-commandBuffer-parameter\"\n// Checked by chassis: commandBuffer: \"VUID-vkCmdWriteBufferMarkerAMD-commonparent\"\nskip |= ValidateObject(dstBuffer, kVulkanObjectTypeBuffer, false, \"VUID-vkCmdWriteBufferMarkerAMD-dstBuffer-parameter\",\n                       \"VUID-vkCmdWriteBufferMarkerAMD-commonparent\", error_obj.location.dot(Field::dstBuffer));\n"
        },
        {
            "role": "user",
            "content": "{\"VUID-vkAcquireDrmDisplayEXT-display-parameter\", \"display must be a valid VkDisplayKHR handle\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "bool skip = false;\n// Checked by chassis: physicalDevice: \"VUID-vkAcquireDrmDisplayEXT-physicalDevice-parameter\"\nskip |= ValidateObject(display, kVulkanObjectTypeDisplayKHR, false, \"VUID-vkAcquireDrmDisplayEXT-display-parameter\",\n                       \"VUID-vkAcquireDrmDisplayEXT-display-parent\", error_obj.location.dot(Field::display),\n                       kVulkanObjectTypePhysicalDevice);\n"
        },
        {
            "role": "user",
            "content": "{\"VUID-vkCmdBindInvocationMaskHUAWEI-imageView-parameter\", \"If imageView is not VK_NULL_HANDLE, imageView must be a valid VkImageView handle\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "bool skip = false;\n// Checked by chassis: commandBuffer: \"VUID-vkCmdBindInvocationMaskHUAWEI-commandBuffer-parameter\"\n// Checked by chassis: commandBuffer: \"VUID-vkCmdBindInvocationMaskHUAWEI-commonparent\"\nskip |= ValidateObject(imageView, kVulkanObjectTypeImageView, true, \"VUID-vkCmdBindInvocationMaskHUAWEI-imageView-parameter\",\n                       \"VUID-vkCmdBindInvocationMaskHUAWEI-commonparent\", error_obj.location.dot(Field::imageView));\n"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkCopyMicromapInfoEXT-src-parameter\", \"src must be a valid VkMicromapEXT handle\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (pInfo) {\n    [[maybe_unused]] const Location pInfo_loc = error_obj.location.dot(Field::pInfo);\n    skip |= ValidateObject(pInfo->src, kVulkanObjectTypeMicromapEXT, false, \"VUID-VkCopyMicromapInfoEXT-src-parameter\",\n                           \"VUID-VkCopyMicromapInfoEXT-commonparent\", pInfo_loc.dot(Field::src));\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkCopyMemoryToMicromapInfoEXT-dst-parameter\", \"dst must be a valid VkMicromapEXT handle\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (pInfo) {\n    [[maybe_unused]] const Location pInfo_loc = error_obj.location.dot(Field::pInfo);\n    skip |= ValidateObject(pInfo->dst, kVulkanObjectTypeMicromapEXT, false, \"VUID-VkCopyMemoryToMicromapInfoEXT-dst-parameter\",\n                           \"UNASSIGNED-VkCopyMemoryToMicromapInfoEXT-dst-parent\", pInfo_loc.dot(Field::dst));\n}"
        },
        {
            "role": "user",
            "content": "{\"VUID-vkDestroyShaderEXT-shader-parameter\", \"If shader is not VK_NULL_HANDLE, shader must be a valid VkShaderEXT handle\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "bool skip = false;\n// Checked by chassis: device: \"VUID-vkDestroyShaderEXT-device-parameter\"\nskip |= ValidateObject(shader, kVulkanObjectTypeShaderEXT, true, \"VUID-vkDestroyShaderEXT-shader-parameter\",\n                       \"VUID-vkDestroyShaderEXT-shader-parent\", error_obj.location.dot(Field::shader));\n"
        },
        {
            "role": "user",
            "content": "{\"VUID-vkSetLatencyMarkerNV-swapchain-parameter\", \"swapchain must be a valid VkSwapchainKHR handle\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "bool skip = false;\n// Checked by chassis: device: \"VUID-vkSetLatencyMarkerNV-device-parameter\"\nskip |= ValidateObject(swapchain, kVulkanObjectTypeSwapchainKHR, false, \"VUID-vkSetLatencyMarkerNV-swapchain-parameter\",\n                       \"VUID-vkSetLatencyMarkerNV-swapchain-parent\", error_obj.location.dot(Field::swapchain));\n"
        },
        {
            "role": "user",
            "content": "{\"VUID-vkCreateInstance-pInstance-parameter\", \"pInstance must be a valid pointer to a VkInstance handle\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "[[maybe_unused]] const Location pAllocator_loc = loc.dot(Field::pAllocator);\nskip |= ValidateAllocationCallbacks(*pAllocator, pAllocator_loc);\nskip |= ValidateRequiredPointer(loc.dot(Field::pInstance), pInstance, \"VUID-vkCreateInstance-pInstance-parameter\");\n"
        },
        {
            "role": "user",
            "content": "{\"VUID-vkMapMemory-ppData-parameter\", \"ppData must be a valid pointer to a pointer value\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "skip |= ValidateRequiredHandle(loc.dot(Field::memory), memory);\nskip |= ValidateFlags(loc.dot(Field::flags), vvl::FlagBitmask::VkMemoryMapFlagBits, AllVkMemoryMapFlagBits, flags,\n                      kOptionalFlags, \"VUID-vkMapMemory-flags-parameter\");\nskip |= ValidateRequiredPointer(loc.dot(Field::ppData), ppData, \"VUID-vkMapMemory-ppData-parameter\");\n"
        },
        {
            "role": "user",
            "content": "{\"VUID-vkCreateBuffer-pBuffer-parameter\", \"pBuffer must be a valid pointer to a VkBuffer handle\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "[[maybe_unused]] const Location pAllocator_loc = loc.dot(Field::pAllocator);\nskip |= ValidateAllocationCallbacks(*pAllocator, pAllocator_loc);\nskip |= ValidateRequiredPointer(loc.dot(Field::pBuffer), pBuffer, \"VUID-vkCreateBuffer-pBuffer-parameter\");\n"
        },
        {
            "role": "user",
            "content": "{\"VUID-vkCreateSampler-pSampler-parameter\", \"pSampler must be a valid pointer to a VkSampler handle\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "[[maybe_unused]] const Location pAllocator_loc = loc.dot(Field::pAllocator);\nskip |= ValidateAllocationCallbacks(*pAllocator, pAllocator_loc);\nskip |= ValidateRequiredPointer(loc.dot(Field::pSampler), pSampler, \"VUID-vkCreateSampler-pSampler-parameter\");\n"
        },
        {
            "role": "user",
            "content": "{\"VUID-vkCmdBlitImage-filter-parameter\", \"filter must be a valid VkFilter value\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "\"VUID-VkImageSubresourceLayers-aspectMask-requiredbitmask\");\nskip |= ValidateRangedEnum(loc.dot(Field::filter), vvl::Enum::VkFilter, filter, \"VUID-vkCmdBlitImage-filter-parameter\");\n"
        },
        {
            "role": "user",
            "content": "{\"VUID-vkGetPrivateData-pData-parameter\", \"pData must be a valid pointer to a uint64_t value\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "skip |= ValidateRangedEnum(loc.dot(Field::objectType), vvl::Enum::VkObjectType, objectType,\n                           \"VUID-vkGetPrivateData-objectType-parameter\");\nskip |= ValidateRequiredHandle(loc.dot(Field::privateDataSlot), privateDataSlot);\nskip |= ValidateRequiredPointer(loc.dot(Field::pData), pData, \"VUID-vkGetPrivateData-pData-parameter\");\n"
        },
        {
            "role": "user",
            "content": "{\"VUID-vkGetDeviceGroupSurfacePresentModesKHR-pModes-parameter\", \"pModes must be a valid pointer to a VkDeviceGroupPresentModeFlagsKHR value\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (!(IsExtEnabled(device_extensions.vk_khr_swapchain) || IsExtEnabled(device_extensions.vk_khr_device_group)))\n    skip |= OutputExtensionError(loc, {vvl::Extension::_VK_KHR_swapchain, vvl::Extension::_VK_KHR_device_group});\nskip |= ValidateRequiredHandle(loc.dot(Field::surface), surface);\nskip |= ValidateRequiredPointer(loc.dot(Field::pModes), pModes, \"VUID-vkGetDeviceGroupSurfacePresentModesKHR-pModes-parameter\");\n"
        },
        {
            "role": "user",
            "content": "{\"VUID-vkGetPhysicalDeviceXlibPresentationSupportKHR-dpy-parameter\", \"dpy must be a valid pointer to a Display value\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (!IsExtEnabled(instance_extensions.vk_khr_xlib_surface))\n    skip |= OutputExtensionError(loc, {vvl::Extension::_VK_KHR_xlib_surface});\nskip |= ValidateRequiredPointer(loc.dot(Field::dpy), dpy, \"VUID-vkGetPhysicalDeviceXlibPresentationSupportKHR-dpy-parameter\");\n"
        },
        {
            "role": "user",
            "content": "{\"VUID-vkGetMemoryWin32HandleKHR-pHandle-parameter\", \"pHandle must be a valid pointer to a HANDLE value\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "\"VUID-VkMemoryGetWin32HandleInfoKHR-handleType-parameter\",\n\"VUID-VkMemoryGetWin32HandleInfoKHR-handleType-parameter\");\nskip |= ValidateRequiredPointer(loc.dot(Field::pHandle), pHandle, \"VUID-vkGetMemoryWin32HandleKHR-pHandle-parameter\");\n"
        },
        {
            "role": "user",
            "content": "{\"VUID-vkGetFenceFdKHR-pFd-parameter\", \"pFd must be a valid pointer to an int value\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "\"VUID-VkFenceGetFdInfoKHR-handleType-parameter\", \"VUID-VkFenceGetFdInfoKHR-handleType-parameter\");\nskip |= ValidateRequiredPointer(loc.dot(Field::pFd), pFd, \"VUID-vkGetFenceFdKHR-pFd-parameter\");\n"
        },
        {
            "role": "user",
            "content": "{\"VUID-vkGetMemoryWin32HandleNV-pHandle-parameter\", \"pHandle must be a valid pointer to a HANDLE value\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "\"VUID-vkGetMemoryWin32HandleNV-handleType-parameter\",\n\"VUID-vkGetMemoryWin32HandleNV-handleType-requiredbitmask\");\nskip |= ValidateRequiredPointer(loc.dot(Field::pHandle), pHandle, \"VUID-vkGetMemoryWin32HandleNV-pHandle-parameter\");\n"
        },
        {
            "role": "user",
            "content": "{\"VUID-vkRegisterDeviceEventEXT-pFence-parameter\", \"pFence must be a valid pointer to a VkFence handle\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "[[maybe_unused]] const Location pAllocator_loc = loc.dot(Field::pAllocator);\nskip |= ValidateAllocationCallbacks(*pAllocator, pAllocator_loc);\nskip |= ValidateRequiredPointer(loc.dot(Field::pFence), pFence, \"VUID-vkRegisterDeviceEventEXT-pFence-parameter\");\n"
        },
        {
            "role": "user",
            "content": "{\"VUID-vkGetPerformanceParameterINTEL-pValue-parameter\", \"pValue must be a valid pointer to a VkPerformanceValueINTEL structure\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "skip |= OutputExtensionError(loc, {vvl::Extension::_VK_INTEL_performance_query});\nskip |= ValidateRangedEnum(loc.dot(Field::parameter), vvl::Enum::VkPerformanceParameterTypeINTEL, parameter,\n                       \"VUID-vkGetPerformanceParameterINTEL-parameter-parameter\");\nskip |= ValidateRequiredPointer(loc.dot(Field::pValue), pValue, \"VUID-vkGetPerformanceParameterINTEL-pValue-parameter\");\n"
        },
        {
            "role": "user",
            "content": "{\"VUID-vkCreateCudaModuleNV-pModule-parameter\", \"pModule must be a valid pointer to a VkCudaModuleNV handle\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "[[maybe_unused]] const Location pAllocator_loc = loc.dot(Field::pAllocator);\nskip |= ValidateAllocationCallbacks(*pAllocator, pAllocator_loc);\nskip |= ValidateRequiredPointer(loc.dot(Field::pModule), pModule, \"VUID-vkCreateCudaModuleNV-pModule-parameter\");\n"
        },
        {
            "role": "user",
            "content": "{\"VUID-vkCreateDirectFBSurfaceEXT-pSurface-parameter\", \"pSurface must be a valid pointer to a VkSurfaceKHR handle\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "[[maybe_unused]] const Location pAllocator_loc = loc.dot(Field::pAllocator);\nskip |= ValidateAllocationCallbacks(*pAllocator, pAllocator_loc);\nskip |= ValidateRequiredPointer(loc.dot(Field::pSurface), pSurface, \"VUID-vkCreateDirectFBSurfaceEXT-pSurface-parameter\");\n"
        },
        {
            "role": "user",
            "content": "{\"VUID-vkGetDescriptorSetHostMappingVALVE-ppData-parameter\", \"ppData must be a valid pointer to a pointer value\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "if (!IsExtEnabled(device_extensions.vk_valve_descriptor_set_host_mapping))\n    skip |= OutputExtensionError(loc, {vvl::Extension::_VK_VALVE_descriptor_set_host_mapping});\nskip |= ValidateRequiredHandle(loc.dot(Field::descriptorSet), descriptorSet);\nskip |= ValidateRequiredPointer(loc.dot(Field::ppData), ppData, \"VUID-vkGetDescriptorSetHostMappingVALVE-ppData-parameter\");\n"
        },
        {
            "role": "user",
            "content": "{\"VUID-VkPipelineMultisampleStateCreateInfo-flags-zerobitmask\", \"flags must be 0\", \"1.3-extensions\"}"
        },
        {
            "role": "assistant",
            "content": "\"VUID-VkPipelineMultisampleStateCreateInfo-pNext-pNext\",\n\"VUID-VkPipelineMultisampleStateCreateInfo-sType-unique\", VK_NULL_HANDLE, true);\nskip |= ValidateReservedFlags(loc.dot(Field::flags), info.flags, \"VUID-VkPipelineMultisampleStateCreateInfo-flags-zerobitmask\");\n"
        }
    ]
}